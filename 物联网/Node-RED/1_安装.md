# 安装

[TOC]

## 概述
选择想要运行 Node-RED 的位置，无论是在本地计算机上，还是在 Raspberry Pi 等设备上，还是在云中。

## 本地运行

在本地计算机上安装 Node-RED 。

> 如果使用 Raspberry Pi 或任何基于 Debian 的操作系统，包括 Ubuntu 和 Diet-Pi ，可以使用[此处](https://nodered.org/docs/getting-started/raspberrypi)提供的 Pi 安装脚本。
>
> 如果使用的是基于 RPM的 操作系统， RedHat，Fedora 和 CentOS，可以使用[这里](https://github.com/node-red/linux-installers)提供的 RPM 安装脚本。
>
> 如果使用的是 Windows，则可以[在此处](https://nodered.org/docs/getting-started/windows)找到安装 Node-RED 的详细说明。

### 先决条件

要在本地安装 Node-RED ，您需要[支持的 Node.js 版本](https://nodered.org/docs/faq/node-versions)。

### 使用 npm 安装

要安装 Node-RED ，可以使用 node.js 附带的 `npm` 命令：

```bash
sudo npm install -g --unsafe-perm node-red
```

如果使用的是Windows，请不要使用 `sudo` 启动命令。

That command will install Node-RED as a global module along with its dependencies.
该命令将 Node-RED 安装为全局模块沿着及其依赖项。

如果命令输出的结尾类似于以下内容，则可以确认它已成功：

```bash
+ node-red@1.1.0
added 332 packages from 341 contributors in 18.494s
found 0 vulnerabilities
```

### 使用 Docker 安装

要以最简单的形式在 Docker 中运行，只需运行：

```bash
docker run -it -p 1880:1880 --name mynodered nodered/node-red
```

### 使用 snap 安装

如果操作系统支持 [Snap](https://snapcraft.io/docs/core/install) ，则可以使用以下命令安装 Node-RED ：

```bash
sudo snap install node-red
```

当作为 Snap 包安装时，它将在一个安全的容器中运行，**该容器无法访问** ，可能需要使用的一些额外设施，例如：

- 访问主系统存储。只能读/写本地主目录。
- `gcc` - 需要编译要安装的节点的任何二进制组件
- `git` - needed if you want to use the Projects feature
  `git`-如果要使用项目功能，则需要使用
- 直接访问 gpio 硬件
- access to any external commands your flows want to use with the Exec node (for example).
  访问您的流要与Exec节点一起使用的任何外部命令（例如）。

If you need access to system hardware or to add nodes that require  compilation then we recommend using a full install of Node-RED and not  using the snap.
如果需要访问系统硬件或添加需要编译的节点，建议使用 Node-RED 的完整安装，而不是使用快照。

### 运行

Once installed as a global module you can use the `node-red` command to start Node-RED in your terminal. 
安装为全局模块后，可以使用 `node-red` 命令在终端中启动 Node-RED 。可以使用 `Ctrl-C` 或关闭终端窗口来停止 Node-RED 。

```bash
$ node-red

Welcome to Node-RED
===================

30 Jun 23:43:39 - [info] Node-RED version: v1.3.5
30 Jun 23:43:39 - [info] Node.js  version: v14.7.2
30 Jun 23:43:39 - [info] Darwin 19.6.0 x64 LE
30 Jun 23:43:39 - [info] Loading palette nodes
30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive
30 Jun 23:43:44 - [info] Settings file  : /Users/nol/.node-red/settings.js
30 Jun 23:43:44 - [info] HTTP Static    : /Users/nol/node-red/web
30 Jun 23:43:44 - [info] Context store  : 'default' [module=localfilesystem]
30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red
30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable
30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json
30 Jun 23:43:44 - [info] Starting flows
30 Jun 23:43:44 - [info] Started flows
30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/
```

然后，可以通过将浏览器指向 [http://localhost:1880](http://localhost:1880) 来访问 Node-RED 编辑器。

日志输出提供了各种信息：

- Node-RED 和 Node.js 的版本
- Any errors hit when it tried to load the palette nodes
  当它试图加载调色板节点时，
- 配置文件和用户目录的位置
- 它正在使用的流文件的名称。

Node-RED 使用 `flows_<hostname>.json` 作为默认流文件。您可以通过将流文件名作为参数提供给 `node-red` 命令来更改这一点。

### 命令行用法

Node-RED 可以使用命令 `node-red` 启动。此命令可以接受各种参数：

```bash
node-red [-v] [-?] [--settings settings.js] [--userDir DIR]
         [--port PORT] [--title TITLE] [--safe] [flows.json|projectName]
         [-D X=Y|@file]
```

| Option 选项              | Description 描述                                             |
| ------------------------ | ------------------------------------------------------------ |
| `-p`, `--port PORT`      | 设置运行时侦听的 TCP 端口。默认值：`1880`                    |
| `--safe`                 | This allows you to open the flows  in the editor and make changes without the flows running. When you  deploy your changes, the flows are then started. 启动 Node-RED 而不启动流。这允许在编辑器中打开流，并在流不运行的情况下进行更改。当您部署更改时，流程将启动。 |
| `-s`, `--settings FILE`  | 设置要使用的配置文件。默认值：`userDir` 中的 `settings.js`   |
| `--title TITLE`          | 设置进程窗口标题                                             |
| `-u`, `--userDir DIR`    | 设置要使用的用户目录。默认值：`~/.node-red`                  |
| `-v`                     | 启用详细输出                                                 |
| `-D X=Y|@file`           | [Override individual settings 设置个性化设置](https://nodered.org/docs/getting-started/local#override-individual-settings) |
| `-?`, `--help`           | 显示命令行用法帮助和退出                                     |
| `flows.json|projectName` | If the Projects feature is not enabled, this sets the flow file you want  to work with. If the Projects feature is enabled, this identifies which  project should be started. 如果未启用“项目”功能，则会设置要使用的流文件。如果启用了“项目”功能，则会标识应启动的项目。 |

If the computer you are running on may change its hostname, then you should ensure you provide a static file name; either as a command-line argument or using the `flowsFile` option in your [settings file](https://nodered.org/docs/user-guide/runtime/settings-file).
Node-RED 使用 `flows_<hostname>.json` 作为默认流文件。如果正在运行的计算机可能更改其主机名，则应确保提供静态文件名；作为命令行参数或使用[设置文件](https://nodered.org/docs/user-guide/runtime/settings-file)中的`flowsFile`选项。

#### 设置个性化设置

*自 Node-RED 1.1.0 起*

可以使用 `-D`（或 `--define`）选项覆盖命令行上的各个设置。

例如，要更改日志记录级别，可以使用用途：

```bash
-D logging.console.level=trace
```

You can also provide the custom settings as a file:
您也可以将自定义设置作为文件提供：

```bash
-D @./custom-settings.txt
```

The file should contain a list of the settings to override:
该文件应包含要覆盖的设置列表：

```bash
logging.console.level=trace
logging.console.audit=true
```

### 向底层 Node.js 进程传递参数

There are occasions when it is necessary to pass arguments to the underlying Node.js process. For example, when running on devices like the Raspberry Pi or BeagleBone Black that have a constrained amount of memory.
有时需要将参数传递给基础Node.js进程。例如，在内存有限的设备（如Raspberry Pi或BeagleBone Black）上运行时。

To do this, you must use the `node-red-pi` start script in place of `node-red`. *Note*: this script is not available on Windows.
为此，必须使用`node-red-pi`启动脚本代替`node-red`. *注意*：此脚本在Windows上不可用。

Alternatively, if are running Node-RED using the `node` command, you must provide arguments for the node process before specifying `red.js` and the arguments you want passed to Node-RED itself.
或者，如果使用`node`命令运行Node-RED，则必须在指定`red.js`和要传递给Node-RED本身的参数之前为节点进程提供参数。

The following two commands show these two approaches:
以下两个命令显示了这两种方法：

```
node-red-pi --max-old-space-size=128 --userDir /home/user/node-red-data/
node --max-old-space-size=128 red.js --userDir /home/user/node-red-data/
```

### 升级 Node-RED

如果使用 Pi 脚本安装了 Node-RED，则可以将其升级的脚本在[这里](https://nodered.org/docs/hardware/raspberrypi)可用。

如果已将 Node-RED 安装为全局 npm 包，则可以使用以下命令升级到最新版本：

```bash
sudo npm install -g --unsafe-perm node-red
```

如果使用的是 Windows ，请不要使用 `sudo` 启动命令。

## Raspberry Pi

使用 Raspberry Pi 的一体化安装脚本。

### 先决条件

如果使用的是 Raspberry Pi OS ，则 Bullseye 是当前支持的版本。

### 安装和升级 Node-RED

提供了一个脚本来将 Node.js，npm 和 Node-RED 安装到 Raspberry Pi 上。当有新版本可用时，该脚本还可用于升级现有安装。

运行以下命令将下载并运行脚本。如果你想先查看脚本的内容，可以[在Github上](https://raw.githubusercontent.com/node-red/linux-installers/master/deb/update-nodejs-and-nodered)查看。

```bash
bash <(curl -sL https://raw.githubusercontent.com/node-red/linux-installers/master/deb/update-nodejs-and-nodered)
```

There are extra parameters you can pass to the script. Add ` --help` to the end of the above command to see them.
可以向脚本传递一些额外的参数。将 `--help`添加到上述命令的末尾以查看它们。

This script will work on any **Debian-based** operating system, including **Ubuntu** and **Diet-Pi**. You may need to run `sudo apt install build-essential git curl` first to ensure npm is able to fetch and build any binary modules it needs to install. 
这个脚本可以在任何**基于Debian的**操作系统上运行，包括**Ubuntu**和**Diet-Pi**。您可能需要运行 `sudo apt install build-essential git curl`  首先要确保npm能够获取和构建任何需要安装的二进制模块。

该脚本将：

- 删除现有版本的 Node-RED（如果存在）。
- if it detects Node.js is already installed, it will ensure it is at least  v14. If less than v14 it will stop and let the user decide whether to  stay with Node-RED version 1 - or upgrade Nodejs to a more recent LTS  version. If nothing is found it will install the Node.js 16 LTS release  using the [NodeSource](https://github.com/nodesource/distributions/blob/master/README.md) package.
  如果它检测到Node.js已经安装，它将确保它至少是v14。如果小于v14，它将停止，让用户决定是否继续使用Node-RED版本1 -或将Nodejs升级到更新的LTS版本。如果没有找到任何内容，它将使用[NodeSource](https://github.com/nodesource/distributions/blob/master/README.md)包安装Node.js 16 LTS版本。
- 使用 npm 安装最新版本的 Node-RED 。
- optionally install a collection of useful Pi-specific nodes.
  可选地安装有用的特定于Pi的节点的集合。
- setup Node-RED to run as a service and provide a set of commands to work with the service.
  设置Node-RED作为服务运行，并提供一组命令来使用该服务。



Node-RED has also been packaged for the Raspberry Pi OS repositories and appears in their list of 'Recommended Software'. This allows it to be installed using `apt-get install nodered` and includes the Raspberry Pi OS-packaged version of Node.js, but *does not* include `npm`. 
Node-RED也已打包用于Raspberry Pi OS存储库，并出现在其 “推荐软件”列表。这允许使用 `apt-get install nodered`，包含Raspberry Pi OS打包版本的Node.js，但*不*包含`npm`。

**Note**: at this time the default node.js included with RaspiOS Bullseye is  still v12. This means that the latest Node-RED version that can be  installed is the 2.x branch. While using these packages is convenient at first, we **strongly recommend** using the install script above instead.
**注意**：目前RaspiOS Bullseye中包含的默认node.js仍然是v12。这意味着可以安装的最新Node-RED版本是2.x分支。虽然一开始使用这些包很方便，但我们**强烈建议**使用上面的安装脚本。

### 本地运行

As with [running Node-RED locally](https://nodered.org/docs/getting-started/local), you can use the `node-red` command to run Node-RED in a terminal. It can then be stopped by pressing `Ctrl-C` or by closing the terminal window.
与在[本地运行Node-RED](https://nodered.org/docs/getting-started/local)一样，您可以使用`node-red`命令在终端中运行Node-RED。然后可以通过按`Ctrl-C`或关闭终端窗口来停止它。

Due to the limited memory of the Raspberry Pi, you will need to start Node-RED with an additional argument to tell the underlying Node.js process to free up unused memory sooner than it would otherwise.
由于Raspberry Pi的内存有限，您将需要启动Node-RED并添加一个参数，以告诉底层Node.js进程更快地释放未使用的内存。

To do this, you should use the alternative `node-red-pi` command and pass in the `max-old-space-size` argument.
为此，您应该使用另一`个node-red-pi`命令并传入 `max-old-space-size`参数。

```
node-red-pi --max-old-space-size=256
```

### 作为服务运行

The install script for the Pi also sets it up to run as a service. This means it can run in the background and be enabled to automatically start on boot.
Pi的安装脚本还将其设置为作为服务运行。这意味着它可以在后台运行，并能够在靴子时自动启动。

The following commands are provided to work with the service:
提供了以下命令来使用该服务：

- `node-red-start` - this starts the Node-RED service and displays its log output. Pressing `Ctrl-C` or closing the window does *not* stop the service; it keeps running in the background
  `node-red-start`-启动Node-RED服务并显示其日志输出。按`Ctrl-C`或关闭窗口*不会*停止服务;它会继续在后台运行
- `node-red-stop` - this stops the Node-RED service
  `node-red-stop`-停止Node-RED服务
- `node-red-restart` - this stops and restarts the Node-RED service
  `node-red-restart`-停止和重新启动Node-RED服务
- `node-red-log` - this displays the log output of the service
  `node-red-log`-显示服务的日志输出

You can also start the Node-RED service on the Raspberry Pi OS Desktop by selecting the `Menu -> Programming -> Node-RED` menu option.
您还可以通过选择 `Menu -> Programming -> Node-RED` 菜单选项在Raspberry Pi OS Desktop上启动Node-RED服务。

### 自动启动

If you want Node-RED to run when the Pi is turned on, or re-booted, you can enable the service to autostart by running the command:
如果您希望Node-RED在Pi打开或重新启动时运行，则可以通过运行以下命令启用服务自动启动：

```bash
sudo systemctl enable nodered.service
```

要禁用该服务，请运行以下命令：

```bash
sudo systemctl disable nodered.service
```

### 打开编辑器

Node-RED 运行后，可以在浏览器中访问编辑器。

如果使用的是 Pi 桌面上的浏览器，则可以打开地址：[http://localhost:1880](http://localhost:1880) 。

We recommend using a browser outside of the PI and pointing it at Node-RED running on the Pi. However you can use the built in browser and if so  we recommend Chromium or Firefox-ESR and *not* Epiphany
我们建议使用PI外部的浏览器，并将其指向在PI上运行的Node-RED。但是，您可以使用内置的浏览器，如果是这样，我们建议使用Chromium或Firefox-ESR，而*不是*Epiphany

.

When browsing from another machine you should use the hostname or IP-address of the Pi: `http://<hostname>:1880`. You can find the IP address by running `hostname -I` on the Pi.
从另一台机器浏览时，您应该使用Pi的主机名或IP地址：`http：//<hostname>：1880`。您可以通过在Pi上运行`hostname -I来`查找IP地址。

## Docker

使用 Docker 运行 Node-RED 。

This guide assumes you have some basic familiarity with Docker and the [Docker Command Line](https://docs.docker.com/engine/reference/commandline/cli/). It describes some of the many ways Node-RED can be run under Docker and has support for multiple architectures (amd64, arm32v6, arm32v7,  arm64v8 and s390x).
本指南假设您对Docker和 [Docker命令](https://docs.docker.com/engine/reference/commandline/cli/)行它描述了在Docker下运行Node-RED的多种方式中的一些，并支持多种架构（amd 64，arm 32 v6，arm 32 v7，arm 64 v8和s390 x）。

As of Node-RED 1.0 the repository on [Docker Hub](https://hub.docker.com/r/nodered/node-red/) was renamed to `nodered/node-red`.
从Node-RED 1.0开始，[Docker Hub](https://hub.docker.com/r/nodered/node-red/)上的存储库 重命名为`nodered/node-red`。

### 快速启动

To run in Docker in its simplest form just run:
要以最简单的形式在Docker中运行，只需运行：

```
    docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red
```

Let’s dissect that command:
让我们仔细分析这个命令：

```
    docker run              - run this container, initially building locally if necessary
    -it                     - attach a terminal session so we can see what is going on
    -p 1880:1880            - connect local port 1880 to the exposed internal port 1880
    -v node_red_data:/data  - mount a docker named volume called `node_red_data` to the container /data directory so any changes made to flows are persisted
    --name mynodered        - give this machine a friendly local name
    nodered/node-red        - the image to base it on - currently Node-RED v1.2.0
```

Running that command should give a terminal window with a running instance of Node-RED.
运行该命令应该会给出一个终端窗口，其中包含一个正在运行的Node-RED实例。

```
    Welcome to Node-RED
    ===================

    10 Oct 12:57:10 - [info] Node-RED version: v1.2.0
    10 Oct 12:57:10 - [info] Node.js  version: v10.22.1
    10 Oct 12:57:10 - [info] Linux 4.19.76-linuxkit x64 LE
    10 Oct 12:57:11 - [info] Loading palette nodes
    10 Oct 12:57:16 - [info] Settings file  : /data/settings.js
    10 Oct 12:57:16 - [info] Context store  : 'default' [module=memory]
    10 Oct 12:57:16 - [info] User directory : /data
    10 Oct 12:57:16 - [warn] Projects disabled : editorTheme.projects.enabled=false
    10 Oct 12:57:16 - [info] Flows file     : /data/flows.json
    10 Oct 12:57:16 - [info] Creating new flow file
    10 Oct 12:57:17 - [warn]

    ---------------------------------------------------------------------
    Your flow credentials file is encrypted using a system-generated key.

    If the system-generated key is lost for any reason, your credentials
    file will not be recoverable, you will have to delete it and re-enter
    your credentials.

    You should set your own key using the 'credentialSecret' option in
    your settings file. Node-RED will then re-encrypt your credentials
    file using your chosen key the next time you deploy a change.
    ---------------------------------------------------------------------

    10 Oct 12:57:17 - [info] Starting flows
    10 Oct 12:57:17 - [info] Started flows
    10 Oct 12:57:17 - [info] Server now running at http://127.0.0.1:1880/

    [...]
```

You can then browse to `http://{host-ip}:1880` to get the familiar Node-RED desktop.
然后，您可以浏览到`http：//{host-ip}：1880`以获取熟悉的Node-RED桌面。

The advantage of doing this is that by giving it a name (mynodered) we can manipulate it more easily, and by fixing the host port we know we are on familiar ground. Of course this does mean we can only run one instance at a time… but one step at a time folks.
这样做的好处是，通过给它一个名字（mynodered），我们可以更容易地操纵它，并且通过修复主机端口，我们知道我们在熟悉的基础上。当然，这意味着我们一次只能运行一个实例……但是一次只能运行一步。

If we are happy with what we see, we can detach the terminal with `Ctrl-p` `Ctrl-q` - the container will keep running in the background.
如果我们对所看到的内容感到满意，我们可以使用`Ctrl-p``Ctrl-q`分离终端-容器将继续在后台运行。

To reattach to the terminal (to see logging) run:
要重新连接到终端（查看日志记录），请运行：

```
docker attach mynodered
```

If you need to restart the container (e.g. after a reboot or restart of the Docker daemon):
如果您需要重新启动容器（例如，在重新启动或重新启动Docker守护程序后）：

```
docker start mynodered
```

and stop it again when required:
并在需要时再次停止：

```
docker stop mynodered
```

### Image Variations 图像变型

The Node-RED images are based on [official Node JS Alpine Linux](https://hub.docker.com/_/node/) images to keep them as small as possible. Using Alpine Linux reduces the built image size, but removes standard  dependencies that are required for native module compilation. If you  want to add dependencies with native dependencies, extend the Node-RED  image with the missing packages on running containers or build new  images see [docker-custom](https://nodered.org/docs/getting-started/docker-custom) which expands on the [README.md](https://github.com/node-red/node-red-docker/tree/master/docker-custom) in the Node-RED Docker project.
Node-RED镜像基于[官方Node JS Alpine Linux](https://hub.docker.com/_/node/)镜像，以尽可能地保持它们的小尺寸。使用Alpine  Linux可以减小构建的映像大小，但删除了本机模块编译所需的标准依赖项。如果您想添加具有本机依赖项的依赖项，请使用正在运行的容器上缺少的包扩展Node-RED镜像或构建新镜像，请参阅在Node-RED Docker项目的[README.md](https://github.com/node-red/node-red-docker/tree/master/docker-custom)上展开的[docker-custom](https://nodered.org/docs/getting-started/docker-custom)。

See the [Github project README](https://github.com/node-red/node-red-docker/blob/master/README.md) for detailed Image, Tag and Manifest information.
查看[Github项目README](https://github.com/node-red/node-red-docker/blob/master/README.md)以获取详细的Image、Tag和Manifest信息。

For example: suppose you are running on a Raspberry PI 3B, which has `arm32v7` as architecture. Then just run the following command to pull the image (tagged by `1.2.0-10-arm32v7`), and run the container.
例如：假设您正在Raspberry PI 3B上运行，它具有`arm 32 v7`架构。然后运行以下命令拉取镜像（标签为`1.2.0-10-arm 32 v7`），并运行容器。

```
docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red:latest
```

The same command can be used for running on an amd64 system, since Docker  discovers it is running on an amd64 host and pulls the image with the  matching tag (`1.2.0-10-amd64`).
同样的命令也可以用于在amd 64系统上运行，因为Docker发现它正在amd 64主机上运行，并使用匹配的标签（`1.2.0-10-amd 64`）拉取镜像。

This has the advantage that you don’t need to know/specify which  architecture you are running on and makes docker run commands and docker compose files more flexible and exchangeable across systems.
这样做的好处是，你不需要知道/指定你正在哪个架构上运行，并且使Docker运行命令和Docker编写文件更加灵活，并且可以跨系统交换。

**Note**: Currently there is a bug in Docker’s architecture detection that fails for `arm32v6` - eg Raspberry Pi Zero or 1. For these devices you currently need to specify the full image tag, for example:
**注意**：目前Docker的架构检测中有一个bug，对于`arm 32 v6`-例如Raspberry Pi Zero或1失败。对于这些设备，您当前需要指定完整的图像标记，例如：

```
docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red:1.2.0-10-arm32v6
```

As of Node-RED v3.1.0 we also provide a Debian based image for those nodes with native components that do not work well on Alpine.
从Node-RED v3.1.0开始，我们还为那些在Alpine上无法正常工作的具有本地组件的节点提供了基于Debian的映像。

### Managing User Data 管理用户数据

Once you have Node-RED running with Docker, we need to ensure any added nodes or flows are not lost if the container is destroyed. This user data can be persisted by mounting a data directory to a volume outside the container. This can either be done using a bind mount or a named data volume.
一旦你让Node-RED与Docker一起运行，我们需要确保如果容器被破坏，任何添加的节点或流不会丢失。可以通过将数据目录挂载到容器外部的卷来持久化此用户数据。这可以使用绑定挂载或命名数据卷来完成。

Node-RED uses the `/data` directory inside the container to store user configuration data.
Node-RED使用容器内的`/data`目录来存储用户配置数据。

#### Using a Host Directory for Persistence (Bind Mount) 使用主机目录进行持久化（绑定装载）

To save your Node-RED user directory inside the container to a host directory outside the container, you can use the command below. To allow access to this host directory, the node-red user (default uid=1000) inside the container must have the same uid as the owner of the host directory.
要将容器内的Node-RED用户目录保存到容器外的主机目录，可以使用下面的命令。要允许访问此主机目录，容器中的node-red用户（默认uid=1000）必须与主机目录的所有者具有相同的uid。

```
docker run -it -p 1880:1880 -v /home/pi/.node-red:/data --name mynodered nodered/node-red
```

In this example the host `/home/pi/.node-red` directory is bound to the container `/data` directory.
在本例中，host`/home/pi/.node-red`目录绑定到container`/data`目录。

**Note**: Users migrating from version 0.20 to 1.0 will need to ensure that any existing `/data` directory has the correct ownership. As of 1.0 this needs to be `1000:1000`. This can be forced by the command `sudo chown -R 1000:1000 path/to/your/node-red/data`
**注意**：从0.20版迁移到1.0版的用户需要确保所有现有`/数据` 目录具有正确的所有权。从1.0开始，这需要`1000：1000`。这可以通过命令 `sudo chown -R 1000:1000 path/to/your/node-red/data` 强制执行

See [the wiki](https://github.com/node-red/node-red-docker/wiki/Permissions-and-Persistence) for detailed information on permissions.
有关权限的详细信息，请参阅[wiki](https://github.com/node-red/node-red-docker/wiki/Permissions-and-Persistence)。

#### Using Named Data Volumes 使用命名数据库

Docker also supports using named [data volumes](https://docs.docker.com/engine/tutorials/dockervolumes/) to store persistent or shared data outside the container.
Docker还支持使用命名[数据卷](https://docs.docker.com/engine/tutorials/dockervolumes/) 在容器外部存储持久或共享数据。

To create a new named data volume to persist our user data and run a new container using this volume.
创建一个新的命名数据卷来持久化用户数据，并使用此卷运行一个新的容器。

```
$ docker volume create --name node_red_data
$ docker volume ls
DRIVER              VOLUME NAME
local               node_red_data
$ docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red
```

If you need to backup the data from the mounted volume you can access it while the container is running.
如果您需要从挂载的卷备份数据，您可以在容器运行时访问它。

```
$ docker cp  mynodered:/data  /your/backup/directory
```

Using Node-RED to create and deploy some sample flows, we can now destroy the container and start a new instance without losing our user data.
使用Node-RED创建和部署一些示例流，我们现在可以销毁容器并启动新实例，而不会丢失用户数据。

```
$ docker stop mynodered
$ docker rm mynodered
$ docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red
```

### 更新

As the /data is now preserved outside of the container, updating the base container image is now as simple as
由于/data现在保留在容器外部，因此更新基本容器映像现在就像

```
$ docker pull nodered/node-red
$ docker stop mynodered
$ docker rm mynodered
$ docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red
```

### Docker Stack / Docker Compose

Below an example of a Docker Compose file which can be run by `docker stack` or `docker-compose`. Please refer to the official Docker pages for more info about [Docker stack](https://docs.docker.com/engine/reference/commandline/stack/) and [Docker compose](https://docs.docker.com/compose/).
下面是一个Docker Compose文件的例子，它可以由`Docker stack`或`docker-compose`运行。请参考官方Docker页面了解更多关于[Docker堆栈](https://docs.docker.com/engine/reference/commandline/stack/)和[Docker合成的](https://docs.docker.com/compose/)信息。

```
################################################################################
# Node-RED Stack or Compose
################################################################################
# docker stack deploy node-red --compose-file docker-compose-node-red.yml
# docker-compose -f docker-compose-node-red.yml -p myNoderedProject up
################################################################################
version: "3.7"

services:
  node-red:
    image: nodered/node-red:latest
    environment:
      - TZ=Europe/Amsterdam
    ports:
      - "1880:1880"
    networks:
      - node-red-net
    volumes:
      - node-red-data:/data

volumes:
  node-red-data:

networks:
  node-red-net:
```

The above compose file: 上面的compose文件：

- creates a node-red service
  创建一个红色节点服务
- pulls the latest node-red image
  拉取最新的红色节点图像
- sets the timezone to Europe/Amsterdam
  将时区设置为欧洲/阿姆斯特丹
- Maps the container port 1880 to the host port 1880
  将容器端口1880映射到主机端口1880
- creates a node-red-net network and attaches the container to this network
  创建一个node-red-net网络并将容器连接到此网络
- persists the `/data` dir inside the container to the `node-red-data` volume in Docker
  将容器内的`/data`目录持久化到Docker中的`node-red-data`卷

### Dockerfile which copies in local resources 在本地资源中复制的Dockerfile

It can sometimes be useful to populate a Node-RED Docker image with files  from a local directory (for example, if you want a whole project to be  kept in a git repo). To do this, you’ll want your local directory to  look like this:
使用本地目录中的文件填充Node-RED Docker镜像有时会很有用（例如，如果您希望将整个项目保存在git repo中）。要做到这一点，你需要你的本地目录看起来像这样：

```
Dockerfile
README.md
package.json     # add any extra nodes your flow needs into your own package.json.
flows.json       # the normal place Node-RED store your flows
flows_cred.json  # credentials your flows may need
settings.js      # your settings file
```

**NOTE**: This method is NOT suitable if you want to mount the /data volume  externally. If you need to use an external volume for persistence then  copy your settings and flows files to that volume instead.
**注意**：如果您想从外部装入/数据卷，则此方法不适合。如果您需要使用外部卷进行持久化，请将您的设置和流文件复制到该卷。

The following Dockerfile builds on the base Node-RED Docker image, but  additionally moves your own files into place into that image:
以下Dockerfile构建在基本Node-RED Docker镜像之上，但还会将您自己的文件移动到该镜像中：

```
FROM nodered/node-red

# Copy package.json to the WORKDIR so npm builds all
# of your added nodes modules for Node-RED
WORKDIR /data
COPY package.json /data
RUN npm install --unsafe-perm --no-update-notifier --no-fund --only=production
WORKDIR /usr/src/node-red

# Copy _your_ Node-RED project files into place
# NOTE: This will only work if you DO NOT later mount /data as an external volume.
#       If you need to use an external volume for persistence then
#       copy your settings and flows files to that volume instead.
COPY settings.js /data/settings.js
COPY flows_cred.json /data/flows_cred.json
COPY flows.json /data/flows.json
```

**Note**: the `package.json` file must contain a start option within the script section. For example the default container is like this:
**注意**：`package.json`文件必须在脚本部分包含start选项。例如，默认容器是这样的：

```
    "scripts": {
        "start": "node $NODE_OPTIONS node_modules/node-red/red.js $FLOWS",
        ...
```

#### Dockerfile order and build speed Dockerfile顺序和构建速度

While not necessary, it’s a good idea to do the `COPY package... npm install...` steps early because, although the `flows.json` changes frequently as you work in Node-RED, your `package.json` will only change when you change what modules are part of your project. And since the `npm install` step that needs to happen when `package.json` changes can sometimes be time consuming, it’s better to do the  time-consuming, generally-unchanging steps earlier in a Dockerfile so  those build images can be reused, making subsequent overall builds much  faster.
虽然没有必要，但最好尽早执行 `COPY package... npm install...` 步骤，因为尽管在Node-RED中工作时`flows.json`会频繁更改，但只有当您更改项目中的模块时，`package.json`才会更改。由于在`package.json`更改时需要进行的`npm安装`步骤有时很耗时，因此最好在Dockerfile中更早地执行耗时且通常不变的步骤，以便可以重用这些构建映像，从而使后续的整体构建速度更快。

#### Credentials, secrets, and environment variables 凭据、机密和环境变量

Of course you never want to hard-code credentials anywhere, so if you need to use credentials with your Node-RED project, the above Dockerfile  will let you have this in your `settings.js`…
当然，你永远不想在任何地方硬编码凭证，所以如果你需要在Node-RED项目中使用凭证，上面的Dockerfile将让你在settings.js中拥有它。``

```
module.exports = {
  credentialSecret: process.env.NODE_RED_CREDENTIAL_SECRET // add exactly this
}
```

…and then when you run in Docker, you add an environment variable to your `run` command…
.然后当你在Docker中运行时，你在`run`命令中添加一个环境变量。

```
docker run -e "NODE_RED_CREDENTIAL_SECRET=your_secret_goes_here"
```

#### Building and running 构建和运行

You *build* this Dockerfile normally:
您*可以正常构建*此Dockerfile：

```
docker build -t your-image-name:your-tag .
```

To *run* locally for development where changes are written immediately and only the local directory that you are working from, `cd` into the project’s directory and then run:
要在本地*运行*以进行开发，其中更改会立即写入，并且只在您正在使用的本地目录中运行，请`cd`到项目目录中，然后运行：

```
docker run --rm -e "NODE_RED_CREDENTIAL_SECRET=your_secret_goes_here" -p 1880:1880 -v `pwd`:/data --name a-container-name your-image-name
```

### Startup 启动

Environment variables can be passed into the container to configure the runtime of Node-RED.
可以将环境变量传递到容器中以配置Node-RED的运行时。

The flows configuration file is set using an environment parameter (**FLOWS**), which defaults to *‘flows.json’*. This can be changed at runtime using the following command-line flag.
流配置文件是使用环境参数（**FLOWS**）设置的，默认为*'flows.json'*。这可以在运行时使用以下命令行标志进行更改。

```
docker run -it -p 1880:1880 -v node_red_data:/data -e FLOWS=my_flows.json nodered/node-red
```

**Note**: If you set `-e FLOWS=""` then the flow file can be set via the *flowFile* property in the `settings.js` file.
**注意**：如果设置`-e FLOWS="“`，则可以通过*flowFile*设置流文件 `设置`文件中的属性。

Other useful environment variables include
其他有用的环境变量包括

- `-e NODE_RED_ENABLE_SAFE_MODE=false` # setting to true starts Node-RED in safe (not running) mode
   `-e NODE_RED_ENABLE_SAFE_MODE=false` #设置为true将Node-RED以安全（不运行）模式启动
- `-e NODE_RED_ENABLE_PROJECTS=false`  # setting to true starts Node-RED with the projects feature enabled
   `-e NODE_RED_ENABLE_PROJECTS=false` #设置为true启动Node-RED并启用项目功能

Node.js runtime arguments can be passed to the container using an environment parameter (**NODE_OPTIONS**). For example, to fix the heap size used by the Node.js garbage collector you would use the following command.
Node.js运行时参数可以通过环境参数（**NODE_OPTIONS**）传递给容器。例如，要修复Node.js垃圾收集器使用的堆大小，您可以使用以下命令。

```
docker run -it -p 1880:1880 -v node_red_data:/data -e NODE_OPTIONS="--max_old_space_size=128" nodered/node-red
```

### Running headless 无头跑

To run headless, (i.e. in the background), just replace the `-it` in most previous commands with `-d`, for example:
要运行headless，（即在后台），只需将大多数以前命令中的`-it`替换为`-d`，例如：

```
docker run -d -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red
```

### Container Shell 容器壳体

Once it is running headless you can use the following command to get access back into the container.
一旦它运行无头，你可以使用下面的命令来访问回到容器。

```
$ docker exec -it mynodered /bin/bash
bash-4.4$
```

Will give a command line inside the container - where you can then run the npm install command you wish - for example
将在容器内提供一个命令行-然后您可以在其中运行您想要的npm install命令-例如

```
bash-4.4$ npm install node-red-dashboard
bash-4.4$ exit
$ docker stop mynodered
$ docker start mynodered
```

Refreshing the browser page should now reveal the newly added nodes in the palette.
刷新浏览器页面现在应该会在面板中显示新添加的节点。

### Multiple Instances 多个实例

Running 运行

```
docker run -d -p 1880 nodered/node-red
```

will create a locally running instance of a machine. Note: we did not specify a name.
将创建一个本地运行的机器实例。注意：我们没有指定名称。

This container will have an id number and be running on a random port… to find out which port, run `docker ps`
这个容器将有一个ID号，并在一个随机端口上运行.要找出哪个端口，运行`docker ps`

```
$ docker ps
CONTAINER ID  IMAGE             COMMAND                 CREATED         STATUS        PORTS                    NAMES
860258cab092  nodered/node-red  "npm start -- --user…"  10 seconds ago  Up 9 seconds  0.0.0.0:32768->1880/tcp  dazzling_euler
```

You can now point a browser to the host machine on the tcp port reported back, so in the example above browse to `http://{host ip}:32768`
您现在可以将浏览器指向返回报告的TCP端口上的主机，因此在上面的示例中浏览到`http：//{hostip}：32768`

### Linking Containers 链接容器

You can link containers “internally” within the docker runtime by using Docker [user-defined bridges](https://docs.docker.com/network/bridge/).
您可以通过使用Docker[用户定义的桥](https://docs.docker.com/network/bridge/)在Docker运行时中“内部”链接容器。

Before using a bridge, it needs to be created.  The command below will create a new bridge called **iot**
在使用桥梁之前，需要创建它。下面的命令将创建一个名为**iot的**新网桥

```
docker network create iot
```

Then all containers that need to communicate need to be added to the same bridge using the **–network** command line option
然后，需要使用**-network**命令行选项将所有需要通信的容器添加到同一个网桥

```
docker run -itd --network iot --name mybroker eclipse-mosquitto mosquitto -c /mosquitto-no-auth.conf
```

(no need to expose the port 1883 globally unless you want to… as we do magic below)
(no需要在全局范围内公开端口1883，除非你想这样做.

Then run nodered docker, also added to the same bridge
然后运行nodered docker，也添加到同一个桥

```
docker run -itd -p 1880:1880 --network iot --name mynodered nodered/node-red
```

containers on the same user-defined bridge can take advantage of the built in name resolution provided by the bridge and use the container name (specified using the **–name** option) as the target hostname.
同一用户定义的桥上的容器可以利用桥提供的内置名称解析，并使用容器名称（使用**-name**选项指定）作为目标主机名。

In the above example the broker can be reached from the Node-RED application using hostname *mybroker*.
在上面的示例中，可以使用主机名*mybroker*从Node-RED应用程序访问代理。

Then a simple flow like below show the mqtt nodes connecting to the broker
然后，下面的简单流程显示了连接到代理的MQTT节点

```
    [{"id":"c51cbf73.d90738","type":"mqtt in","z":"3fa278ec.8cbaf","name":"","topic":"test","broker":"5673f1d5.dd5f1","x":290,"y":240,"wires":[["7781c73.639b8b8"]]},{"id":"7008d6ef.b6ee38","type":"mqtt out","z":"3fa278ec.8cbaf","name":"","topic":"test","qos":"","retain":"","broker":"5673f1d5.dd5f1","x":517,"y":131,"wires":[]},{"id":"ef5b970c.7c864","type":"inject","z":"3fa278ec.8cbaf","name":"","repeat":"","crontab":"","once":false,"topic":"","payload":"","payloadType":"date","x":290,"y":153,"wires":[["7008d6ef.b6ee38"]]},{"id":"7781c73.639b8b8","type":"debug","z":"3fa278ec.8cbaf","name":"","active":true,"tosidebar":true,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":505,"y":257,"wires":[]},{"id":"5673f1d5.dd5f1","type":"mqtt-broker","z":"","name":"","broker":"mybroker","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"15","cleansession":true,"birthTopic":"","birthQos":"0","birthRetain":"false","birthPayload":"","closeTopic":"","closeRetain":"false","closePayload":"","willTopic":"","willQos":"0","willRetain":"false","willPayload":""}]
```

This way the internal broker is not exposed outside of the docker host - of course you may add `-p 1883:1883`  etc to the broker run command if you want other systems outside your computer to be able to use the broker.
这样，内部代理就不会暴露在docker主机之外-当然，如果您希望计算机之外的其他系统能够使用代理，您可以在broker run命令中添加`-p 1883：1883`等。

### Raspberry PI - native GPIO support Raspberry PI -原生GPIO支持

| v1.0 - BREAKING: Native GPIO support for Raspberry PI has been dropped | | — | The replacement for native GPIO is [node-red-node-pi-gpiod](https://github.com/node-red/node-red-nodes/tree/master/hardware/pigpiod).
| v1.0 -突破：乌藨子PI的本机GPIO支持已被删除|| - |原生GPIO的替代品是[node-red-node-pi-gpiod](https://github.com/node-red/node-red-nodes/tree/master/hardware/pigpiod)。

Disadvantages of the native GPIO support are:
原生GPIO支持的缺点是：

- Your Docker container needs to be deployed on the same Docker node/host on which you want to control the gpio.
  你的Docker容器需要部署在你想要控制gpio的同一个Docker节点/主机上。
- Gain access to `/dev/mem` of your Docker node/host
  访问Docker节点/主机的`/dev/dev`
- privileged=true is not supported for `docker stack` command
  `docker stack`命令不支持privileged=true

`node-red-node-pi-gpiod` fixes all these disadvantages. With `node-red-node-pi-gpiod` it is possible to interact with gpio of multiple Raspberry Pi’s from a  single Node-RED container, and for multiple containers to access  different gpio on the same Pi.
`node-red-node-pi-gpiod`解决了所有这些缺点。使用`node-red-node-pi-gpiod`，可以从单个Node-RED容器与多个Raspberry Pi的gpio交互，并且多个容器可以访问同一Pi上的不同gpio。

#### Quick Migration steps to `node-red-node-pi-gpiod` 快速迁移到`node-red-node-pi-gpiod的`步骤

1. Install `node-red-node-pi-gpiod` through the Node-RED palette.
   通过Node-RED调色板安装`node-red-node-pi-gpiod`。
2. Install and run `PiGPIOd daemon` on the host Pi. For detailed install instruction please refer to the `node-red-node-pi-gpiod` [README](https://github.com/node-red/node-red-nodes/tree/master/hardware/pigpiod#node-red-node-pi-gpiod).
   在主机Pi上安装并运行`PiGPIOd守护进程`。有关详细的安装说明，请参阅`node-red-node-pi-gpiod`[README](https://github.com/node-red/node-red-nodes/tree/master/hardware/pigpiod#node-red-node-pi-gpiod)。
3. Replace all native gpio nodes with `pi gpiod` nodes.
   将所有本机gpio节点替换为`pi gpiod`节点。
4. Configure `pi gpiod` nodes to connect to `PiGPIOd daemon`. Often the host machine will have an IP 172.17.0.1 port 8888 - but not always. You can use `docker exec -it mynodered ip route show default | awk '/default/ {print $3}'` to check.
   配置`pi gpiod`节点以连接到`PiGPIOd守护进程`。主机通常会有一个IP 172.17.0.1端口8888 -但并不总是如此。你可以使用 `docker exec -it mynodered ip route show default | awk '/default/ {print $3}'` 来检查。

**Note**: There is a contributed [gpiod project](https://github.com/corbosman/node-red-gpiod) that runs the gpiod in its own container rather than on the host if required.
**注意**：有一个贡献的[gpiod项目](https://github.com/corbosman/node-red-gpiod)，它在自己的容器中运行gpiod，而不是在主机上运行（如果需要）。

### Serial Port - Dialout - Adding Groups 串行端口-拨号-添加组

To access the host serial port you may need to add the container to the `dialout` group. This can be enabled by adding `--group-add dialout` to the start command. For example
要访问主机串行端口，您可能需要将容器添加到`拨出`组。这可以通过将`--group-add dialout`添加到start命令来启用。例如

```
docker run -it -p 1880:1880 -v node_red_data:/data --group-add dialout --name mynodered nodered/node-red
```

------

### Common Issues and Hints 常见问题和提示

Here is a list of common issues users have reported with possible solutions.
以下是用户报告的常见问题以及可能的解决方案列表。

#### User Permission Errors 用户权限错误

See [the wiki](https://github.com/node-red/node-red-docker/wiki/Permissions-and-Persistence) for detailed information on permissions.
有关权限的详细信息，请参阅[wiki](https://github.com/node-red/node-red-docker/wiki/Permissions-and-Persistence)。

If you are seeing *permission denied* errors opening files or accessing host devices, try running the container as the root user.
如果您在打开文件或访问主机设备时看到*权限被拒绝的错误*，请尝试以root用户身份运行容器。

```
docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered -u node-red:dialout nodered/node-red
```

References: 参考文献：

https://github.com/node-red/node-red-docker/issues/15

https://github.com/node-red/node-red-docker/issues/8

#### Accessing Host Devices 主机设备

If you want to access a device from the host inside the container, e.g.  serial port, use the following command-line flag to pass access through.
如果您想从容器内的主机访问设备，例如串行端口，请使用以下命令行标志来传递访问。

```
docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered --device=/dev/ttyACM0 nodered/node-red
```

References: https://github.com/node-red/node-red/issues/15
参考文献：https://github.com/node-red/node-red/issues/15

#### Setting Timezone 设置时区

If you want to modify the default timezone, use the TZ environment variable with the [relevant timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
如果要修改默认时区，请将TZ环境变量与[相关时区一起](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)使用。

```
docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered -e TZ=America/New_York nodered/node-red
```

or within a docker-compose file
或在docker-compose文件中

```
  node-red:
    environment:
      - TZ=America/New_York
```

References: https://groups.google.com/forum/#!topic/node-red/ieo5IVFAo2o
参考资料：https：//groups.google.com/forum/#！topic/node-red/ieo5IVFAo2o

## 从 git 安装

从源代码构建 Node-RED 。获取最新的开发代码，开始贡献。

Building and running the code from source is only intended for users who are happy to be using development code, or for developers wanting to contribute to the project.
从源代码构建和运行代码仅适用于乐于使用开发代码的用户，或者希望为项目做出贡献的开发人员。

### Prerequisites 先决条件

To run Node-RED from source you will need:
要从源代码运行Node-RED，您需要：

- a [supported version of Node.js](https://nodered.org/docs/faq/node-versions).
  [支持的Node.js版本](https://nodered.org/docs/faq/node-versions)。

- a `git` client
  `Git`客户端

- the 

  ```plaintext
  grunt-cli
  ```

   npm module installed globally:    

  
  全局安装的`grunt-grunnpm`模块：

  ```
  sudo npm install -g grunt-cli
  ```

### Cloning the code and installing dependencies 克隆代码并安装依赖项

You can clone the source repository directly from GitHub:
您可以直接从GitHub克隆源代码库：

```
git clone https://github.com/node-red/node-red.git
```

This will create a directory called `node-red` in the current directory that contains the full source code of the project. The rest of these instructions assume you are inside that directory.
这将在当前目录中创建一个名为`node-red的`目录，其中包含项目的完整源代码。这些指令的其余部分假设您在该目录中。

You should then pick which branch you want to build.
然后，您应该选择要构建的分支。

- `master` - the default branch. This is the maintenance branch which contains the code of the current stable release, plus any bug fixes that have been applied ahead of the next maintenance release.
  `master`-默认分支。这是维护分支，包含当前稳定版本的代码，以及在下一个维护版本之前应用的任何错误修复。
- `dev` - the development branch. This is where all new development happens.
  `dev`-开发分支。这是所有新发展发生的地方。

If you want to use the `dev` branch, you should run the command:
如果你想使用`dev`分支，你应该运行命令：

```
git checkout dev
```

Once you are on you your chosen branch, you should install all of the dependencies with the command:
一旦你在你选择的分支上，你应该用命令安装所有的依赖项：

```
npm install
```

### Building Node-RED 构建Node-RED

Before you can start Node-RED you must build it. This can be done using the command:
在启动Node-RED之前，您必须构建它。这可以使用命令完成：

```
grunt build
```

### Running Node-RED 运行Node-RED

You can then run Node-RED using the command:
然后，您可以使用以下命令运行Node-RED：

```
npm start
```

If you want to pass any [command-line arguments](https://nodered.org/docs/getting-started/local#command-line-usage), you must use the following syntax:
如果要传递任何[命令行参数](https://nodered.org/docs/getting-started/local#command-line-usage)，则必须使用以下语法：

```
npm start -- <args>
```

The `--` argument tells `npm` to pass any following arguments to the command it runs.
-`-` 参数告诉`npm`将任何后续参数传递给它运行的命令。

### Automatically restarting 自动再起动

If you are editing the source code you must restart Node-RED to load the changes.
如果您正在编辑源代码，则必须重新启动Node-RED以加载更改。

A special `grunt` task is provided to do this automatically.
提供了一个特殊`的grunt`任务来自动完成此任务。

```
grunt dev
```

This command will build and run Node-RED and then watch the filesystem for any changes to the source code. If it detects changes made to the editor code, it will rebuild the editor component and you can reload the editor to see the changes. If it detects changes made to the runtime or nodes it will restart Node-RED to load those changes.
此命令将构建并运行Node-RED，然后监视文件系统中对源代码的任何更改。如果它检测到对编辑器代码所做的更改，它将重新构建编辑器组件，您可以重新加载编辑器以查看更改。如果它检测到对运行时或节点所做的更改，它将重新启动Node-RED以加载这些更改。

This mode does not allow you to pass arguments to the Node-RED command other than to specify a different flow file:
此模式不允许您将参数传递给Node-RED命令，只能指定不同的流文件：

```
grunt dev --flowFile=my-flow-file.json
```

## BeagleBone Boards

在 BeagleBone 主板上运行 Node-RED 。

### Installing 安装

If you want the latest Node-RED 1.x then you need to use the Debian (10) Buster image from [beagleboard.org](https://beagleboard.org/latest-images) - and then do a full upgrade to latest.
如果你想要最新的Node-RED 1.x，那么你需要使用Debian（10）Buster镜像， [beagleboard.org](https://beagleboard.org/latest-images)-然后完全升级到最新版本。

```
sudo apt update && sudo apt full-upgrade
```

Currently, Debian (10) Buster is only available as an SD card image. If you wish to flash the image to the eMMC, edit the file `/boot/uEnv.txt` file, and uncomment the line
目前，Debian（10）Buster仅以SD卡映像的形式提供。如果您希望将图像闪存到eMMC，请编辑文件`/boot/uEnv. txt`文件，并取消对该行的注释

```
cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh
```

The image can then be flashed to the eMMC like any ‘flasher’ image on the BeagleBoard website. To do this, insert the SD card with the BeagleBone powered off, hold down the S2 button and apply power. Once the LEDs start flashing, release the button. Flashing will take between 5 and 25 minutes. The BeagleBone will power down at the end of this process, the SD card can be removed, and the BeagleBone will now boot from the eMMC.
然后，图像可以像BeagleBoard网站上的任何“闪光器”图像一样闪烁到eMMC。为此，请在BeagleBone断电的情况下插入SD卡，按住S2按钮并通电。一旦LED开始闪烁，松开按钮。闪烁将需要5到25分钟。BeagleBone将在此过程结束时关闭电源，SD卡可以取出，BeagleBone现在将从eMMC靴子启动。

All the 4GB images for BeagleBone boards already have Node-RED pre-installed and set to auto-start, so you can just boot and point your browser at your BeagleBone, port 1880.
BeagleBone板的所有4GB映像都已经预安装了Node-RED并设置为自动启动，因此您只需靴子并将浏览器指向BeagleBone，端口1880。

The 2GB console version suitable for flashing to older eMMC versions of the BBB is not recommended but can be installed as per the manual installation instructions below.
不建议使用适合闪存到旧版eMMC BBB的2GB控制台版本，但可以按照下面的手动安装说明进行安装。

### Running 运行

To view the Node-RED log
查看Node-RED日志

```
sudo journalctl -f -u node-red -o cat
```

To stop Node-RED 停止Node-RED

```
sudo service node-red stop
```

To start Node-RED 启动Node-RED

```
sudo service node-red start
```

To set Node-RED to auto-start on every boot
将Node-RED设置为在每次靴子时自动启动

```
sudo systemctl enable node-red.service
```

and likewise to stop it auto-running on boot
同样地，在靴子时停止其自动运行

```
sudo systemctl disable node-red.service
```

### Upgrading 升级

The latest Debian images already have Node-RED and Node.js installed - the  easiest way to upgrade is to use the built-in upgrade tool:
最新的Debian镜像已经安装了Node-RED和Node.js-最简单的升级方法是使用内置的升级工具：

```
sudo apt update
sudo apt upgrade nodejs bb-node-red-installer
```

This should also restart the Node-RED service - but you will need to refresh any open browser sessions.
这也会重新启动Node-RED服务，但您需要刷新任何打开的浏览器会话。

If you are on the 2017 Debian 9.2 version you may need to run `sudo apt full-upgrade` first.
如果您使用的是2017 Debian 9.2版本，则可能需要先运行`sudo apt full-upgrade`。

**Note**: Do NOT use the Raspberry Pi / Debian upgrade script (`update-nodejs-and-nodered`) as it will re-install both Node.js and Node-RED in different locations and will conflict with and break the existing systemd configuration files.
**注意**：不要使用Raspberry Pi / Debian升级脚本（`update-nodejs-and-nodered`），因为它会在不同的位置重新安装Node.js和Node-RED，并且会与现有的systemd配置文件冲突并破坏它们。

### Configuring 配置

The Beaglebone is configured by default to run Node-RED as root. Therefore the configuration files are located in the `/root/.node-red` directory and you will need root privileges (sudo) to edit them. This is where you need to edit your `settings.js` file for example.
Beaglebone默认配置为以root身份运行Node-RED。因此，配置文件位于 `/root/.node-red`目录，你需要root权限（sudo）来编辑它们。这是你需要编辑你的 例如`settings.js`文件。

Beaglebone also has a systemd service, `/lib/systemd/system/node-red.socket`, that automatically starts Node-RED when it sees an attempt to connect. By default this is port 1880 - but if you want to change that you need to change it here as well as in the `settings.js` file.
Beaglebone还有一个systemd服务 `/lib/systemd/system/node-red.socket` ，当看到尝试连接时，该服务会自动启动Node-RED。默认情况下，这是端口1880 -但如果你想改变，你需要改变它在这里，以及在`settings.js`文件。

### Beaglebone specific nodes Beaglebone特定节点

There are some Beaglebone specific nodes that give you direct access to the I/O pins in the simplest possible manner. The easiest way to install them is direct from npm.
有一些Beaglebone特定的节点可以让您以最简单的方式直接访问I/O引脚。最简单的安装方法是直接从npm安装。

To install manually run the following command:
要手动安装，请运行以下命令：

```
sudo npm install -g --unsafe-perm beaglebone-io johnny-five node-red-contrib-gpio
```

## Android

有点实验性，但可以使用 Termux 在 Android 设备上运行。

Using the [Termux](https://termux.com) app makes it easy to run Node-RED on Android devices. Get it directly from their [github](https://github.com/termux/termux-app#github) or via [F-Droid](https://f-droid.org/) here [Termux on F-Droid](https://f-droid.org/en/packages/com.termux/).
使用[Termux](https://termux.com)应用程序可以轻松在Android设备上运行Node-RED。直接从他们的[github](https://github.com/termux/termux-app#github)或通过[F-Droid](https://f-droid.org/)获取[Termux on F-Droid](https://f-droid.org/en/packages/com.termux/)。

Note that the Play Store version is not maintained.
请注意，Play Store版本不保留。

*Note* : the Node-RED team have no connection with the Termux application nor its development, nor F-Droid. We cannot provide support for it in any way, other than to say that at this point in time it works.
*注意*：Node-RED团队与Termux应用程序及其开发和F-Droid没有任何联系。我们不能以任何方式支持它，只能说，在这个时候，它是有效的。

### Installing 安装

Install it, and run it. Then at the prompt type
安装并运行它。然后在提示符下键入

```
apt update
apt upgrade
apt install coreutils nano nodejs
npm i -g --unsafe-perm node-red
node-red
```

Then you can point a browser to `http://localhost:1880`
然后您可以将浏览器指向`http：//localhost：1880`

Note that installing openssh may make interacting with termux a little easier.  [see this thread](https://discourse.nodered.org/t/android-termux-playstore-no-longer-a-recommended-install-source/85034/4) for a description of one such install.
请注意，安装openssh可能会使与termux的交互更容易一些。[请参阅此线程](https://discourse.nodered.org/t/android-termux-playstore-no-longer-a-recommended-install-source/85034/4)的描述一个这样的安装。

### Notes 注意到

- You can also npm install other node-red nodes such as `node-red-dashboard` in the standard way :
  你也可以npm安装其他node-red节点，比如`node-red-dashboard`：

  ```
  cd ~/.node-red
  npm i node-red-dashboard
  ```

  or via the Pallete Manager.
  或通过托盘管理器。

- The `volume-down` key is the ctrl key - so `vol-down-c` can be used to “break” a running app.
  `volume-down`键是center键，所以`vol-down-c`可以用来“中断”一个正在运行的应用。

- The instructions above also install the `nano` editor, which is useful for editing files.
  上面的说明还安装了`nano`编辑器，这对编辑文件很有用。

### Autostarting 自动起动

The recommended way of starting applications running in Termux is using the [Termux:Boot application](https://github.com/termux/termux-boot) (available from [F-droid](https://f-droid.org/en/packages/com.termux.boot/) - note that the Play Store version may not be maintained, and it’s  recommended to use the same source that you installed termux from).
启动在Termux中运行的应用程序的推荐方法是使用[Termux：靴子应用程序](https://github.com/termux/termux-boot)（可从[F-droid](https://f-droid.org/en/packages/com.termux.boot/)获得-请注意，Play Store版本可能不会被维护，建议使用您安装termux的同一来源）。

We have found this other app useful for autostarting Termux on boot - [Autostart - No Root](https://play.google.com/store/apps/details?id=com.autostart&hl=en_GB) (Note: with termux:boot, use of other autoboot apps does not seem to be required).
我们发现这个其他应用程序对在靴子-[Autostart - No Root](https://play.google.com/store/apps/details?id=com.autostart&hl=en_GB)上自动启动Termux很有用（注意：使用termux：靴子，似乎不需要使用其他自动靴子应用程序）。

Note that the shebang in the node-red script is incompatible with  termux:boot scripts.  The workaround is to start node-red using a  termux:boot startup script like:
请注意，node-red脚本中的shebang与termux：靴子脚本不兼容。解决方法是使用termux：靴子启动脚本启动node-red，如下所示：

```
#!/data/data/com.termux/files/usr/bin/sh
termux-wake-lock
node /data/data/com.termux/files/usr/bin/node-red
```

### Device Access 设备访问

You can get direct access to various hardware on the device by using the extra Termux device plugins - which can then be accessed via `Node-RED` using the `exec` node.
您可以通过使用额外的Termux设备插件直接访问设备上的各种硬件-然后可以通过`Node-RED`使用`exec` node.

**Note**: you need to install both the add-on app, and also the add-on api in Termux.
**注意**：您需要在Termux中安装附加应用程序和附加API。

Install add-on app - Termux:API from the same source you got termux.
安装附加应用程序- Termux：API从同一来源你得到termux。

Install add-on access into Termux
在Termux中安装附加访问

```
apt install termux-api
```

## FlowFuse

运行多租户 Node-RED 解决方案。

FlowFuse allows organizations to reliably deliver Node-RED applications in a continuous, collaborative and secure manner. The key features of FlowFuse are:
FlowCloud允许组织以连续、协作和安全的方式可靠地交付Node-RED应用程序。FlowerTools的主要特点是：

- Collaborative development
  协同发展
- Manage remote deployments
  管理远程部署
- Steamline application delivery
  Steamline应用交付
- Flexible deployment models
  灵活的部署模式
- Professional support for Node-RED and FlowFuse deployments
  为Node-RED和FlowCloud部署提供专业支持

A [free trial](https://app.flowforge.com/account/create) is available for FlowFuse Cloud.
FlowCloud提供[免费试用版](https://app.flowforge.com/account/create)。

You can also run FlowFuse locally, docker-based, or in Kubernetes. Check out our [installation instructions.](https://flowfuse.com/docs/install/).
您还可以在本地、基于docker或在Kubernetes中运行FlowerTools。查看我们 [安装说明。](https://flowfuse.com/docs/install/).

## AWS

开始在 Elastic Beanstalk 或 EC2 上运行。

This guide takes you through the steps to get Node-RED running in an AWS environment.
本指南将带您完成在AWS环境中运行Node-RED的步骤。

There are two approaches:
有两种方法：

1. [Running on the AWS Elastic Beanstalk Service (EB)
   在AWS Elastic Beanstalk Service（EB）上运行](https://nodered.org/docs/getting-started/aws#running-on-aws-ebs)
2. [Running on Elastic Beanstalk with High Availability
   在弹性Beanstalk上运行，具有高可用性](https://nodered.org/docs/getting-started/aws#running-on-elastic-beanstalk-with-high-availability)
3. [Running under an Ubuntu image on AWS EC2
   在AWS EC2上的Ubuntu映像下运行](https://nodered.org/docs/getting-started/aws#running-on-aws-ec2-with-ubuntu)

### Running on AWS EBS 在AWS EBS上运行

#### Prerequisites 先决条件

1. Ensure you have an AWS account with Elastic Beanstalk, SQS and S3 enabled
   确保您拥有启用了Elastic Beanstalk、SQS和S3的AWS帐户
2. Download EB command line and install on your local computer - see [link](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html)
   下载EB命令行并安装在本地计算机上-参见[链接](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html)
3. Create AWS credentials and save in a local file (~/.aws/config or Usersusername.awsconfig) as below
   创建AWS凭证并保存在本地文件（~/.aws/config或Usersusername.awsconfig）中，如下所示

```
[profile eb-cli]
aws_access_key_id = key id
aws_secret_access_key = access key
```

#### Create EB Environment 创建EB环境

1. Create a new directory (e.g. `demoapp`)
   创建一个新目录（例如`demoapp`）
2. cd to that directory cd到该目录
3. run `eb init` to create a new elastic beanstalk project. Select the preferred region  and use node.js as the platform. You will be asked if you wish to use ssh. If you do, please ensure you  have ssh installed on your computer if you wish to generate a new key  pair.
   运行`eb init`创建一个新的弹性beanstalk项目。选择首选区域并使用node.js作为平台。你会被问到是否要使用ssh。如果您这样做，请确保您的计算机上安装了ssh，以便生成新的密钥对。
4. Login to the AWS Console on your browser, select Identity and Access  Management (IAM) and add the AmazonS3FullAccess policy to the  aws-elasticbeanstalk-ec2-role. Note: this gives full access from EBS to  S3 and you may wish to tailor this policy to meet your own security  needs
   在浏览器上登录AWS控制台，选择Identity and Access Management（IAM）并将AmazonS  3FullAccess策略添加到aws-elasticbeanstalk-ec2-role。注意：这提供了从EBS到S3的完全访问权限，您可能希望定制此策略以满足您自己的安全需求

#### Create a Node-RED environment 创建Node-RED环境

1. Create a `package.json` file with the following content (replacing “demoapp” with your app name)
   创建一个包含以下内容`的package.json`文件（将“demoapp”替换为您的应用名称）

```
{
    "name": "demoapp",
    "version": "1.0.0",
    "description": "node-red demo app",
    "main": "",
    "scripts": {
        "start": "./node_modules/.bin/node-red -s ./settings.js"
    },
    "engines": {
        "node": "10.x"
    },
    "dependencies": {
        "node-red": "1.1.x",
        "aws-sdk": "2.4.x",
        "node-red-contrib-storage-s3": "0.0.x",
        "when": "3.7.x"
    },
    "author": "",
    "license": "ISC"
}
```

1. Copy the default [Node-RED settings.js file](https://github.com/node-red/node-red/blob/master/packages/node_modules/node-red/settings.js) to the demoapp directory
   将默认的[Node-RED settings.js文件](https://github.com/node-red/node-red/blob/master/packages/node_modules/node-red/settings.js)复制到demoapp目录
2. Edit the settings.js file to add the following entries to module.exports  (setting awsRegion to that used in eb init and replacing demoapp with  your app name) :
   编辑settings.js文件，将以下条目添加到模块.exports中（将awsRegion设置为eb init中使用的区域，并将demoapp替换为您的应用名称）：

```
     awsRegion: 'eu-west-1',
     awsS3Appname: 'demoapp',
     storageModule: require('node-red-contrib-storage-s3'),
```

1. At the command prompt make sure you are in your application’s top-level directory and run the command `eb create`; you may wish to specify a more unique application name. This will take a long time to run but eventually will return successfully.
   在命令提示符处，确保您位于应用程序的顶级目录中，并运行命令`eb create`;您可能希望指定一个更唯一的应用程序名称。这将需要很长的时间来运行，但最终将成功返回。

#### Configuring Node-RED access 配置Node-RED访问

Node-RED is now accessible directly from the web url of the application. However this is insecure and does not work very well for logging. Instead we  will configure direct access to the administration port of node-red on  the ec2 instance it is using.
Node-RED现在可以直接从应用程序的Web URL访问。然而，这是不安全的，并且对于日志记录不太有效。相反，我们将配置对node-red在其使用的ec2实例上的管理端口的直接访问。

1. In the AWS Console, select EC2, then select security groups. You will see a set of security groups. Select one with the name of your environment  and a description of “Security Group for ElasticBeanstalk Environment”.  Once selected, click on “Actions” and then “Edit inbound settings”. A  dialog box with rules with appear. Add a new rule. Set type to “all  traffic” and source to “my ip”. Save the rule.
   在AWS控制台中，选择EC2，然后选择安全组。您将看到一组安全组。选择一个具有您的环境名称和“ElasticBeanstalk环境安全组”描述的安全组。选择后，点击“操作”，然后点击“编辑入站设置”。出现一个带有规则的对话框。添加新规则。将类型设置为“所有流量”，将来源设置为“我的IP”。保存规则。
2. Select the EC2 instance which is running the node-red application. copy its IP address
   选择正在运行node-red应用程序的EC2实例。复制其IP地址
3. Enter the IP address in the browser with a port of 8081. This will provide direct access to the node-red administration console.
   在浏览器中输入端口为8081的IP地址。这将提供对node-red管理控制台的直接访问。

Note: the public IP address also provides access to the node-red application  and it would be good practice to remove that access at the same time   i.e. the HTTP rule for port 80.
注意事项：公共IP地址还提供了对node-red应用程序的访问，并且同时删除该访问（即，端口80的HTTP规则）将是一个良好的实践。

Your Node-RED instance is now running on EBS. Any flows you create will be  saved to AWS S3 so you can tear down the environment and the flows will  be accessible whenever you redeploy.
您的Node-RED实例现在正在EBS上运行。您创建的任何流都将保存到AWS S3，以便您可以拆除环境，并且无论何时重新部署都可以访问这些流。

### Running on Elastic Beanstalk with High availability 在Elastic Beanstalk上运行，具有高可用性

This deployment option gives you a multiple node Node-RED setup, with a  shared filesystem using Amazon Elastic File System (EFS). Because it  runs multiple nodes behind a load balancer, you will have high  availability - if a node dies, Elastic Beanstalk will replace it  automatically.
此部署选项为您提供多节点Node-RED设置，并使用Amazon Elastic File System（EFS）提供共享文件系统。因为它在负载均衡器后面运行多个节点，所以您将拥有高可用性-如果一个节点死亡，Elastic Beanstalk将自动替换它。

![solution diagram](https://nodered.org/images/node-red-ha-on-aws.png)

To get started, clone the repository here https://github.com/guysqr/node-red-ha-on-aws and follow the simple instructions. The infrastructure is created for  you by a CloudFormation template, so you don’t need to know much about  AWS to set it up.
要开始，请在https://github.com/guysqr/node-red-ha-on-aws克隆存储库，并按照简单的说明操作。基础设施是由CloudFormation模板为您创建的，因此您不需要太了解AWS即可进行设置。

In addition, this deployment option enables you to run Node-RED under  https and to login via Auth0 (or you can easily swap to in-built auth or any Passport-compatible ID provider).
此外，此部署选项使您能够在https下运行Node-RED并通过Auth 0登录（或者您可以轻松地交换到内置的auth或任何与Passport兼容的ID提供程序）。

### Running on AWS EC2 with Ubuntu 使用Ubuntu在AWS EC2上运行

#### Create the base EC2 image 创建基础EC2映像

1. Log in to the [AWS EC2 console](https://console.aws.amazon.com/ec2)
   登录[AWS EC2控制台](https://console.aws.amazon.com/ec2)
2. Click ‘Launch Instance’ 单击“启动实例”
3. In the list of Quick Start AMIs, select **Ubuntu Server**
   在快速入门AMI列表中，选择**Ubuntu服务器**
4. Select the Instance Type - `t2.micro` is a good starting point
   选择实例类型-`t2.micro`是一个很好的起点
5. On the ‘Configure Security Group’ tab, add a new ‘Custom TCP Rule’ for port 1880
   在“配置安全组”选项卡上，为端口1880添加新的“自定义TCP规则
6. On the final ‘Review’ step, click the ‘Launch’ button
   在最后的“查看”步骤中，单击“启动”按钮
7. The console will prompt you to configure a set of SSH keys. Select ‘Create a new key pair’ and click ‘Download key pair’. Your browser will save the `.pem` file - keep that safe. Finally, click ‘Launch’.
   控制台将提示您配置一组SSH密钥。选择“创建新密钥对”，然后单击“下载密钥对”。您的浏览器将保存`.pem`文件-请确保其安全。最后，点击“启动”。

After a couple of minutes your EC2 instance will be running. In the console you can find your instance’s IP address.
几分钟后，您的EC2实例将运行。在控制台中，您可以找到实例的IP地址。

#### Setup Node-RED 设置Node-RED

The next task is to log into the instance then install node.js and Node-RED.
接下来的任务是登录到实例，然后安装node.js和Node-RED。

Follow the AWS guide for [connecting to your instance](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstances.html).
按照AWS指南[连接到实例](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AccessingInstances.html)。

Once logged in you need to install node.js and Node-RED
登录后，您需要安装node.js和Node-RED

```
   curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
   sudo apt-get install -y nodejs build-essential
   sudo npm install -g --unsafe-perm node-red
```

At this point you can test your instance by running `node-red`. *Note*: you may get some errors regarding the Serial node - that’s to be expected and can be ignored.
此时，您可以通过运行`node-red来`测试您的实例。*注意*：您可能会得到一些关于串行节点的错误-这是预期的，可以忽略。

Once started, you can access the editor at `http://<your-instance-ip>:1880/`.
一旦开始，您可以访问编辑器 `http://<your-instance-ip>:1880/` 。

To get Node-RED to start automatically whenever your instance is restarted, you can use pm2:
要让Node-RED在您的实例重新启动时自动启动，您可以使用pm2：

```
   sudo npm install -g --unsafe-perm pm2
   pm2 start `which node-red` -- -v
   pm2 save
   pm2 startup
```

**Note:** this final command will prompt you to run a further command - **make sure you do as it says**.
**注意：**最后一个命令将提示您运行另一个命令-**确保您按照它说的做**。

### Next steps 后续步骤

This guide barely scratches the surface of how you may choose to configure your instance to run in EC2. Node-RED is ‘just’ a node.js application that exposes an HTTP server - on that principle, there are many online guides you can use to learn what else is possible.
本指南仅涉及如何选择配置实例以在EC2中运行的皮毛。Node-RED“只是”一个node.js应用程序，它公开了一个HTTP服务器--基于这一原则，有许多在线指南可以帮助你了解其他可能性。

## Microsoft Azure

在 Azure 虚拟机实例上运行。

This guide takes you through the steps to get Node-RED running on an Azure Virtual Machine instance.
本指南将带您完成在Azure虚拟机实例上运行Node-RED的步骤。

### Create the base image 创建基础映像

1. 登录到 [Azure 控制台](https://portal.azure.com/)
   
2. Click to add a New … Virtual Machine
   单击以添加新.虚拟机

3. In the list of Virtual Machines, select **Ubuntu Server**, then click ‘Create’
   在虚拟机列表中，选择**Ubuntu服务器**，然后单击“创建”

4. Give your machine a name, the username you want to use and the authentication details you want to use to access the instance
   给你的机器一个名字，你想使用的用户名和你想用来访问实例的身份验证细节

5. Choose the Size of your instance. Remember that node.js is single-threaded so there’s no benefit to picking a size with multiple cores for a simple node-red instance. `A1 Basic` is a good starting point
   选择实例的大小。请记住，node.js是单线程的，因此为一个简单的node-red实例选择多核大小没有任何好处。`A1 Basic`是一个很好的起点

6. On the ‘Settings’ step, click on the ‘Network security group’ option. Add a new ‘Inbound rule’ with the options set as:    

   
   在“设置”步骤中，单击“网络安全组”选项。添加 新的“删除规则”，其选项设置为：

   - Name: node-red-editor Name：zhang cheng
   - Priority: 1010 优先级：1010
   - Protocol: TCP 协议：TCP
   - Destination port range: 1880
     目的端口范围：1880

7. Click ‘Ok’ on the Settings page, check the Summary then click ‘Ok’ to deploy the new instance
   在设置页面上单击“确定”，检查摘要，然后单击“确定”以部署新实例

After a couple of minutes your instance will be running. In the console you can find your instance’s IP address
几分钟后，您的实例将运行。在控制台中，您可以找到实例的IP地址

### 设置  Node-RED

The next task is to log into the instance then install node.js and Node-RED.
接下来的任务是登录到实例，然后安装node.js和Node-RED。

Log into your instance using the authentication details you specified in the previous stage.
使用您在前一阶段中指定的身份验证详细信息登录到实例。

Once logged in you need to install node.js and Node-RED
登录后，您需要安装node.js和Node-RED

```
   curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
   sudo apt-get install -y nodejs build-essential
   sudo npm install -g --unsafe-perm node-red
```

At this point you can test your instance by running `node-red`. *Note*: you may get some errors regarding the Serial node - that’s to be expected and can be ignored.
此时，您可以通过运行`node-red来`测试您的实例。*注意*：您可能会得到一些关于串行节点的错误-这是预期的，可以忽略。

Once started, you can access the editor at `http://<your-instance-ip>:1880/`.
一旦开始，您可以访问编辑器 `http://<your-instance-ip>:1880/` 。

To get Node-RED to start automatically whenever your instance is restarted, you can use pm2:
要让Node-RED在您的实例重新启动时自动启动，您可以使用pm2：

```
   sudo npm install -g --unsafe-perm pm2
   pm2 start `which node-red` -- -v
   pm2 save
   pm2 startup
```

*Note:* this final command will prompt you to run a further command - make sure you do as it says.
*注意：*最后一个命令将提示您运行另一个命令-确保您按照它说的做。