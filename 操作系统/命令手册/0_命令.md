# 命令

[TOC]

## 概论

Current Linux systems have graphical utilities dedicated to the work  of an administrator. However, it is important to be able to use the  interface in command line mode for several reasons:

- The majority of system commands are common to all Linux distributions, which is not the case for graphical tools.
- It can happen that the system does not start correctly but that a backup command interpreter remains accessible.
- Remote administration is done on the command line with an SSH terminal.
- In order to preserve server resources, the graphical interface is either not installed or launched on demand.
- Administration is done by scripts.

Learning these commands allows the administrator to connect to a  Linux terminal, to manage its resources, its files, to identify the  station, the terminal, and the connected users, etc.

### The users[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#the-users)

The user of a Linux system is defined in the `/etc/passwd` file, by:

- a **login name**, more commonly called "login", containing no spaces;
- a numeric identifier : **UID** (User Identifier);
- a group identifier : **GID** (Group Identifier);
- a **command interpreter**, a shell, which can be different from one user to another;
- a **connection directory**, the **home directory**.

In other files by:

- a **password**, which will be encrypted before being stored (`/etc/shadow`);
- a **command prompt**, or **prompt** login, which will be symbolized by a `#` for administrators and a `$` for other users (`/etc/profile`).

Depending on the security policy implemented on the system, the  password will have to contain a certain number of characters and meet  certain complexity requirements.

Among the existing command interpreters, the **Bourne-Again Shell** (`/bin/bash`) is the one most frequently used. It is assigned by default to new  users. For various reasons, advanced Linux users can choose alternative  shells from among the Korn Shell (`ksh`), the C Shell (`csh`), etc.

The user's login directory is by convention stored in the `/home` directory of the workstation. It will contain the user's personal data  and the configuration files of his applications. By default, at login,  the login directory is selected as the current directory.

A workstation type installation (with graphical interface) starts  this interface on terminal 1. Linux being multi-user, it is possible to  connect several users several times, on different **physical terminals** (TTY) or **virtual terminals** (PTS). Virtual terminals are available within a graphical environment. A user switches from one physical terminal to another using Alt + Fx from the command line or using CTRL + Alt + Fx.

### The shell[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#the-shell)

Once the user is connected to a console, the shell displays the command **prompt**. It then behaves like an infinite loop, with each statement entered:

- displaying the command prompt;
- reading the command ;
- syntax analysis ;
- substitution of special characters ;
- execute the command;
- display the command prompt;
- etc.

The key sequence CTRL + C is used to interrupt a running command.

The use of a command generally follows this sequence:

```
command [option(s)] [arguments(s)]
```

The name of the command is **often in lower case**.

A space separates each item.

Short **options** begin with a dash (`-l`), while **long options** begin with two dashes (`--list`). A double dash (`--`) indicates the end of the option list.

It is possible to group some short options together:

```
$ ls -l -i -a
```

is equivalent to:

```
$ ls -lia
```

There can of course be several arguments after an option:

```
$ ls -lia /etc /home /var
```

In the literature, the term "option" is equivalent to the term  "parameter," which is more commonly used in programming. The optional  side of an option or argument is symbolized by enclosing it in square  brackets `[` and `]`. When more than one option is possible, a vertical bar called a "pipe" separates them `[a|e|i]`.

## General commands[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#general-commands)

### `apropos`, `whatis` and `man` commands[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#apropos-whatis-and-man-commands)

It is impossible for an administrator at any level to know all the  commands and options in detail. A manual is usually available for all  installed commands.

#### `apropos` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#apropos-command)

The command `apropos` allows you to search by keyword within these manual pages:

| Options                                     | Observations                                               |
| ------------------------------------------- | ---------------------------------------------------------- |
| `-s`, `--sections list` or `--section list` | Limited to manual sections.                                |
| `-a` or `--and`                             | Displays only the item matching all the provided keywords. |

Example:

```
$ apropos clear
clear (1)            - clear the terminal screen
clear_console (1)    - clear the console
clearenv (3)         - clear the environment
clearerr (3)         - check and reset stream status
clearerr_unlocked (3) - nonlocking stdio functions
feclearexcept (3)    - floating-point rounding and exception handling
fwup_clear_status (3) - library to support management of system firmware updates
klogctl (3)          - read and/or clear kernel message ring buffer; set console_loglevel
sgt-samegame (6)     - Block-clearing puzzle
syslog (2)           - read and/or clear kernel message ring buffer; set console_loglevel
timerclear (3)       - timeval operations
XClearArea (3)       - clear area or window
XClearWindow (3)     - clear area or window
XSelectionClearEvent (3) - SelectionClear event structure
```

To find the command that will allow changing the password of an account:

```
$ apropos --exact password  -a change
chage (1)            - change user password expiry information
passwd (1)           - change user password
```

#### `whatis` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#whatis-command)

The `whatis` command displays the description of the command passed as argument:

```
whatis clear
```

Example:

```
$ whatis clear
clear (1)            - clear the terminal screen
```

#### `man` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#man-command)

Once found by `apropos` or `whatis`, the manual is read by `man` ("Man is your friend"). This set of manuals is divided into 8 sections, grouping information by topic, the default section being 1:

1. User Commands;
2. System Calls;
3. C library functions;
4. Peripherals and special files;
5. File formats ;
6. Games;
7. Miscellaneous;
8. System administration tools and daemons. Information about each section can be accessed by typing `man x intro`, where `x` is the section number.

The command:

```
man passwd
```

will tell the administrator about the passwd command, its options, etc. While a:

```
$ man 5 passwd
```

will inform him about the files related to the command.

Not all pages of the manual are translated from English. However,  they are generally very accurate and provide all the information needed. The syntax used and the division may confuse the beginner  administrator, but with practice, he will quickly find the information  he is looking for.

The navigation in the manual is done with the arrows ↑ and ↓. The manual is exited by pressing the q key.

### `shutdown` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#shutdown-command)

The `shutdown` command allows you to **electrically shut down** a Linux server, either immediately or after a certain period of time.

```
shutdown [-h] [-r] time [message]
```

The shutdown time should be specified in the format `hh:mm` for a precise time, or `+mm` for a delay in minutes.

To force an immediate stop, the word `now` will replace the time. In this case, the optional message is not sent to other users of the system.

Examples:

```
[root]# shutdown -h 0:30 "Server shutdown at 0:30"
[root]# shutdown -r +5
```

Options:

| Options | Remarks                          |
| ------- | -------------------------------- |
| `-h`    | Shutdown the system electrically |
| `-r`    | Restarts the system              |

### `history` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#history-command)

The `history` command displays the history of commands that have been entered by the user. The commands are stored in the `.bash_history` file in the user's login directory.

Example of a history command

```
$ history
147 man ls
148 man history
```

| Options | Comments                                                     |
| ------- | ------------------------------------------------------------ |
| `-w`    | The `-w` option will copy the history of the current session to it. |
| `-c`    | The `-c` option will delete the history of the current session (but not the contents of the `.bash_history` file). |

- Manipulating history:

To manipulate the history, the following commands entered from the command prompt will:

| Keys    | Function                                                  |
| ------- | --------------------------------------------------------- |
| !!      | Recall the last command placed.                           |
| !n      | Recall the command by its number in the list.             |
| !string | Recall the most recent command beginning with the string. |
| ↑       | Recall the most recent command beginning with the string. |
| ↓       | Recall the most recent command beginning with the string. |

### The auto-completion[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#the-auto-completion)

Auto-completion is also a great help.

- It allows you to complete commands, entered paths, or file names.
- A press of the TAB key completes the entry in the case of a single solution.
- Otherwise, a second press will be required to obtain the list of possibilities.

If a double press of the TAB key causes no reaction from the system, then there is no solution to the current completion.

## Display and identification[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#display-and-identification)

### `clear` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#clear-command)

The `clear` command clears the contents of the terminal  screen. In fact, to be more precise, it shifts the display so that the  command prompt is at the top of the screen on the first line.

In a terminal, the display will be permanently hidden, whereas in a  graphical interface, a scrollbar will allow you to go back in the  history of the virtual terminal.

!!! Tip CTRL + L will have the same effect as the `clear` command

### `echo` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#echo-command)

The `echo` command is used to display a string of characters.

This command is most commonly used in administration scripts to inform the user during execution.

The `-n` option will not return to the line after displaying the text (which is the default behavior of the command).

For various reasons, the script developer may need to use special sequences (starting with a `\` character). In this case, the `-e` option will be stipulated, allowing interpretation of the sequences.

Among the frequently used sequences, we can mention:

| Sequence | Result                |
| -------- | --------------------- |
| `\a`     | Send a sonor bip      |
| `\b`     | Back                  |
| `\n`     | Adds a line break     |
| `\t`     | Adds a horizontal tab |
| `\v`     | Adds vertical tab     |

### `date` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#date-command)

The `date` command displays the date and time. The command has the following syntax:

```
date [-d AAAAMMJJ] [format]
```

Examples:

```
$ date
Mon May 24 16:46:53 CEST 2021
$ date -d 20210517 +%j
137
```

In this last example, the `-d` option displays a given date. The `+%j` option formats this date to show only the day of the year.

!!! Warning The format of a date can change depending on the value of the language defined in the environment variable `$LANG`.

The date display can follow the following formats:

| Option | Format                           |
| ------ | -------------------------------- |
| `+%A`  | Full Name of Day                 |
| `+%B`  | Full Name of Month               |
| `+%c`  | Full Date Display                |
| `+%d`  | Day number                       |
| `+%F`  | Date in `YYYY-MM-DD` format      |
| `+%G`  | Year                             |
| `+%H`  | Time of day                      |
| `+%j`  | Day of the year                  |
| `+%m`  | Month number                     |
| `+%M`  | Minute                           |
| `+%R`  | Time in `hh:mm` format           |
| `+%s`  | Seconds since January 1, 1970    |
| `+%T`  | Time in `hh:mm:ss` format        |
| `+%u`  | Day of the week (`1` for Monday) |
| `+%V`  | Week number (`+%V`)              |
| `+%x`  | Date in format `DD/MM/YYYY`      |

The `date` command also allows you to change the system date and time. In this case, the `-s` option will be used.

```
[root]# date -s "2021-05-24 10:19"
```

The format to be used following the `-s` option is this:

```
date -s "[AA]AA-MM-JJ hh:mm:[ss]"
```

### `id`, `who` and `whoami` commands[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#id-who-and-whoami-commands)

The `id` command displays the name of the current user and its groups or those of a user, if the user's login is given as an argument.

```
$ id rockstar
uid=1000(rockstar) gid=1000(rockstar) groups=1000(rockstar),10(wheel)
```

The `-g`, `-G`, `-n` and `-u` options display the main group GID, subgroup GIDs, names instead of numeric identifiers, and the user's UID respectively.

The `whoami` command displays the login of the current user.

The `who` command alone displays the names of logged in users:

```
$ who
rockstar tty1   2021-05-24 10:30
root     pts/0  2021-05-24 10:31
```

Since Linux is multi-user, it is likely that multiple sessions are  open on the same station, either physically or over the network. It is  interesting to know which users are logged in, if only to communicate  with them by sending messages.

- tty: represents a terminal.
- pts/: represents a virtual console in a graphical environment with  the number after representing the instance of the virtual console (0, 1, 2...)

The `-r` option also displays the execution level (see chapter "startup").

## 文件及目录操作

* cat
* cd
* cp
* head
* less
* ls
* mkdir
* more
* mv
* rm
* rmdir
* stat
* tail
* touch
* tree

In Linux, the file tree is an inverted tree, called a **single hierarchical tree**, whose root is the directory `/`.

The **current directory** is the directory where the user is located.

The **connection directory** is the working directory associated with the user. The login directories are, by default, stored in the `/home` directory.

When the user logs in, the current directory is the login directory.

An **absolute path** references a file from the root by traversing the entire tree to the file level:

- `/home/groupA/alice/file`

The **relative path** references that same file by traversing the entire tree from the current directory:

- `../alice/file`

In the above example, the "`..`" refers to the parent directory of the current directory.

A directory, even if it is empty, will necessarily contain at least **two references**:

- `.`: reference to itself.
- `..`: reference to the parent directory of the current directory.

A relative path can thus start with `./` or `../`. When the relative path refers to a subdirectory or file in the current directory, then the `./` is often omitted. Mentioning the first `./` in the tree will only really be required to run an executable file.

Errors in paths can cause many problems: creating folders or files in the wrong places, unintentional deletions, etc. It is therefore  strongly recommended to use auto-completion when entering paths.

![our example tree](https://docs.rockylinux.org/books/admin_guide/images/commands-pathabsolute.png)

In the above example, we are looking to give the location of the file `myfile` from the directory of bob.

- By an **absolute path**, the current directory does not matter. We start at the root, and work our way down to the directories `home`, `groupA`, `alice` and finally the file `myfile`: `/home/groupA/alice/myfile`.
- By a **relative path**, our starting point being the current directory `bob`, we go up one level through `..` (i.e., into the `groupA` directory), then down into the alice directory, and finally the `myfile` file: `../alice/myfile`.

### `pwd` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#pwd-command)

The `pwd` (Print Working Directory) command displays the absolute path of the current directory.

```
$ pwd
/home/rockstar
```

To move around using a relative path, you must know its position in the tree.

Depending on the command interpreter, the command prompt may also display the name of the current directory.









## Visualization[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#visualization)

### `file` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#file-command)

The `file` command displays the type of a file.

```
file file1 [files]
```

Example:

```
$ file /etc/passwd /etc
/etc/passwd:    ASCII text
/etc:        directory
```

### `tac` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#tac-command)

The `tac` command does almost the opposite of the `cat` command. It displays the contents of a file starting from the end (which is particularly interesting for reading logs!).

Example: Display a log file by displaying the last line first:

```
[root]# tac /var/log/messages | less
```





### `sort` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#sort-command)

The `sort` command sorts the lines of a file.

It allows you to order the result of a command or the content of a  file in a given order, numerically, alphabetically, by size (KB, MB, GB) or in reverse order.

```
sort [-kx] [-n] [-u] [-o file] [-ty] file
```

Example:

```
$ sort -k3 -t: -n /etc/passwd
root:x:0:0:root:/root:/bin/bash
adm:x:3:4:adm:/var/adm/:/sbin/nologin
```

| Option    | Observation                                  |
| --------- | -------------------------------------------- |
| `-kx`     | Specifies the `x` column to sort on          |
| `-n`      | Requests a numeric sort                      |
| `-o file` | Saves the sort to the specified file         |
| `-ty`     | Specifies the field separator character `y`. |
| `-r`      | Reverse the order of the result              |
| `- u`     | unique                                       |

The `sort` command sorts the file only on the screen. The file is not modified by the sorting. To save the sort, use the `-o` option or an output redirection `>`.

By default, the numbers are sorted according to their character.  Thus, "110" will be before "20", which will itself be before "3". The `-n` option must be specified so that the numeric character blocks are sorted by their value.

The `sort` command reverses the order of the results, with the `-r` option:

```
$ sort -k3 -t: -n -r /etc/passwd
root:x:0:0:root:/root:/bin/bash
adm:x:3:4:adm:/var/adm/:/sbin/nologin
```

In this example, the `sort` command will sort the contents of the `/etc/passwd` file this time from largest uid to smallest.

Some advanced examples of using the `sort` command:

- Shuffling values

The `sort` command also allows you to shuffle values with the `-R` option:

```
$ sort -R /etc/passwd
```

- Sorting IP addresses

A system administrator is quickly confronted with the processing of  IP addresses from the logs of his services such as SMTP, VSFTP or  Apache. These addresses are typically extracted with the `cut` command.

Here is an example with the file `dns-client.txt`:

```
192.168.1.10
192.168.1.200
5.1.150.146
208.128.150.98
208.128.150.99
$ sort -nr dns-client.txt
208.128.150.99
208.128.150.98
192.168.1.200
192.168.1.10
5.1.150.146
```

- Sorting file by removing duplicates

The `sort` command knows how to remove the duplicates from the file output using `-u` as option.

Here is an example with the file `colours.txt`:



```
Red
Green
Blue
Red
Pink
$ sort -u colours.txt
Blue
Green
Pink
Red
```



- Sorting file by sizes

The `sort` command knows how to recognize file sizes, from commands like `ls` with the `-h` option.

Here is an example with the file `size.txt`:

```
1,7G
18M
69K
2,4M
1,2M
4,2G
6M
124M
12,4M
4G
$ sort -hr size.txt
4,2G
4G
1,7G
124M
18M
12,4M
6M
2,4M
1,2M
69K
```

### `wc` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#wc-command)

The `wc` command counts the number of lines, words and/or bytes in a file.

```
wc [-l] [-m] [-w] file [files]
```

| Option | Observation                     |
| ------ | ------------------------------- |
| `-c`   | Count the number of bytes.      |
| `-m`   | Count the number of characters. |
| `-l`   | Counts the number of lines.     |
| `-w`   | Counts the number of words.     |

## Search[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#search)

### `find` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#find-command)

The `find` command searches for files or directories location.

```
find directory [-name name] [-type type] [-user login] [-date date]
```

Since there are so many options to the `find` command, it is best to refer to the `man`.

If the search directory is not specified, the `find` command will search from the current directory.

| Option              | Observation                            |
| ------------------- | -------------------------------------- |
| `-perm permissions` | Search for files by their permissions. |
| `-size size`        | Search for files by size.              |

### `-exec` option of the `find` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#-exec-option-of-the-find-command)

It is possible to use the `-exec` option of the `find` command to execute a command on each result line:

```
$ find /tmp -name *.txt -exec rm -f {} \;
```

The previous command searches for all files in the `/tmp` directory named `*.txt` and deletes them.

!!! Tip "Understand the `-exec` option" In the example above, the `find` command will construct a string representing the command to be executed.

````
If the `find` command finds three files named `log1.txt`, `log2.txt`, and `log3.txt`, then the `find` command will construct the string by replacing in the string `rm -f {} \;` the braces with one of the results of the search, and do this as many times as there are results.

This will give us:

```
rm -f /tmp/log1.txt ; rm -f /tmp/log2.txt ; rm -f /tmp/log3.txt ;
```


The `;` character is a special shell character that must be protected by a `\` to prevent it from being interpreted too early by the `find` command (and not in the `-exec`).
````

!!! Tip `$ find /tmp -name *.txt -delete` does the same thing.

### `whereis` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#whereis-command)

The `whereis` command searches for files related to a command.

```
whereis [-b] [-m] [-s] command
```

Example:

```
$ whereis -b ls
ls: /bin/ls
```

| Option | Observation                     |
| ------ | ------------------------------- |
| `-b`   | Search only the binary file.    |
| `-m`   | Searches only for man pages.    |
| `-s`   | Searches only for source files. |

### `grep` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#grep-command)

The `grep` command searches for a string in a file.

```
grep [-w] [-i] [-v] "string" file
```

Example:

```
$ grep -w "root:" /etc/passwd
root:x:0:0:root:/root:/bin/bash
```

| Option | Observation                             |
| ------ | --------------------------------------- |
| `-i`   | Ignore the case of the searched string. |
| `-v`   | Excludes lines containing the string.   |
| `-w`   | Search for the exact word.              |

The `grep` command returns the complete line containing the string you are looking for. * The `^` special character is used to search for a string at the beginning of a line. * The special character `$` searches for a string at the end of a line.

```
$ grep -w "^root" /etc/passwd
```

!!! Note This command is very powerful and it is highly recommended to consult its manual. It has many derivatives.

It is possible to search for a string in a file tree with the `-R` option.

```
grep -R "Virtual" /etc/httpd
```

### Meta-characters (wildcards)[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#meta-characters-wildcards)

Meta-characters replace one or more characters (or even an absence of characters) during a search. These meta-characters are also known as  wildcards. They can be combined. The `*` character replaces a string composed of any characters. The `*` character can also represent an absence of character.

```
$ find /home -name "test*"
/home/rockstar/test
/home/rockstar/test1
/home/rockstar/test11
/home/rockstar/tests
/home/rockstar/test362
```

Meta-characters allow more complex searches by replacing all or part  of a word. Simply replace the unknowns with these special characters.

The character `?` replaces a single character, whatever it is.

```
$ find /home -name "test?"
/home/rockstar/test1
/home/rockstar/tests
```

The square brackets `[` are used to specify the values that a single character can take.

```
$ find /home -name "test[123]*"
/home/rockstar/test1
/home/rockstar/test11
/home/rockstar/test362
```

!!! Note Always surround words containing meta-characters with `"` to prevent them from being replaced by the names of files that meet the criteria.

!!! Warning Do not confuse shell meta-characters with regular expression meta-characters. The `grep` command uses regular expression meta-characters.

## Redirects and pipes[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#redirects-and-pipes)

### Standard input and output[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#standard-input-and-output)

On UNIX and Linux systems, there are three standard streams. They allow programs, via the `stdio.h` library, to input or output information.

These streams are called X channel or X file descriptor.

By default: * the keyboard is the input device for channel 0, called **stdin** ; * the screen is the output device for channels 1 and 2, called **stdout** and **stderr**.

![standards channels](https://docs.rockylinux.org/books/admin_guide/images/input-output.png)

**stderr** receives the error streams returned by a command. The other streams are directed to **stdout**.

These streams point to peripheral files, but since everything is a  file in UNIX/Linux, I/O streams can easily be diverted to other files.  This principle is the strength of the shell.

### Input redirection[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#input-redirection)

It is possible to redirect the input stream from another file with the character `<` or `<<`. The command will read the file instead of the keyboard:

```
$ ftp -in serverftp << ftp-commands.txt
```

!!! Note Only commands that require keyboard input will be able to handle input redirection.

Input redirection can also be used to simulate user interactivity.  The command will read the input stream until it encounters the defined  keyword after the input redirection.

This feature is used to script interactive commands:

```
$ ftp -in serverftp << END
user alice password
put file
bye
END
```

The keyword `END` can be replaced by any word.

```
$ ftp -in serverftp << STOP
user alice password
put file
bye
STOP
```

The shell exits the `ftp` command when it receives a line containing only the keyword.

!!! Warning The ending keyword, here `END` or `STOP`, must be the only word on the line and must be at the beginning of the line.

The standard input redirection is rarely used because most commands accept a filename as an argument.

The command `wc` could be used like this:

```
$ wc -l .bash_profile
27 .bash_profile # the number of lines is followed by the file name
$ wc -l < .bash_profile
27 # returns only the number of lines
```

### Output redirection[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#output-redirection)

Standard output can be redirected to other files using the `>` or `>>` characters.

The simple `>` redirection overwrites the contents of the output file:

```
$ date +%F > date_file
```

while the double redirection `>>` adds (concatenates) to the content of the output file.

```
$ date +%F >> date_file
```

In both cases, the file is automatically created when it does not exist.

The standard error output can also be redirected to another file.  This time it will be necessary to specify the channel number (which can  be omitted for channels 0 and 1):

```
$ ls -R / 2> errors_file
$ ls -R / 2>> errors_file
```

### Examples of redirection[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#examples-of-redirection)

Redirection of 2 outputs to 2 files:

```
$ ls -R / >> ok_file 2>> nok_file
```

Redirection of the 2 outputs to a single file:

```
$ ls -R / >> log_file 2>&1
```

Redirection of *stderr* to a "bottomless pit" (`/dev/null`):

```
$ ls -R / 2>> /dev/null
```

When both output streams are redirected, no information is displayed  on the screen. To use both the output redirection and to keep the  display, you will have to use the command `tee`.

### Pipes[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#pipes)

A **pipe** is a mechanism allowing you to link the standard output of a first command to the standard input of a second command.

This communication is uni directional and is done with the `|` symbol. The pipe symbol `|` is obtained by pressing the  SHIFT + | simultaneously.

![pipe](https://docs.rockylinux.org/books/admin_guide/images/pipe.png)

All data sent by the control on the left of the pipe through the  standard output channel is sent to the standard input channel of the  control on the right.

The commands particularly used after a pipe are filters.

- Examples:

Display only the beginning:

```
$ ls -lia / | head
```

Display only the end:

```
$ ls -lia / | tail
```

Sort the result:

```
$ ls -lia / | sort
```

Count the number of words / characters:

```
$ ls -lia / | wc
```

Search for a string in the result:

```
$ ls -lia / | grep fichier
```

## Special points[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#special-points)

### `tee` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#tee-command)

The `tee` command is used to redirect the standard output of a command to a file while maintaining the screen display.

It is combined with the `|` pipe to receive as input the output of the command to be redirected:

```
$ ls -lia / | tee fic
$ cat fic
```

The `-a` option adds to the file instead of overwriting it.

### `alias` and `unalias` commands[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#alias-and-unalias-commands)

Using **alias** is a way to ask the shell to remember a particular command with its options and give it a name.

For example:

```
$ ll
```

will replace the command:

```
$ ls -l
```

The `alias` command lists the aliases for the current  session. Aliases are set by default on Linux distributions. Here, the  aliases for a Rocky server:

```
$ alias
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```

The aliases are only defined temporarily, for the time of the user session.

For permanent use, they must be created in the:

- `.bashrc` file in the user's login directory;
- `/etc/profile.d/alias.sh` file for all users.

!!! Warning Special care must be taken when using aliases which can  be potentially dangerous! For example, an alias set up without the  administrator's knowledge:

````
```bash
alias cd='rm -Rf'
```
````

The `unalias` command allows you to delete aliases.

To delete a single alias:

```
$ unalias ll
```

To delete all aliases:

```
$ unalias -a
```

To disable an alias temporarily, the combination is `\<alias name>`.

For example if we do:

```
$ type ls
```

it might return the following:

```
ls is an alias to « ls -rt »
```

Now that this is known, we can see the results of using the alias or disabling it one time with the `\` by executing the following:

```
$ ls file*   # order by time
file3.txt  file2.txt  file1.txt
$ \ls file*  # order by name
file1.txt  file2.txt  file3.txt
```

### Aliases and useful functions[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#aliases-and-useful-functions)

- `grep` alias Colorize the result of the `grep` command: `alias grep='grep --color=auto'`
- `mcd` function It is common to create a folder and then move around in it: `mcd() { mkdir -p "$1"; cd "$1"; }`
- `cls` function Move to a folder and list its contents: `cls() { cd "$1"; ls; }`
- `backup` function Create a backup copy of a file: `backup() { cp "$1"{,.bak}; }`
- `extract` function Extract any type of archive:

```
extract () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
      *.tar.gz) tar xzf $1 ;;
      *.bz2) bunzip2 $1 ;;
      *.rar) unrar e $1 ;;
      *.gz) gunzip $1 ;;
      *.tar) tar xf $1 ;;
      *.tbz2) tar xjf $1 ;;
      *.tgz) tar xzf $1 ;;
      *.zip) unzip $1 ;;
      *.Z) uncompress $1 ;;
      *.7z) 7z x $1 ;;
      *)
        echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}
```

- If `alias cmount` returns the following: `alias cmount="mount | column -t"`

Then we can use cmount to show all of the system mounts in columns like this:

```
[root]# cmount
```

which would return our mounted filesystem in the following format:

```
/dev/simfs  on  /                                          type  simfs        (rw,relatime,usrquota,grpquota)
proc        on  /proc                                      type  proc         (rw,relatime)
sysfs       on  /sys                                       type  sysfs        (rw,relatime)
none        on  /dev                                       type  devtmpfs     (rw,relatime,mode=755)
none        on  /dev/pts                                   type  devpts       (rw,relatime,mode=600,ptmxmode=000)
none        on  /dev/shm                                   type  tmpfs        (rw,relatime)
none        on  /proc/sys/fs/binfmt_misc                   type  binfmt_misc  (rw,relatime)
```

### The character `;`[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#the-character)

The `;` character strings the commands.

The commands will all run sequentially in the order of input once the user presses ENTER.

```
$ ls /; cd /home; ls -lia; cd /
```

## 检测所学知识[¶](https://docs.rockylinux.org/zh/books/admin_guide/03-commands/#_2)

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) What defines a user under Linux? (7 answers)

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) What characterizes a long option for an order?

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) Which commands allow you to search for help on a command:

-  `google`
-  `chuck --norris`
-  `info`
-  `apropos`
-  `whatis`

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) Which command allows you to view a user's history?

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) Which command allows you to search for text in a file?

-  `find`
-  `grep`

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) Which command allows you to search for a file?

-  `find`
-  `grep`

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) Which command redirects the error stream of a command to a new `errors.log` file:

-  `ls -R / 2> errors.log`
-  `ls -R / 2>> errors.log`
-  `ls -R / 2> errors.log 2>&1`   

Author: Antoine Le Morvan

Contributors: Steven Spencer, Aditya Putta







# Advanced Commands for Linux users[¶](https://docs.rockylinux.org/zh/books/admin_guide/04-advanced-commands/#advanced-commands-for-linux-users)

In this chapter you will learn some advanced commands for Linux.

------

**Objectives** : In this chapter, future Linux administrators will learn:

![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) some useful commands not covered in the previous chapter; 
 ![✔](https://twemoji.maxcdn.com/v/latest/svg/2714.svg) some advanced commands.

![🏁](https://twemoji.maxcdn.com/v/latest/svg/1f3c1.svg) **user commands**, **Linux**

**Knowledge**: ![⭐](https://twemoji.maxcdn.com/v/latest/svg/2b50.svg) 
 **Complexity**: ![⭐](https://twemoji.maxcdn.com/v/latest/svg/2b50.svg) ![⭐](https://twemoji.maxcdn.com/v/latest/svg/2b50.svg) ![⭐](https://twemoji.maxcdn.com/v/latest/svg/2b50.svg)

**阅读时间**: 20 分钟

------

## `uniq` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/04-advanced-commands/#uniq-command)

The `uniq` command is a very powerful command, used with the `sort` command, especially for log file analysis. It allows you to sort and display entries by removing duplicates.

To illustrate how the `uniq` command works, let's use a `firstnames.txt` file containing a list of first names:

```
antoine
xavier
steven
patrick
xavier
antoine
antoine
steven
```

!!! Note `uniq` requires the input file to be sorted because it only compares consecutive lines.

Without an argument, the `uniq` command will not display identical lines that follow each other in the `firstnames.txt` file:

```
$ sort firstnames.txt | uniq
antoine
patrick
steven
xavier
```

To display only the rows that appear only once, use the `-u` option:

```
$ sort firstnames.txt | uniq -u
patrick
```

Conversely, to display only the lines that appear at least twice in the file, you must use the `-d` option:

```
$ sort firstnames.txt | uniq -d
antoine
steven
xavier
```

To simply delete lines that appear only once, use the `-D` option:

```
$ sort firstnames.txt | uniq -D
antoine
antoine
antoine
steven
steven
xavier
xavier
```

Finally, to count the number of occurrences of each line, use the `-c` option:

```
$ sort firstnames.txt | uniq -c
      3 antoine
      1 patrick
      2 steven
      2 xavier
$ sort firstnames.txt | uniq -cd
      3 antoine
      2 steven
      2 xavier
```

## `xargs` commands[¶](https://docs.rockylinux.org/zh/books/admin_guide/04-advanced-commands/#xargs-commands)

The `xargs` command allows the construction and execution of command lines from standard input.

The `xargs` command reads whitespace or linefeed delimited arguments from standard input, and executes the command (`/bin/echo` by default) one or more times using the initial arguments followed by the arguments read from standard input.

A first and simplest example would be the following:

```
$ xargs
use
of
xargs
<CTRL+D>
use of xargs
```

The `xargs` command waits for an input from the standard **stdin** input. Three lines are entered. The end of the user input is specified to `xargs` by the keystroke sequence CTRL+D. `xargs` then executes the default command `echo` followed by the three arguments corresponding to the user input, namely :

```
$ echo "use" "of" "xargs"
use of xargs
```

It is possible to specify a command to be run by `xargs`.

In the following example, `xargs` will run the command `ls -ld` on the set of folders specified in the standard input:

```
$ xargs ls -ld
/home
/tmp
/root
<CTRL+D>
drwxr-xr-x. 9 root root 4096  5 avril 11:10 /home
dr-xr-x---. 2 root root 4096  5 avril 15:52 /root
drwxrwxrwt. 3 root root 4096  6 avril 10:25 /tmp
```

In practice, the `xargs` command executed the `ls -ld /home /tmp /root` command.

What happens if the command to be executed does not accept multiple arguments as is the case with the `find` command?

```
$ xargs find /var/log -name
*.old
*.log
find: paths must precede expression: *.log
```

The `xargs` command attempted to execute the `find` command with multiple arguments behind the `-name` option, which caused `find` to generate an error:

```
$ find /var/log -name "*.old" "*.log"
find: paths must precede expression: *.log
```

In this case, the `xargs` command must be forced to execute the `find` command several times (once per line entered as standard input). The `-L` option followed by an **integer** allows you to specify the maximum number of entries to be processed with the command at one time:

```
$ xargs -L 1 find /var/log -name
*.old
/var/log/dmesg.old
*.log
/var/log/boot.log
/var/log/anaconda.yum.log
/var/log/anaconda.storage.log
/var/log/anaconda.log
/var/log/yum.log
/var/log/audit/audit.log
/var/log/anaconda.ifcfg.log
/var/log/dracut.log
/var/log/anaconda.program.log
<CTRL+D>
```

If we wanted to be able to specify both arguments on the same line, we would have to use the `-n 1` option:

```
$ xargs -n 1 find /var/log -name
*.old *.log
/var/log/dmesg.old
/var/log/boot.log
/var/log/anaconda.yum.log
/var/log/anaconda.storage.log
/var/log/anaconda.log
/var/log/yum.log
/var/log/audit/audit.log
/var/log/anaconda.ifcfg.log
/var/log/dracut.log
/var/log/anaconda.program.log
<CTRL+D>
```

Case study of a backup with a `tar` based on a search:

```
$ find /var/log/ -name "*.log" -mtime -1 | xargs tar cvfP /root/log.tar
$ tar tvfP /root/log.tar
-rw-r--r-- root/root      1720 2017-04-05 15:43 /var/log/boot.log
-rw-r--r-- root/root    499270 2017-04-06 11:01 /var/log/audit/audit.log
```

The special feature of the `xargs` command is that it  places the input argument at the end of the called command. This works  very well with the above example since the files passed in will form the list of files to be added to the archive.

Now, if we take the example of the `cp` command and want  to copy a list of files in a directory, this list of files will be added at the end of the command... but what the `cp` command expects at the end of the command is the destination. To do this, we use the `-I` option to put the input arguments somewhere else than at the end of the line.

```
$ find /var/log -type f -name "*.log" | xargs -I % cp % /root/backup
```

The `-I` option allows you to specify a character (in our example the `%` character) where the input files to `xargs` will be placed.

## `yum-utils` package[¶](https://docs.rockylinux.org/zh/books/admin_guide/04-advanced-commands/#yum-utils-package)

The `yum-utils` package is a collection of utilities from different authors for `yum`, which make it easier and more powerful to use.

!!! Note While `yum` has been replaced by `dnf` in Rocky Linux 8, the package name has remained `yum-utils` although it can be installed as `dnf-utils` as well. These are classic YUM utilities implemented as CLI shims on top of DNF to maintain backwards compatibility with `yum-3`.

Here are some examples of usage:

- `repoquery` command:

The `repoquery` command queries the repositories.

Examples of use:

- Knowing the dependencies of an uninstalled package:

```
repoquery --requires <package>
```

- Know the files provided by a non-installed package:

```
$ repoquery -l yum-utils
/etc/bash_completion.d
/etc/bash_completion.d/yum-utils.bash
/usr/bin/debuginfo-install
/usr/bin/find-repos-of-install
/usr/bin/needs-restarting
/usr/bin/package-cleanup
/usr/bin/repo-graph
/usr/bin/repo-rss
/usr/bin/repoclosure
/usr/bin/repodiff
/usr/bin/repomanage
/usr/bin/repoquery
/usr/bin/reposync
/usr/bin/repotrack
/usr/bin/show-changed-rco
/usr/bin/show-installed
/usr/bin/verifytree
/usr/bin/yum-builddep
/usr/bin/yum-config-manager
/usr/bin/yum-debug-dump
/usr/bin/yum-debug-restore
/usr/bin/yum-groups-manager
/usr/bin/yumdownloader
…
```

- `yumdownloader` command:

The `yumdownloader` command downloads RPM packages from the repositories.

!!! Note This command is very useful to quickly build a local repository of a few rpm!

Example: `yumdownloader` will download the *repoquery* rpm package and all its dependencies:

```
$ yumdownloader --destdir /var/tmp -- resolve repoquery
```

| Options     | Comments                                                     |
| ----------- | ------------------------------------------------------------ |
| -`-destdir` | The downloaded packages will be stored in the specified folder. |
| `--resolve` | Also downloads the package dependencies.                     |

## `psmisc` packages[¶](https://docs.rockylinux.org/zh/books/admin_guide/04-advanced-commands/#psmisc-packages)

The `psmisc` package contains utilities for managing system processes:

- `pstree`: the `pstree` command displays the current processes on the system in a tree-like structure.
- `killall`: the `killall` command sends a kill signal to all processes identified by name.
- `fuser`: the `fuser` command identifies the `PID` of processes that use the specified files or file systems.

Examples:

```
$ pstree
systemd─┬─NetworkManager───2*[{NetworkManager}]
        ├─agetty
        ├─auditd───{auditd}
        ├─crond
        ├─dbus-daemon───{dbus-daemon}
        ├─firewalld───{firewalld}
        ├─lvmetad
        ├─master─┬─pickup
        │        └─qmgr
        ├─polkitd───5*[{polkitd}]
        ├─rsyslogd───2*[{rsyslogd}]
        ├─sshd───sshd───bash───pstree
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-udevd
        └─tuned───4*[{tuned}]
# killall httpd
```

Kill processes (option `-k`) that access the `/etc/httpd/conf/httpd.conf` file:

```
# fuser -k /etc/httpd/conf/httpd.conf
```

## `watch` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/04-advanced-commands/#watch-command)

The `watch` command regularly executes a command and displays the result in the terminal in full screen.

The `-n` option allows you to specify the number of seconds between each execution of the command.

!!! Note To exit the `watch` command, you must type the keys: CTRL+C to kill the process.

Examples:

- Display the end of the `/etc/passwd` file every 5 seconds:

```
$ watch -n 5 tail -n 3 /etc/passwd
```

Result:

```
Every 5,0s: tail -n 3 /etc/passwd                                                                                                                                rockstar.rockylinux.lan: Thu Jul  1 15:43:59 2021

sssd:x:996:993:User for sssd:/:/sbin/nologin
chrony:x:995:992::/var/lib/chrony:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
```

- Monitoring the number of files in a folder:

```
$ watch -n 1 'ls -l | wc -l'
```

- Display a clock:

```
$ watch -t -n 1 date
```