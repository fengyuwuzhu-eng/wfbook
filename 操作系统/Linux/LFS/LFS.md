# LFS

[TOC]

## 分支
* LFS
* BLFS (Beyond Linux From Scratch)
* CLFS (Cross Linux From Scratch)

## 架构

LFS 的主要目标架构是 AMD/Intel 的 x86 (32 位) 和 x86_64 (64 位) CPU。  

## 标准    

LFS 的结构尽可能遵循 Linux 的各项标准。主要的标准有：      

- POSIX.1-2008

- Filesystem Hierarchy Standard (FHS) Version 3.0

- Linux Standard Base (LSB) Version 5.0 (2015)

LSB 由 4 个独立的标准组成：Core、Desktop、Runtime Language 和 Imaging。

两个处于试用阶段的标准：Gtk3 和 Graphics 。

定义 LSB 的主要目的是保证专有软件能够在满足 LSB 的系统上正常运行。然而 LFS 是基于源代码的，用户拥有完全的控制权，有权选择不安装 LSB 要求的软件包。创建一个能够通过 LSB 认证测试的完整 LFS 系统是可行的，但需要安装大量超过 LFS 范畴的额外软件包。      



LFS 系统必须在一个已经安装好的 Linux 发行版中构建。这个安装好的 Linux 系统 (称为宿主) 提供包括编译器、链接器和 shell 在内的必要程序，作为构建新系统的起点。可以选择不安装一个单独的发行版，而是使用某个商业发行版的 LiveCD。 

## 分区

一个最小的系统需要大小约 10 GB 的分区。这足够保存所有源代码压缩包，并且编译所有软件包。然而，如果希望用 LFS 作为日常的 Linux 系统，很可能需要安装额外软件，需要更多空间。一个 30 GB 的分区是比较合理的。大分区可以提供足够的临时存储空间，以及在 LFS 构建完成后增添附加功能需要的空间。另外，编译软件包可能需要大量磁盘空间，但在软件包安装完成后可以回收这些空间。

计算机未必有足够满足编译过程要求的内存 (RAM) 空间，因此可以使用一个小的磁盘分区作为 `swap` 空间。内核使用此分区存储很少使用的数据，从而为活动进程留出更多内存。LFS 的 `swap` 分区可以和宿主系统共用，这样就不用专门为 LFS 创建一个。      

**根分区**

根分区一般分配 20 GB 的空间就足以保证多数系统的运行。          

**交换 (Swap) 分区**

一般来说，推荐采用两倍于物理内存的交换空间，然而这几乎没有必要。如果磁盘空间有限，可以创建不超过 2GB 的交换空间，并注意它的使用情况。

如果希望使用 Linux 的休眠功能 (挂起到磁盘)，它会在关机前将内存内容写入到交换分区。这种情况下，交换分区的大小应该至少和系统内存相同。          

交换到磁盘从来就不是一件好事。对于机械硬盘，通过听硬盘的工作噪声，同时观察系统的响应速度，就能说出系统是否在交换。对于            SSD，您无法听到工作噪声，但可以使用**top** 或 **free** 程序查看使用了多少交换空间。应该尽量避免使用 SSD 作为交换分区。一旦发生交换，首先检查是否输入了不合理的命令，例如试图编辑一个 5GB 文件。如果交换时常发生，最好的办法是为系统添置内存。          

**Grub Bios 分区**

如果启动磁盘采用 GUID 分区表(GPT)，那么必须创建一个小的，一般占据 1MB 的分区，除非它已经存在。这个分区不能格式化，在安装启动引导器时必须能够被 GRUB 发现。这个分区在 **fdisk** 显示为 `BIOS Boot` 分区，在 **gdisk** 下显示分区类型代号为 `EF02` 。          

Grub Bios 分区必须位于 BIOS 引导系统使用的磁盘上。这个磁盘未必是 LFS 根分区所在的磁盘。不同磁盘可以使用不同分区表格式，只有引导盘采用 GPT 时才必须创建该分区。

**推荐：**                     

- boot – 可以存储内核和其他引导信息。为了减少大磁盘可能引起的问题，建议将 /boot 分区设为第一块磁盘的第一个分区。为它分配 200 MB 就绰绰有余。                
- /home – 独立的 /home 分区可以在多个发行版或 LFS 系统之间共享 home 目录和用户设置。它的尺寸一般很大，取决于硬盘的可用空间。                
- /usr – 独立的 /usr 分区一般被用于瘦客户端或无盘站的服务器，LFS 一般不需要。为它划分 10GB 足够满足多数系统要求。                
- /opt – 这个目录往往被用于在 BLFS 中安装 Gnome 或 KDE 等大型软件，以免把大量文件塞进 /usr 目录树。如果将它划分为独立分区，5 到 10 GB 一般就足够了。                
- /tmp – 独立的 /tmp 分区是很少见的，但在配置瘦客户端时很有用。如果分配了这个分区，大小一般不会超过几个 GB。                
- /usr/src – 划分为独立分区，可以用于存储 BLFS 源代码，并在多个 LFS 系统之间共享它们。它也可以用于编译 BLFS 软件包。30-50 GB 的分区可以提供足够的空间。 

## 文件系统

文件系统的选型：      

- ext2       适用于不经常更新的小分区，例如 /boot。                      
- ext3       是 ext2 的升级版本，拥有日志系统，能够在非正常关机的情况下恢复分区的正常状态。它被广泛用于一般场合。                      
- ext4       是 ext 文件系统家族的最新成员，它具有纳秒精度时间戳、超大 (16 TB) 文件支持等新功能，速度也更快。                      

## $LFS 环境变量   

```bash
export LFS=/mnt/lfs        
```

## 挂载新的分区      

```bash
mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS
```

## 软件包存放路径

下载好的软件包和补丁需要保存在一个适当的位置，使得在整个构建过程中都能容易地访问它们。另外，还需要一个工作目录，以便解压和编译软件包。将 `$LFS/sources` 既用于保存软件包和补丁，又作为工作目录。这样，我们需要的所有东西都在 LFS 分区中，因此在整个构建过程中都能够访问。            

```bash
mkdir -v $LFS/sources
```

为该目录添加写入权限和 sticky 标志。“Sticky” 标志使得即使有多个用户对该目录有写入权限，也只有文件所有者能够删除其中的文件。      

```bash
chmod -v a+wt $LFS/sources
```

## 在 LFS 文件系统中创建有限目录布局      

```bash
mkdir -pv $LFS/{bin,etc,lib,sbin,usr,var}
case $(uname -m) in
  x86_64) mkdir -pv $LFS/lib64 ;;
esac

mkdir -pv $LFS/tools
```



分为三个阶段：首先构建一个交叉编译器和与之相关的库；然后使用这个交叉工具链构建一些工具，构建方法保证它们和宿主系统分离；最后进入        chroot 环境，以进一步提高与宿主的隔离度，并构建剩余的，在构建最终的系统时必须的工具。      

## 工具链技术说明

构造一个临时环境，它包含一组可靠的，能够与宿主系统完全分离的工具。这样，通过使用 **chroot** 命令，其余后续执行的命令就被限制在这个临时环境中。这确保我们能够干净、顺利地构建 LFS 系统。      

构建过程是基于*交叉编译*过程的。交叉编译通常被用于为一台与本机完全不同的计算机构建编译器及其工具链。这对于 LFS 并不严格必要，因为新系统运行的机器就是构建它时使用的。但是，交叉编译拥有一项重要优势，即任何交叉编译产生的程序都不可能依赖于宿主环境。      

## 关于交叉编译

定义讨论交叉编译时常用的术语：        

- ​              build            

  ​                              指构建程序时使用的机器。注意在某些其他章节，这台机器被称为“host”(宿主)。                          

- ​              host            

  ​                              指将来会运行被构建的程序的机器。注意这里说的“host”与其他章节使用的“宿主”(host) 一词不同。                          

- ​              target            

  ​                              只有编译器使用这个术语。编译器为这台机器产生代码。它可能和 build 与 host 都不同。                          

​          例如，我们考虑下列场景 (有时称为“Canadian          Cross”)：我们仅在一台运行缓慢的机器上有编译器，称这台机器为 A，这个编译器为          ccA。我们还有一台运行较快的机器 (B)，但它没有安装编译器，而我们希望为另一台缓慢的机器 (C) 生成代码。如果要为 C          构建编译器，可以通过三个阶段完成：        

| 阶段 | Build | Host | Target | 操作描述                                 |
| ---- | ----- | ---- | ------ | ---------------------------------------- |
| 1    | A     | A    | B      | 在机器 A 上，使用 ccA 构建交叉编译器 cc1 |
| 2    | A     | B    | C      | 在机器 A 上，使用 cc1 构建交叉编译器 cc2 |
| 3    | B     | C    | C      | 在机器 B 上，使用 cc2 构建交叉编译器 ccC |

​          这样，我们可以为机器 C 使用 cc2 在快速的机器 B 上构建所有其他程序。注意除非 B 能运行为 C          编译的程序，我们无法测试编译得到的程序，直到在 C 上运行它。例如，如果要测试 ccC，我们可以增加第四个阶段：        

| 阶段 | Build | Host | Target | 操作描述                                   |
| ---- | ----- | ---- | ------ | ------------------------------------------ |
| 4    | C     | C    | C      | 在机器 C 上，用 ccC 重新构建它本身，并测试 |

​          在上面的例子中，只有 cc1 和 cc2 是交叉编译器，它们为与它们本身运行的机器不同的机器产生代码。而另外的编译器 ccA 和          ccC 为它们本身运行的机器产生代码，它们称为*本地*编译器。        

## LFS 的交叉编译实现

​            几乎所有构建系统都使用形如            CPU-供应商-内核-操作系统，称为三元组的名称表示目标机器。好奇的读者可能感到奇怪，为什么一个“三元组”却包含四个部分。这是历史遗留的：最早，三个部分就足以无歧义地描述一台机器。但是随着新的机器和系统不断出现，最终证明三个部分是不够的。然而，“三元组”这个术语保留了下来。有一种简单方法可以获得您的机器的三元组，即运行许多软件包附带的            **config.guess** 脚本。解压缩            Binutils 源码，然后运行脚本：**`./config.guess`**，观察输出。例如，对于 32 位            Intel 处理器，输出应该是 *i686-pc-linux-gnu*，而对于 64 位系统输出应该是            *x86_64-pc-linux-gnu*。          

​            另外注意平台的动态链接器的名称，它又被称为动态加载器 (不要和 Binutils 中的普通链接器 **ld** 混淆)。动态链接器由 Glibc            提供，它寻找并加载程序所需的共享库，为程序运行做好准备，然后运行程序。在 32 位 Intel 机器上动态链接器的名称是            `ld-linux.so.2` (在 64 位系统上是            `ld-linux-x86-64.so.2`)。一个确定动态链接器名称的准确方法是从宿主系统找一个二进制可执行文件，然后执行：**`readelf            -l <二进制文件名> | grep interpreter`**            并观察输出。包含所有平台的权威参考可以在 Glibc 源码树根目录的 `shlib-versions` 文件中找到。          

​          为了将本机伪装成交叉编译目标机器，我们在 `LFS_TGT`          变量中，对宿主系统三元组的 "vendor" 域进行修改。我们还会在构建交叉链接器和交叉编译器时使用 *`--with-sysroot`* 选项，指定查找所需的 host          系统文件的位置。这保证在[第 6 章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter06/chapter06.html)中的其他程序在构建时不会链接到宿主          (build) 系统的库。前两个阶段是必要的，第三个阶段可以用于测试：        

| 阶段 | Build | Host | Target | 操作描述                                  |
| ---- | ----- | ---- | ------ | ----------------------------------------- |
| 1    | pc    | pc   | lfs    | 在 pc 上使用 cc-pc 构建交叉编译器 cc1     |
| 2    | pc    | lfs  | lfs    | 在 pc 上使用 cc1 构建 cc-lfs              |
| 3    | lfs   | lfs  | lfs    | 在 lfs 上使用 cc-lfs 重新构建并测试它本身 |

​          在上表中，“在 pc 上”          意味着命令在已经安装好的发行版中执行。“在 lfs          上” 意味着命令在 chroot 环境中执行。        

​          现在，关于交叉编译，还有更多要处理的问题：C 语言并不仅仅由一个编译器实现，它还规定了一个标准库。在本书中，我们使用 GNU C          运行库，即 glibc。它必须为 lfs 目标机器使用交叉编译器 cc1          编译。但是，编译器本身使用一个库，实现汇编指令集并不支持的一些复杂指令。这个内部库称为 libgcc，它必须链接到 glibc          库才能实现完整功能！另外，C++ 标准库 (libstdc++) 也必须链接到          glibc。为了解决这个”先有鸡还是先有蛋“的问题，只能先构建一个降级的 cc1，它的 libgcc          缺失线程和异常等功能，再用这个降级的编译器构建 glibc (这不会导致 glibc 缺失功能)，再构建          libstdc++。但是这种方法构建的 libstdc++ 和 libgcc 一样，会缺失一些功能。        

​          讨论还没有结束：上面一段的结论是 cc1 无法构建功能完整的 libstdc++，但这是我们在阶段 2 构建 C/C++          库时唯一可用的编译器！当然，在阶段 2 中构建的编译器 cc-lfs 将会可以构建这些库，但是 (1) GCC          构建系统不知道这个编译器在 pc 上可以使用，而且 (2) 它是一个本地编译器，因此在 pc 上使用它可能产生链接到 pc          (宿主系统) 库的风险。因此我们必须在进入 chroot 后再次构建 libstdc++。        

##           构建过程的其他细节        

​          交叉编译器会被安装在独立的 `$LFS/tools`          目录，因为它不属于最终构建的系统。        

​          我们首先安装 Binutils。这是由于 GCC 和 Glibc 的 **configure**          脚本首先测试汇编器和链接器的一些特性，以决定启用或禁用一些软件特性。初看起来这并不重要，但没有正确配置的 GCC 或者 Glibc          可以导致工具链中潜伏的故障。这些故障可能到整个构建过程快要结束时才突然爆发，不过在花费大量无用功之前，测试套件的失败可以将这类错误凸显出来。        

​          Binutils 将汇编器和链接器安装在两个位置，一个是 `$LFS/tools/bin`，另一个是 `$LFS/tools/$LFS_TGT/bin`。这两个位置中的工具互为硬链接。链接器的一项重要属性是它搜索库的顺序，通过向          **ld** 命令加入 *`--verbose`*          参数，可以得到关于搜索路径的详细信息。例如，**ld --verbose |          grep SEARCH** 会输出当前的搜索路径及其顺序。此外，通过编译一个样品 (dummy)          程序并向链接器 **ld** 传递          *`--verbose`*          参数，可以知道哪些文件被链接。例如，**gcc dummy.c          -Wl,--verbose 2>&1 | grep succeeded**          将显示所有在链接过程中被成功打开的文件。        

​          下一步安装 GCC。在执行它的 **configure** 脚本时，您会看到类似下面这样的输出：        

```
checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /mnt/lfs/tools/i686-lfs-linux-gnu/bin/ld
```

​          基于我们上面论述的原因，这些输出非常重要。这说明 GCC 的配置脚本没有在 PATH 变量指定的目录中搜索工具。然而，在          **gcc**          的实际运行中，未必会使用同样的搜索路径。为了查询 **gcc**          会使用哪个链接器，需要执行以下命令：**$LFS_TGT-gcc          -print-prog-name=ld**。        

​          通过向 **gcc** 传递 *`-v`*          参数，可以知道在编译样品程序时发生的细节。例如，**gcc -v          dummy.c** 会输出预处理、编译和汇编阶段中的详细信息，包括 **gcc** 的包含文件搜索路径和顺序。        

​          下一步安装“净化的” (sanitized) Linux API 头文件。这允许 C 标准库 (Glibc) 与 Linux          内核提供的各种特性交互。        

​          下一步安装 Glibc。在构建 Glibc 时需要着重考虑编译器，二进制工具，以及内核头文件。编译器一般不成问题，Glibc          总是使用传递给配置脚本的 *`--host`*          参数相关的编译器。例如，在我们的例子中，使用的编译器是 **$LFS_TGT-gcc**。但二进制工具和内核头文件的问题比较复杂。安全起见，我们使用配置脚本提供的开关，保证正确的选择。在          **configure**          脚本运行完成后，可以检查 `build` 目录中的 `config.make` 文件，了解全部重要的细节。注意参数 *`CC="$LFS_TGT-gcc"`* (其中 `$LFS_TGT` 会被展开) 控制构建系统使用正确的二进制工具，而参数 *`-nostdinc`* 和 *`-isystem`* 控制编译器的包含文件搜索路径。这些事项凸显了 Glibc          软件包的一个重要性质 —— 它的构建机制是相当自给自足的，通常不依赖于工具链默认值。        

​          正如前文所述，接下来构建 C++ 标准库，然后是[第 6           章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter06/chapter06.html)中那些需要自身才能构建的程序后。在安装这些软件包时使用 `DESTDIR`          变量，将它安装到 LFS 文件系统中。        

​          在[第 6 章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter06/chapter06.html)一节的末尾，构建 lfs          本地编译器。首先使用和其他程序相同的 `DESTDIR` 第二次构建          binutils，然后第二次构建 GCC，构建时忽略 libstdc++ 和其他不重要的库。由于 GCC          配置脚本的一些奇怪逻辑，`CC_FOR_TARGET` 变量在 host 系统和          target 相同，但与 build 不同时，被设定为 **cc**。因此我们必须显式地在配置选项中指定 *`CC_FOR_TARGET=$LFS_TGT-gcc`*。        

​          在[第 7 章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter07/chapter07.html)中，进入 chroot          环境后，首先安装          libstdc++。之后临时性地安装工具链的正常工作所必须的程序。还要构建测试其他程序时必须的程序。此后，核心工具链成为自包含的本地工具链。在[第 8           章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter08/chapter08.html)中，构建、测试并最后一次安装所有软件包，它们组成功能完整的系统。        

# 编译过程的一般说明      

​        在构建软件包时，本书提供的命令基于下列假设：      

- ​              某些软件包在编译前需要打补丁，然而补丁只在绕过特定问题时才需要。补丁常常在本章和下一章都要使用，然而有时只在其中一章使用。因此，如果发现本书给出的步骤中没有使用某个下载好的补丁，这是正常的，不必担心。在应用补丁时可能会出现关于              *offset* 或者 *fuzz* 的警告信息。不用担心这些警告，补丁还是会成功应用到源码上的。            

- ​              在编译大多数软件包时，屏幕上都会出现一些警告。这是正常的，可以放心地忽略。这些警告就像它们描述的那样，是关于一些过时的，但并不是错误的              C 或 C++ 语法。C 标准经常改变，一些软件包仍然在使用旧的标准。这并不是一个严重的问题，但确实会触发警告。            

- ​              最后确认 `LFS` 环境变量是否配置正确：            

  ```
  echo $LFS
  ```

  ​              确认上述命令输出 LFS 分区挂载点的路径，如果使用了本书的例子，就是 `/mnt/lfs`。            

- ​              最后强调两个重要事项：            

  ![[重要]](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/images/important.png)

  ###                 重要              

  ​                本书中的命令假设[宿主系统需求](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter02/hostreqs.html)中的所有内容，包括符号链接，都被正确设置：              

  - ​                      **bash**                      是正在使用的 shell。                    
  - ​                      **sh** 是指向                      **bash**的符号链接。                    
  - ​                      **/usr/bin/awk** 是指向                      **gawk**                      的符号链接。                    
  - ​                      **/usr/bin/yacc** 是指向                      **bison**                      的符号链接，或者一个执行 bison 的小脚本。                    

  ![[重要]](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/images/important.png)

  ###                 重要              

  ​                再次强调构建过程：              

  1. ​                      把所有的源码包和补丁放在一个能够从 chroot 环境访问的目录，例如 `/mnt/lfs/sources/`。                    
  2. ​                      切换到放着源码包的目录。                    
  3. ​                      对于每个软件包：                    
     1. ​                            使用 **tar**                            程序，解压需要构建的软件包。在[第 5                             章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter05/chapter05.html)和[第 6                             章](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter06/chapter06.html)中解压软件包时，确认您以用户 *lfs* 的身份登录。                          
     2. ​                            切换到解压源码包时产生的目录。                          
     3. ​                            根据书中的指示构建软件包。                          
     4. ​                            切换回包含所有源码包的目录。                          
     5. ​                            除非另有说明，删除解压出来的目录。                          

## 编译交叉工具链

编译的程序会被安装在 `$LFS/tools`  目录中，以将它们和后续安装的文件分开。但是，编译的库会被安装到它们的最终位置，因为这些库在我们最终要构建的系统中也存在。      

### Binutils - 第一遍      

首先构建 Binutils 相当重要，因为 Glibc 和 GCC 都会对可用的链接器和汇编器进行测试，以决定可以启用它们自带的哪些特性。        

Binutils 文档推荐在一个专用的目录中构建 Binutils：        

```bash
mkdir -v build
cd build
```

准备编译 Binutils：        

```
../configure --prefix=$LFS/tools       \
             --with-sysroot=$LFS        \
             --target=$LFS_TGT          \
             --disable-nls              \
             --disable-werror
```

​            **配置选项的含义：**          

- ​              *`--prefix=$LFS/tools`*            

  ​                              这告诉配置脚本准备将 Binutils 程序安装在 `/$LFS/tools` 目录中。                          

- ​              *`--with-sysroot=$LFS`*            

  ​                              该选项告诉构建系统，交叉编译时在 $LFS 中寻找目标系统的库。                          

- ​              `--target=$LFS_TGT`            

  ​                              由于 `LFS_TGT` 变量中的机器描述和 **config.guess** 脚本的输出略有不同,                这个开关使得 **configure** 脚本调整 Binutils                的构建系统，以构建交叉链接器。                          

- ​              *`--disable-nls`*            

  ​                              该选项禁用临时工具不需要的国际化功能。                          

- ​              *`--disable-werror`*            

  ​                              该选项防止宿主系统编译器警告导致构建失败。                          

​          然后编译该软件包：        

```
make
```

​          安装该软件包：        

```
make install
```

​          这个软件包的细节在[第 8.18.2 节 “Binutils           的内容”](https://bf.mengyan1223.wang/lfs/zh_CN/10.0/chapter08/binutils.html#contents-binutils)中可以找到。        