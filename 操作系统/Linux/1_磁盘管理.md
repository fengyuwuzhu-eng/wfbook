# 磁盘管理

[TOC]

## 概述

## 硬盘安装过程

添加新硬盘的过程包括以下这些步骤：

* 将硬盘连接到计算机上。
* 如果必要的话（通常不需要），格式化硬盘。
* 为硬盘添加卷标以及对硬盘进行分区。
* 建立逻辑卷。
* 在硬盘分区中创建文件系统。
* 设置自动安装机制。
* 在交换分区上设置交换机制。

## 连接硬盘

将硬盘添加到系统中的方式取决于硬盘所用的接口。剩下的工作就是安装托架和连上电缆。如果是 IDE 硬盘，那么就应该试着把系统配置为在每条总线上只安装一个 IDE 硬盘。应该仔细检查电缆的方向和每个硬盘上的主/从设置。如果是 SCSI 硬盘，那么就应该仔细检查，确保已经正确终结了 SCSI 总线的两端，电缆长度要比所用 SCSI 的最大电缆长度短，以及新 SCSI 设备的目标号不应该与控制器以及总线上的其他设备发生冲突。

在可以访问一个新硬盘之前，需要在 /dev 下有指向它的文件。Linux 自动为所有可能的 SCSI 设备创建了文件。

向硬盘随机执行写操作有可能在几秒之内毁掉一个文件系统，所以应该相当严格地设置硬盘文件的访问权限。假如让组的属主（“operator” 或者 “disk”）有读权限，这样的设定可以让操作员无需超级用户特权就能执行转储操作（dump），但又能避免普通用户读原始设备。

## 格式化硬盘

厂商经常用没有经过格式化的字节数来标明硬盘的容量。硬盘容量的大约 10% 一般会用于标记硬盘的表面，以便让系统硬件和软件可以找到已经写入数据的地方。在买硬盘的时候，应该始终用格式化之后的大小来考虑硬盘的容量和比较价格。

硬盘的容量用的兆字节是百万字节数，这和内存标称不同，内存的兆实际上是 2<sup>20</sup> 或者 1048576 字节。这种差别大约有 5% （当然，“mega” 的前缀实际上就是指 “million” ，所以那种用法并不是完全没有理由的。）。所以，在估计和比较硬盘容量时，一定要检查它们的单位。

格式化硬盘的过程就是在盘片上写入地址信息和时间标志来划分每一个扇区。它还能标出“坏块”，也就是介质上的一些会导致不能在硬盘某个区域内进行可靠的读或者写操作的瑕疵。现代硬盘具有内置的坏块管理功能，所以无论是您还是驱动程序都不必担心这个问题。（然而，硬盘格式化之后出现的任何坏区都是不能“处理的”。它们将通过读写错误以及丢失数据的形式表现出来。）所有的硬盘都要事先格式化好，制造工厂对硬盘的格式化通常比您所能进行的任何格式化都要精确得多。如果没有必要的话，最好应该避免进行低级格式化。如果遇到了硬盘读写错误，那么首先应该检查电缆、终结以及地址方面的问题，这些问题也能够引起和硬盘坏区相类似的症状。如果完成了这个过程之后您仍然确信硬盘坏了，那么使用一个新硬盘来替换该盘会比为完成硬盘的格式化而等待很长时间更好一些。

IDE 硬盘在通常情况下是不能在制造工厂之外进行格式化的。但您可以从制造商那里获得专用的格式化软件，通常情况下在 Windows 中使用。应该确保所得到的软件与自己打算格式化的硬盘相匹配并且要仔细遵循制造商的指导操作。

SCSI 硬盘能够响应您从主计算机中发出的命令，自己完成格式化。发送该命令的过程随系统不同而异。在 PC 上，通常可以从 SCSI 控制器的 BIOS 中发送该命令。

借助各种不同的工具，可以通过在硬盘上随机写入然后进行读取来检验硬盘的完整性。这个过程非常花时间，所以，除非怀疑硬盘坏了而且不能简单地替换它（或者在乎时间），可以跳过这个过程。除此之外，可以让这个测试过程在夜间运行。不要担心过多的使用或者过分的检测会对硬盘造成磨损。因为硬盘的设计可以经受持续不断的操作。

## 标记硬盘和硬盘分区

在对硬盘进行格式化并标记了坏扇区之后，就必须将它划分成分区这样的大块区域。硬盘分区能够把硬盘当作一组独立的数据区域，而不是一个巨大的数据块集合。硬盘分区中还有引导块和分区表这样的结构，它们本身对于高层软件（比如说，文件系统）而言是不可见的。只有设备驱动程序知道整个硬盘的布局结构，其他软件都是在整理过的抽象分区上进行工作的。

分区可以使备份更容易、可以防止用户窃取其他用户的硬盘空间、提高系统性能以及限制来自失控程序的潜在损害。分区表保存在硬盘上一个称为卷标的记录中。卷标通常占据硬盘上最开始的几个数据块。它的具体内容各不相同，但它一般都包括了保证系统启动的足够信息。在概念上，硬盘上的各个分区都不同，并且彼此之间互相独立。然而，/dev/sda 是硬盘的块设备文件，它实质上是整个硬盘的映像。用户级的命令可以通过这个设备文件来“直接”访问硬盘。例如，用户级的进程能够通过使用 dd 命令来写硬盘的卷标，或者将它的内容复制到一个备份硬盘中。当然，必须很小心地使用这个特殊的文件，因为它会一下子就破坏硬盘上的每个分区。

有些系统甚至在这条危险的路上走得更远，这样的系统允许定义多个重叠的分区组。例如，分区1、2 和 3 可以按一种方式来划分硬盘，而分区 4 和 5 又可以使用另外一种方式划分硬盘。应该使用一组自相容的分区，然后忽略其他所有的分区组。在实际使用中，这样的重叠分区会引起操作者的错误，它是数据不时发生损坏的常见原因。

现在的系统倾向于比以前的系统使用更少的分区，但在大多数系统里必须至少有下面两种分区。

* 根分区：让系统进入单用户模式所需要的所有东西都保存在这里。这个分区的一个副本通常保存在另外一个硬盘中，以供应急之用。
* 交换分区:当没有足够的物理内存来保存信息时，交换分区就能存储虚拟内存中的内容。每个系统都至少应该有一个交换分区。

划分硬盘分区的最好方式如何选择则会有不同，下面是一些提示。

* 如果有多个硬盘，那么在其中的一个硬盘上复制一份根文件系统，检验一下是否可以从该硬盘进行启动。
* 在给机器添加内存时，还应该增加交换分区的空间。根据满足系统上工作量的需要来分配交换空间的大小。
* 在几个硬盘上分摊交换分区可以增强系统的性能。这项技术也能对文件系统起作用，也就是说，把那些很繁忙的文件系统放置在不同的硬盘上。
* 如果想要备份一个分区，那么不要让这个分区比备份设备的容量还要大。
* 把变化较快的信息集中在几个分区上，并经常备份这些分区。
* 把 /tmp 放在一个独立的文件系统上，把临时文件大小限制在有限的范围，能够省去备份操作。因为日志文件保存在 /var 中，所以将 /var 作为一个独立的硬盘分区是个好主意。让 /var 作为一个很小的根分区中的一部分，很容易使其填满根区，导致机器进入暂停状态。
* 把 /home 定为一个独立的分区比较有用。即使根分区出问题或者损坏了，用户数据也有很大机会没有受到影响。相反，甚至在被诱导的用户 shell 脚本填满了 /home 之后，系统仍然能够继续运行。

将物理磁盘划分为分区卷的过程记录在分区表中，该表存储在磁盘的第一个扇区（MBR，主引导记录）。

最开始的时候，硬盘分区只有一种类型，就是主分区，但是由于 MBR 中只保留了 64B 存储空间，而每个分区要用 16B，所以一块硬盘只能分成 4个主分区。当硬盘很小的时候，4 个主分区足够使用。

 ![](../../Image/0/07-file-systems-001.png)

但是随着硬盘容量的不断增加，4 个分区已经不能满足需要了。这时为了分配更多的分区，就出现了扩展分区和逻辑分区。

 ![](../../Image/0/07-file-systems-002.png)

* 主分区 Primary 。由于 MBR 的限制，最多只能分配 4 个主分区。

* 扩展分区 Extended 。

  扩展分区在一块硬盘上只能有 1 个，而且扩展分区和主分区是平级的，也就是说，主分区加扩展分区最多只能有 4 个。扩展分区不能直接写入数据和格式化，需要在扩展分区中再划分出逻辑分区才能使用。MBR 分区表可以识别的最大物理磁盘是 2TB 。

* 逻辑分区。

  逻辑分区是在扩展分区中再划分出来的。在 Linux 系统中，IDE 硬盘最多有 59 个逻辑分区（加 4 个主分区最多能识别 63 个分区），SCSI 硬盘最多有 11 个逻辑分区（加 4 个主分区最多能识别 15 个分区）。

 ![](../../Image/0/07-file-systems-003.png)

通常需要划分的分区有两个：

* 一个是根分区 “/” ，在硬盘不太大时，建议根分区越大越好 ，主要用于存储数据。但在硬盘越来越大的情况下，不建议根分区越大越好，而是建议给根分区几十 GB 足够使用即可，剩余空间可以分配在真正存储数据的分区（如 /home 分区等）。
* 另一个是虚拟内存分区 “swap” 。

其他可以单独分区的目录：

* /boot/            建议 500MB 。
* /usr/
* home/

不能单独分区的目录：

* /etc/
* /bin/
* /dev/
* /lib/
* /sbin/

## 在硬盘分区内创建文件系统

即便一个硬盘已经在概念上被分成了若干个分区，它仍旧没有为保存文件做好准备。在硬盘为使用准备就绪之前，文件系统需要加一点儿自己的开销。

要在一个硬盘分区里安装一个文件系统，需使用命令 mke2fs 。要在一个硬盘分区上安装一个 ext3fs 文件系统，可以使用 `mke2fs -j` （没有 mke3fs 这样的命令，-j 选项告诉 mke2fs 创建 ext3fs 的日志）命令。除非使用的系统有特殊之处，否则只要用 `mke2fs -j` 命令加上分区名就应该能建立文件系统。使用 mke2fs 要小心，用错了会毁坏系统，即便有可能恢复数据，也极其困难。ext3fs 文件系统包括 5 个组成部分：

* 一组索引结点（inode）存储单元。
* 一组分散的“超级块（superblock）”。
* 一份文件系统中磁盘块的映射表。
* 一份磁盘块使用情况的汇总。
* 一组数据块。

日志就仿佛它是新文件系统根目录中的一个普通文件那样来进行分配，所以它实际上并不是一个特别的结构部分。

每个文件系统分区都被分成若干个块簇。诸如索引结点表这样的结构则在块簇间进行分配，于是，要一起访问的若干磁盘块可以在硬盘上彼此保存得很靠近。这种成机制减少了在访问同一个文件的磁盘块时，需要搜索整个硬盘的情况。

inode 是长度固定的表项，每个 inode 都保存着关于一个文件的信息。因为在初始建立文件系统的结构时就开辟出一块空间用于保存 inode ，所以必须事先判断要创建多少个 inode 。由于不可能准确预测将来有一天会需要多少个文件（inode），所以建立文件系统的命令使用一个经验公式，根据分区的大小以及文件的平均长度来猜测一个合适的数值。

在创建文件系统的时候可以把 inode 的数量往多或者往少调整：小文件多的文件系统（比如存放源代码库的文件系统）inode 多一些，保存几个大文件的文件系统（比如保存有数据库的文件系统）inode 少一些。

超级块是一种描述文件系统特性的记录。它包含的信息有：磁盘块的长度、inode 表的大小和位置、磁盘块的映射表和使用情况信息、块簇的大小、以及其他几个重要的文件系统参数。因为损坏超级块可能会丢失一些极其关键的信息，所以文件系统在硬盘上的分散位置（在每个块的起始处）保存有超级块的几个副本。

对于每个已经安装到操作系统中的文件系统来说，内核都会在内核里保存一份超级块的副本，也同时在硬盘上保留几份超级块的副本。系统调用 sync 把缓存在内存里的超级块冲洗（flush）到它们在硬盘上的永久位置上，瞬间就让文件系统保持了一致性。这种周期性的保存操作，能够把文件系统尚未更新超级块机器就发生崩溃时造成的损失减少到最小。sync 也会冲洗修改过的 inode 和被缓存的数据块。传统上每隔 30s 执行一次 sync，但是 ext3fs 却每隔 5s 执行一次。

文件系统的磁盘块映射表是它所包含的空闲块的一张表。在写新文件的时候，要研究这个映射表，设计一种有效的布局方案。块的使用情况汇总记录了有关已经投入使用的块的基本信息。

## 挂载

进程可以使用文件系统之前必须先安装它。文件系统的安装点可以是任何目录，但是如果在某个目录上安装了一个文件系统，那么在它下面的文件和子目录都会访问不到了。

在安装一个新硬盘之后，应该手工安装新的文件系统来测试每样东西是否都能正确工作。例如：

```bash
mount /dev/sda1 /mnt
```

命令会把设备文件 /dev/sda1 所表示的分区里的文件系统安装到目录 /mnt ，这是用于临时安装文件系统的传统路径。如果是崭新的文件系统，那么它的内容应该看上去和下面的类似：

```bash
ls /mnt

lost+found
```

当构建一个文件系统的时候，会自动创建一个 `lost+found` 目录。它在紧急情况下供 fsck 使用，不要删除它。`lost+found` 目录还预先分配了一些额外的空间，所以在一个不稳定的文件系统里，fsck 能够在那里保存“没有链接”的文件而不需要多分配目录项。

用 df 命令可以核实文件系统的大小。下面是一个例子：

```bash
df /home

Filesystem	1k-blocks	Used	Available	Use%	Mounted on
/dev/hda5	4128448		697968	3220768		18%		/home
```

df 报告的单位是 1K 大小的块，或者可以使用 -h 选项要求以好读的数值来显示结果（例如，2.4G）。

## 设置自动安装

用户一般希望配置系统在启动的时候自动安装本地的文件系统。/etc/fstab 文件包含与文件系统相对应的设备的清单。

包含前面文件系统的一个 fstab 文件可能看起来像下面这样：

```bash
LABEL=/		/				ext3	defaults			1	1
none		/dev/pts		devpts	gid=5,mode=620		0	0
/dev/hda5	/home			ext3	defaults			1	2
none		/proc			proc	defaults			0	0
none		/dev/shm		tmpfs	defaults			0	0
/dev/cdrom	/media/cdrom	iso9660	ro,noauto,owner	0	0
/dev/hda3	/usr			ext3	defaults			1	2
/dev/hda6	/var			ext3	defaults			1	2
/dev/hda2	swap			swap	defaults			0	0
```



多数情况下，Linux 分区需要挂载到根目录中的某个目录上才能使用。在 Linux 中把这个目录称为挂载点。


There are at least two commands for partitioning a disk: `fdisk` and `cfdisk`. Both commands have an interactive menu. `cfdisk` is more reliable and better optimized, so it is best to use it.

The only reason to use `fdisk` is when you want to list all logical devices with the `-l` option.

```
sudo fdisk -l
sudo fdisk -l /dev/sdc
sudo fdisk -l /dev/sdc2
```

### `parted` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#parted-command)

The `parted` (*partition editor*) command is able to partition a disk.

```
parted [-l] [device]
```

It also has a recovery function capable of rewriting a deleted partition table.

Under graphical interface, there is the very complete `gparted` tool: *G*nome *PAR*tition *ED*itor.

The `gparted -l` command lists all logical devices on a computer.

The `gparted` command alone will return to an interactive mode with its own internal options:

- `help` or an incorrect command will display these options.
- `print all` in this mode will have the same result as `gparted -l` on the command line.
- `quit` to return to the prompt.

### `cfdisk` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#cfdisk-command)

The `cfdisk` command is used to manage partitions.

```
cfdisk device
```

Example:

```
$ sudo cfdisk /dev/sda
                                 Disk: /dev/sda
               Size: 16 GiB, 17179869184 bytes, 33554432 sectors
                       Label: dos, identifier: 0xcf173747
    Device        Boot       Start        End    Sectors   Size   Id Type
>>  /dev/sda1     *           2048    2099199    2097152     1G   83 Linux
    /dev/sda2              2099200   33554431   31455232    15G   8e Linux LVM
 lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk
 x Partition type: Linux (83)                                                 x
 x     Attributes: 80                                                         x
 xFilesystem UUID: 54a1f5a7-b8fa-4747-a87c-2dd635914d60                       x
 x     Filesystem: xfs                                                        x
 x     Mountpoint: /boot (mounted)                                            x
 mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj
     [Bootable]  [ Delete ]  [ Resize ]  [  Quit  ]  [  Type  ]  [  Help  ]
     [  Write ]  [  Dump  ]
```

The preparation, without *LVM*, of the physical media goes through five steps:

- Setting up the physical disk;
- Partitioning of the volumes (geographical division of the disk, possibility of installing several systems, ...);
- Creation of the file systems (allows the operating system to manage the files, the tree structure, the rights, ...);
- Mounting of file systems (registration of the file system in the tree structure);
- Manage user access.