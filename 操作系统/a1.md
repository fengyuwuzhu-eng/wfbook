一般情况下，软件的源代码只由编写者拥有，而开源（即开放源代码，Open Source  Code）是指一种更自由的软件发布模式。简单来说，开源软件的特点就是把软件程序和源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以对代码按需修改，让软件更贴合硬件环境，让功能更符合工作需求。用户还可以将其编制成衍生产品再发布出去。用户一般享有使用自由、复制自由、修改自由、创建衍生品自由，以及收费自由。是的，您没有看错，用户具备创建衍生品和收费的自由。这也就是说，可以对一个开源软件进行深度定制化加工。如果修改过的程序更加好用，或者颇具新的特色，只要符合原作者的许可要求，我们就完全可以合法地将软件进行商标注册，以商业版的形式再发布出去，只要有新用户使用您的软件并支付相应的费用，那就是您的收入。这也正好符合了黑客和极客对自由的追求，因此在合作与竞争中，国内外的开源社区慢慢生长出了强健的根基，人气也非常高。![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/OSI_Approved_License-745x1024.png)

但是，如果开源软件只单纯追求“自由”而牺牲了程序员的利益，这肯定会影响程序员的创作热情。为了平衡两者的关系，截至目前，世界上已经有100多种被开源促进组织（OSI，Open Source  Initiative）确认的开源许可证，用于保护开源工作者的权益。对于那些只知道一味抄袭、篡改、破解或者盗版他人作品的不法之徒，终归会在某一天收到法院的传票。

考虑到大家没准儿以后会以开源工作者的身份编写出一款畅销软件，因此刘遄老师根据开源促进组织的推荐建议以及实际使用情况，为大家筛选出了程序员最喜欢的前6名的开源许可证，并教大家怎么从中进行选择。提前了解最热门的开源许可证，并在未来选择一个合适的可最大程度地保护自己软件权益的开源许可证，这对创业公司来讲能起到事半功倍的作用。

开源许可证总览：https://opensource.org/licenses/alphabetical

### 

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/FSF.png)
 自由软件基金会（Free Software Foundation，FSF）是一个非营利组织，其使命是在全球范围内促进计算机用户的自由，捍卫所有软件用户的权利。。



大家经常会在开源社区中看到Copyleft这个单词，这是一个由自由软件运动所发展出的概念，中文被翻译为“著佐权”或者“公共版权”。与Copyright截然相反，Copyleft不会限制使用者复制、修改或再发布软件。

此外，大家应该经常会听到别人说开源软件是free的，没错，开源软件就是自由的。这里的free千万不要翻译成“免费”，这样就大错特错了，这与您去酒吧看到的“第一杯免费”的意思可相差甚远。

下面我们来看一下程序员最喜欢的前6名的开源许可证，以及它们各自赋予用户的权利。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/GPL.png)

**GNU通用公共许可证（**General Public License，**GPL）**：目前广泛使用的开源软件许可协议之一，用户享有运行、学习、共享和修改软件的自由。GPL最初是自由软件基金会创始人Richard  Stallman起草的，其版本目前已经发展到了第3版。GPL的目的是保证程序员在开源社区中所做的工作对整个世界是有益的，所开发的软件也是自由的，并极力避免开源软件被私有化以及被无良软件公司所剥削。

现在，只要软件中包含了遵循GPL许可证的产品或代码，该软件就必须开源、免费，因此这个许可证并不适合商业收费软件。遵循该许可证的开源软件数量极其庞大，包括Linux内核在内的大多数的开源软件都是基于GPL许可证的。GPL赋予了用户著名的五大自由。

> **使用自由：**允许用户根据需要自由使用这个软件。
>
> **复制自由：**允许把软件复制到任何人的计算机中，并且不限制复制的数量。
>
> **修改自由：**允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可证。
>
> **衍生自由：**允许用户深度定制化软件后，为软件注册自己的新商标，再发行衍生品的自由。
>
> **收费自由：**允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的。因此，一般来讲，开源软件都是通过为用户提供有偿服务的形式来营利的。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/LGPL-1024x445.png)

**较宽松通用公共许可证（****Lesser GPL, LGPL）**：一个主要为保护类库权益而设计的GPL开源协议。与标准GPL许可证相比，LGPL允许商业软件以类库引用的方式使用开源代码，而不用将其产品整体开源，因此普遍被商业软件用来引用类库代码。简单来说，就是针对使用了基于LGPL许可证的开源代码，在涉及这部分代码，以及修改过或者衍生出来的代码时，都必须继续采用LGPL协议，除此以外的其他代码则不强制要求。

如果您觉得LGPL许可证更多地是关注对类库文件的保护，而不是软件整体，那就对了。因为该许可证最早的名字是Library GPL，即GPL类库开源许可证，保护的对象有glibc、GTK widget toolkit等类库文件。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2016/03/bsd.png)

**伯克利软件发布版（****Berkeley Software Distribution, BSD）许可证**：另一款被广泛使用的开源软件许可协议。相较于GPL许可证，BSD更加宽松，适合于商业用途。用户可以使用、修改和重新发布遵循该许可证的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件。

> 如果再发布的软件中包含开源代码，则源代码必须继续遵循BSD许可证。
>
> 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD许可证。
>
> 不允许用原始软件的名字、作者名字或机构名称进行市场推广。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2016/03/apache.png)

**Apache许可证（****Apache License）**：顾名思义，是由Apache软件基金会负责发布和维护的开源许可协议。作为当今世界上最大的开源基金会，Apache不仅因此协议而出名，还因市场占有率第一的Web服务器软件而享誉行业。目前使用最广泛的Apache许可证是2004年发行的2.0版本，它在为开发人员提供版权及专利许可的同时，还允许用户拥有修改代码及再发布的自由。该许可证非常适合用于商业软件，现在热门的Hadoop、Apache HTTP Server、MongoDB等项目都是基于该许可证研发的。程序开发人员在开发遵循该许可证的软件时，要严格遵守下面4个条件。

> 该软件及其衍生品必须继续使用Apache许可证。
>
> 如果修改了程序源代码，需要在文档中进行声明。
>
> 若软件是基于他人的源代码编写而成的，则需要保留原始代码的许可证、商标、专利声明及原作者声明的其他内容信息。
>
> 如果再发布的软件中有声明文件，则需在此文件中注明基于了Apache许可证及其他许可证。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/MIT-1024x530.png)

**MIT许可证（****Massachusetts Institute of Technology License）**：源于麻省理工学院，又称为X11协议。MIT许可证是目前限制最少的开源许可证之一，用户可以使用、复制、修改、再发布软件，而且只要在修改后的软件源代码中保留原作者的许可信息即可，因此普遍被商业软件（例如jQuery与Node.js）所使用。也就是说，MIT许可证宽松到一个新境界，即用户只要在代码中声明了MIT许可证和版权信息，就可以去做任何事情，而无须承担任何责任。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/Mozilla_Foundation_logo.svg_-1024x1024.png)

**Mozilla公共许可证（**Mozilla Public License，**MPL）**：于1998年初由Netscape公司的Mozilla小组设计，原因是它们认为GPL和BSD许可证不能很好地解决开发人员对源代码的需求和收益之间的平衡关系，因此便将这两个协议进行融合，形成了MPL。2012年年初，Mozilla基金会发布了MPL 2.0版本（目前为止也是最新的版本），后续被用在Firefox、Thunderbird等诸多产品上。最新版的MPL公共许可证有以下特点。

> 在使用基于MPL许可证的源代码时，后续只需要继续开源这部分特定代码即可，新研发的软件不用完全被该许可证控制。
>
> 开发人员可以将基于MPL、GPL、BSD等多种许可证的代码一起混合使用。
>
> 开发人员在发布新软件时，必须附带一个专门用于说明该程序的文件，内容要有原始代码的修改时间和修改方式。

估计大家在看完上面琳琅满目的许可证后，会心生怨念：“这不都差不多吗？到底该选哪个呢？”写到这里时，刘遄老师也是一脸无助：“到底该怎么让大家进行选择呢？”搜肠刮肚之际突然眼前一亮，乌克兰程序员Paul Bagwell创作的一幅流程图正好对刚才讲过的这6款开源许可证进行了汇总归纳，具体如下图所示。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/开源协议选择流程图-1.jpg)

开源许可证的选择流程图

众所周知，绝大部分的开源软件在安装完毕之后即可使用，很难在软件界面中找到相关的收费信息。所以经常会有同学提问：“刘老师，开源社区的程序员总要吃饭的呀，他们是靠什么营利呢？”针对这个问题，网络上好像只有两种声音：

> **情怀——**开源社区的程序员觉悟好，本领强，写代码纯粹是为了兴趣以及造福社会；
>
> **服务——**先让用户把软件安装上，等用好、用习惯之后，再通过提供一些维护服务来营利。

这两种解释都各有道理，但是不够全面。读者也不要把开源软件和商业软件完全对立起来，因为好的项目也需要好的运营模式。就开源软件来讲，营利模式具体包括以下5种。

> **多条产品线**：如MySQL数据库便有个人版和企业版两个版本，即个人版完全免费，起到了很好的推广作用；企业版则通过销售授权许可来营利。
>
> **技术服务型**：JBoss应用服务器便是典型代表，JBoss软件可自由免费使用，软件提供方通过技术文档、培训课程以及定制开发服务来盈利。
>
> **软硬件结合**：比如IBM公司在出售服务器时，一般会为用户捆绑销售AIX或Linux系统来确保硬件设施的营利。
>
> **技术出版物**：比如O'Reilly既是一家开源公司，也是一家出版商，诸多优秀图书都是由O'Reilly出版的。
>
> **品牌和口碑**：微软公司曾多次表示支持开源社区。大家对此可能会感到意外，但这是真的！Visual Studio Code、PowerShell、TypeScript等软件均已开源。大家是不是瞬间就对微软公司好感倍增了呢？买一份正版系统表示支持也就是人之常情了。













**![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2015/01/linux-windows.png)**

开源软件便具备了4大关键性优势。

> **低风险**：使用闭源软件无疑把命运交付给他人，一旦封闭的源代码没有人来维护，您将进退维谷。而且相较于商业软件公司，开源社区很少存在倒闭的问题。并且，源代码一旦公布于世，任何人或组织都可以接手进行新的维护工作。
>
> **高品质**：相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户数量众多，一般的bug还没有等暴发就已经被修补。另外，在灵感不断碰撞、代码不断迭代的交流氛围中，程序员也不可能将“半成品”上传到开源社区中。
>
> **低成本**：开源工作者大多都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。
>
> **更透明：**没有哪个笨蛋会把木马或后门代码放到开源项目中，这样无疑是把自己的罪行暴露在阳光之下，很容易被他人发现。



从1965年开始讲起。当时，为了解决服务器的终端连接数量的限制和处理复杂计算的问题，贝尔（Bell）实验室、通用电气（GE）公司以及麻省理工学院（MIT）决定联手打造一款全新的操作系统—MULTICS（多任务信息与计算系统）。但由于开发过程不顺利，遇到了诸多阻碍，后期连资金也出现了短缺现象，最终在1969年，随着贝尔实验室的退出，MULTICS也终止了研发工作。而同年，MULTICS的开发人员Ken Thompson使用汇编语言编写出了一款新的系统内核，当时被同事戏称为UNICS（联合信息与计算系统），在贝尔实验室内广受欢迎。

1973年时，C语言之父Dennis M.  Ritchie了解到UNICS系统并对其非常看好，但汇编语言有致命的缺点—需要针对每一台不同架构的服务器重新编写汇编语言代码，才能使其使用UNICS系统内核。这样不仅麻烦而且使用门槛极高。于是Dennis M. Ritchie便决定使用C语言重新编写一遍UNICS系统，让其具备更好的跨平台性，更适合被广泛普及。开源且免费的UNIX系统由此诞生。

但是在1979年，贝尔实验室的上级公司AT&T看到了UNIX系统的商业价值和潜力，不顾贝尔实验室的反对声音，依然坚决做出了对其商业化的决定，并在随后收回了版权，逐步限制UNIX系统源代码的自由传播，渴望将其转化成专利产品而大赚一笔。崇尚自由分享的黑客面对冷酷无情的资本力量心灰意冷，开源社区的技术分享热潮一度跌入谷底。此时，人们也不能再自由地享受科技成果了，一切都以商业为重。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2016/03/gnu.png)

面对如此封闭的软件创作环境，著名的黑客Richard  Stallman在1983年发起了GNU源代码开放计划，并在1989年起草了著名的GPL许可证。他渴望建立起一个更加自由和开放的操作系统和社区。之所以称之为GNU，其实是有“GNU’s Not  Unix!”的含义，这暗戳戳地鄙视了一下被商业化的UNIX系统。但是，想法和计划只停留在口头上是不够的，还需要落地才行，因此Richard便以当时现有的软件功能为蓝本，重新开发出了多款开源免费的好用工具。在1987年，GNU计划终于有了重大突破，Richard和社区共同编写出了一款能够运行C语言代码的编译器—gcc（GNU C  Compiler）。这使得人们可以免费地使用gcc编译器将自己编写的C语言代码编译成可执行文件，供更多的用户使用，这进一步发展壮大了开源社区。随后的一段时间里，Emacs编辑器和bash解释器等重磅产品陆续亮相，一批批的技术爱好者也纷纷加入GNU源代码开放计划中来。

在1984年时，UNIX系统版权依然被AT&T公司死死地攥在手里，AT&T公司明确规定不允许将代码提供给学生使用。荷兰的一位大学教授Andrew（历史中被遗忘的大神）为了能给学生上课，竟然仿照UNIX系统编写出了一款名为Minix的操作系统。但当时他只是用于课堂教学，根本没有大规模商业化的打算，所以实际使用Minix操作系统的人数其实并不算多。

芬兰赫尔辛基大学的在校生Linus  Torvalds便是其中一员，他在1991年10月使用bash解释器和gcc编译器等开源工具编写出了一个名为Linux的全新的系统内核，并且在技术论坛中低调地上传了该内核的0.02版本。该系统内核因其较高的代码质量且基于GNU GPL许可证的开放源代码特性，迅速得到了GNU源代码开放计划和一大批黑客程序员的支持，随后Linux正式进入如火如荼的发展阶段。Linus  Torvalds最早发布的帖子内容的截图如下。

```
  Hello everybody out there using minix -

  I'm doing a (free) operating system (just a hobby, won't be big and
  professional like gnu) for 386(486) AT clones.  This has been brewing
  since april, and is starting to get ready.  I'd like any feedback on
  things people like/dislike in minix, as my OS resembles it somewhat
  (same physical layout of the file-system (due to practical reasons)
  among other things).

  I've currently ported bash(1.08) and gcc(1.40), and things seem to work.
  This implies that I'll get something practical within a few months, and
  I'd like to know what features most people would want.  Any suggestions
  are welcome, but I won't promise I'll implement them :-)

                Linus torvalds
```

Linux系统的吉祥物名为Tux，是一只呆萌的小企鹅。相传Linus  Torvalds在童年时期去澳大利亚的动物园游玩时，不幸被一只企鹅咬伤，所以为了“报复”就选择了这个物种作为吉祥物。这个故事是否可信无从考证，但万幸是只企鹅，而不是老虎或者狮子，否则就不是换个Logo这么简单的事了。

1994年，红帽（Red Hat）公司创始人Bob  Young在Linux系统内核的基础之上，集成了众多的常用源代码和程序软件，随后发布了红帽操作系统并开始出售技术服务，这进一步推动了Linux系统的普及。1998年以后，随着GNU源代码开放计划和Linux系统的继续火热，以IBM和Intel为首的多家IT巨头企业开始大力推动开放源代码软件的发展，很多人认为这是一个重要转折点。2012年，红帽公司成为全球第一家年收入10亿美元的开源公司，后来是20亿、30亿……不断刷新纪录。

时至今日，Linux内核已经发展到5.6版本，衍生系统也有数百个版本之多，它们使用的都是Linus Torvalds开发维护的Linux系统内核。红帽也成为开源行业及Linux系统的领头羊。

##### **0.5 常见的Linux系统版本**

在介绍常见的Linux系统版本之前，首先需要区分Linux系统内核与Linux发行套件系统的不同。

> Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、磁盘、文件系统控制及多任务功能的系统核心程序（第2章会有详细介绍）。
>
> Linux发行套件系统是我们常说的Linux操作系统，也就是由Linux内核与各种常用软件的集合产品。

全球大约有数百款的Linux系统版本，每个系统版本都有自己的特性和目标人群—有的主打稳定性和安全性，有的主打免费使用，还有的主要突出定制化强等特点。下面从用户的角度选出最热门的几款进行介绍。

### **Tips**

本书全篇将以“Linux系统”来替代“Linux发行套件系统”这个词。

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/redhat.png)

**红帽企业版系统****（RHEL,RedHatEnterpriseLinux）**

前文在介绍Linux系统的发展历史时，曾提到过红帽公司。红帽公司作为全球知名的开源技术厂商，其产品值得我们放到第一位来介绍。红帽公司成立于1994年，于1998年在纳斯达克上市，自从1999年起陆续收购了包括JBoss中间件供应商、CentOS（社区企业操作系统）、Ceph企业级存储业务等在内的数十家高科技公司及热门产品，这么做的目的当然是为了对主营业务红帽企业版Linux进行增强。

红帽企业版Linux最初于2002年3月面世，当年Dell、HP、Oracle以及IBM公司便纷纷表示支持该系统平台的硬件开发，因此红帽企业版Linux系统的市场份额在近20年时间内不断猛增。红帽企业版Linux当时是全世界使用最广泛的Linux系统之一，在世界500强企业中，所有的航空公司、电信服务提供商、商业银行、医疗保健公司均无一例外地通过该系统向外提供服务。

红帽企业版Linux当前的最新版本是RHEL 8，该系统具有极强的稳定性，在全球范围内都可以获得完善的技术支持。该系统也是本书和红帽认证考试中默认使用的操作系统。

RHEL系统及随书配套工具下载链接：https://www.linuxprobe.com/tools

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2015/01/centos.jpg)

**CentOS社区企业操作系统（Community Enterprise Operating System）**

顾名思义，CentOS是由开源社区研发和维护的一款企业级Linux操作系统，在2014年1月被红帽公司正式收购。CentOS系统最为人广泛熟悉的标签就是“免费”。如果您问一个运维“老鸟”选择CentOS系统的理由，他绝对不会跟你说更安全或更稳定，而只是说两个字—免费！由于红帽企业版Linux是开源软件，任何人都有修改和创建衍生品的权利，因此CentOS便是将红帽企业版Linux中的收费功能通通去掉，然后将新系统重新编译后发布给用户免费使用的Linux系统。也正因为其免费的特性，CentOS拥有了广泛的用户。

从本质上来说，由于CentOS是针对红帽企业版Linux进行修改后再发布的版本，因此不会针对它单独开发新功能，CentOS的版本号也是随红帽企业版Linux而变更。例如，CentOS 8.0对应的就是RHEL 8.0，CentOS 8.1对应的就是RHEL  8.1；以此类推。再就是，CentOS系统和RHEL系统的软件包可以通用。也就是说，如果工作中用的是RHEL，但是在安装某款软件时只找到了该软件的CentOS系统软件源，也是可以正常安装该软件的。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2015/01/fedora-e1422160855872.png)

**Fedora Linux**

Fedora翻译为中文是“浅顶软呢男帽”的意思，翻译之后跟Linux系统很不搭界，所以更多人干脆将其音译为“费多拉”系统。Fedora  Linux是正正经经的红帽公司自己的产品，最初是为了给红帽企业版Linux制作和测试第三方软件而构建的产品，孕育了最早的开源社群，固定每6个月发布一个新版本，当前在全球已经有几百万的用户。

Fedora是桌面版本的Linux系统，可以理解成是微软公司的Windows XP或者Windows  10。它的目标用户是应付日常的工作需要，而不会追求稳定性的人群。用户可以在这个系统中体验到最新的技术和工具，当这些技术和工具成熟后才会被移植到红帽企业版Linux中，因此Fedora也被称为RHEL系统的“试验田”。运维人员如果想每天都强迫自己多学点Linux知识，保持自己技术的领先性，就应该多关注此类Linux系统的发展变化和新特征，不断调整自己的学习方向。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2015/01/debian.png)

**Debian Linux**

一款基于GNU开源许可证的Linux系统，历史久远，最初发布于1993年9月。Debian的名字取自创始人**Ian** Murdock和他女朋友**Deb**ra的姓氏组合。在维基百科中，Debian被翻译为“蝶变”系统，多么浪漫而富有诗意的名字。但可惜国内的用户不买账，看着Logo一圈一圈的形状，硬生生地将经念歪了。这么多年下来，现在反而很少有人听说过蝶变系统这个名字了。

Debian系统具有很强的稳定性和安全性，并且提供了免费的基础支持，可以良好地适应各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。虽然Debian也是基于Linux内核，但是在实际操作中还是跟红帽公司的产品有一些差别，例如RHEL 7和RHEL 8分别使用Yum和DNF工具来安装软件，而Debian使用的则是APT工具。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/ubuntu-e1624206289343.png)

**Ubuntu Linux**

ubuntu是一款桌面版Linux系统，以Debian为蓝本进行修改和衍生而来，发布周期为6个月。Ubuntu的中文音译为“乌班图”，这个词最初来自于非洲南部部落使用的祖鲁语，意思是“我的存在是因为大家的存在”，体现了一种谦卑、感恩的价值观，寓意非常好。

Ubuntu系统的第一个版本发布于2004年10月。2005年7月，Ubuntu基金会成立，Ubuntu后续不断增加开发分支，有了桌面版系统、服务器版系统和手机版系统。据调查，Ubuntu最高峰时的用户达到了10亿人。尽管Ubuntu基于Debian系统衍生而来，但会对系统进行深度化定制，因此两者之间的软件并不一定完全兼容。Ubuntu系统现在由Canonical公司提供商业技术支持，只要购买付费技术支持服务就能获得帮助，桌面版系统最长时间3年，服务器版系统最长时间5年。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2016/03/OpenSUSE.png)

**openSUSE Linux**

一款源自德国的Linux系统，在全球范围内有着不错的声誉及市场占有率。openSUSE的桌面版系统简洁轻快易于使用，而服务器版本则功能丰富极具稳定性，而且即便是“菜鸟”也能轻松上手。虽然openSUSE在技术上颇具优势，而且大大的绿色蜥蜴Logo人见人爱，只可惜命途多舛，赞助和研发该系统的SuSE Linux  AG公司由于效益不佳，于2003年被Novell公司收购，而Novell公司又因经营不佳而在2011年被Attachmate公司收购。而到了2014年，Attachmate公司又被Micro Focus公司收购，后者仍然只把维护openSUSE系统的团队当作公司内的一个部门来运营。

即便如此，依然不妨碍openSUSE系统的坚强发展，用户可以完全自主选择要使用的软件。例如，针对GUI环境，就提供了诸如GNOME、KDE、Cinnamon、MATE、LXQt、Xfce等可选项；除此之外，还为用户提供了数千个免费开源的软件包。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/kali.jpg)

**Kali Linux**

跟上面的呆萌大蜥蜴相比，Kali  Linux的Logo似乎有点凶巴巴，一副不好惹的样子。这款系统一般是供黑客或安全人员使用的，能够以此为平台对网站进行渗透测试，通俗来讲就是能“攻击”网站。Kali  Linux系统的前身名为BackTrack，其设计用途就是进行数字鉴识和渗透测试，内置有600多款网站及系统的渗透测试软件，包括大名鼎鼎的Nmap、Wireshark、sqlmap等。Kali  Linux能够被安装到个人电脑、公司服务器，甚至手掌大小的树莓派（一款微型电脑）上，可以让人有一种随身携带了一个武器库的感觉，有机会真应该单独写本书聊聊它。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2016/03/Gentoo.png)

**Gentoo Linux**

Gentoo翻译为中文是“巴布亚企鹅”。终于找到一个跟Linux吉祥物—企鹅相关的名字了。巴布亚企鹅是企鹅家族中体型最大的物种之一，游泳时速最快可达36千米—多么灵活的胖子！

Gentoo系统最大的特色就是允许用户完全自由地进行定制。开发人员Daniel曾经说过：“Gentoo系统的设计出发点就是让用户随意使用，没有限制地使用”。只要理解了这句话，后面也就不需要再解释什么了。在Gentoo系统中，任何一部分功能（包括最基本的系统库和编译器）都允许用户重新编译；用户也可以选择喜欢的补丁或者插件进行定制。但是，也因为Gentoo极高的自定制性，导致操作复杂，因此仅适合有经验的运维人员使用。有兴趣的读者可以在学习完本书后尝试一下该系统。

如果大家今后真的安装了Gentoo系统，千万别忘记试一下Portage工具。这款软件管理工具以模块化、可移植、易维护和灵活性而著称，几乎可以无限制地适应用户的计算机硬件。

------

![第0章 咱们先来谈谈为什么要学习Linux系统第0章 咱们先来谈谈为什么要学习Linux系统](https://www.linuxprobe.com/wp-content/uploads/2020/04/deepin.png)

**深度操作系统（deepin）**

在过去的十多年，基于开源系统二次定制开发的“国产操作系统”陆续出现过一些，但大多发展不好，深度操作系统却是少数能够将技术研发与商业运作结合起来的成功案例。据Deepin的官网介绍，该系统是由武汉深之度科技有限公司于2011年基于Debian系统衍生而来的，提供32种语言版本，目前累计下载量已近1亿次，用户遍布100余个国家/地区。

就Deepin来讲，最吸引人的还是它的本土化工作。Deepin默认集成了诸如WPS  Office、搜狗输入法、有道词典等国内常用的软件，对“小白”用户相当友好。当然，Deepin的技术研发能力相较于国际水平肯定还有差距，这点我们也要承认并正视。虽然刘遄老师偶尔也会在微博上调侃一下，但谁又不希望自己国家的技术发展越来越强大呢？

------

总结来说，虽然上述不同版本的Linux系统在界面上可能差别很大，或是在操作方法上不尽相同，但只要是基于Linux内核研发的，我们都称之为Linux系统。大家手中的这本书是基于最新发布的RHEL  8系统编写而成，书中内容及实验完全通用于当前主流的Linux系统。也就是说，当您学完本书后，即便公司内的生产环境部署的是CentOS、Fedora等，我们也照样可以搞得定。更重要的是，本书配套资料中的ISO系统镜像与红帽RHCSA及RHCE考试基本保持一致，因此很适合备考红帽认证的考生使用。

另外，需要强调的是，现在国内大多数Linux相关的图书都是基于CentOS系统编写的，作者大多也会给出围绕CentOS系统进行写作的一系列理由，但是很多理由都站不住脚，根本没有剖析到CentOS系统与RHEL系统的本质关系。CentOS系统是通过把RHEL系统释放出的程序源代码经过二次编译之后生成的一种衍生Linux系统，其命令操作和服务配置方法与RHEL完全相同，只是去掉了RHEL的一些收费功能，而且还不提供任何形式的技术支持，出现问题后只能由运维人员自己解决。

经过这般分析基本上可以判断出，选择CentOS系统的理由只剩下一个—免费！当人们大举开源、免费、正义的旗帜来宣扬CentOS系统的时候，殊不知CentOS系统其实早在2014年年初就已经被红帽公司“收编”，当前只是战略性的免费而已。再者，根据GNU  GPL许可协议，我们同样也可以免费使用RHEL系统，甚至是修改其代码创建衍生产品。开源系统在自由程度上没有任何差异，更无关道德问题，请大家务必要辨别清楚。

> 随书配备的ISO系统镜像文件下载地址：https://www.linuxprobe.com/tools
>
> 深度评解红帽RHCSA、RHCE、RHCA认证：https://www.linuxprobe.com/redhat-certificate



2019年年末，Red Hat公司发布了当前最新的红帽企业版Linux系统—RHEL  8，彼时国内外各大媒体都给了不少特写镜头，行业也给予了硕大的期待。但是，时至今日RHEL  8系统的市场占有率却一直不温不火，于是有人开始对RHEL  8系统的未来表示担忧，甚至有人还拿出各种论调来唱衰Linux系统，觉得开源厂商已经过了事业最高点，要在服务器领域让步于Windows系统了。这些话其实并没必要去反驳，任何一个产品都会有其拥趸和黑粉，时间会向所有人证明一切。我们现在只是来单纯地聊一聊这个RHEL 8系统。

在正式开聊之前，希望读者对Linux系统的特性和运维领域有基本的了解，知道Linux系统在服务器领域中占据着不可小觑的市场份额，认识到Red  Hat厂商对Linux系统及整个开源行业的重要影响，更知道CentOS系统其实是RHEL系统的衍生品。如果您以前使用过一段时间的Linux系统，那么我们就更能顺畅地讨论“红帽RHEL 8系统是否是一个失败的产品”这个问题。

我们先来看一个烫手的热议问题：“为什么半年过去了，RHEL  8系统的市场份额依然不温不火？要不要返回去学习老版本的Linux系统？”甚至有阴谋论说是美国在使用新版本的Linux系统来搜集全球用户信息，告诫大家千万不要去碰。这个问题必须要回应，否则更多的阴谋论会层出不穷，甚至会让国内某些认知能力欠缺的媒体对开源行业产生误解。

基于前面提到的与读者共有的经验知识和篇幅限制，下面的论证速度会比较快，也会很有意思。首先，RHEL是企业版的服务器系统而不是用来玩耍折腾的桌面版系统，并不是能随意更换的，更何况作为桌面版系统的Windows 7在2009年7月14日发布之后，也整整用了4年才开始真正普及，难道在2009年到2013年间，Windows  7就是失败的产品吗？再者，RHEL  8系统创新式地集成了Docker虚拟化技术，支持XFS文件系统，兼容微软的身份管理，并采用systemd作为系统初始化进程，其性能和兼容性相较于之前版本都有了很大的改善，很明显是一款非常优秀的操作系统。最后，其实从纳入OpenStack、Docker、Cockpit以及Ansible等技术的决策上来讲，就应该相信红帽公司的开发团队不是在闭门造车。应该重新思考到底是哪里出了问题。

当大家真正从事运维工作后，相信就能回答这个问题了。因为运维人员每天都在想：“现在的环境跑得好好的，为什么要换呢？”重新部署生产环境可不是说装上操作系统就万事大吉，也不是把软件随便安装上就能拍屁股走人的，还要考虑升级带来的一系列风险。

> 日后的生产环境出了问题，谁来负责？
>
> 新系统是否能与旧的软件兼容？
>
> 不再兼容的软件是否有升级版本？
>
> 新的系统或软件是否有bug？
>
> 安全性如何，审计怎么做？
>
> 之前购买的第三方技术支持是否可以具备相应的能力？
>
> 升级后是否会影响到某些软件的版权，是否需要重新付费？
>
> 不习惯新系统带来的变化怎么办？
>
> 费力升级后对自己有什么好处？
>
> ……

我们来看一个极端的例子。现在全国各地有几十万台ATM机，绝大部分使用的是Windows  XP系统，但微软公司已经从2014年4月8日起停止对Windows  XP进行任何的维护，甚至不再提供补丁服务。假设中国人民银行发布招标公告，想将ATM机的操作系统统一替换成Windows  7版本。现在我们敢不敢接这个活？如果接了，且不说旷日持久地升级和调试工作，也不提升级期间因业务关停带来的损失，我们就看一个小问题—用户在从升级后的ATM机上取钱时，如果有钞票多吐出来，这个责任该由谁承担？

当然，上面的情况非常极端，描述的也比较偏激，目的只是给大家举个例子，让没有工作经验的同学也能迅速明白“生产环境中的设备不要随便乱动”的道理。但这绝对不是说运维工作就是日常“丢锅”，不作为。在需要升级的时候，我们需要当机立断，采取行动，不能有一丝马虎。

### **Tips**

2012年5月19日，在英国汉普郡利明顿附近的小镇Milford-on-Sea上，一台ATM机在维护后发生故障，在顾客取款时会吐出双倍数额的现金。此消息不胫而走之后，总共有200名顾客取走现金，有的人甚至取走了数千英镑。“狂欢”总共持续了两个多小时，随后警方赶到现场，关闭了这台ATM机。

------

客观来讲，RHEL 7和RHEL  8系统的改变都很大，最重要的是它们采用了systemd作为初始化进程，替换了很多原有的老命令。这样一来，几乎之前所有的运维自动化脚本都需要修改。那么，到底还要不要升级到新版本呢？当然，也不是说服务器机房中的生产环境从不更新换代。除了硬件更替外，当工作需求超过了当前软件版本的能力范围时，就必须要进行升级了。

比如，RHEL 7系统使用的Linux内核还是3.10版本，而现在最新的RHEL  8系统使用的内核版本已经是4.18，两个系统之间差了一个大版本号。再者，RHEL  7在安装软件时使用的是基于v3版本的Yum技术，这个版本的技术滞后且效率低，而RHEL  8在安装软件时则使用的是DNF技术。DNF技术已经相当于Yum 4.x版本，其功能就有了巨大的差别。此外，RHEL  8系统最大支持24TB的物理内存，比RHEL 7系统整整翻了一倍。这些更新数不胜数，您现在还觉得会一直使用旧的版本吗？

早在2014年年初，Fedora系统首次采用了systemd系统初始化进程，当时我就断言RHEL  7系统也会使用systemd，所以当即更新了自己的培训课程。这也让身在其他培训机构还在学习init参数的学员心生羡慕。所以，不论是学习Linux还是编程语言，都应该选择当前稳定且最新的版本作为学习环境。这样在学完后，从概率上来讲能适应的工作也会越多。

最后总结一下，我每次在公开场合讲座时都会表达这样一个观点：“我们并不是因为开源而喜欢Linux，而是因为Linux系统真的非常优秀，开源精神仅仅是锦上添花而已。”我们在前文中已经狠狠地肯定了Linux系统对运维行业甚至是对世界的影响，大家要做的就是相信我对运维行业未来发展的判断，然后放手来学习吧。





Linux系统在启动时要进行大量的初始化工作，比如挂载文件系统和交换分区、启动各类进程服务等，这些都可以看作是一个一个的单元（unit），systemd用目标（target）代替了System V init中运行级别的概念，这两者的区别如表1-3所示。

表1-3                  systemd与System V init的区别以及作用

| System V init运行级别 | systemd目标名称   | systemd 目标作用 |
| --------------------- | ----------------- | ---------------- |
| 0                     | poweroff.target   | 关机             |
| 1                     | rescue.target     | 单用户模式       |
| 2                     | multi-user.target | 多用户的文本界面 |
| 3                     | multi-user.target | 多用户的文本界面 |
| 4                     | multi-user.target | 多用户的文本界面 |
| 5                     | graphical.target  | 多用户的图形界面 |
| 6                     | reboot.target     | 重启             |
| emergency             | emergency.target  | 救援模式         |



如果想要将系统默认的运行目标修改为“多用户的文本界面”模式，可直接用ln命令把多用户模式目标文件链接到/etc/systemd/system/目录：

```
[root@linuxprobe ~]# ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target
```

如果有读者之前学习过RHEL  5/6系统，或者已经习惯使用service、chkconfig等命令来管理系统服务，那么现在就比较郁闷了，因为在RHEL  7/8系统中是使用systemctl命令来管理服务的。表1-4和表1-5所示为新老版本系统的对比，您可以先大致了解一下，后续章节中会经常用到它们。

表1-4                  服务的启动、重启、停止、重载、查看状态等常用命令

| 老系统命令          | 新系统命令              | 作用                           |
| ------------------- | ----------------------- | ------------------------------ |
| service foo start   | systemctl start httpd   | 启动服务                       |
| service foo restart | systemctl restart httpd | 重启服务                       |
| service foo stop    | systemctl stop httpd    | 停止服务                       |
| service foo reload  | systemctl reload httpd  | 重新加载配置文件（不终止服务） |
| service foo status  | systemctl status httpd  | 查看服务状态                   |



表1-5                  服务开机启动、不启动、查看各级别下服务启动状态等常用命令

| 老系统命令        | 新系统命令                             | 作用                               |
| ----------------- | -------------------------------------- | ---------------------------------- |
| chkconfig foo on  | systemctl enable httpd                 | 开机自动启动                       |
| chkconfig foo off | systemctl disable httpd                | 开机不自动启动                     |
| chkconfig foo     | systemctl is-enabled httpd             | 查看特定服务是否为开机自启动       |
| chkconfig --list  | systemctl list-unit-files --type=httpd | 查看各个级别下服务的启动与禁用情况 |



##### **1.6 重置root密码**

平日里让运维人员头疼的事情已经很多了，偶尔忘记Linux系统密码的事情也很常见。不过不用慌，只需简单几步就可以完成密码的重置工作。

> **如果您是第一次阅读本书，或者之前没有Linux系统的使用经验，请一定先跳过本节，等学习完Linux系统的命令后再来学习本节内容。**

假设您刚刚接手了一台Linux系统，要先确定是否为RHEL 8系统。如果是，然后再进行下面的操作。

> ```
> [root@linuxprobe ~]# cat /etc/redhat-release 
> Red Hat Enterprise Linux release 8.0 (Ootpa)
> ```

重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面，如图1-50所示。

![第1章 动手部署一台Linux操作系统第1章 动手部署一台Linux操作系统](https://www.linuxprobe.com/wp-content/uploads/2020/05/Linux系统的引导界面.png)

图1-50 Linux系统的引导界面

在linux参数这行的最后面追加rd.break参数，然后按下Ctrl + X组合键运行修改过的内核程序，如图1-51所示。

![第1章 动手部署一台Linux操作系统第1章 动手部署一台Linux操作系统](https://www.linuxprobe.com/wp-content/uploads/2020/05/内核信息的编辑界面.png)

图1-51 内核信息的编辑界面

大约30秒过后，系统会进入紧急救援模式，如图1-52所示。

![第1章 动手部署一台Linux操作系统第1章 动手部署一台Linux操作系统](https://www.linuxprobe.com/wp-content/uploads/2020/05/Linux系统的紧急救援模式-1024x614.png)

图1-52 Linux系统的紧急救援模式

然后依次输入以下命令，再连续按下两次Ctrl + D组合键盘来退出并重启。等待系统再次重启完毕后便可以使用新密码登录Linux系统。这一系列命令的执行效果如图1-53所示。

```
mount -o remount,rw /sysroot
chroot /sysroot
passwd
touch /.autorelabel
```

![第1章 动手部署一台Linux操作系统第1章 动手部署一台Linux操作系统](https://www.linuxprobe.com/wp-content/uploads/2020/05/重置Linux系统的管理员密码.png)

图1-53 重置Linux系统的管理员密码

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．为什么建议读者在下载系统文件后先进行校验而不是直接安装呢？

**答：**为了保证系统和软件包的安全与完整性，避免因为外部因素导致安装失败—磨刀不误砍柴工。

2．使用虚拟机安装Linux系统时，为什么要先选择稍后安装操作系统，而不是去选择RHEL 8系统镜像文件？

**答：**在配置界面中若直接选择了RHEL 8系统镜像文件，则VMware Workstation虚拟机会使用内置的安装向导自动进行安装，最终安装出来的系统跟我们后续进行实验所需的系统环境会不一样。

3．在安装系统时如果出现类似于“CPU不支持虚拟化”这样的报错信息，该怎么解决？

**答：**遇到此类报错，最大的可能原因是BIOS中没有开启VT功能，手动开启后重启即可。

4．RPM（红帽软件包管理器）只有红帽企业系统在使用，对吗？

**答：**RPM已经被CentOS、Fedora、openSUSE等众多Linux系统采用，它真的很好用！

5．简述RPM与软件仓库的作用。

**答：**RPM是通过将源代码与安装规则打包在一起，降低了单个软件的安装难度。而Yum与DNF软件仓库则是将大量常用的RPM软件包打包到一起，解决了软件包之间的依赖关系，这进一步降低了软件的整体安装难度。

6．RHEL 7/8系统采用了systemd作为初始化进程，那么如何查看某个服务的运行状态呢？

**答：**执行命令“systemctl status服务名”可以查看服务的运行状态。



一台完整的计算机是由运算器、控制器、存储器、输入/输出等多种硬件设备共同组成的，而能让各种硬件设备各司其职且又能协同运行的东西就是系统内核。[Linux系统](https://www.linuxprobe.com/)的内核负责完成对硬件资源的分配、调度等管理任务，对系统的正常运行起着十分重要的作用。

与修改Windows系统中的注册表类似，直接改动内核参数的难度比较大，而且一旦“手滑”还有可能导致系统直接崩溃。因此不建议同学们直接去编辑内核中的参数，而是用基于系统调用接口开发出来的程序或服务来管理计算机，以满足日常的工作需要。

如图2-1所示，人类是无法直接控制硬件的（想象一个人捧着块硬盘自言自语的滑稽场景）。硬件设备由系统内核直接管理，但由于内核的复杂性太高，在访问时存在较大的风险，因此用户不能直接访问内核。虽然通过调用系统提供的API（应用程序编程接口）就能实现某个功能，但哪怕实现“将一条信息通过互联网传输给别人”这样简单的任务，都要手动调用几十次API接口，使用起来太不切实际。而最外层的服务程序则是最贴近于用户端的，这些服务程序是集成了大量API接口的完整软件，微信、QQ就是这样的服务程序。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/用户与硬件-1.jpg)

图2-1 用户与硬件

讲到这里，相信大家已经能够明白服务程序对用户和硬件所能发挥的作用了。如果把整台电脑比喻成人类社会，那么服务程序就是一名翻译官，负责将用户提出的需求转换成硬件能够接收的指令代码，然后再将处理结果反馈成用户能够读懂的内容格式。这样一来一回，用户就能使用硬件资源了。![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/蜗牛.png)

看到被一层层“包裹”起来的硬件设备，大家有没有感觉像一只蜗牛的壳呢？英文中的壳叫作Shell，我们在行业中也将用户终端程序称之为Shell，方便好记。

Shell就是终端程序的统称，它充当了人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端程序，它就会调用相应的程序服务去完成某些工作。现在包括[红帽](https://www.linuxprobe.com/)系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器，这个Bash解释器主要有以下4项优势：

> 通过上下方向键来调取执行过的Linux命令；
>
> 命令或参数仅需输入前几位就可以用Tab键补全；
>
> 具有强大的批处理[脚本](https://www.linuxcool.com/)；
>
> 具有实用的环境变量功能。

大家可以在今后的学习和生产工作中细细体会Linux系统命令行的美妙之处，真正从心里爱上它们。

### **Tips**

Shell与Bash是包含与被包含的关系。举例来说，在社会中有翻译官这个职业，它是由许多从业者共同组成的职业名称，而Bash则是其中一个出色的成员，是Shell终端程序中的一份子。

必须肯定的是，Linux系统中有些图形化工具（比如逻辑卷管理器[Logical Volume Manager，LVM]）确实非常好用，极大地降低了运维人员出错的概率，值得称赞。但是，很多图形化工具其实只是调用了命令[脚本](https://www.linuxcool.com/)来完成相应的工作，或往往只是为了完成某种特定工作而设计的，缺乏Linux命令原有的灵活性及可控性。再者，图形化工具相较于Linux命令行界面会更加消耗系统资源，因此经验丰富的运维人员甚至都不会给Linux系统安装图形界面，在需要开始运维工作时直接通过命令行模式远程连接过去。不得不说，这样做确实挺高效的。

##### **2.2 执行命令的必备知识**

既然Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习一下怎么跟它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际情况来灵活调整各种命令的参数。比如，我们切寿司时尽管可以用菜刀，但米粒一定会撒得满地都是，因此寿司刀上设计的用于透气的圆孔就是为了更好地适应场景而额外增加的参数。当您学完本书并具备一定的工作经验之后，一定能够领悟Linux命令的奥秘。

常见的执行Linux命令的格式是下面这样的。

>  **命令名称   [命令参数]   [命令对象]**

**命令名称**：就是语法中的“动词”，表达的是想要做的事情，例如创建用户、查看文件、重启系统等操作。

**命令参数**：用于对命令进行调整，让“修改”过的命令能更好地贴合工作需求，达到事半功倍的效果。就像买衣服一样，衣服的尺码总会感觉偏大或偏小，要么只能将就着穿，要么就再裁剪修改一下，而这种对命令进行“裁剪”的行为就是加参数。例如创建一个编码为888的用户、仅查看文件的前20行、重启系统前先提醒其他用户等。参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用“--”与“-”作为前缀（示例请见表2-1）。

表2-1                     Linux命令参数的长格式与短格式示例

| 长格式 | man --help |
| ------ | ---------- |
| 短格式 | man -h     |



**命令对象**：一般指要处理的文件、目录、用户等资源名称，也就是命令执行后的“承受方”。例如创建一位叫小明的用户、查看一个叫工资表的文件、重启一个IP为192.168.10.10的系统等。

### **Tips**

命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。

在Linux相关的图书中，我们会约定俗成地将可选择的、可加或可不加的、非必需的参数使用中括号引起来，例如“man [命令参数]”；而命令所要求的、必须有的参数或对象值，则不带中括号。这样一来，读者可以更好地理解下面出现的命令格式。

在初学Linux系统时不会执行命令大多是因为参数比较复杂，参数值需要随不同的命令和实际工作情况而发生改变。所以有读者现在可能会想：“Linux系统中有那么多命令，我怎么知道某个命令是干嘛用的？在日常工作中遇到了一个不熟悉的Linux命令，我又怎样才能知道它有哪些可用参数呢？”接下来，我们就拿man这个命令作为本书中的第一个Linux命令教给读者去学习。对于真正的零基础读者，可以通过图2-2～图2-5来学习如何在RHEL 8系统中执行Linux命令。

默认的主机登录界面中只有我们刚刚新建的普通用户，因此在正式进入系统之前，还需要先单击“Not listed?”选项切换至root管理员身份。这是红帽RHEL 8系统为了避免用户乱使用权限而采取的一项小措施，如图2-2所示。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/切换至root管理员身份-1024x614.png)

图2-2 切换至root管理员身份。

如果使用默认的linuxprobe用户登录到主机中，那么本章后面的一些命令会因为权限不足而无法执行，我们需要有足够的权限才能完成接下来的实验。至于同学们关心的“root管理员和普通用户之间的区别，在生产环境时又该如何选择”的疑问，将会在第5章慢慢讲给大家。

登录成功后，单击桌面左上角的Activities按钮，在左侧弹出的菜单中单击命令行终端图标即可打开Bash解释器，如图2-3所示。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/打开命令行终端-1024x614.png)

图2-3 打开命令行终端

在命令行终端中输入man man命令来查看man命令自身的帮助信息，如图2-4所示。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/查看man命令的帮助信息-1024x614.png)

图2-4 查看man命令的帮助信息

敲击回车键后即可看到如图2-5所示的帮助信息。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/man命令的帮助信息-1024x614.png)

图2-5 man命令的帮助信息

小试牛刀成功。大家是不是热情倍增！不过还是要注意Linux系统中的命令、参数、对象都是严格区分大小写的。比如，分别执行几次man命令，大家能看得出来哪个是正确的吗？


```
[root@linuxprobe ~]# Man
bash: Man: command not found...
Similar command is: 'man'
[root@linuxprobe ~]# MAN
bash: MAN: command not found...
Similar command is: 'man'
[root@linuxprobe ~]# man
What manual page do you want?
```

在man命令帮助信息的界面中，所包含的常用操作按键及其作用如表2-2所示。

表2-2                      man命令中常用按键以及作用

| 按键      | 作用                               |
| --------- | ---------------------------------- |
| 空格键    | 向下翻一页                         |
| PaGe down | 向下翻一页                         |
| PaGe up   | 向上翻一页                         |
| home      | 直接前往首页                       |
| end       | 直接前往尾页                       |
| /         | 从上至下搜索某个关键词，如“/linux” |
| ?         | 从下至上搜索某个关键词，如“?linux” |
| n         | 定位到下一个搜索到的关键词         |
| N         | 定位到上一个搜索到的关键词         |
| q         | 退出帮助文档                       |



一般来讲，使用man命令查看到的帮助内容信息都会很长很多，如果读者不了解帮助文档信息的目录结构和操作方法，乍一看到这么多信息可能会感到相当困惑。man命令的帮助信息的结构及其代表意义如表2-3所示。

表2-3                     man命令中帮助信息的结构以及意义

| 结构名称    | 代表意义                 |
| ----------- | ------------------------ |
| NAME        | 命令的名称               |
| SYNOPSIS    | 参数的大致使用方法       |
| DESCRIPTION | 介绍说明                 |
| EXAMPLES    | 演示（附带简单说明）     |
| OVERVIEW    | 概述                     |
| DEFAULTS    | 默认的功能               |
| OPTIONS     | 具体的可用选项（带介绍） |
| ENVIRONMENT | 环境变量                 |
| FILES       | 用到的文件               |
| SEE ALSO    | 相关的资料               |
| HISTORY     | 维护历史与联系方式       |



需要多说一句的是，在输入命令前就已经存在的“[root@linuxprobe～]#”这部分内容是终端提示符，它用于向用户展示一些基本的信息—当前登录用户名为root，简要的主机名是linuxprobe，所在目录是～（这里的～是指用户家目录，第6章会讲解），#表示管理员身份（如果是$则表示普通用户，相应的权限也会小一些）。

额外的4个快捷键/组合键小技巧

**Tab键**：

在Bash解释器的快捷键中，Tab键绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。例如，如果想执行reboot重启命令，但一时想不起来该命令的完整拼写，则可以这样输入：

```
[root@linuxprobe ~]# re<Tab键><Tab键>
read                    redhat-access-insights  rescan-scsi-bus.sh
readarray               reject                  reset
readelf                 remotectl               resize2fs
readlink                rename                  resizecons
readmult                renew-dummy-cert        resizepart
readonly                renice                  resolvconf
readprofile             report-cli              resolvectl
realm                   reporter-rhtsupport     restorecon
realpath                reporter-upload         restorecon_xattr
reboot                  report-gtk              return
recode-sr-latin         repquota                rev
red                     request-key     
[root@linuxprobe ~]# reb<Tab键>
[root@linuxprobe ~]# reboot
```

在上面的实验中，先输入了两个字母re，随后敲击了两下Tab键。由于以re开头的命令不止一个，所以系统将所有以re开头的命令全部显示了出来。而第二次输入reb后再敲击Tab键，由于此时没有以reb开头的其他命令，所以系统就显示出了完整的reboot重启命令。

对于文件名也是一样的操作—只需要输入前面的一部分名称，且不存在多个以这部分名称开头的文件名，系统就会自动补全。不仅速度快，而且避免了手动输入有可能出错的问题。

**Ctrl+c组合键**：当同时按下键盘上的Ctrl和字母c的时候，意味着终止当前进程的运行。假如执行了一个错误命令，或者是执行某个命令后迟迟无法结束，这时就可以冷静地按下Ctrl+c组合键，命令行终端的控制权会立刻回到我们手中。

下述命令的执行效果是每1s刷新一次系统负载情况（先不用管命令的作用），直到按下Ctrl+c组合键时才停止运行。

```
[root@linuxprobe ~]# watch -n 1 uptime
Every 1.0s: uptime                        localhost.localdomain: Mon Sep 28 19:11:44 2020
19:11:44 up 59 min,  2 users,  load average: 0.00, 0.00, 0.00
<Ctrl>+<c>
[root@linuxprobe ~]#
```

**Ctrl+d组合键**：当同时按下键盘上的Ctrl和字母d的时候，表示键盘输入结束。

**Ctrl+l组合键**：当同时按下键盘上的Ctrl和字母l的时候，会清空当前终端中已有的内容（相当于清屏操作）。

从现在开始，本书后面的内容都是重磅内容。本书将会带领读者掌握大约150个常用的Linux命令，以及50多个热门的命令。这50多个热门的命令是以Linux命令大全网（www.linuxcool.com）的查询阅览量为基础筛选出来的。当然，将这些命令全都放到第2章讲完肯定不现实，所以刘遄老师根据10多年来的运维经验优先筛选出了10多个高频使用的基础命令。由于后面的章节中会反复用到这些命令，因此大家需要好好学习并掌握它们，这样才能在后面章节的学习中做到游刃有余。加油！

##### **2.3 常用系统工作命令**

您现在阅读的这本书是刘遄老师在经历了数十期的培训授课后总结而成的，您可能无法在本节中找到某些之前见过的命令。但不用担心，之所以这样安排，原因是我们在努力地将Linux命令与实战相结合，真正让读者在实操中理解技术，而不是单纯地把命令堆砌到书中让读者去硬背。

刘遄老师用了近一年的时间把最常用的Linux命令进行汇总、归纳、整理、分类后，把这些常用的命令合理安排到了后续章节中，然后采用以练代学的方式来加深读者的理解和掌握。从数年的培训成果反馈来看，这种方式相当有效，因此也相信这种方式肯定适合您的学习。

**1．echo命令**

echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为“echo [字符串] [$变量]”。

这是Linux系统中最常用的几个命令之一，它的操作却非常简单，执行“echo字符串”或“echo $变量”就行，其中$符号的意思是提取变量的实际值，以便后续的输出操作。



例如，把指定字符串“LinuxProbe.com”输出到终端屏幕的命令为：

```
[root@linuxprobe ~]# echo LinuxProbe.com
```

该命令会在终端屏幕上显示如下信息：

```
LinuxProbe.com
```

下面使用“$变量”的方式提取出变量SHELL的值，并将其输出到屏幕上：

```
[root@linuxprobe ~]# echo $SHELL
/bin/bash
```

**2．date命令**

date命令用于显示或设置系统的时间与日期，语法格式为“date [+指定的格式]”。

用户只需在强大的date命令后输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2020-9-1.tar.gz”，用户只需要看一眼文件名称就能大致了解到每个文件的备份时间了。date命令中常见的参数格式及其作用如表2-4所示。

表2-4                        date命令中的参数及其作用

| 参数 | 作用                             |
| ---- | -------------------------------- |
| %S   | 秒（00～59）                     |
| %M   | 分钟（00～59）                   |
| %H   | 小时（00～23）                   |
| %I   | 小时（00～12）                   |
| %m   | 月份（1~12）                     |
| %p   | 显示出AM或PM                     |
| %a   | 缩写的工作日名称（例如：Sun）    |
| %A   | 完整的工作日名称（例如：Sunday） |
| %b   | 缩写的月份名称（例如：Jan）      |
| %B   | 完整的月份名称（例如：January）  |
| %q   | 季度（1~4）                      |
| %y   | 简写年份（例如：20）             |
| %Y   | 完整年份（例如：2020）           |
| %d   | 本月中的第几天                   |
| %j   | 今年中的第几天                   |
| %n   | 换行符（相当于按下回车键）       |
| %t   | 跳格（相当于按下Tab键）          |



![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/date.png)

按照默认格式查看当前系统时间的date命令如下所示：

```
[root@linuxprobe ~]# date
Sat Sep 5 09:13:45 CST 2020
```

按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：

```
[root@linuxprobe ~]# date "+%Y-%m-%d %H:%M:%S"
2020-09-05 09:14:35
```

将系统的当前时间设置为2020年11月1日8点30分的date命令如下所示：

```
[root@linuxprobe ~]# date -s "20201101 8:30:00"
Sun Nov 1 08:30:00 CST 2020
```

再次使用date命令并按照默认的格式查看当前的系统时间，如下所示：

```
[root@linuxprobe ~]# date
Sun Nov 1 08:30:08 CST 2020
```

date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的早晚，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示：

```
[root@linuxprobe ~]# date "+%j"
306
```

**3．timedatectl命令**

timedatectl命令用于设置系统的时间，英文全称为“time date control”，语法格式为“timedatectl [参数]”。

发现电脑时间跟实际时间不符？如果只差几分钟的话，我们可以直接调整。但是，如果差几个小时，那么除了调整当前的时间，还有必要检查一下时区了。timedatectl命令中常见的参数格式及作用如表2-5所示。

表2-5                        timedatectl命令中的参数以及作用

| 参数           | 作用         |
| -------------- | ------------ |
| status         | 显示状态信息 |
| list-timezones | 列出已知时区 |
| set-time       | 设置系统时间 |
| set-timezone   | 设置生效时区 |



查看系统时间与时区的方法如下：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/timedatectl.png)

```
[root@linuxprobe ~]# timedatectl status
               Local time: Sun 2020-09-06 19:51:22 CST
           Universal time: Sun 2020-09-06 11:51:22 UTC
                 RTC time: Sun 2020-09-06 19:51:21
                Time zone: Asia/Shanghai (CST, +0800)
System clock synchronized: no
              NTP service: inactive
          RTC in local TZ: no
```

如果您查到的时区不是上海（Asia/Shanghai），可以手动进行设置：

```
[root@linuxprobe ~]# timedatectl set-timezone Asia/Shanghai
```

如果时间还是不正确，可再手动修改系统日期：

```
[root@linuxprobe ~]# timedatectl set-time 2021-05-18
```

而如果想修改时间的话，也很简单：

```
[root@linuxprobe ~]# timedatectl set-time 9:30
[root@linuxprobe ~]# date 
Tue May 18 09:30:01 CST 2021
```

**4．reboot命令**

reboot命令用于重启系统，输入该命令后按回车键执行即可。

由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以root管理员的身份来重启，普通用户在执行该命令时可能会被拒绝。reboot的命令如下：

```
[root@linuxprobe ~]# reboot
```

**5．poweroff命令**

poweroff命令用于关闭系统，输入该命令后按回车键执行即可。

与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以root管理员的身份来关闭电脑，其命令如下：

```
[root@linuxprobe ~]# poweroff
```

**6．wget命令**

wget命令用于在终端命令行中下载网络文件，英文全称为“web get”，语法格式为“wget [参数] 网址”。

借助于wget命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。如果您没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一眼下面的演示实验就够了，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等掌握了网卡的配置方法后再来进行这个实验操作。表2-6所示为wget命令中的参数以及参数的作用。

表2-6                        wget命令中的参数以及作用

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -b   | 后台下载模式                         |
| -P   | 下载到指定目录                       |
| -t   | 最大尝试次数                         |
| -c   | 断点续传                             |
| -p   | 下载页面内所有资源，包括图片、视频等 |
| -r   | 递归下载                             |



### **Tips**

由于本实验需要从外部网络下载文件，但虚拟机默认是无法连接外网的，在操作后会提示响应超时的报错，因此可先不进行实操。

尝试使用wget命令从本书的配套站点中下载本书最新的PDF格式的电子文档。执行该命令后的下载效果如下：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/wget.png)

```
[root@linuxprobe ~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf
--2020-09-28 19:24:39--  https://www.linuxprobe.com/docs/LinuxProbe.pdf
Resolving www.linuxprobe.com (www.linuxprobe.com)... 221.15.64.1
Connecting to www.linuxprobe.com (www.linuxprobe.com)|221.15.64.1|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 17676281 (17M) [application/pdf]
Saving to: ‘LinuxProbe.pdf’

LinuxProbe.pdf      100%[===================>]  16.86M  15.9MB/s    in 1.1s    

2020-09-28 19:24:40 (15.9 MB/s) - ‘LinuxProbe.pdf’ saved [17676281/17676281]
```

接下来，使用wget命令递归下载www.linuxprobe.com网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为www.linuxprobe.com的目录中。该命令的执行结果如下：

```
[root@linuxprobe ~]# wget -r -p https://www.linuxprobe.com
--2020-09-28 19:26:12--  https://www.linuxprobe.com/
Resolving www.linuxprobe.com (www.linuxprobe.com)... 221.15.64.1
Connecting to www.linuxprobe.com (www.linuxprobe.com)|221.15.64.1|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘www.linuxprobe.com/index.html’
………………省略下载过程………………
```

**7．ps命令**

ps命令用于查看系统中的进程状态，英文全称为“processes”，语法格式为“ps [参数]”。

估计读者在第一次执行这个命令时都要惊呆一下—怎么会有这么多输出值，这可怎么看得过来？其实，高手通常会将ps命令与第3章的管道符技术搭配使用，用来抓取与某个指定服务进程相对应的PID号码。ps命令的常见参数以及作用如表2-7所示。

表2-7                         ps命令中的参数以及作用

| 参数 | 作用                               |
| ---- | ---------------------------------- |
| -a   | 显示所有进程（包括其他用户的进程） |
| -u   | 用户以及其他详细信息               |
| -x   | 显示没有控制终端的进程             |



![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/ps.png)

Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。

> **R（运行）**：进程正在运行或在运行队列中等待。
>
> **S（中断）**：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。
>
> **D（不可中断）**：进程不响应系统异步信号，即便用kill命令也不能将其中断。
>
> **Z（僵死）**：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。
>
> **T（停止）**：进程收到停止信号后停止运行。

除了上面5种常见的进程状态，还有可能是高优先级（<）、低优先级（N）、被锁进内存（L）、包含子进程（s）以及多线程（l）这5种补充形式。

当执行ps aux命令后通常会看到如表2-8所示的进程状态。表2-8只是列举了部分输出值，而且正常的输出值中不包括中文注释。

表2-8                              进程状态

| USER         | PID      | %CPU             | %MEM       | VSZ                      | RSS                        | TTY      | STAT     | START        | TIME              | COMMAND                                                      |
| ------------ | -------- | ---------------- | ---------- | ------------------------ | -------------------------- | -------- | -------- | ------------ | ----------------- | ------------------------------------------------------------ |
| 进程的所有者 | 进程ID号 | 运算器占用率     | 内存占用率 | 虚拟内存使用量(单位是KB) | 占用的固定内存量(单位是KB) | 所在终端 | 进程状态 | 被启动的时间 | 实际使用CPU的时间 | 命令名称与参数                                               |
| root         | 1        | 0.0              | 0.5        | 244740                   | 10636                      | ?        | Ss       | 07:54        | 0:02              | /usr/lib/systemd/  systemd --switched-root --system --deserialize 18 |
| root         | 2        | 0.0              | 0.0        | 0                        | 0                          | ?        | S        | 07:54        | 0:00              | [kthreadd]                                                   |
| root         | 3        | 0.0              | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [rcu_gp]                                                     |
| root         | 4        | 0.0              | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [rcu_par_gp]                                                 |
| root         | 5        | 0.0              | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [kworker/0:0H-kbl                                            |
| root         | 6        | 0.0              | 0.0        | 0                        | 0                          | ?        | I<       | 07:54        | 0:00              | [mm_percpu_wq]                                               |
| root         | 7        | 0.0              | 0.0        | 0                        | 0                          | ?        | S        | 07:54        | 0:00              | [ksoftirqd/0]                                                |
| root         | 8        | 0.0              | 0.0        | 0                        | 0                          | ?        | I        | 07:54        | 0:00              | [rcu_sched]                                                  |
| root         | 9        | 0.0              | 0.0        | 0                        | 0                          | ?        | S        | 07:54        | 0:00              | [migration/0]                                                |
|              | ………………   | 省略部分输出信息 | ………………     |                          |                            |          |          |              |                   |                                                              |



### **Tips**

如前面所提到的，在Linux系统中的命令参数有长短格式之分，长格式和长格式之间不能合并，长格式和短格式之间也不能合并，但短格式和短格式之间是可以合并的，合并后仅保留一个减号（-）即可。另外ps命令可允许参数不加减号（-），因此可直接写成ps aux的样子。

**8．pstree命令**

pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”，输入该命令后按回车键执行即可。

前文提到，在执行ps命令后，产生的信息量太大又没有规律，很难让人再想看第二眼。如果想让进程以树状图的形式，有层次地展示出进程之间的关系，则可以使用pstree命令：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/pstree.png)

```
[root@linuxprobe ~]# pstree
systemd─┬─ModemManager───2*[{ModemManager}]
├─NetworkManager───2*[{NetworkManager}]
├─VGAuthService
├─accounts-daemon───2*[{accounts-daemon}]
├─atd
├─auditd─┬─sedispatch
│ └─2*[{auditd}]
├─avahi-daemon───avahi-daemon
├─boltd───2*[{boltd}]
├─colord───2*[{colord}]
├─crond
├─cupsd
├─dbus-daemon───{dbus-daemon}
├─dnsmasq───dnsmasq
├─firewalld───{firewalld}
├─fprintd───{fprintd}
├─fwupd───4*[{fwupd}]
………………省略部分输出信息………………
```

**9．top命令**

top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。

前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。top是相当好用的性能分析工具，该命令的运行界面如图2-6所示。

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/top命令-1024x648.png)

图2-6 top命令的运行界面

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/top-1.png)

在图2-6中，top命令执行结果的前5行为系统整体的统计信息，其所代表的含义如下。

> 第1行：系统时间、运行时间、登录终端数、系统负载（3个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。
>
> 第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。
>
> 第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“99.9 id”意味着有99.9%的CPU处理器资源处于空闲。
>
> 第4行：物理内存总量、内存空闲量、内存使用量、作为内核缓存的内存量。
>
> 第5行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。

**10．nice命令**

nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。

在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。例如将bash服务的优先级调整到最高：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/nice.png)

```
[root@linuxprobe ~]# nice -n -20 bash
[root@linuxprobe ~]#
```

**11．pidof命令**

pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。

每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。例如，执行如下命令来查询本机上sshd服务程序的PID：

```
[root@linuxprobe ~]# pidof sshd
2156
```

**12．kill命令**

kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。

接下来，使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务。

```
[root@linuxprobe ~]# kill 2156
```

但有时系统会提示进程无法被终止，此时可以加参数-9，表示最高级别地强制杀死进程：

```
[root@linuxprobe ~]# kill -9 2156
```

**13．killall命令**

killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。

通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果用kill命令逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程。由于RHEL 8系统默认没有安装httpd服务程序，因此大家此时只需看操作过程和输出结果即可，等学习了相关内容之后再来实践。![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/pidof.png)

```
[root@linuxprobe ~]# pidof httpd
13581 13580 13579 13578 13577 13576
[root@linuxprobe ~]# killall httpd
[root@linuxprobe ~]# pidof httpd
[root@linuxprobe ~]# 
```

如果在系统终端中执行一个命令后想立即停止它，可以同时按下Ctrl +  C组合键（生产环境中比较常用的一个组合键），这样将立即终止该命令的进程。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加一个&符号，这样命令将进入系统后台来执行。

很多同学在报名培训课程时会提到自己的英语基础不好，其实大可不必担心，因为咱们的书籍、培训课程甚至红帽考题都是中文的。而接下来您也就会发现，原来一直使用的是Linux命令，而绝不是纯粹的英语单词，即便它们的拼写100%相同，最终用处肯定也是不一样的。因此在学习Linux系统技术的这件事上，跟英语达人绝对都是站在同一起跑线上的，更何况还正确的选择了一本适合您的Linux教材，放心开始学习吧！

刘遄老师主讲的Linux技术培训课程介绍：https://www.linuxprobe.com/training

##### **2.4 系统状态检测命令**

作为一名合格的运维人员，要想更快、更好地了解Linux服务器，必须具备快速查看系统运行状态的能力，因此接下来会逐个讲解与网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法。这些命令都超级实用，还请读者用心学习，加以掌握。

**1．ifconfig命令**

ifconfig命令用于获取网卡配置与网络状态等信息，英文全称为“interface config”，语法格式为“ifconfig [参数] [网络设备]”。

使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/ifconfig.png)

```
[root@linuxprobe ~]# ifconfig
ens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.10.10  netmask 255.255.255.0  broadcast 192.168.10.255
        inet6 fe80::c8f8:f5c5:8251:aeaa  prefixlen 64  scopeid 0x20
        ether 00:0c:29:7d:27:bf  txqueuelen 1000  (Ethernet)
        RX packets 304  bytes 33283 (32.5 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 91  bytes 11052 (10.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 376  bytes 31784 (31.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 376  bytes 31784 (31.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether 52:54:00:a2:89:54  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

**2．uname命令**

uname命令用于查看系统内核版本与系统架构等信息，英文全称为“unix name”，语法格式为“uname [-a]”。

在使用uname命令时，一般要固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、压制时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息：

```
[root@linuxprobe ~]# uname -a
Linux linuxprobe.com 4.18.0-80.el8.x86_64 #1 SMP Wed Mar 13 12:02:46 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下：

```
[root@linuxprobe ~]# cat /etc/redhat-release
Red Hat Enterprise Linux release 8.0 (Ootpa)
```

**3．uptime命令**

uptime命令用于查看系统的负载信息，输入该命令后按回车键执行即可。

uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分），负载值越低越好：

```
[root@linuxprobe ~]# uptime
22:49:55 up 10 min, 1 users, load average: 0.01, 0.19, 0.18
```

### **Tips**

“负载值越低越好”是对运维人员来讲的，越低表示越安全省心。但是公司购置的硬件设备如果长期处于空闲状态，则明显是种资源浪费，老板也不会开心。所以建议负载值保持在1左右，在生产环境中不要超过5就好。

**4．free命令**

free命令用于显示当前系统中内存的使用量信息，语法格式为“free [-h]”。

为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。表2-9所示为在刘遄老师的电脑上执行free -h命令之后的输出信息。需要注意的是，输出信息中的中文注释是作者自行添加的内容，实际输出时没有相应的参数解释。![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/free.png)

```
[root@linuxprobe ~]# free -h
```

表2-9                      执行free -h命令后的输出信息

|       | 内存总量 | 已用量 | 空闲量 | 进程共享的内存量 | 磁盘缓存的内存量 | 缓存的内存量 | 可用量    |
| ----- | -------- | ------ | ------ | ---------------- | ---------------- | ------------ | --------- |
|       | total    | used   | free   | shared           | buffers          | buff/cache   | available |
| Mem:  | 1.9Gi    | 1.4Gi  | 99Mi   | 20Mi             | 450Mi            | 348Mi        |           |
| Swap: | 2.0Gi    | 80Mi   | 1.9Gi  |                  |                  |              |           |



如果不使用-h（易读模式）查看内存使用量情况，则默认以KB为单位。这样一来，服务器如果有几百GB的内存，则换算下来就会是一大长串的数字，真不利于阅读。

**5．who命令**

who命令用于查看当前登入主机的用户终端信息，输入该命令后按回车键执行即可。

这3个简单的字母可以快速显示出所有正在登录本机的用户名称以及他们正在开启的终端信息；如果有远程用户，还会显示出来访者的IP地址。表2-10所示为执行who命令后的结果。

```
[root@linuxprobe ~]# who
```

表2-10                     执行who命令的结果

| 登陆的用户名 | 终端设备 | 登陆到系统的时间        |
| ------------ | -------- | ----------------------- |
| root         | tty2     | 2020-07-24 06:26 (tty2) |



**6．last命令**

last命令用于调取主机的被访记录，输入该命令后按回车键执行即可。

Linux系统会将每次的登录信息都记录到日志文件中，如果哪天想翻阅了，直接执行这条命令就行：

```
[root@linuxprobe ~]# last
root     pts/1        192.168.10.1     Tue May 18 10:30 - 11:03  (00:32)
root     tty2         tty2             Fri Jul 24 06:26    gone - no logout
reboot   system boot  4.18.0-80.el8.x8 Fri Jul 24 05:59   still running
root     tty2         tty2             Tue Jul 21 05:19 - down   (00:00)
reboot   system boot  4.18.0-80.el8.x8 Tue Jul 21 05:16 - 05:19  (00:02)

wtmp begins Tue Jul 21 05:16:47 2020
```

**7．ping命令**

ping命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。

即便大家没有学习过Linux系统，相信也肯定见过别人使用ping命令。执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。由此可见，ping命令可用于判断远端主机是否在线并且网络是否正常。ping命令的常见参数以及作用如表2-11所示。

表2-11                         ping命令中的参数以及作用

| 参数 | 作用               |
| ---- | ------------------ |
| -c   | 总共发送次数       |
| -l   | 指定网卡名称       |
| -i   | 每次间隔时间（秒） |
| -W   | 最长等待时间（秒） |


 ![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/ping.png)

我们使用ping命令测试一台在线的主机（其IP地址为192.168.10.10），得到的回应是这样的：

```
[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.155 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.110 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.112 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.209 ms

--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 56ms
rtt min/avg/max/mdev = 0.110/0.146/0.209/0.042 ms
```

测试一台不在线的主机（其IP地址为192.168.10.20），得到的回应是这样的：

```
[root@linuxprobe ~]# ping -c 4 192.168.10.20
PING 192.168.10.20 (192.168.10.20) 56(84) bytes of data.
From 192.168.10.10 icmp_seq=1 Destination Host Unreachable
From 192.168.10.10 icmp_seq=2 Destination Host Unreachable
From 192.168.10.10 icmp_seq=3 Destination Host Unreachable
From 192.168.10.10 icmp_seq=4 Destination Host Unreachable

--- 192.168.10.20 ping statistics ---
4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 68ms
pipe 4
```

**8．tracepath命令**

tracepath命令用于显示数据包到达目的主机时途中经过的所有路由信息，语法格式为“tracepath [参数] 域名”。

当两台主机之间无法正常ping通时，要考虑两台主机之间是否有错误的路由信息，导致数据被某一台设备错误地丢弃。这时便可以使用tracepath命令追踪数据包到达目的主机时途中的所有路由信息，以分析是哪台设备出了问题。下面的情况就很清晰了：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/tracepath.png)

```
[root@linuxprobe ~]# tracepath www.linuxprobe.com
 1?: [LOCALHOST]                                          pmtu 1500
 1:  no reply
 2:  11.223.0.189                                          5.954ms asymm  1 
 3:  11.223.0.14                                           6.256ms asymm  2 
 4:  11.220.159.62                                         3.313ms asymm  3 
 5:  116.251.107.13                                        1.841ms 
 6:  140.205.50.237                                        2.416ms asymm  5 
 7:  101.95.211.117                                        2.772ms 
 8:  101.95.208.45                                        40.839ms 
 9:  101.95.218.217                                       13.898ms asymm  8 
10:  202.97.81.162                                         8.113ms asymm  9 
11:  221.229.193.238                                      15.693ms asymm 10 
12:  no reply
13:  no reply
14:  no reply
15:  no reply
16:  no reply
17:  no reply
18:  no reply
………………省略部分输出信息………………
```

**9．netstat命令**

netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。

只要netstat命令使用得当，便可以查看到网络状态的方方面面信息。我们找出一些常用的参数让大家感受一下。netstat命令的常见参数以及作用如表2-12所示。

表2-12                         netstat命令中的参数以及作用

| -a   | 显示所有连接中的Socket   |
| ---- | ------------------------ |
| -p   | 显示正在使用的Socket信息 |
| -t   | 显示TCP协议的连接状态    |
| -u   | 显示UDP协议的连接状态    |
| -n   | 使用IP地址，不使用域名   |
| -l   | 仅列出正在监听的服务状态 |
| -i   | 显示网卡列表信息         |
| -r   | 显示路由表信息           |


 ![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/netstat.png)

使用netstat命令显示详细的网络状况：

```
[root@linuxprobe ~]# netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN     
tcp        0      0 localhost:ipp           0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:sunrpc          0.0.0.0:*               LISTEN     
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN     
tcp6       0      0 localhost:ipp           [::]:*                  LISTEN     
tcp6       0      0 [::]:sunrpc             [::]:*                  LISTEN     
udp        0      0 0.0.0.0:bootps          0.0.0.0:*                          
udp        0      0 0.0.0.0:sunrpc          0.0.0.0:*                          
udp        0      0 0.0.0.0:mdns            0.0.0.0:*                          
udp        0      0 0.0.0.0:37396           0.0.0.0:*                          
udp6       0      0 [::]:sunrpc             [::]:*                             
udp6       0      0 [::]:mdns               [::]:*                             
udp6       0      0 [::]:38541              [::]:*       
………………省略部分输出信息………………     
```

使用netstat命令显示网卡列表：

```
[root@linuxrpobe ~]# netstat -i 
Kernel Interface table
Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
ens160           1500       70      0      0 0            79      0      0      0 BMRU
lo              65536      248      0      0 0           248      0      0      0 LRU
virbr0           1500        0      0      0 0             0      0      0      0 BMU
```

**10．history命令**

history命令用于显示执行过的命令历史，语法格式为“history [-c]”。

history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。总之，history命令有很多有趣的玩法等待您去开发。

```
[root@linuxprobe ~]# history
1 ifconfig
2 uname -a
3 cat /etc/redhat-release
4 uptime
5 free -h
6 who
7 last
8 ping -c 192.168.10.10
9 ping -c 192.168.10.20
10 tracepath www.linuxprobe.com
11 netstat -a
12 netstat -i
13 history
[root@linuxprobe ~]# !3
cat /etc/redhat-release
Red Hat Enterprise Linux release 8.0 (Ootpa)
```

历史命令会被保存到用户家目录中的.bash_history文件中。Linux系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用cat命令查看其文件内容：

```
[root@linuxprobe ~]# cat ~/.bash_history
```

要清空当前用户在本机上执行的Linux命令历史记录信息，可执行如下命令：

```
[root@linuxprobe ~]# history -c
```

**11．sosreport命令**

sosreport命令用于收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可。

当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，抑或让他们能提前了解某些复杂问题。在下面的输出信息中，加粗的部分是收集好的资料压缩文件以及校验码，将其发送给技术支持人员即可：

```
[root@linuxprobe ~]# sosreport
sosreport (version 3.6)
This command will collect diagnostic and configuration information from
this Red Hat Enterprise Linux system and installed applications.

An archive containing the collected information will be generated in
/var/tmp/sos.9_i0glu8 and may be provided to a Red Hat support
representative.

Any information provided to Red Hat will be treated in accordance with
the published support policies at:
https://access.redhat.com/support/
The generated archive may contain data considered sensitive and its
content should be reviewed by the originating organization before being
passed to any third party.

No changes will be made to system configuration.
Press ENTER to continue, or CTRL-C to quit.
此处按下回车键进行确认
Please enter the case id that you are generating this report for []:此处按下回车键进行确认
Setting up archive ...
Setting up plugins ...
Running plugins. Please wait ...
………………省略部分输出信息………………
Finished running plugins 
Creating compressed archive...

Your sosreport has been generated and saved in:
/var/tmp/sosreport-linuxprobe.com-2021-05-18-jnkaspu.tar.xz

The checksum is: 9fbecbd167b7e5836db1ff8f068c4db3
Please send this file to your support representative.
```

### **Tips**

sosreport命令有点像是远程问诊。假如我们今天有点咳嗽发烧不舒服，可以先从网上搜索相关症状的病因，如果仅仅是感冒的话那就多喝水，这就免去了到医院挂号看病的车马劳顿；而如果怀疑出了大毛病，再请专业人员进行处理也不迟。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

##### **2.5 查找定位文件命令**

工作目录指的是用户当前在系统中所处的位置。由于工作目录会牵涉系统存储结构相关的知识，因此第6章将详细讲解这部分内容。读者只需简单了解一下这里的操作实验即可，如果不能完全掌握也没有关系，毕竟Linux系统的知识体系太过庞大，每一位初学人员都需要经历这么一段时期。

**1．pwd命令**

pwd命令用于显示用户当前所处的工作目录，英文全称为“print working directory”，输入该命令后按回车键执行即可。

使用pwd命令查看当前所处的工作目录：

```
[root@linuxprobe etc]# pwd
/etc
```

**2．cd命令**

cd命令用于切换当前的工作路径，英文全称为“change directory”，语法格式为“cd [参数] [目录]”。

这个命令应该是最常用的一个Linux命令了。可以通过cd命令迅速、灵活地切换到不同的工作目录。除了常见的切换目录方式，还可以使用“cd  -”命令返回到上一次所处的目录，使用“cd..”命令进入上级目录，以及使用“cd～”命令切换到当前用户的家目录，抑或使用“cd～username”命令切换到其他用户的家目录（就像在游戏中使用了“回城”技能一样）。例如，使用下述的cd命令切换进/etc目录中：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/cd.png)

```
[root@linuxprobe ~]# cd /etc
```

同样的道理，可使用下述命令切换到/bin目录中：

```
[root@linuxprobe etc]# cd /bin
```

此时，要返回到上一次的目录（即/etc目录），可执行如下命令：

```
[root@linuxprobe bin]# cd -
/etc
[root@linuxprobe etc]#
```

还可以通过下面的命令快速切换到用户的家目录：

```
[root@linuxprobe etc]# cd ~
[root@linuxprobe ~]#
```

### **Tips**

随着切换目录的操作，命令提示符也在发生变化，例如[root@linuxprobe etc]#就是在告诉我们当前处于/etc中。

**3．ls命令**

ls命令用于显示目录中的文件信息，英文全称为“list”，语法格式为“ls [参数] [文件名称]”。

所处的工作目录不同，当前工作目录下能看到的文件肯定也不同。使用ls命令的-a参数可以看到全部文件（包括隐藏文件），使用-l参数可以查看文件的属性、大小等详细信息。将这两个参数整合之后，再执行ls命令即可查看当前目录中的所有文件并输出这些文件的属性信息：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/ls.png)

```
[root@linuxprobe ~]# ls -al
total 48
dr-xr-x---. 15 root root 4096 Jul 24 06:33 .
dr-xr-xr-x. 17 root root  224 Jul 21 05:04 ..
-rw-------.  1 root root 1407 Jul 21 05:09 anaconda-ks.cfg
-rw-------.  1 root root  335 Jul 24 06:33 .bash_history
-rw-r--r--.  1 root root   18 Aug 13  2018 .bash_logout
-rw-r--r--.  1 root root  176 Aug 13  2018 .bash_profile
-rw-r--r--.  1 root root  176 Aug 13  2018 .bashrc
drwx------. 10 root root  230 Jul 21 05:19 .cache
drwx------. 11 root root  215 Jul 24 06:27 .config
-rw-r--r--.  1 root root  100 Aug 13  2018 .cshrc
drwx------.  3 root root   25 Jul 21 05:16 .dbus
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Desktop
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Documents
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Downloads
-rw-------.  1 root root   16 Jul 21 05:19 .esd_auth
-rw-------.  1 root root  620 Jul 24 06:26 .ICEauthority
-rw-r--r--.  1 root root 1562 Jul 21 05:18 initial-setup-ks.cfg
drwx------.  3 root root   19 Jul 21 05:19 .local
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Music
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Pictures
drwxr-----.  3 root root   19 Jul 21 05:19 .pki
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Public
-rw-r--r--.  1 root root  129 Aug 13  2018 .tcshrc
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Templates
drwxr-xr-x.  2 root root    6 Jul 21 05:19 Videos
-rw-------.  1 root root 3235 Jul 24 06:32 .viminfo
```

如果想要查看目录属性信息，则需要额外添加一个-d参数。例如，可使用如下命令查看/etc目录的权限与属性信息：

```
[root@linuxprobe ~]# ls -ld /etc
drwxr-xr-x. 132 root root 8192 Jul 10 10:48 /etc
```

**4．tree命令**

tree命令用于以树状图的形式列出目录内容及结构，输入该命令后按回车键执行即可。

虽然ls命令可以很便捷地查看目录内有哪些文件，但无法直观地获取到目录内文件的层次结构。比如，假如目录A中有个B，B中又有个C，那么ls命令就只能看到最外面的A目录，显然有些时候这不太够用。tree命令则能够以树状图的形式列出目录内所有文件的结构。

我们来对比一下两者的区别。

使用ls命令查看目录内的文件：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/tree.png)

```
[root@linuxprobe ~]# ls
A                Desktop    Downloads             Music     Public     Videos
anaconda-ks.cfg  Documents  initial-setup-ks.cfg  Pictures  Templates
```

使用tree命令查看目录内文件名称以及结构：

```
[root@linuxprobe ~]# tree
.
├── A
│   └── B
│       └── C
├── anaconda-ks.cfg
├── Desktop
├── Documents
├── Downloads
├── initial-setup-ks.cfg
├── Music
├── Pictures
├── Public
├── Templates
└── Videos
```

**5．find命令**

find命令用于按照指定条件来查找文件所对应的位置，语法格式为“find [查找范围] 寻找条件”。

本书中会多次提到“Linux系统中的一切都是文件”，接下来就要见证这句话的分量了。在Linux系统中，搜索工作一般都是通过find命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。find命令的参数以及作用如表2-13所示。

表2-13                       find命令中的参数以及作用

| 参数              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名称                                                     |
| -perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| -atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| -ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| -nouser           | 匹配无所有者的文件                                           |
| -nogroup          | 匹配无所有组的文件                                           |
| -newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune            | 忽略某个目录                                                 |
| -exec …… {}\;     | 后面可跟用于进一步处理搜索结果的命令（下文会有演示）         |



这里需要重点讲解-exec参数的重要作用。这个参数用于把find命令搜索到的结果交由紧随其后的命令作进一步处理。它十分类似于第3章将要讲解的管道符技术，并且由于find命令对参数有特殊要求，因此虽然exec是长格式形式，但它的前面依然只需要一个减号（-）。

根据文件系统层次标准（Filesystem Hierarchy Standard）协议，Linux系统中的配置文件会保存到/etc目录中（详见第6章）。如果要想获取该目录中所有以host开头的文件列表，可以执行如下命令：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/find.png)

```
[root@linuxprobe ~]# find /etc -name "host*" -print
/etc/host.conf
/etc/hosts
/etc/hosts.allow
/etc/hosts.deny
/etc/avahi/hosts
/etc/hostname
```

如果要在整个系统中搜索权限中包括SUID权限的所有文件（详见第5章），只需使用-4000即可：

```
[root@linuxprobe ~]# find / -perm -4000 -print
/usr/bin/fusermount
/usr/bin/chage
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/umount
/usr/bin/mount
/usr/bin/su
/usr/bin/pkexec
/usr/bin/crontab
/usr/bin/passwd
………………省略部分输出信息………………
```

> 进阶实验：
>
> 在整个文件系统中找出所有归属于linuxprobe用户的文件并复制到/root/findresults目录中。
>  该实验的重点是“-exec {} \;”参数，其中的{}表示find命令搜索出的每一个文件，并且命令的结尾必须是“\;”。完成该实验的具体命令如下：
>
> [root@linuxprobe ~]# find / -user linuxprobe -exec cp -a {} /root/findresults/ \;

**6．locate命令**

locate命令用于按照名称快速搜索文件所对应的位置，语法格式为“locate文件名称”。

使用find命令进行全盘搜索虽然更准确，但是效率有点低。如果仅仅是想找一些常见的且又知道大概名称的文件，不如试试locate命令。在使用locate命令时，先使用updatedb命令生成一个索引库文件，这个库文件的名字是/var/lib/mlocate/mlocate.db，后续在使用locate命令搜索文件时就是在该库中进行查找操作，速度会快很多。

第一次使用locate命令之前，记得先执行updatedb命令来生成索引数据库，然后再进行查找：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/locate.png)

```
[root@linuxprobe ~]# updatedb 
[root@linuxprobe ~]# ls -l /var/lib/mlocate/mlocate.db
-rw-r-----. 1 root slocate 2945917 Sep 13 17:54 /var/lib/mlocate/mlocate.db
```

使用locate命令搜索出所有包含“whereis”名称的文件所在的位置：

```
[root@linuxprobe ~]# locate whereis
/usr/bin/whereis
/usr/share/bash-completion/completions/whereis
/usr/share/man/man1/whereis.1.gz
```

**7．whereis命令**

whereis命令用于按照名称快速搜索二进制程序（命令）、源代码以及帮助文件所对应的位置，语法格式为“whereis命令名称”。

简单来说，whereis命令也是基于updatedb命令所生成的索引库文件进行搜索，它与locate命令的区别是不关心那些相同名称的文件，仅仅是快速找到对应的命令文件及其帮助文件所在的位置。

下面使用whereis命令分别查找出ls和pwd命令所在的位置：

```
[root@linuxprobe ~]# whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
[root@linuxprobe ~]# whereis pwd
pwd: /usr/bin/pwd /usr/share/man/man1/pwd.1.gz /usr/share/man/man1p/pwd.1p.gz
```

**8．which命令**

which命令用于按照指定名称快速搜索二进制程序（命令）所对应的位置，语法格式为“which命令名称”。

which命令是在PATH变量所指定的路径中，按照指定条件搜索命令所在的路径。也就是说，如果我们既不关心同名文件（find与locate），也不关心命令所对应的源代码和帮助文件（whereis），仅仅是想找到命令本身所在的路径，那么这个which命令就太合适了。下面查找一下locate和whereis命令所对应的路径：

```
[root@linuxprobe ~]# which locate
/usr/bin/locate
[root@linuxprobe ~]# which whereis
/usr/bin/whereis
```

##### **2.6 文本文件编辑命令**

通过前面几个小节的学习，读者应该已经掌握了切换工作目录及对文件的管理方法。在Linux系统中，一切都是文件，对服务程序进行配置自然也就是编辑程序的配置文件。如果不能熟练地查阅系统或服务的配置文件，那以后工作时可就真的要尴尬了。本节将讲解几条用于查看文本文件内容的命令。至于相对比较复杂的文本编辑器工具，将在第4章与Shell脚本一起讲解。

**1．cat命令**

cat命令用于查看纯文本文件（内容较少的），英文全称为“concatenate”，语法格式为“cat [参数] 文件名称”。

Linux系统中有多个用于查看文本内容的命令，每个命令都有自己的特点，比如这个cat命令就是用于查看内容较少的纯文本文件。cat这个命令也很好记，因为cat在英语中是“猫”的意思，小猫咪是不是给您一种娇小、可爱的感觉呢？![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/cat.png)

如果在查看文本内容时还想顺便显示行号的话，不妨在cat命令后面追加一个-n参数：

```
[root@linuxprobe ~]# cat -n initial-setup-ks.cfg 
     1	#version=RHEL8
     2	# X Window System configuration information
     3	xconfig  --startxonboot
     4	# License agreement
     5	eula --agreed
     6	# Use graphical install
     7	graphical
     8	# Network information
     9	network  --bootproto=dhcp --device=ens160 --onboot=off --ipv6=auto --no-activate
    10	network  --bootproto=dhcp --hostname=localhost.localdomain
    11	repo --name="AppStream" --baseurl=file:///run/install/repo/AppStream
    12	ignoredisk --only-use=sda
    13	# Use CDROM installation media
    14	cdrom
    15	# Run the Setup Agent on first boot
    16	firstboot --enable
    17	# System services
………………省略部分输出信息………………
```

**2．more命令**

more命令用于查看纯文本文件（内容较多的），语法格式为“more [参数] 文件名称”。

如果需要阅读长篇小说或者非常长的配置文件，那么“小猫咪”可就真的不适合了。因为一旦使用cat命令阅读长篇的文本内容，信息就会在屏幕上快速翻滚，导致自己还没有来得及看到，内容就已经翻篇了。因此对于长篇的文本内容，推荐使用more命令来查看。more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容；还可以使用空格键或回车键向下翻页：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/more.png)

```
[root@linuxprobe ~]# more initial-setup-ks.cfg 
#version=RHEL8
# X Window System configuration information
xconfig  --startxonboot
# License agreement
eula --agreed
# Use graphical install
graphical
# Network information
network  --bootproto=dhcp --device=ens160 --onboot=off --ipv6=auto --no-activate
network  --bootproto=dhcp --hostname=localhost.localdomain
repo --name="AppStream" --baseurl=file:///run/install/repo/AppStream
ignoredisk --only-use=sda
# Use CDROM installation media
cdrom
# Run the Setup Agent on first boot
firstboot --enable
# System services
services --disabled="chronyd"
# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8
--More--(41%)
```

**3．head命令**

head命令用于查看纯文本文件的前*N*行，语法格式为“head [参数] 文件名称”。

在阅读文本内容时，谁也难以保证会按照从头到尾的顺序往下看完整个文件。如果只想查看文本中前10行的内容，该怎么办呢？head命令就能派上用场了：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/head.png)

```
[root@linuxprobe ~]# head -n 10 initial-setup-ks.cfg 
#version=RHEL8
# X Window System configuration information
xconfig --startxonboot
# License agreement
eula --agreed
# Use graphical install
graphical
# Network information
network --bootproto=dhcp --device=ens160 --onboot=off --ipv6=auto --no-activate
network --bootproto=dhcp --hostname=localhost.localdomain
```

**4．tail命令**

tail命令用于查看纯文本文件的后*N*行或持续刷新文件的最新内容，语法格式为“tail [参数] 文件名称”。

我们可能还会遇到另外一种情况，比如需要查看文本内容的最后10行，这时就需要用到tail命令了。tail命令的操作方法与head命令非常相似，只需要执行“tail -n 20文件名称”命令就可以达到这样的效果：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/tail.png)

```
[root@linuxprobe ~]# tail -n 10 initial-setup-ks.cfg 
%addon com_redhat_subscription_manager 
%end
%addon ADDON_placeholder --disable --reserve-mb=auto
%end

%anaconda
pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
%end
```

tail命令最强悍的功能是能够持续刷新一个文件的内容，当想要实时查看最新的日志文件时，这特别有用，此时的命令格式为“tail -f文件名称”：

```
[root@linuxprobe ~]# tail -f /var/log/messages
Sep 15 00:14:01 localhost rsyslogd[1392]: imjournal: sd_journal_get_cursor() failed: Cannot assign requested address [v8.37.0-9.el8]
Sep 15 00:14:01 localhost rsyslogd[1392]: imjournal: journal reloaded... [v8.37.0-9.el8 try http://www.rsyslog.com/e/0 ]
Sep 15 00:14:01 localhost systemd[1]: Started update of the root trust anchor for DNSSEC validation in unbound.
Sep 15 00:14:01 localhost sssd[kcm][2764]: Shutting down
Sep 15 00:14:06 localhost systemd[1]: Starting SSSD Kerberos Cache Manager...
Sep 15 00:14:06 localhost systemd[1]: Started SSSD Kerberos Cache Manager.
Sep 15 00:14:06 localhost sssd[kcm][3989]: Starting up
Sep 15 00:14:26 localhost NetworkManager[1203]: <info> [1600100066.4675] audit: op="sleep-control" arg="off" pid=3990 uid=0 result="fail" reason="Already awake"
Sep 15 00:19:04 localhost org.gnome.Shell.desktop[2600]: Window manager warning: last_user_time (2361102) is greater than comparison timestamp (2361091). This most likely represents a buggy client sending inaccurate timestamps in messages such as _NET_ACTIVE_WINDOW. Trying to work around...
Sep 15 00:19:04 localhost org.gnome.Shell.desktop[2600]: Window manager warning: W14 (root@local) appears to be one of the offending windows with a timestamp of 2361102. Working around...
```

**5．tr命令**

tr命令用于替换文本内容中的字符，英文全称为“transform”，语法格式为“tr [原始字符] [目标字符]”。

在很多时候，我们想要快速地替换文本中的一些词汇，又或者想把整个文本内容都进行替换。如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符（详见第3章）把这些文本内容传递给tr命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/tr.png)

```
[root@linuxprobe ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z]
#VERSION=RHEL8
IGNOREDISK --ONLY-USE=SDA
AUTOPART --TYPE=LVM
# PARTITION CLEARING INFORMATION
CLEARPART --ALL --INITLABEL --DRIVES=SDA
# USE GRAPHICAL INSTALL
GRAPHICAL
REPO --NAME="APPSTREAM" --BASEURL=FILE:///RUN/INSTALL/REPO/APPSTREAM
# USE CDROM INSTALLATION MEDIA
CDROM
# KEYBOARD LAYOUTS
KEYBOARD --VCKEYMAP=US --XLAYOUTS='US'
# SYSTEM LANGUAGE
LANG EN_US.UTF-8
# NETWORK INFORMATION
NETWORK --BOOTPROTO=DHCP --DEVICE=ENS160 --ONBOOT=OFF --IPV6=AUTO --NO-ACTIVATE
NETWORK --HOSTNAME=LOCALHOST.LOCALDOMAIN
# ROOT PASSWORD
ROOTPW --ISCRYPTED $6$TTBUW5DKOPYQQ.VI$RMK9FCGHOJOQ2QAPRURTQM.QOK2NN3YFN/I4F/FALVGGGND9XOIYFBRXDN16WWIZIASJ0/CR06U66IPEOGLPJ.
# X WINDOW SYSTEM CONFIGURATION INFORMATION
XCONFIG --STARTXONBOOT
# RUN THE SETUP AGENT ON FIRST BOOT
FIRSTBOOT --ENABLE
# SYSTEM SERVICES
SERVICES --DISABLED="CHRONYD"
# SYSTEM TIMEZONE
TIMEZONE ASIA/SHANGHAI --ISUTC --NONTP
………………省略部分输出信息………………
```

**6．wc命令**

wc命令用于统计指定文本文件的行数、字数或字节数，英文全称为“word counts”，语法格式为“wc [参数] 文件名称”。

每次我在课堂上讲到这个命令时，总有同学会联想到一种公共设施，其实这两者毫无关联。wc命令用于统计文本的行数、字数、字节数等。如果为了方便自己记住这个命令的作用，也可以联想到上厕所时好无聊，无聊到数完了手中的如厕读物上有多少行字。

wc的参数以及相应的作用如表2-14所示。

表2-14                          wc命令中的参数以及作用

| 参数 | 作用         |
| ---- | ------------ |
| -l   | 只显示行数   |
| -w   | 只显示单词数 |
| -c   | 只显示字节数 |



在Linux系统中，/etc/passwd是用于保存所有用户信息的文件，要统计当前系统中有多少个用户，可以使用下面的命令来进行查询，是不是很神奇：

```
[root@linuxprobe ~]# wc -l /etc/passwd
45 /etc/passwd
```

**7．stat命令**

stat命令用于查看文件的具体存储细节和时间等信息，英文全称为“status”，语法格式为“stat文件名称”。

大家都知道，文件有一个修改时间。其实，除了修改时间之外，Linux系统中的文件包含3种时间状态，分别是Access  Time（内容最后一次被访问的时间，简称为Atime），Modify Time（内容最后一次被修改的时间，简称为Mtime）以及Change  Time（文件属性最后一次被修改的时间，简称为Ctime）。

下面使用state命令查看文件的这3种时间状态信息：

```
[root@linuxprobe ~]# stat anaconda-ks.cfg
  File: anaconda-ks.cfg
  Size: 1407      	Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d	Inode: 35321091    Links: 1
Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)
Context: system_u:object_r:admin_home_t:s0
Access: 2020-07-21 05:16:52.347279499 +0800
Modify: 2020-07-21 05:09:16.421009316 +0800
Change: 2020-07-21 05:09:16.421009316 +0800
 Birth: -
```

**8．grep命令**

grep命令用于按行提取文本内容，语法格式为“grep [参数] 文件名称”。

grep命令是用途最广泛的文本搜索匹配工具。它虽然有很多参数，但是大多数基本上都用不到。刘遄老师在总结了10多年的运维工作和培训教学的经验后，提出的本书的写作理念“去掉不实用的内容”绝对不是信口开河。如果一名IT培训讲师的水平只能停留在“技术的搬运工”层面，而不能对优质技术知识进行提炼总结，对他的学生来讲绝非好事。有鉴于此，我们在这里只讲grep命令两个最常用的参数：

> -n参数用来显示搜索到的信息的行号；
>
> -v参数用于反选信息（即没有包含关键词的所有信息行）。

这两个参数几乎能完成您日后80%的工作需要，至于其他上百个参数，即使以后在工作期间遇到了，再使用man grep命令查询也来得及。

grep命令的参数及其作用如表2-15所示。

表2-15                       grep命令中的参数及其作用

| 参数 | 作用                                           |
| ---- | ---------------------------------------------- |
| -b   | 将可执行文件(binary)当作文本文件（text）来搜索 |
| -c   | 仅显示找到的行数                               |
| -i   | 忽略大小写                                     |
| -n   | 显示行号                                       |
| -v   | 反向选择——仅列出没有“关键词”的行。             |



![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/grep.png)

在Linux系统中，/etc/passwd文件保存着所有的用户信息，而一旦用户的登录终端被设置成/sbin/nologin，则不再允许登录系统，因此可以使用grep命令查找出当前系统中不允许登录系统的所有用户的信息：

```
[root@linuxprobe ~]# grep /sbin/nologin /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
………………省略部分输出过程信息………………
```

**9．cut命令**

cut命令用于按“列”提取文本内容，语法格式为“cut [参数] 文件名称”。

系统文件在保存用户数据信息时，每一项值之间是采用冒号来间隔的，先查看一下：

```
[root@linuxprobe ~]# head -n 2 /etc/passwd 
root:x:0:0:root:/root:/bin/bash 
bin:x:1:1:bin:/bin:/sbin/nologin
```

一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按“列”搜索，不仅要使用-f参数设置需要查看的列数，还需要使用-d参数来设置间隔符号。

接下来使用下述命令尝试提取出passwd文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/cut.png)

```
[root@linuxprobe ~]# cut -d : -f 1 /etc/passwd
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
operator
games
ftp
nobody
dbus
………………省略部分输出信息………………
```

**10．diff命令**

diff命令用于比较多个文件之间内容的差异，英文全称为“different”，语法格式为“diff [参数] 文件名称A 文件名称B”。

在使用diff命令时，不仅可以使用--brief参数来确认两个文件是否相同，还可以使用-c参数来详细比较出多个文件的差异之处。这绝对是判断文件是否被篡改的有力神器。例如，先使用cat命令分别查看diff_A.txt和diff_B.txt文件的内容，然后进行比较：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/diff.png)

```
[root@linuxprobe ~]# cat diff_A.txt
Welcome to linuxprobe.com
Red Hat certified
Free Linux Lessons
Professional guidance
Linux Course
[root@linuxprobe ~]# cat diff_B.txt
Welcome tooo linuxprobe.com

Red Hat certified
Free Linux LeSSonS
////////.....////////
Professional guidance
Linux Course
```

接下来使用diff --brief命令显示比较后的结果，判断文件是否相同：

```
[root@linuxprobe ~]# diff --brief diff_A.txt diff_B.txt
Files diff_A.txt and diff_B.txt differ
```

最后使用带有-c参数的diff命令来描述文件内容具体的不同：

```
[root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt
*** diff_A.txt 2020-08-30 18:07:45.230864626 +0800
--- diff_B.txt 2020-08-30 18:08:52.203860389 +0800
***************
*** 1,5 ****
! Welcome to linuxprobe.com
Red Hat certified
! Free Linux Lessons
Professional guidance
Linux Course
--- 1,7 ----
! Welcome tooo linuxprobe.com
!
Red Hat certified
! Free Linux LeSSonS
! ////////.....////////
Professional guidance
Linux Course
```

**11．uniq命令**

uniq命令用于去除文本中连续的重复行，英文全称为“unique”，语法格式为“uniq [参数] 文件名称”。

由uniq命令的英文全称unique（独特的，唯一的）可知，该命令的作用是用来去除文本文件中连续的重复行，中间不能夹杂其他文本行（非相邻的默认不会去重）—去除了重复的，保留的都是唯一的，自然也就是“独特的”“唯一的”了。

我们使用uniq命令对两个文本内容进行操作，区别一目了然：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/uniq.png)

```
[root@linuxprobe ~]# cat uniq.txt 
Welcome to linuxprobe.com
Welcome to linuxprobe.com
Welcome to linuxprobe.com
Welcome to linuxprobe.com
Red Hat certified
Free Linux Lessons
Professional guidance
Linux Course
[root@linuxprobe ~]# uniq uniq.txt 
Welcome to linuxprobe.com
Red Hat certified
Free Linux Lessons
Professional guidance
Linux Course
```

**12．sort命令**

sort命令用于对文本内容进行再排序，语法格式为“sort [参数] 文件名称”。

有时文本中的内容顺序不正确，一行行地手动修改实在太麻烦了。此时使用sort命令就再合适不过了，它能够对文本内容进行再次排序。这个命令千万不能只讲理论，一定要借助于实战让大家一看就懂。sort命令的参数及其作用如表2-16所示。

表2-16                       sort命令中的参数及其作用

| 参数 | 作用           |
| ---- | -------------- |
| -f   | 忽略大小写     |
| -b   | 忽略缩进与空格 |
| -n   | 以数值型排序   |
| -r   | 反向排序       |
| -u   | 去除重复行     |
| -t   | 指定间隔符     |
| -k   | 设置字段范围   |



首先，在执行sort命令后默认会按照字母顺序进行排序，非常方便：

![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/uniq.png)

```
[root@linuxprobe ~]# cat fruit.txt 
banana
pear
apple
orange
raspaberry
[root@linuxprobe ~]# sort fruit.txt 
apple
banana
orange
pear
raspaberry
```

此外，与uniq命令不同，sort命令是无论内容行之间是否夹杂有其他内容，只要有两个一模一样的内容行，立马就可以使用-u参数进行去重操作：

```
[root@linuxprobe ~]# cat sort.txt 
Welcome to linuxprobe.com
Red Hat certified
Welcome to linuxprobe.com
Free Linux Lessons
Linux Course
[root@linuxprobe ~]# sort -u sort.txt 
Free Linux Lessons
Linux Course
Red Hat certified
Welcome to linuxprobe.com
```

想对数字进行排序？一点问题都没有，而且完全不用担心出现1大于20这种问题（因为有些命令只比较数字的第一位，忽略了十、百、千的位）：

```
[root@linuxprobe ~]# cat number.txt 
45
12
3
98
82
67
24
56
9
[root@linuxprobe ~]# sort -n number.txt 
3
9
12
24
45
56
67
82
98
```

最后，我们挑战一个“高难度”的小实验。下面的内容节选自/etc/passwd文件中的前5个字段，并且进行了混乱排序。

```
[root@linuxprobe ~]# cat user.txt 
tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon
polkitd:x:998:996:User for polkitd
geoclue:x:997:995:User for geoclue
rtkit:x:172:172:RealtimeKit
pulse:x:171:171:PulseAudio System Daemon
qemu:x:107:107:qemu user
usbmuxd:x:113:113:usbmuxd user
unbound:x:996:991:Unbound DNS resolver
rpc:x:32:32:Rpcbind Daemon
gluster:x:995:990:GlusterFS daemons
```

不难看出，上面其实是5个字段，各个字段之间是用了冒号进行间隔，如果想以第3个字段中的数字作为排序依据，那么可以用-t参数指定间隔符，用-k参数指定第几列，用-n参数进行数字排序来搞定：

```
[root@linuxprobe ~]# sort -t : -k 3 -n user.txt 
rpc:x:32:32:Rpcbind Daemon
tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon
qemu:x:107:107:qemu user
usbmuxd:x:113:113:usbmuxd user
pulse:x:171:171:PulseAudio System Daemon
rtkit:x:172:172:RealtimeKit
gluster:x:995:990:GlusterFS daemons
unbound:x:996:991:Unbound DNS resolver
geoclue:x:997:995:User for geoclue
polkitd:x:998:996:User for polkitd
```

##### **2.7 文件目录管理命令**

目前为止，我们学习Linux命令的过程就像是在夯实地基，虽然表面上“高楼未起”，但其实大家的内功已经相当深厚了。有了上面的知识铺垫，我们将在本节介绍Linux系统日常运维工作中最常用的命令，实现对文件的创建、修改、复制、剪切、更名与删除等操作。

**1．touch命令**

touch命令用于创建空白文件或设置文件的时间，语法格式为“touch [参数] 文件名称”。

在创建空白的文本文件方面，这个touch命令相当简洁，简捷到没有必要铺开去讲。比如，touch  linuxprobe命令可以创建出一个名为linuxprobe的空白文本文件。对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（Mtime）、文件权限或属性的更改时间（Ctime）与文件的访问时间（Atime）上面。touch命令的参数及其作用如表2-17所示。

表2-17                       touch命令中的参数及其作用

| 参数 | 作用                      |
| ---- | ------------------------- |
| -a   | 仅修改“读取时间”（atime） |
| -m   | 仅修改“修改时间”（mtime） |
| -d   | 同时修改atime与mtime      |



接下来，先使用ls命令查看一个文件的修改时间，随后修改这个文件，最后再查看一下文件的修改时间，看是否发生了变化：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/touch.png)

```
[root@linuxprobe ~]# ls -l anaconda-ks.cfg
-rw-------. 1 root root 1213 May  4 15:44 anaconda-ks.cfg
[root@linuxprobe ~]# echo "Visit the LinuxProbe.com to learn linux skills" >> anaconda-ks.cfg
[root@linuxprobe ~]# ls -l anaconda-ks.cfg
-rw-------. 1 root root 1260 Aug  2 01:26 anaconda-ks.cfg
```

如果不想让别人知道我们修改了它，那么这时就可以用touch命令把修改后的文件时间设置成修改之前的时间（很多黑客就是这样做的呢）：

```
[root@linuxprobe ~]# touch -d "2020-05-04 15:44" anaconda-ks.cfg 
[root@linuxprobe ~]# ls -l anaconda-ks.cfg 
-rw-------. 1 root root 1260 May  4 15:44 anaconda-ks.cfg
```

**2．mkdir命令**

mkdir命令用于创建空白的目录，英文全称为“make directory”，语法格式为“mkdir [参数] 目录名称”。

除了能创建单个空白目录外，mkdir命令还可以结合-p参数来递归创建出具有嵌套层叠关系的文件目录：

```
[root@linuxprobe ~]# mkdir linuxprobe
[root@linuxprobe ~]# cd linuxprobe
[root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e
[root@linuxprobe linuxprobe]# cd a
[root@linuxprobe a]# cd b
[root@linuxprobe b]#
```

**3．cp命令**

cp命令用于复制文件或目录，英文全称为“copy”，语法格式为“cp [参数] 源文件名称 目标文件名称”。

大家对文件复制操作应该不陌生，几乎每天都会使用到。在Linux系统中，复制操作具体分为3种情况：

> 如果目标文件是目录，则会把源文件复制到该目录中；
>
> 如果目标文件也是普通文件，则会询问是否要覆盖它；
>
> 如果目标文件不存在，则执行正常的复制操作。

复制命令基本不会出错，唯一需要记住的就是在复制目录时要加上-r参数。cp命令的参数及其作用如表2-18所示。

表2-18                        cp命令中的参数及其作用

| 参数 | 作用                                         |
| ---- | -------------------------------------------- |
| -p   | 保留原始文件的属性                           |
| -d   | 若对象为“链接文件”，则保留该“链接文件”的属性 |
| -r   | 递归持续复制（用于目录）                     |
| -i   | 若目标文件存在则询问是否覆盖                 |
| -a   | 相当于-pdr（p、d、r为上述参数）              |



接下来，使用touch命令创建一个名为install.log的普通空白文件，然后将其复制为一份名为x.log的备份文件，最后再使用ls命令查看目录中的文件：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/cp.png)

```
[root@linuxprobe ~]# touch install.log
[root@linuxprobe ~]# cp install.log x.log
[root@linuxprobe ~]# ls
install.log x.log
```

**4．mv命令**

mv命令用于剪切或重命名文件，英文全称为“move”，语法格式为“mv [参数] 源文件名称 目标文件名称”。

剪切操作不同于复制操作，因为它默认会把源文件删除，只保留剪切后的文件。如果在同一个目录中将某个文件剪切后还粘贴到当前目录下，其实也就是对该文件进行了重命名操作：

```
[root@linuxprobe ~]# mv x.log linux.log
[root@linuxprobe ~]# ls
install.log linux.log
```

**5．rm命令**

rm命令用于删除文件或目录，英文全称为“remove”，语法格式为“rm [参数] 文件  名称”。

在Linux系统中删除文件时，系统会默认向您询问是否要执行删除操作，如果不想总是看到这种反复的确认信息，可在rm命令后跟上-f参数来强制删除。另外，要想删除一个目录，需要在rm命令后面加一个-r参数才可以，否则删除不掉。rm命令的参数及其作用如表2-19所示。

表2-19                        rm命令中的参数及其作用

| 参数 | 作用       |
| ---- | ---------- |
| -f   | 强制执行   |
| -i   | 删除前询问 |
| -r   | 删除目录   |
| -v   | 显示过程   |



下面尝试删除前面创建的install.log和linux.log文件，大家感受一下加与不加-f参数的区别：

```
[root@linuxprobe ~]# rm install.log
rm: remove regular empty file ‘install.log’? y
[root@linuxprobe ~]# rm -f linux.log
[root@linuxprobe ~]# ls
[root@linuxprobe ~]#
```

**6．dd命令**

dd命令用于按照指定大小和个数的数据块来复制文件或转换文件，语法格式为“dd if=参数值of=参数值count=参数值bs=参数值”。

dd命令是一个比较重要而且比较有特色的命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然，如果愿意的话，还可以在复制过程中转换其中的数据。Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此常常使用它作为dd命令的输入文件，来生成一个指定大小的文件。dd命令的参数及其作用如表2-20所示。

表2-20                        dd命令中的参数及其作用

| 参数  | 作用                 |
| ----- | -------------------- |
| if    | 输入的文件名称       |
| of    | 输出的文件名称       |
| bs    | 设置每个“块”的大小   |
| count | 设置要复制“块”的个数 |



例如，用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/dd.png)

```
[root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M
1+0 records in
1+0 records out
587202560 bytes (587 MB, 560 MiB) copied, 1.28667 s, 456 MB/s
```

dd命令的功能也绝不仅限于复制文件这么简单。如果想把光驱设备中的光盘制作成iso格式的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像：

```
[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-8.0-x86_64-LinuxProbe.Com.iso
13873152+0 records in
13873152+0 records out
7103053824 bytes (7.1 GB, 6.6 GiB) copied, 27.8812 s, 255 MB/s
```

考虑到有些读者会纠结bs块大小与count块个数的关系，下面举一个吃货的例子进行解释。假设小明的饭量（即需求）是一个固定的值，用来盛饭的勺子的大小是bs块的大小，而用勺子盛饭的次数则是count块的个数。小明要想吃饱（满足需求），则需要在勺子大小（bs块大小）与用勺子盛饭的次数（count块个数）之间进行平衡。勺子越大，用勺子盛饭的次数就越少。由上可见，bs与count都是用来指定容量的大小，只要能满足需求，可随意组合搭配方式。

**7．file命令**

file命令用于查看文件的类型，语法格式为“file文件名称”。

在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，但是它们又不像Windows系统那样都有后缀，因此很难通过文件名一眼判断出具体的文件类型，这时就需要使用file命令来查看文件类型了。![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/file.png)

```
[root@linuxprobe ~]# file anaconda-ks.cfg 
anaconda-ks.cfg: ASCII text
[root@linuxprobe ~]# file /dev/sda
/dev/sda: block special
```

### **Tips**

在Windows系统中打开文件时，一般是通过用户双击鼠标完成的，系统会自行判断用户双击的文件是什么类型，因此需要有后缀进行区别。而Linux系统则是根据用户执行的命令来调用文件，例如执行cat命令查看文本，执行bash命令执行脚本等，所以也就不需要强制让用户给文件设置后缀了。

**8．tar命令**

tar命令用于对文件进行打包压缩或解压，语法格式为“tar参数 文件名称”。

在网络上，人们越来越倾向于传输压缩格式的文件，原因是压缩文件的体积小，在网速相同的情况下，体积越小则传输时间越短。在Linux系统中，主要使用的是.tar、.tar.gz或.tar.bz2格式，大家不用担心格式太多而记不住，其实这些格式大部分都是由tar命令生成的。tar命令的参数及其作用如表2-21所示。

表2-21                        tar命令中的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -c   | 创建压缩文件           |
| -x   | 解开压缩文件           |
| -t   | 查看压缩包内有哪些文件 |
| -z   | 用Gzip压缩或解压       |
| -j   | 用bzip2压缩或解压      |
| -v   | 显示压缩或解压的过程   |
| -f   | 目标文件名             |
| -p   | 保留原始的权限与属性   |
| -P   | 使用绝对路径来压缩     |
| -C   | 指定解压到的目录       |



首先，-c参数用于创建压缩文件，-x参数用于解压文件，因此这两个参数不能同时使用。其次，-z参数指定使用gzip格式来压缩或解压文件，-j参数指定使用bzip2格式来压缩或解压文件。用户使用时则是根据文件的后缀来决定应使用何种格式的参数进行解压。在执行某些压缩或解压操作时，可能需要花费数个小时，如果屏幕一直没有输出，您一方面不好判断打包的进度情况，另一方面也会怀疑电脑死机了，因此非常推荐使用-v参数向用户不断显示压缩或解压的过程。-C参数用于指定要解压到哪个指定的目录。-f参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。刘遄老师一般使用“tar -czvf压缩包名称.tar.gz要打包的目录”命令把指定的文件进行打包压缩；相应的解压命令为“tar  -xzvf压缩包名称.tar.gz”。下面我们逐个演示打包压缩与解压的操作，先使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：
 ![第2章 新手必须掌握的Linux命令第2章 新手必须掌握的Linux命令](https://www.linuxprobe.com/wp-content/uploads/2020/05/tar.png)

```
[root@linuxprobe ~]# tar czvf etc.tar.gz /etc
tar: Removing leading `/' from member names
/etc/
/etc/fstab
/etc/crypttab
/etc/mtab
/etc/fonts/
/etc/fonts/conf.d/
/etc/fonts/conf.d/65-0-madan.conf
/etc/fonts/conf.d/59-liberation-sans.conf
/etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
/etc/fonts/conf.d/59-liberation-mono.conf
/etc/fonts/conf.d/66-sil-nuosu.conf
………………省略部分压缩过程信息………………
```

接下来将打包后的压缩包文件指定解压到/root/etc目录中（先使用mkdir命令创建/root/etc目录）：

```
[root@linuxprobe ~]# mkdir /root/etc
[root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc
etc/
etc/fstab
etc/crypttab
etc/mtab
etc/fonts/
etc/fonts/conf.d/
etc/fonts/conf.d/65-0-madan.conf
etc/fonts/conf.d/59-liberation-sans.conf
etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
etc/fonts/conf.d/59-liberation-mono.conf
etc/fonts/conf.d/66-sil-nuosu.conf
etc/fonts/conf.d/65-1-vlgothic-gothic.conf
etc/fonts/conf.d/65-0-lohit-bengali.conf
etc/fonts/conf.d/20-unhint-small-dejavu-sans.conf
………………省略部分解压过程信息………………
```

在本章最后再多提几句，很多读者初次接触到本书时都担心因为自己的英语不好而导致学不会Linux系统，其实大可不必担心，因为我们的图书、培训课程甚至红帽考题都是中文的。而在学习完本章后您也一定发现以后要使用的是Linux命令，而绝不是纯粹的英语单词。即便它们的拼写100%相同，最终用处肯定也是不一样的。因此就学习Linux系统技术来讲，您跟英语达人绝对都是站在同一起跑线上的，更何况还正确地选择了一本适合您的Linux教材。



1．在RHEL 8及众多的Linux系统中，最常使用的Shell终端是什么？

**答：**Bash（Bourne-Again SHell）解释器。

2．执行Linux系统命令时，添加参数的目的是什么？

**答：**为了让Linux系统命令能够更贴合用户的实际需求进行工作。

3．Linux系统命令、命令参数及命令对象之间，应该使用什么来间隔？

**答：**应该使用一个或多个空格进行间隔。

4．请写出用echo命令把SHELL变量值输出到屏幕终端的命令。

**答****：**echo $SHELL。

5．简述Linux系统中5种进程的名称及含义。

**答：**在Linux系统中，有下面5种进程名称。

> **R****（运行）**：进程正在运行或在运行队列中等待。
>
> **S****（中断）**：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。
>
> **D****（不可中断）**：进程不响应系统异步信号，即便用kill命令也不能将其中断。
>
> **Z****（僵死）**：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。
>
> **T****（停止）**：进程收到停止信号后停止运行。

6．请尝试使用Linux系统命令关闭PID为5529的服务进程。

**答：**执行kill 5529命令即可；若知道服务的名称，则可以使用killall命令进行关闭。

7．使用ifconfig命令查看网络状态信息时，需要重点查看的4项信息分别是什么？

**答：**这4项重要的信息分别是网卡名称、IP地址、网卡物理地址以及RX/TX的收发流量数据大小。

8．使用uptime命令查看系统负载时，对应的负载数值如果是0.91、0.56、0.32，那么最近15分钟内负载压力最大的是哪个时间段？

**答：**通过负载数值可以看出，最近1分钟内的负载压力是最大的。

9．使用history命令查看历史命令的执行记录时，命令前面的编码数字除了排序外还有什么用处？

**答：**还可以用“!编码数字”的命令格式重复执行某一次的命令记录，从而避免了重复输入较长命令的麻烦。

10．若想查看的文件具有较长的内容，那么使用cat、more、head、tail中的哪个命令最合适？

**答：**文件内容较长，使用more命令；反之使用cat命令。

11．在使用mkdir命令创建有嵌套关系的目录时，应该加上什么参数呢？

**答：**应该加上-p递归迭代参数，从而自动化地创建有嵌套关系的目录。

12．在使用rm命令删除文件或目录时，可使用哪个参数来避免二次确认呢？

**答：**可使用-f参数，这样即可无须二次确认。

13．若有一个名为backup.tar.gz的压缩包文件，那么解压的命令应该是什么？

**答：**应该用tar命令进行解压，执行tar -xzvf backup.tar.gz命令即可。

14．使用grep命令对某个文件进行关键词搜索时，若想要进行文件内容反选，应使用什么参数？

**答：**可使用-v参数来进行匹配内容的反向选择，即显示出不包含某个关键词的行。

 				   




# [第3章 管道符、重定向与环境变量](https://www.linuxprobe.com/basic-learning-03.html)

​		

目前为止，我们已经学习了10多个常用的[Linux系统](https://www.linuxprobe.com/)[命令](https://www.linuxcool.com/)，如果不能把这些[命令](https://www.linuxcool.com/)进行组合使用，则无法提升工作效率。本章首先讲解与文件读写操作有关的重定向技术的5种模式—标准覆盖输出重定向、标准追加输出重定向、错误覆盖输出重定向、错误追加输出重定向以及输入重定向，让读者通过实验切实理解每个重定向模式的作用，解决输出信息的保存问题。然后深入讲解管道命令符，帮助读者掌握命令之间的搭配使用方法，进一步提高命令输出值的处理效率。随后通过讲解[Linux](https://www.linuxprobe.com/)系统命令行中的通配符和常用转义字符，让您输入的Linux命令具有更准确的意义，为下一章学习编写[Shell](https://www.linuxcool.com/)[脚本](https://www.linuxcool.com/)打好功底。最后，本章深度剖析了Bash解释器执行Linux命令的内部原理，为读者掌握PATH变量及Linux系统中的重要环境变量打下了基础。

本章目录结构

- [3.1 输入输出重定向](https://www.linuxprobe.com/basic-learning-03.html#31)
- [3.2 管道命令符](https://www.linuxprobe.com/basic-learning-03.html#32)
- [3.3 命令行的通配符](https://www.linuxprobe.com/basic-learning-03.html#33)
- [3.4 常用的转义字符](https://www.linuxprobe.com/basic-learning-03.html#34)
- [3.5 重要的环境变量](https://www.linuxprobe.com/basic-learning-03.html#35)

##### **3.1 输入输出重定向**

既然已经在上一章学完了几乎所有基础且常用的Linux命令，那么接下来的任务就是把多个Linux命令适当地组合到一起，使其协同工作，以便我们更加高效地处理数据。要做到这一点，就必须搞明白命令的输入重定向和输出重定向的原理。

简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。听起来就很玄妙？[刘遄](https://www.linuxprobe.com/)老师接下来将慢慢道来。

> **标准输入重定向（STDIN，文件描述符为0）**：默认从键盘输入，也可从其他文件或命令中输入。
>
> **标准输出重定向（STDOUT，文件描述符为1）**：默认输出到屏幕。
>
> **错误输出重定向（STDERR，文件描述符为2）**：默认输出到屏幕。

比如分别查看两个文件的属性信息，我们先创建出第一个文件，而第二个文件是不存在的。所以，虽然针对这两个文件的操作都分别会在屏幕上输出一些信息，但这两个操作的差异其实很大：

```
[root@linuxprobe ~]# touch linuxprobe
[root@linuxprobe ~]# ls -l linuxprobe 
-rw-r--r--. 1 root root 0 Aug 5 05:35 linuxprobe
[root@linuxprobe ~]# ls -l xxxxxx
ls: cannot access xxxxxx: No such file or directory
```

在上述命令中，名为linuxprobe的文件是真实存在的，输出信息是该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息，这也是该命令的标准输出信息。而名为xxxxxx的第二个文件是不存在的，因此在执行完ls命令之后显示的报错提示信息也是该命令的错误输出信息。那么，要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。

对于输入重定向来讲，用到的符号及其作用如表3-1所示。

表3-1                     输入重定向中用到的符号及其作用

| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |



对于输出重定向来讲，用到的符号及其作用如表3-2所示。

表3-2                     输出重定向中用到的符号及其作用

| 符号                                  | 作用                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| 命令 > 文件                           | 将标准输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 2> 文件                          | 将错误输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 >> 文件                          | 将标准输出重定向到一个文件中（追加到原有内容的后面）         |
| 命令 2>> 文件                         | 将错误输出重定向到一个文件中（追加到原有内容的后面）         |
| 命令 >> 文件 2>&1   或  命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |



对于重定向中的标准输出模式，可以省略文件描述符1不写，而错误输出模式的文件描述符2是必须要写的。先来小试牛刀。通过标准输出重定向将man  bash命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt文件中的内容。具体命令如下：

```
[root@linuxprobe ~]# man bash > readme.txt
[root@linuxprobe ~]# cat readme.txt 
BASH(1)                     General Commands Manual                    BASH(1)

NAME
       bash - GNU Bourne-Again SHell

SYNOPSIS
       bash [options] [command_string | file]

COPYRIGHT
       Bash is Copyright (C) 1989-2016 by the Free Software Foundation, Inc.

DESCRIPTION
       Bash  is  an  sh-compatible  command language interpreter that executes
       commands read from the standard input or from a file.  Bash also incor‐
       porates useful features from the Korn and C shells (ksh and csh).

       Bash  is  intended  to  be a conformant implementation of the Shell and
       Utilities portion  of  the  IEEE  POSIX  specification  (IEEE  Standard
       1003.1).  Bash can be configured to be POSIX-conformant by default.

………………省略部分输出信息………………
```

有没有感觉到很方便呢？接下来尝试输出重定向技术中的覆盖写入与追加写入这两种不同模式带来的变化。首先通过覆盖写入模式向readme.txt文件写入多行数据（该文件中已包含上一个实验的man命令信息）。需要注意的是，在通过覆盖写入模式向文件中写入数据时，每一次都会覆盖掉上一次写入的内容，所以最终文件中只有最后一次的写入结果：

```
[root@linuxprobe ~]# echo "Welcome to LinuxProbe.Com" > readme.txt
[root@linuxprobe ~]# echo "Welcome to LinuxProbe.Com" > readme.txt
[root@linuxprobe ~]# echo "Welcome to LinuxProbe.Com" > readme.txt
[root@linuxprobe ~]# echo "Welcome to LinuxProbe.Com" > readme.txt
[root@linuxprobe ~]# echo "Welcome to LinuxProbe.Com" > readme.txt
[root@linuxprobe ~]# cat readme.txt
Welcome to LinuxProbe.Com
```

再通过追加写入模式向readme.txt文件写入一次数据，然后在执行cat命令之后，可以看到如下所示的文件内容：

```
[root@linuxprobe ~]# echo "Quality linux learning materials" >> readme.txt
[root@linuxprobe ~]# cat readme.txt
Welcome to LinuxProbe.Com
Quality linux learning materials
```

虽然都是输出重定向技术，但是命令的标准输出和错误输出还是有区别的。例如查看当前目录中某个文件的信息，这里以linuxprobe文件为例。由于这个文件是真实存在的，因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到了屏幕上。

```
[root@linuxprobe ~]# ls -l linuxprobe > /root/stderr.txt 
[root@linuxprobe ~]# ls -l linuxprobe 2> /root/stderr.txt 
-rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe
```

如果想把命令的报错信息写入到文件，该怎么操作呢？当用户在执行一个自动化的Shell[脚本](https://www.linuxcool.com/)时，这个操作会特别有用，而且特别实用，因为它可以把整个[脚本](https://www.linuxcool.com/)执行过程中的报错信息都记录到文件中，便于安装后的排错工作。

接下来以一个不存在的文件进行实验演示：

```
[root@linuxprobe ~]# ls -l xxxxxx > /root/stderr.txt
cannot access xxxxxx: No such file or directory
[root@linuxprobe ~]# ls -l xxxxxx 2> /root/stderr.txt
[root@linuxprobe ~]# cat /root/stderr.txt 
ls: cannot access xxxxxx: No such file or directory
```

还有一种常见情况，就是我们想不区分标准输出和错误输出，只要命令有输出信息则全部追加写入到文件中。这就要用到&>>操作符了：

```
[root@linuxprobe ~]# ls -l linuxprobe &>> readme.txt
[root@linuxprobe ~]# ls -l xxxxxx &>> readme.txt
-rw-r--r--. 1 root root 0 Mar  1 13:30 linuxprobe
cannot access xxxxxx: No such file or directory
```

输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数：

```
[root@linuxprobe ~]# wc -l < readme.txt
2
```

大家应该发现这次的输出结果与第2章讲的时候有所不同：没有了文件名称。

```
[root@linuxprobe ~]# wc -l /etc/passwd
38 /etc/passwd
```

这是因为此前使用的“wc -l /etc/passwd”是一种非常标准的“命令+参数+对象”的执行格式，而这次的“wc -l <  readme.txt”则是将readme.txt文件中的内容通过操作符导入到命令中，没有被当作命令对象进行执行，因此wc命令只能读到信息流数据，而没有文件名称的信息。这个小差异同学们可以慢慢琢磨下。

##### **3.2 管道命令符**

细心的读者肯定还记得在2.6节学习tr命令时曾经见到过一个名为管道符的东西。同时按下键盘上的Shift+反斜杠（\）键即可输入管道符，其执行格式为“命令A | 命令B”。管道命令符的作用也可以用一句话概括为“**把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入**”。在2.6节讲解grep文本搜索命令时，我们通过匹配关键词/sbin/nologin找出了所有被限制登录系统的用户。在学完本节内容后，完全可以把下面这两条命令合并为一条：

> 找出被限制登录用户的命令是grep /sbin/nologin /etc/passwd；
>
> 统计文本行数的命令则是wc–l。

现在要做的就是把grep搜索命令的输出值传递给wc统计命令，即把原本要输出到屏幕的用户信息列表再交给wc命令作进一步的加工，因此只需要把管道符放到两条命令之间即可，具体如下：

```
[root@linuxprobe ~]# grep /sbin/nologin /etc/passwd | wc -l
40
```

这简直是太方便了！这个管道符就像一个法宝，我们可以将它套用到其他不同的命令上，比如用翻页的形式查看/etc目录中的文件列表及属性信息（这些内容默认会一股脑儿地显示到屏幕上，根本看不清楚）：

```
[root@linuxprobe ~]# ls -l /etc/ | more
total 1344
-rw-r--r--. 1 root root 16 Jul 21 05:08 adjtime
-rw-r--r--. 1 root root 1518 Sep 10 2018 aliases
drwxr-xr-x. 3 root root 65 Jul 21 05:06 alsa
drwxr-xr-x. 2 root root 4096 Jul 21 05:08 alternatives
-rw-r--r--. 1 root root 541 Oct 2 2018 anacrontab
-rw-r--r--. 1 root root 55 Feb 1 2019 asound.conf
-rw-r--r--. 1 root root 1 Aug 12 2018 at.deny
drwxr-x---. 4 root root 100 Jul 21 05:16 audit
drwxr-xr-x. 3 root root 228 Jul 21 05:08 authselect
drwxr-xr-x. 4 root root 71 Jul 21 05:06 avahi
drwxr-xr-x. 2 root root 204 Jul 21 05:06 bash_completion.d
-rw-r--r--. 1 root root 3001 Sep 10 2018 bashrc
--More--
```

在修改用户密码时，通常都需要输入两次密码以进行确认，这在编写自动化脚本时将成为一个非常致命的缺陷。通过把管道符和passwd命令的--stdin参数相结合，可以用一条命令来完成密码重置操作：

```
[root@linuxprobe ~]# echo "linuxprobe" | passwd --stdin root
Changing password for user root.
passwd: all authentication tokens updated successfully.
```

咱们在第2章学习ps命令的时候，输入ps aux命令后屏幕信息呼呼闪过，根本找不到有用的信息。现在也可以将ps、grep、管道符三者结合到一起使用了。下面搜索与bash有关的进程信息：

```
[root@linuxprobe ~]# ps aux | grep bash
root 1070 0.0 0.1 25384 2324 ? S Sep21 0:00 /bin/bash /usr/sbin/ksmtuned
root 3899 0.0 0.2 26540 5136 pts/0 Ss 00:27 0:00 bash
root 4002 0.0 0.0 12112 1056 pts/0 S+ 00:28 0:00 grep --color=auto bash
```

![第3章 管道符、重定向与环境变量第3章 管道符、重定向与环境变量](https://www.linuxprobe.com/wp-content/uploads/2020/05/任意门.gif)

 

大家千万不要误以为管道命令符只能在一个命令组合中使用一次。我们完全可以这样使用：“命令A | 命令B |  命令C”。为了帮助读者进一步理解管道符的作用，刘遄老师在讲课时经常会把管道符描述成“任意门”。想必大家小时候都看过“哆啦A梦”动画片吧。哆啦A梦（也就是常称的机器猫）经常为了取悦大雄而从口袋中掏出一件件宝贝，其中好多次就用到了任意门这个道具。其实，管道符就好像是用于实现数据穿越的任意门，能够帮助提高工作效率，完成之前不敢想象的复杂工作。

 

### **Tips**

曾经有位东北的同学做了一个特别贴切的类比：把管道符当做流水线作业，这跟吃顿烧烤是同一个道理，即第一个人负责切肉，第二个人负责串肉，第三个人负责烧烤，最后的处理结果交付给用户。

如果读者是一名Linux新手，可能会觉得上面的命令组合已经十分复杂了，但是有过运维经验的读者又会感觉如隔靴挠痒般不过瘾，他们希望能将这样方便的命令写得更高级一些，功能更强大一些。为了感谢各位读者的捧场和对本书的认可，刘遄老师当然要义不容辞地把技术拱手奉上。如果需要将管道符处理后的结果既输出到屏幕，又同时写入到文件中，则可以与tee命令结合使用。

下述命令将显示系统中所有与bash相关的进程信息，并同时将输出到屏幕和文件中：

![第3章 管道符、重定向与环境变量第3章 管道符、重定向与环境变量](https://www.linuxprobe.com/wp-content/uploads/2020/05/netstat.png)

```
[root@linuxprobe ~]# ps aux | grep bash | tee result.txt
root 1070 0.0 0.1 25384 2324 ? S Sep21 0:00 /bin/bash /usr/sbin/ksmtuned
root 3899 0.0 0.2 26540 5136 pts/0 Ss 00:27 0:00 bash
root 4320 0.0 0.0 12112 1112 pts/0 S+ 00:51 0:00 grep --color=auto bash
[root@linuxprobe ~]# cat result.txt
root 1070 0.0 0.1 25384 2324 ? S Sep21 0:00 /bin/bash /usr/sbin/ksmtuned
root 3899 0.0 0.2 26540 5136 pts/0 Ss 00:27 0:00 bash
root 4320 0.0 0.0 12112 1112 pts/0 S+ 00:51 0:00 grep --color=auto bash
```

##### **3.3 命令行的通配符**

大家可能都遇到过提笔忘字的尴尬，作为Linux运维人员，我们有时候也会遇到明明一个文件的名称就在嘴边但就是想不起来的情况。如果只记得一个文件的开头几个字母，想遍历查找出所有以这几个字母开头的文件，该怎么操作呢？又比如，假设我们想要批量查看所有硬盘文件的相关权限属性，有一种实现方式是下面这样的：

```
[root@linuxprobe ~]# ls -l /dev/sda
brw-rw----. 1 root disk 8, 0 May 4 15:55 /dev/sda
[root@linuxprobe ~]# ls -l /dev/sda1
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
[root@linuxprobe ~]# ls -l /dev/sda2
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
[root@linuxprobe ~]# ls -l /dev/sda3
ls: cannot access '/dev/sda3': No such file or directory
```

幸亏我的硬盘文件和分区只有3个，要是有几百个，估计需要花费一天的时间来忙这个事情了。所以，这种方式的效率确实很低。

虽然第6章才会讲解Linux系统的存储结构和FHS，但现在应该能看出一些简单规律了。比如，这些硬盘设备文件都是以sda开头并且存放到了/dev目录中，这样一来，即使不知道硬盘的分区编号和具体分区的个数，也可以使用通配符来搞定。

顾名思义，通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。Linux系统中的通配符及含义如表3-3所示。

表3-3                    Linux系统中的通配符及含义

| 通配符      | 含义           |
| ----------- | -------------- |
| *           | 任意字符       |
| ?           | 单个任意字符   |
| [a-z]       | 单个小写字母   |
| [A-Z]       | 单个大写字母   |
| [a-Z]       | 单个字母       |
| [0-9]       | 单个数字       |
| [[:alpha:]] | 任意字母       |
| [[:upper:]] | 任意大写字母   |
| [[:lower:]] | 任意小写字母   |
| [[:digit:]] | 所有数字       |
| [[:alnum:]] | 任意字母加数字 |
| [[:punct:]] | 标点符号       |



俗话讲“百闻不如一见，看书不如实验”，下面我们就来匹配所有在/dev目录中且以sda开头的文件：

```
[root@linuxprobe ~]# ls -l /dev/sda*
brw-rw----. 1 root disk 8, 0 May 4 15:55 /dev/sda
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
```

如果只想查看文件名以sda开头，但是后面还紧跟其他某一个字符的文件的相关信息，这时就需要用到问号来进行通配了：

```
[root@linuxprobe ~]# ls -l /dev/sda?
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
```

除了使用[0-9]来匹配0～9之间的单个数字，也可以用[135]这样的方式仅匹配这3个指定数字中的一个；若没有匹配到数字1或2或3，则不会显示出来：

```
[root@linuxprobe ~]# ls -l /dev/sda[0-9]
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
[root@linuxprobe ~]# ls -l /dev/sda[135]
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
```

通配符不一定非要放到最后面，也可以放到前面。比如，可以使用下述命令来搜索/etc/目录中所有以.conf结尾的配置文件有哪些：

```
[root@linuxprobe ~]# ls -l /etc/*.conf
-rw-r--r--. 1 root root 55 Feb 1 2019 /etc/asound.conf
-rw-r--r--. 1 root root 25696 Dec 12 2018 /etc/brltty.conf
-rw-r--r--. 1 root root 1083 Apr 4 2018 /etc/chrony.conf
-rw-r--r--. 1 root root 1174 Aug 12 2018 /etc/dleyna-server-service.conf
-rw-r--r--. 1 root dnsmasq 26843 Aug 12 2018 /etc/dnsmasq.conf
-rw-r--r--. 1 root root 117 Jan 16 2019 /etc/dracut.conf
-rw-r--r--. 1 root root 20 Aug 12 2018 /etc/fprintd.conf
-rw-r--r--. 1 root root 38 Nov 16 2018 /etc/fuse.conf
………………省略部分输出信息………………
```

通配符不仅可用于搜索文件或代替被通配的字符，还可以与创建文件的命令相结合，一口气创建出好多个文件。不过在创建多个文件时，需要使用大括号，并且字段之间用逗号间隔：

```
[root@linuxprobe ~]# touch {AA,BB,CC}.conf
[root@linuxprobe ~]# ls -l *.conf
-rw-r--r--. 1 root root 0 Sep 22 01:54 AA.conf
-rw-r--r--. 1 root root 0 Sep 22 01:54 BB.conf
-rw-r--r--. 1 root root 0 Sep 22 01:54 CC.conf
```

使用通配符还可以输出一些指定的信息：

```
[root@linuxprobe ~]# echo file{1,2,3,4,5}
file1 file2 file3 file4 file5
```

通配符的玩法特别多，接下来大家就自行摸索、自己开发吧。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

##### **3.4 常用的转义字符**

为了能够更好地理解用户的表达，Shell解释器还提供了特别丰富的转义字符来处理输入的特殊数据。刘遄老师以10多年的工作和培训为基础，愣是用了两周时间从数十个转义字符中提炼出了4个最常用的转义字符！这件事情也让我深刻反省了很长时间，原本认为图书写得越厚，作者越是大牛，现在发现这种观念完全是错误的，希望读者在读完本书后能体会到刘遄老师的用心付出。

4个最常用的转义字符如下所示。

> **反斜杠（\）**：使反斜杠后面的一个变量变为单纯的字符。
>
> **单引号（' '）**：转义其中所有的变量为单纯的字符串。
>
> **双引号（" "）**：保留其中的变量属性，不进行转义处理。
>
> **反引号（` `）**：把其中的命令执行后返回结果。

我们先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：

```
[root@linuxprobe ~]# PRICE=5
[root@linuxprobe ~]# echo "Price is $PRICE"
Price is 5
```

接下来，我们希望能够输出“Price is $5”，即“价格是5美元”的字符串内容，但碰巧美元符号与变量提取符号合并后的$$作用是显示当前程序的进程ID号码，于是命令执行后输出的内容并不是我们所预期的：

```
[root@linuxprobe ~]# echo "Price is $$PRICE" 
Price is 3767PRICE
```

要想让第一个“$”乖乖地作为美元符号，那么就需要使用反斜杠（\）来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能：

```
[root@linuxprobe ~]# echo "Price is \$$PRICE"
Price is $5
```

而如果只需要某个命令的输出值，可以像`命令`这样，将命令用反引号括起来，达到预期的效果。例如，将反引号与uname -a命令结合，然后使用echo命令来查看本机的Linux版本和内核信息：

```
[root@linuxprobe ~]# echo `uname -a`
Linux linuxprobe.com 4.18.0-80.el8.x86_64 #1 SMP Wed Mar 13 12:02:46 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

反斜杠和反引号的功能比较有特点，同学们一般不会犯错，但对于什么时候使用双引号却容易混淆，因为在大多数情况下好像加不加双引号，效果都一样：

```
[root@linuxprobe ~]# echo AA BB CC
AA BB CC
[root@linuxprobe ~]# echo "AA BB CC"
AA BB CC
```

两者的区别在于用户无法得知第一种执行方式中到底有几个参数。是的，不能确定！因为有可能把“AA BB  CC”当作一个参数整体直接输出到屏幕，也有可能分别将AA、BB和CC输出到屏幕。而且，就算摸清了echo命令处理参数的机制，在使用其他命令时依然存在这种情况。

这里给大家总结一个简单小技巧，虽然可能不够严谨，但绝对简单：如果参数中出现了空格，就加双引号；如果参数中没有空格，那就不用加双引号。

##### **3.5 重要的环境变量**

变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，命令则都是小写的，这是一种约定俗成的规范。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。可以直接通过变量名称来提取到对应的变量值。

细心的读者应该发现了，本节和上一节的标题名都分别加了形容词—重要的、常用的，原因其实不言而喻—要想让Linux系统能够正常运行并且为用户提供服务，则需要数百个环境变量来协同工作，我们没有必要逐一介绍、学习每一个变量，而是应该在有限的篇幅中精讲最重要的内容。

为了更好地帮助大家理解变量的作用，给大家举个例子。前文中曾经讲到，在Linux系统中一切都是文件，Linux命令也不例外。那么，在用户执行了一条命令之后，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为4个步骤。

**第1步**：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是绝对路径则直接执行，否则进入第2步继续判断。

**第2步**：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。

之前在使用rm命令删除文件时，Linux系统都会要求用户确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令—“rm -i”。

```
[root@linuxprobe ~]# ls
anaconda-ks.cfg  Documents  initial-setup-ks.cfg  Pictures  Templates
Desktop          Downloads  Music                 Public    Videos
[root@linuxprobe ~]# rm anaconda-ks.cfg 
rm: remove regular file 'anaconda-ks.cfg'? y
```

可以用alias命令来创建一个属于自己的命令别名，语法格式为“alias别名=命令”。若要取消一个命令别名，则是用unalias命令，语法格式为“unalias别名”。

将当前rm命令所被设置的别名取消掉，再删除文件试试：

```
[root@linuxprobe ~]# unalias rm
[root@linuxprobe ~]# rm initial-setup-ks.cfg 
[root@linuxprobe ~]#
```

**第3步**：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“type命令名称”来判断用户输入的命令是内部命令还是外部命令：

```
[root@linuxprobe ~]# type echo
echo is a shell builtin
[root@linuxprobe ~]# type uptime
uptime is /usr/bin/uptime
```

**第4步**：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。

```
[root@linuxprobe ~]# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/root/bin
[root@linuxprobe ~]# PATH=$PATH:/root/bin
[root@linuxprobe ~]# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/root/bin:/root/bin
```

这里有比较经典的问题：“为什么不能将当前目录（.）添加到PATH中呢?”原因是，尽管可以将当前目录（.）添加到PATH变量中，从而在某些情况下可以让用户免去输入命令所在路径的麻烦。但是，如果黑客在比较常用的公共目录/tmp中存放了一个与ls或cd命令同名的木马文件，而用户又恰巧在公共目录中执行了这些命令，那么就极有可能中招了。

所以，作为一名态度谨慎、有经验的运维人员，在接手一台Linux系统后一定会在执行命令前先检查PATH变量中是否有可疑的目录。另外，读者从前面的PATH变量示例中是否也感觉到环境变量特别有用呢？我们可以使用env命令来查看Linux系统中所有的环境变量，而刘遄老师为您精挑细选出了最重要的10个环境变量，如表3-4所示。

表3-4                    Linux系统中最重要的10个环境变量

| 变量名称     | 作用                             |
| ------------ | -------------------------------- |
| HOME         | 用户的主目录（即家目录）         |
| SHELL        | 用户在使用的Shell解释器名称      |
| HISTSIZE     | 输出的历史命令记录条数           |
| HISTFILESIZE | 保存的历史命令记录条数           |
| MAIL         | 邮件保存路径                     |
| LANG         | 系统语言、语系名称               |
| RANDOM       | 生成一个随机数字                 |
| PS1          | Bash解释器的提示符               |
| PATH         | 定义解释器搜索用户执行命令的路径 |
| EDITOR       | 用户默认的文本编辑器             |



Linux作为一个多用户、多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境。因此，一个相同的变量会因为用户身份的不同而具有不同的值。例如，使用下述命令来查看HOME变量在不同的用户身份下都有哪些值（su是用于切换用户身份的命令，将在第5章跟大家见面）：

```
[root@linuxprobe ~]# echo $HOME
/root
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ echo $HOME
/home/linuxprobe
```

其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建变量来满足工作需求。例如，设置一个名称为WORKDIR的变量，方便用户更轻松地进入一个层次较深的目录：

```
[root@linuxprobe ~]# mkdir /home/workdir
[root@linuxprobe ~]# WORKDIR=/home/workdir
[root@linuxprobe ~]# cd $WORKDIR 
[root@linuxprobe workdir]# pwd
/home/workdir
```

但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用：

```
[root@linuxprobe workdir]# su linuxprobe
[linuxprobe@linuxprobe ~]$ cd $WORKDIR
[linuxprobe@linuxprobe ~]$ echo $WORKDIR
[linuxprobe@linuxprobe ~]$ exit
```

如果工作需要，可以使用export命令将其提升为全局变量，这样其他用户也就可以使用它了：

```
[root@linuxprobe ~]# export WORKDIR
[root@linuxprobe ~]# su linuxprobe
[linuxprobe@linuxprobe ~]$ cd $WORKDIR
[linuxprobe@linuxprobe workdir]$ pwd
/home/workdir
```

后续要是不使用这个变量了，则可执行unset命令把它取消掉：

```
[root@linuxprobe ~]# unset WORKDIR
[root@linuxprobe ~]#
```

### **Tips**

直接在终端设置的变量能够立即生效，但在重启服务器后就会失效，因此我们需要将变量和变量值写入到.bashrc或者.bash_profile文件中，以确保永久能使用它们。什么？不知道该怎么编辑文件？快来看第4章吧。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．把ls命令的正常输出信息追加写入到error.txt文件中的命令是什么？

**答：**ls >> error.txt（注意区分>和>>的不同）。

2．请简单概述管道符的作用。

**答：**把左面（前面）命令的输出值作为右面（后面）命令的输入值以便进一步处理信息。

3．Bash解释器的通配符中，星号（*）代表几个字符？

**答：**零个或多个。

4．PATH变量的作用是什么？

**答：**设定解释器搜索所执行命令的路径，找到其所在位置。

5．一般情况下，为参数添加双引号有什么好处？

**答：**双引号通常用于界定参数的个数，以免程序或命令在执行时产生歧义，因此参数中若有空格，则建议添加双引号。

6．使用什么命令可以把名为LINUX的一般变量转换成全局变量？

**答****：**export LINUX。


 		

# [第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/basic-learning-04.html)

​		

本章首先介绍如何使用Vim编辑器来编写和修改文档，然后通过逐步配置主机名称、系统网卡以及软件仓库等文件，帮助大家加深Vim编辑器中诸多[命令](https://www.linuxcool.com/)、快捷键与模式的理解。然后会带领大家重温第2章和第3章中的重点知识，做到[Linux](https://www.linuxprobe.com/)[命令](https://www.linuxcool.com/)、逻辑操作符与[Shell](https://www.linuxcool.com/)[脚本](https://www.linuxcool.com/)的灵活搭配使用。

本章还要求大家能够在Shell[脚本](https://www.linuxcool.com/)中以多种方式接收用户输入的信息，能够对输入值进行文件、数字、字符串的判断比较。在熟练使用“与、或、非”三种逻辑操作符的基础上，大家还要充分学习if、for、while、case条件测试语句，并通过10多个实战脚本的实操练习，达到在工作中灵活运用的水准。

本章最后通过实战的方式演示了使用at命令与crond计划任务服务来分别实现一次性的系统任务设置和长期性的系统任务设置，在分钟、小时、日期、月份、年份的基础上实现工作的自动化，从而让日常的工作更加高效，可以让大家早点下班陪孩子。

本章目录结构

- 4.1 Vim文本编辑器
  - [4.1.1 编写简单文档](https://www.linuxprobe.com/basic-learning-04.html#411)
  - [4.1.2 配置主机名称](https://www.linuxprobe.com/basic-learning-04.html#412)
  - [4.1.3 配置网卡信息](https://www.linuxprobe.com/basic-learning-04.html#413)
  - [4.1.4 配置软件仓库](https://www.linuxprobe.com/basic-learning-04.html#414)
- 4.2 编写Shell脚本
  - [4.2.1 编写简单的脚本](https://www.linuxprobe.com/basic-learning-04.html#421)
  - [4.2.2 接收用户的参数](https://www.linuxprobe.com/basic-learning-04.html#422)
  - [4.2.3 判断用户的参数](https://www.linuxprobe.com/basic-learning-04.html#423)
- 4.3 流程控制语句
  - [4.3.1 if条件测试语句](https://www.linuxprobe.com/basic-learning-04.html#431_if)
  - [4.3.2 for条件循环语句](https://www.linuxprobe.com/basic-learning-04.html#432_for)
  - [4.3.3 while条件循环语句](https://www.linuxprobe.com/basic-learning-04.html#433_while)
  - [4.3.4 case条件测试语句](https://www.linuxprobe.com/basic-learning-04.html#434_case)
- [4.4 计划任务服务程序](https://www.linuxprobe.com/basic-learning-04.html#44)

##### **4.1 Vim文本编辑器**

Vim的发布最早可以追溯到1991年，英文全称为Vi Improved。它也是Vi编辑器的提升版本，其中最大的改进当属添加了代码着色功能，在某些编程场景下还能自动修正错误代码。

每当在讲课时遇到需要让学生记住的知识点时，为了能让他们打起精神来，我都会突然提高嗓门，因此有句话他们记得尤其深刻：“**在[Linux系统](https://www.linuxprobe.com/)中一切都是文件，而配置一个服务就是在修改其配置文件的参数。**”而且在日常工作中大家也肯定免不了要编写文档，这些工作都是通过文本编辑器来完成的。[刘遄](https://www.linuxprobe.com/)老师写作本书的目的是让读者切实掌握Linux系统的运维方法，而不是仅仅停留在“会用某个操作系统”的层面上，所以我们这里选择使用Vim文本编辑器，它默认会安装在当前所有的Linux操作系统上，是一款超棒的文本编辑器。

Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了3种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。要想高效地操作文本，就必须先搞清这3种模式的操作区别以及模式之间的切换方法（见图4-1）。

> **命令模式**：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。
>
> **输入模式**：正常的文本录入。
>
> **末行模式**：保存或退出文档，以及设置编辑环境。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/03/vim不同模式间的切换.png)

图4-1 Vim编辑器模式的切换方法

在每次运行Vim编辑器时，默认进入命令模式，此时需要先切换到输入模式后再进行文档编写工作。而每次在编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档的保存或退出操作。在Vim中，无法直接从输入模式切换到末行模式。Vim编辑器中内置的命令有成百上千种用法，为了能够帮助读者更快地掌握Vim编辑器，表4-1总结了在命令模式中最常用的一些命令。

表4-1                          命令模式中最常用的一些命令

| 命令 | 作用                                               |
| ---- | -------------------------------------------------- |
| dd   | 删除（剪切）光标所在整行                           |
| 5dd  | 删除（剪切）从光标处开始的5行                      |
| yy   | 复制光标所在整行                                   |
| 5yy  | 复制从光标处开始的5行                              |
| n    | 显示搜索命令定位到的下一个字符串                   |
| N    | 显示搜索命令定位到的上一个字符串                   |
| u    | 撤销上一步的操作                                   |
| p    | 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 |



末行模式主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。末行模式中常用的命令如表4-2所示。

表4-2                          末行模式中最常用的一些命令

| 命令          | 作用                                 |
| ------------- | ------------------------------------ |
| :w            | 保存                                 |
| :q            | 退出                                 |
| :q!           | 强制退出（放弃对文档的修改内容）     |
| :wq!          | 强制保存退出                         |
| :set nu       | 显示行号                             |
| :set nonu     | 不显示行号                           |
| :命令         | 执行该命令                           |
| :整数         | 跳转到该行                           |
| :s/one/two    | 将当前光标所在行的第一个one替换成two |
| :s/one/two/g  | 将当前光标所在行的所有one替换成two   |
| :%s/one/two/g | 将全文中的所有one替换成two           |
| ?字符串       | 在文本中从下至上搜索该字符串         |
| /字符串       | 在文本中从上至下搜索该字符串         |



大家在平日里一定要多使用Vim编辑器，一旦把Vim的各种命令练熟，后面在编辑配置文件时，效率就会有很大的提升。在2011年，有一位名为Aleksandr Levchuk的极客，他就为了追求极致的效率，发起了一个名为VIM  Clutch的实验项目。他买了一对类似于汽车油门和刹车的离合器，改装后再用USB与电脑相连，左脚踩刹车是进入编辑模式（i），右脚踩油门是保存文件（wq!）。他对Linux和Vim的热爱真是强大！

###### **4.1.1 编写简单文档**

目前为止，大家已经具备了在Linux系统中编写文档的理论基础，接下来我们一起动手编写一个简单的脚本文档。刘遄老师会尽力把所有操作步骤和按键过程都标注出来，如果忘记了某些快捷键命令的作用，可以再返回前文进行复习。

编写脚本文档的第1步就是给文档取个名字，这里将其命名为practice.txt。如果存在该文档，则是打开它。如果不存在，则是创建一个临时的输入文件，如图4-2所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/尝试编写文本文档.png)

图4-2 尝试编写文本文档

打开practice.txt文档后，默认进入的是Vim编辑器的命令模式。此时只能执行该模式下的命令，而不能随意输入文本内容，我们需要切换到输入模式才可以编写文档。

在图4-1中提到，可以分别使用a、i、o三个键从命令模式切换到输入模式。其中，a键与i键分别是在光标后面一位和光标当前位置切换到输入模式，而o键则是在光标的下面再创建一个空行，此时可敲击a键进入到编辑器的输入模式，如图4-3所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/切换至编辑器的输入模式-1.png)

图4-3 切换至编辑器的输入模式

进入输入模式后，可以随意输入文本内容，Vim编辑器不会把您输入的文本内容当作命令而执行，如图4-4所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/在编辑器中输入文本内容.png)

图4-4 在编辑器中输入文本内容

在编写完之后，要想保存并退出，必须先敲击键盘的Esc键从输入模式返回命令模式，如图4-5所示。然后再输入“:wq!”切换到末行模式才能完成保存退出操作，如图4-6所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/切换至编辑器的命令模式.png)

图4-5 切换至编辑器的命令模式

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/切换至编辑器的末行模式.png)

图4-6 切换至编辑器的末行模式

### **Tips**

请各位同学仔细观察图4-4～图4-6中左下角的提示信息，在不同模式下有不同的提示字样。

当在末行模式中输入“:wq!”命令时，就意味着强制保存并退出文档。然后便可以用cat命令查看保存后的文档内容了，如图4-7所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/查看文档的内容.png)

图4-7 查看文档的内容

是不是很简单？！继续编辑这个文档。因为要在原有文本内容的下面追加内容，所以在命令模式中敲击o键进入输入模式更会高效，操作如图4-8～图4-10所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/再次通过Vim编辑器编写文档.png)

图4-8 再次通过Vim编辑器编写文档

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/进入Vim编辑器的输入模式.png)

图4-9 进入Vim编辑器的输入模式

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/追加写入一行文本内容.png)

图4-10 追加写入一行文本内容

因为此时已经修改了文本内容，所以Vim编辑器在我们尝试直接退出文档而不保存的时候就会拒绝我们的操作了。此时只能强制退出才能结束本次输入操作，如图4-11～图4-13所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/退出文本编辑器.png)

图4-11 退出文本编辑器

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/因文件已被修改而拒绝退出操作.png)

图4-12 因文件已被修改而拒绝退出操作

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/强制退出文本编辑器.png)

图4-13  强制退出文本编辑器

现在大家也算是具有了一些Vim编辑器的实战经验了，应该也感觉到没有想象中那么难吧。现在查看文本的内容，果然发现追加输入的内容并没有被保存下来，如图4-14所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/查看最终编写成的文本内容.png)

图4-14  查看最终编写成的文本内容

大家在学完了理论知识之后又自己动手编写了一个文本，现在是否感觉成就满满呢？接下来将会由浅入深地为读者安排3个小任务。为了彻底掌握Vim编辑器的使用，大家一定要逐个完成不许偷懒，如果在完成这3个任务期间忘记了相关命令，可返回前文进一步复习掌握。

### **Tips**

下面的实验如果做不成功也很正常，请大家把重心放到Vim编辑器上面，能成功修改配置文件就已经很棒啦！

###### **4.1.2 配置主机名称**

为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在Linux系统中，主机名大多保存在/etc/hostname文件中，接下来将/etc/hostname配置文件的内容修改为“linuxprobe.com”，步骤如下。

> **第1步**：使用Vim编辑器修改/etc/hostname主机名称文件。
>
> **第2步**：把原始主机名称删除后追加“linuxprobe.com”。注意，使用Vim编辑器修改主机名称文件后，要在末行模式下执行“:wq!”命令才能保存并退出文档。
>
> **第3步**：保存并退出文档，然后使用hostname命令检查是否修改成功。

```
[root@linuxprobe ~]# vim /etc/hostname
linuxprobe.com
```

hostname命令用于查看当前的主机名称，但有时主机名称的改变不会立即同步到系统中，所以如果发现修改完成后还显示原来的主机名称，可重启虚拟机后再行查看：

```
[root@linuxprobe ~]# hostname
linuxprobe.com
```

###### **4.1.3 配置网卡信息**

网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提。在Linux系统中，一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件。这个小任务不仅可以帮助您练习使用Vim编辑器，而且也为后面学习Linux中的各种服务配置打下了坚实的基础。当您认真学习完本书后，一定会特别有成就感，因为本书前面的基础部分非常扎实，而后面内容则具有几乎一致的网卡IP地址和运行环境，从而确保您全身心地投入到各类服务程序的学习上，而不用操心系统环境的问题。

如果您具备一定的运维经验或者熟悉早期的Linux系统，则在学习本书时会遇到一些不容易接受的差异变化。在RHEL 5、RHEL  6中，网卡配置文件的前缀为eth，第1块网卡为eth0，第2块网卡为eth1；以此类推。在RHEL  7中，网卡配置文件的前缀则以ifcfg开始，再加上网卡名称共同组成了网卡配置文件的名字，例如ifcfg-eno16777736。而在RHEL  8中，网卡配置文件的前缀依然为ifcfg，区别是网卡名称改成了类似于ens160的样子，不过好在除了文件名发生变化外，网卡参数没有其他大的区别。

现在有一个名称为ifcfg-ens160的网卡设备，将其配置为开机自启动，并且IP地址、子网、网关等信息由人工指定，其步骤如下所示。

**第1步**：首先切换到/etc/sysconfig/network-scripts目录中（存放着网卡的配置文件）。

**第2步**：使用Vim编辑器修改网卡文件ifcfg-ens160，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用ifconfig命令自行确认各自网卡的默认名称。

> **设备类型**：TYPE=Ethernet
>
> **地址分配模式**：BOOTPROTO=static
>
> **网卡名称**：NAME=ens160
>
> **是否启动**：ONBOOT=yes
>
> **IP地址**：IPADDR=192.168.10.10
>
> **子网掩码**：NETMASK=255.255.255.0
>
> **网关地址**：GATEWAY=192.168.10.1
>
> **DNS地址**：DNS1=192.168.10.1

**第3步**：重启网络服务并测试网络是否连通。

下面正式开干！

进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：

```
[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/
[root@linuxprobe network-scripts]# vim ifcfg-ens160
TYPE=Ethernet
BOOTPROTO=static
NAME=ens160
ONBOOT=yes
IPADDR=192.168.10.10
NETMASK=255.255.255.0
GATEWAY=192.168.10.1
DNS1=192.168.10.1
```

执行重启网卡设备的命令，然后通过ping命令测试网络能否连通。由于在Linux系统中ping命令不会自动终止，因此需要手动按下Ctrl+C组合键来强行结束进程。

```
[root@linuxprobe network-scripts]# nmcli connection reload ens160
[root@linuxprobe network-scripts]# ping 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.083 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.110 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.106 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.035 ms
^C
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 84ms
rtt min/avg/max/mdev = 0.035/0.083/0.110/0.031 ms
[root@linuxprobe network-scripts]# 
```

是不是感觉很有意思？！当然如果这个实验失败了也不用气馁，后面会有相应的章节专门讲解，请大家把关注点继续放回到Vim编辑器上就好。

###### **4.1.4 配置软件仓库**

本书前面讲到，软件仓库是一种能进一步简化RPM管理软件的难度以及自动分析所需软件包及其依赖关系的技术。可以把Yum或DNF想象成是一个硕大的软件仓库，里面保存有几乎所有常用的工具，而且只需要说出所需的软件包名称，系统就会自动为您搞定一切。

既然要使用软件仓库，就要先把它搭建起来，然后将其配置规则确定好才行。鉴于第6章才会讲解Linux的存储结构和设备挂载操作，所以当前还是将重心放到Vim编辑器的学习上。如果遇到看不懂的参数也不要紧，后面章节会单独讲解。

Yum与DNF软件仓库的配置文件是通用的，也就是说填写好配置文件信息后，这两个软件仓库的命令都是可以正常使用。建议在RHEL 8中使用dnf作为软件的安装命令，因为它具备更高的效率，而且支持多线程同时安装软件。

搭建并配置软件仓库的大致步骤如下所示。

**第1步**：进入/etc/yum.repos.d/目录中（因为该目录存放着软件仓库的配置文件）。

**第2步**：使用Vim编辑器创建一个名为rhel8.repo的新配置文件（文件名称可随意，但后缀必须为.repo），逐项写入下面的配置参数并保存退出。

> **仓库名称**：具有唯一性的标识名称，不应与其他软件仓库发生冲突。
>
> **描述信息（name）**：可以是一些介绍性的词，易于识别软件仓库的用处。
>
> **仓库位置（baseurl）**：软件包的获取方式，可以使用FTP或HTTP下载，也可以是本地的文件（需要在后面添加file参数）。
>
> **是否启用（enabled）**：设置此源是否可用；1为可用，0为禁用。
>
> **是否校验（gpgcheck）**：设置此源是否校验文件；1为校验，0为不校验。
>
> **公钥位置（gpgkey）**：若上面的参数开启了校验功能，则此处为公钥文件位置。若没有开启，则省略不写。

**第3步**：按配置参数中所填写的仓库位置挂载光盘，并把光盘挂载信息写入/etc/fstab文件中。

**第4步**：使用“dnf install httpd -y”命令检查软件仓库是否已经可用。

开始实战！

进入/etc/yum.repos.d目录后创建软件仓库的配置文件：

```
[root@linuxprobe ~]# cd /etc/yum.repos.d/
[root@linuxprobe yum.repos.d]# vim rhel8.repo
[BaseOS]
name=BaseOS
baseurl=file:///media/cdrom/BaseOS
enabled=1
gpgcheck=0
[AppStream]
name=AppStream
baseurl=file:///media/cdrom/AppStream
enabled=1
gpgcheck=0
```

创建挂载点后进行挂载操作，并设置成开机自动挂载（详见第6章）：

```
[root@linuxprobe yum.repos.d]# mkdir -p /media/cdrom 
[root@linuxprobe yum.repos.d]# mount /dev/cdrom /media/cdrom
mount: /media/cdrom: WARNING: device write-protected, mounted read-only.
[root@linuxprobe yum.repos.d]# vim /etc/fstab
/dev/cdrom /media/cdrom iso9660 defaults 0 0
```

尝试使用软件仓库的dnf命令来安装Web服务，软件包名称为httpd，安装后出现“**Complete!**”则代表配置正确：

```
[root@linuxprobe ~]# dnf install httpd -y
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream 3.1 MB/s | 3.2 kB 00:00
BaseOS 2.7 MB/s | 2.7 kB 00:00
Dependencies resolved.
………………省略部分输出信息………………
Installed:
httpd-2.4.37-10.module+el8+2764+7127e69e.x86_64
apr-util-bdb-1.6.1-6.el8.x86_64
apr-util-openssl-1.6.1-6.el8.x86_64
apr-1.6.3-9.el8.x86_64
apr-util-1.6.1-6.el8.x86_64
httpd-filesystem-2.4.37-10.module+el8+2764+7127e69e.noarch
httpd-tools-2.4.37-10.module+el8+2764+7127e69e.x86_64
mod_http2-1.11.3-1.module+el8+2443+605475b7.x86_64
redhat-logos-httpd-80.7-1.el8.noarch

Complete!
```

对于习惯使用yum命令来安装软件的同学，也不需要有压力，因为您依然可以使用yum install httpd命令来安装软件，只是将dnf替换成yum。可见，RHEL 8版本很好地兼容了用户习惯。

##### **4.2 编写Shell脚本**

 

可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。

> **交互式（Interactive）**：用户每输入一条命令就立即执行。
>
> **批处理（Batch）**：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。

在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。

通过查看SHELL变量可以发现，当前系统已经默认使用Bash作为命令行终端解释器了：

```
[root@linuxprobe ~]# echo $SHELL
/bin/bash
```

###### **4.2.1 编写简单的脚本**

估计读者在看完上文中有关Shell脚本的复杂描述后，会累觉不爱吧。但是，上文指的是一个高级Shell脚本的编写原则，其实使用Vim编辑器把Linux命令按照顺序依次写入到一个文件中，就是一个简单的脚本了。

例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：

```
[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
#For Example BY linuxprobe.com 
pwd 
ls -al
```

Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以表示是一个脚本文件。

在上面的这个example.sh脚本中实际上出现了3种不同的元素：第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的Linux命令了。你们不相信这么简单就编写出来了一个脚本程序？！那我们来执行一下看看结果：

```
[root@linuxprobe ~]# bash example.sh
/root
total 60
dr-xr-x---. 15 root root  4096 Oct 12 00:41 .
dr-xr-xr-x. 17 root root   224 Jul 21 05:04 ..
-rw-------.  1 root root  1407 Jul 21 05:09 anaconda-ks.cfg
-rw-------.  1 root root   335 Jul 24 06:33 .bash_history
-rw-r--r--.  1 root root    18 Aug 13  2018 .bash_logout
-rw-r--r--.  1 root root   176 Aug 13  2018 .bash_profile
………………省略部分输出信息………………
```

除了上面用Bash解释器命令直接运行Shell脚本文件外，第二种运行脚本程序的方法是通过输入完整路径的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚本文件增加执行权限即可（详见第5章）。初次学习Linux系统的读者不用心急，等下一章学完用户身份和权限后再来做这个实验也不迟：

```
[root@linuxprobe ~]# ./example.sh
bash: ./Example.sh: Permission denied
[root@linuxprobe ~]# chmod u+x example.sh
[root@linuxprobe ~]# ./example.sh
/root
total 60
dr-xr-x---. 15 root root  4096 Oct 12 00:41 .
dr-xr-xr-x. 17 root root   224 Jul 21 05:04 ..
-rw-------.  1 root root  1407 Jul 21 05:09 anaconda-ks.cfg
-rw-------.  1 root root   335 Jul 24 06:33 .bash_history
-rw-r--r--.  1 root root    18 Aug 13  2018 .bash_logout
-rw-r--r--.  1 root root   176 Aug 13  2018 .bash_profile
………………省略部分输出信息………………
```

###### **4.2.2 接收用户的参数**

但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板。为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。

比如，当用户执行某一个命令时，加或不加参数的输出结果是不同的：

```
[root@linuxprobe ~]# wc -l anaconda-ks.cfg 
44 anaconda-ks.cfg
[root@linuxprobe ~]# wc -c anaconda-ks.cfg 
1407 anaconda-ks.cfg
[root@linuxprobe ~]# wc -w anaconda-ks.cfg 
121 anaconda-ks.cfg
```

这意味着命令不仅要能接收用户输入的内容，还要有能力进行判断区别，根据不同的输入调用不同的功能。

其实，Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间使用空格间隔。例如，$0对应的是当前Shell脚本程序的名称，$#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第*N*个位置的参数值，如图4-15所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/Shell脚本程序中的参数位置变量.png)

图4-15 Shell脚本程序中的参数位置变量

理论过后再来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看一下真实效果：

```
[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第1个参数为$1，第5个为$5。"
[root@linuxprobe ~]# bash example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
```

###### **4.2.3 判断用户的参数**

学习是一个登堂入室、由浅入深的过程。在学习完Linux命令，掌握Shell脚本语法变量和接收用户输入的信息之后，就要踏上新的高度—能够进一步处理接收到的用户参数。

本书在前面章节中讲到，系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回非零值。条件测试语法的执行格式如图4-16所示。切记，条件表达式两边均应有一个空格。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/测试语句格式.png)

图4-16 条件测试语句的执行格式

------

按照测试对象来划分，条件测试语句可以分为4种：

> 文件测试语句；
>
> 逻辑测试语句；
>
> 整数值比较语句；
>
> 字符串比较语句。

文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表4-3所示。

表4-3                          文件测试所用的参数

| 操作符 | 作用                       |
| ------ | -------------------------- |
| -d     | 测试文件是否为目录类型     |
| -e     | 测试文件是否存在           |
| -f     | 判断是否为一般文件         |
| -r     | 测试当前用户是否有权限读取 |
| -w     | 测试当前用户是否有权限写入 |
| -x     | 测试当前用户是否有权限执行 |



下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着它不是目录，或这个目录不存在：

```
[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
```

再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件：

```
[root@linuxprobe ~]# [ -f /etc/fstab ]
[root@linuxprobe ~]# echo $?
0
```

判断与查询一定要敲两次命令吗？其实可以一次搞定。

逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&&，它表示当前面的命令执行成功后才会执行它后面的命令，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。

```
[root@linuxprobe ~]# [ -e /dev/cdrom ] && echo "Exist"
Exist
```

除了逻辑“与”外，还有逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的命令执行失败后才会执行它后面的命令，因此可以用来结合系统环境变量USER来判断当前登录的用户是否为非管理员身份：

```
[root@linuxprobe ~]# echo $USER
root
[root@linuxprobe ~]# [ $USER = root ] || echo "user"
[root@linuxprobe ~]# su - linuxprobe 
[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo "user"
user
```

第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果，则将其变成正确的。

我们现在切换回到root管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：

```
[linuxprobe@linuxprobe ~]$ exit
logout
[root@linuxprobe ~]# [ ! $USER = root ] || echo "administrator"
administrator
```

叹号应该放到判断语句的前面，代表对整个的测试语句进行取反值操作，而不应该写成“$USER != root”，因为“!=”代表的是不等于符号（≠），尽管执行效果一样，但缺少了逻辑关系，这一点还请多加注意。

### **Tips**

&&是逻辑“与”，只有当前面的语句执行成功的时候才会执行后面的语句。
 ||是逻辑“或”，只有当前面的语句执行失败的时候才会执行后面的语句。
 !是逻辑“非”，代表对逻辑测试结果取反值；之前若为正确则变成错误，若为错误则变成正确。

就技术图书的写作来讲，一般有两种套路：让读者真正搞懂技术了；让读者觉得自己搞懂技术了。因此市面上很多浅显的图书会让读者在学完之后感觉进步特别快，这基本上是作者有意为之，目的就是让您觉得“图书很有料，自己收获很大”，但是在步入工作岗位后就露出短板吃大亏。所以刘遄老师决定继续提高难度，为读者增加一个综合的示例，一方面作为前述知识的总结，另一方面帮助读者夯实基础，以便在今后的工作中更灵活地使用逻辑符号。

当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的USER变量名称是否等于root，然后用逻辑“非”运算符进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户。最后若条件成立，则会根据逻辑“与”运算符输出user字样；若条件不满足，则会通过逻辑“或”运算符输出root字样，而只有在前面的&&不成立时才会执行后面的||符号。

```
[root@linuxprobe ~]# [ ! $USER = root ] && echo "user" || echo "root"
root
```

------

整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表4-4所示。

表4-4                         可用的整数比较运算符

| 操作符 | 作用           |
| ------ | -------------- |
| -eq    | 是否等于       |
| -ne    | 是否不等于     |
| -gt    | 是否大于       |
| -lt    | 是否小于       |
| -le    | 是否等于或小于 |
| -ge    | 是否大于或等于 |



接下来小试牛刀。先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：

```
[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0
```

在2.4节曾经讲过free命令，它能够用来获取当前系统正在使用及可用的内存量信息。接下来先使用free  -m命令查看内存使用量情况（单位为MB），然后通过“grep Mem:”命令过滤出剩余内存量的行，再用awk '{print  $4}'命令只保留第4列。这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。

```
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1374         128          16         463         397
Swap:          2047          66        1981
[root@linuxprobe ~]# free -m | grep Mem:
Mem:           1966        1374         128          16         463         397
[root@linuxprobe ~]# free -m | grep Mem: | awk '{print $4}'
128
```

如果想把这个命令写入到Shell脚本中，那么建议把输出结果赋值给一个变量，以方便其他命令进行调用：

```
[root@linuxprobe ~]# FreeMem=`free -m | grep Mem: | awk '{print $4}'`
[root@linuxprobe ~]# echo $FreeMem 
128
```

上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：

```
[root@linuxprobe ~]# [ $FreeMem -lt 1024 ] && echo "Insufficient Memory"
Insufficient Memory
```

字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表4-5所示。

表4-5                        常见的字符串比较运算符

| 操作符 | 作用                   |
| ------ | ---------------------- |
| =      | 比较字符串内容是否相同 |
| !=     | 比较字符串内容是否不同 |
| -z     | 判断字符串内容是否为空 |



接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：

```
[root@linuxprobe ~]# [ -z $String ]
[root@linuxprobe ~]# echo $?
0
```

再次尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样：

```
[root@linuxprobe ~]# echo $LANG
en_US.UTF-8
[root@linuxprobe ~]# [ ! $LANG = "en.US" ] && echo "Not en.US"
Not en.US
```

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

##### **4.3 流程控制语句**

尽管此时可以通过使用Linux命令、管道符、重定向以及条件测试语句来编写最基本的Shell脚本，但是这种脚本并不适用于生产环境。原因是它不能根据真实的工作需求来调整具体的执行命令，也不能根据某些条件实现自动循环执行。通俗来讲，就是不能根据实际情况做出调整。

通常脚本都是从上到下一股脑儿地执行，效率是很高，但一旦某条命令执行失败了，则后面的功能全都会受到影响。假如大家有一天遇到了心仪的他（她），心中默默地进行如下规划（见图4-17）。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/Shell脚本流程图-2.jpg)

图4-17 心中规划

结果可能是见面聊天后就觉得不合适了，后续的“要手机号码”“一起吃晚饭”和“一起看电影”就要终止了，就需要转而去做其他事情，因此需要判断语句来帮助完成。

接下来我们通过if、for、while、case这4种流程控制语句来学习编写难度更大、功能更强的Shell脚本。为了保证下文的实用性和趣味性，做到寓教于乐，我会尽可能多地讲解各种不同功能的Shell脚本示例，而不是逮住一个脚本不放，在它原有内容的基础上修修补补。尽管这种修补式的示例教学也可以让读者明白理论知识，但是却无法开放思路，不利于日后的工作。

###### **4.3.1 if条件测试语句**

if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。

if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图4-18所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/单分支的if语句.png)

图4-18 单分支的if条件语句

下面使用单分支的if条件语句来判断/media/cdrom目录是否存在，若不存在就创建这个目录，反之则结束条件判断和整个Shell脚本的执行。

```
[root@linuxprobe ~]# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -d $DIR ]
then    
        mkdir -p $DIR
fi 
```

由于第5章才讲解用户身份与权限，因此这里继续用“bash脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用ls命令验证/media/cdrom目录是否已经成功创建：

```
[root@linuxprobe ~]# bash mkcdrom.sh
[root@linuxprobe ~]# ls -ld /media/cdrom
drwxr-xr-x. 2 root root 6 Oct 13 21:34 /media/cdrom
```

------

if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图4-19所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/双分支结构-1.png)

图4-19 双分支的if条件语句

下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络连通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。

```
[root@linuxprobe ~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
        echo "Host $1 is On-line."
else
        echo "Host $1 is Off-line."
fi
```

我们在4.2.3节中用过$?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则$?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：

```
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
```

if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图4-20所示。

下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一些提示信息。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/多分支的if条件语句.png)

图 4-20 多分支的if条件语句

在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分时，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：

```
[root@linuxprobe ~]# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then
        echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then
        echo "$GRADE is Pass"
else
        echo "$GRADE is Fail" 
fi
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@linuxprobe ~]# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass
```

下面执行该脚本。当用户输入的分数分别为30和200时，其结果如下：

```
[root@linuxprobe ~]# bash chkscore.sh  
Enter your score（0-100）：30
30 is Fail
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：200 
200 is Fail
```

为什么输入的分数为200时，依然显示Fail呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于100或小于0的分数时，给予Error报错字样的提示。

###### **4.3.2 for条件循环语句**

for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当要处理的数据有范围时，使用for循环语句就再适合不过了。for循环语句的语法格式如图4-21所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/for条件语句-1.png)

图4-21 for范围循环语句

下面使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数：

```
[root@linuxprobe ~]# vim users.txt
andy
barry
carl
duke
eric
george
```

接下来编写Shell脚本addusers.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。

```
[root@linuxprobe ~]# vim addusers.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
        id $UNAME &> /dev/null
        if [ $? -eq 0 ]
        then
                echo "$UNAME , Already exists"
        else
                useradd $UNAME
                echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
                echo "$UNAME , Create success"
        fi
done
```

### **Tips**

/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。

执行批量创建用户的Shell脚本addusers.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。

在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。

```
[root@linuxprobe ~]# bash addusers.sh
Enter The Users Password : linuxprobe
andy , Create success
barry , Create success
carl , Create success
duke , Create success
eric , Create success
george , Create success
[root@linuxprobe ~]# tail -6 /etc/passwd
andy:x:1001:1001::/home/andy:/bin/bash
barry:x:1002:1002::/home/barry:/bin/bash
carl:x:1003:1003::/home/carl:/bin/bash
duke:x:1004:1004::/home/duke:/bin/bash
eric:x:1005:1005::/home/eric:/bin/bash
george:x:1006:1006::/home/george:/bin/bash
```

大家还记得在学习双分支if条件语句时，用到的那个测试主机是否在线的脚本么？既然我们现在已经掌握了for循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。

首先创建一个主机列表文件ipaddrs.txt：

```
[root@linuxprobe ~]# vim ipaddrs.txt
192.168.10.10
192.168.10.11
192.168.10.12
```

然后将前面的双分支if条件语句与for循环语句相结合，让脚本从主机列表文件ipaddrs.txt中自动读取IP地址（用来表示主机）并将其赋值给HLIST变量，从而通过判断ping命令执行后的返回值来逐个测试主机是否在线。脚本中出现的“$（命令）”是一种完全类似于第3章的转义字符中反引号`命令`的Shell操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：

```
[root@linuxprobe ~]# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipaddrs.txt)
for IP in $HLIST
do
        ping -c 3 -i 0.2 -W 3 $IP &> /dev/null
        if [ $? -eq 0 ]  
        then
                echo "Host $IP is On-line."
        else
                echo "Host $IP is Off-line."
        fi
done
[root@linuxprobe ~]# ./CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.
```

细心的读者应该发现了，Shell脚本中的代码缩进格式会根据不同的语句而改变。这是由Vim编辑器自动完成的，用户无须进行额外操作。但是，如果您使用的是RHEL 7以前的版本，则没有这个自动缩进功能，不过功能不受影响，只是会影响阅读体验而已。

###### **4.3.3 while条件循环语句**

while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图4-22所示。![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/07/while条件语句-1.png)

图4-22 while条件循环语句

接下来结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），然后将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为3种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，才运行exit 0命令，终止脚本的执行。

```
[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
        read -p "请输入您猜测的价格数目：" INT
        let TIMES++
        if [ $INT -eq $PRICE ] ; then
                echo "恭喜您答对了，实际价格是 $PRICE"
                echo "您总共猜测了 $TIMES 次"
                exit
        elif [ $INT -gt $PRICE ] ; then
                echo "太高了！"
        else
                echo "太低了！"
        fi
done
```

在这个Guess.sh脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到let TIMES++命令时都会让TIMES变量内的数值加1，用来统计循环总计执行了多少次。这可以让用户得知在总共猜测了多少次之后，才猜对价格。

```
[root@linuxprobe ~]# bash Guess.sh
商品实际价格为0-999之间，猜猜看是多少？
请输入您猜测的价格数目：500
太低了！
请输入您猜测的价格数目：800
太高了！
请输入您猜测的价格数目：650
太低了！
请输入您猜测的价格数目：720
太高了！
请输入您猜测的价格数目：690
太低了！
请输入您猜测的价格数目：700
太高了！
请输入您猜测的价格数目：695
太高了！
请输入您猜测的价格数目：692
太高了！
请输入您猜测的价格数目：691
恭喜您答对了，实际价格是 691
您总共猜测了 9 次
```

当条件为true（真）的时候，while语句会一直循环下去，只有碰到exit才会结束，所以同学们一定要记得加上exit哦。

###### **4.3.4 case条件测试语句**

如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑：“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case语句的语法结构如图4-23所示。

![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2020/10/case条件测试语句的语法结构.png)

图4-23 case条件测试语句

在前文介绍的Guess.sh脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a是否大于等于3”这样的命题是完全错误的。必须有一定的措施来判断用户输入的内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。

通过在脚本中组合使用case条件测试语句和通配符（详见第3章），完全可以满足这里的需求。接下来我们编写脚本Checkkeys.sh，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。

```
[root@linuxprobe ~]# vim Checkkeys.sh
#!/bin/bash
read -p "请输入一个字符，并按Enter键确认：" KEY
case "$KEY" in
        [a-z]|[A-Z])
                echo "您输入的是 字母。"
                ;;
        [0-9])
                echo "您输入的是 数字。"
                ;;
        *)
                echo "您输入的是 空格、功能键或其他控制字符。"
esac
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：6
您输入的是 数字。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：p
您输入的是 字母。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：^[[15~
您输入的是 空格、功能键或其他控制字符。
```

##### **4.4 计划任务服务程序**

经验丰富的系统运维工程师可以使得Linux在无须人为介入的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，就太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成。

计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。

> **一次性计划任务**：今晚23:30重启网站服务。
>
> **长期性计划任务**：每周一的凌晨3:25把/home/wwwroot目录打包备份为backup.tar.gz。

顾名思义，一次性计划任务只执行一次，一般用于临时的工作需求。可以用at命令实现这种功能，只需要写成“at时间”的形式就行。如果想要查看已设置好但还未执行的一次性计划任务，可以使用at -l命令；要想将其删除，可以使用“atrm任务序号”。at命令中的参数及其作用如表4-6所示。

表4-6                        at命令的参数及其作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| -f   | 指定包含命令的任务文件 |
| -q   | 指定新任务名称         |
| -l   | 显示待执行任务列表     |
| -d   | 删除指定待执行任务     |
| -m   | 任务执行后给用户发邮件 |



在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系统设置为在今晚23:30自动重启网站服务。

```
[root@linuxprobe ~]# at 23:30
warning: commands will be executed using /bin/sh
at> systemctl restart httpd
at> 此处请同时按下<Ctrl>+<d>键来结束编写计划任务
job 1 at Wed Oct 14 23:30:00 2020
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
```

看到warning提醒信息不要慌，at命令只是在告诉我们接下来的任务将由sh解释器负责执行。这与此前学习的Bash解释器基本一致，不需要有额外的操作。

另外，如果大家想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。

```
[root@linuxprobe ~]# echo "systemctl restart httpd" | at 23:30
warning: commands will be executed using /bin/sh
job 2 at Wed Oct 14 23:30:00 2020
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
2 Wed Oct 14 23:30:00 2020 a root
```

上面设置了两条一样的计划任务，可以使用atrm命令轻松删除其中一条：

```
[root@linuxprobe ~]# atrm 2
[root@linuxprobe ~]# at -l
1 Wed Oct 14 23:30:00 2020 a root
```

这里还有一种特殊场景—把计划任务写入Shell脚本中，当用户激活该脚本后再开始倒计时执行，而不是像上面那样在固定的时间（“at 23:30”命令）进行。这该怎么办呢？

一般我们会使用“at now +2 MINUTE”的方式进行操作，这表示2分钟（MINUTE）后执行这个任务，也可以将其替代成小时（HOUR）、日（DAY）、月（MONTH）等词汇：

```
[root@linuxprobe ~]# at now +2 MINUTE
warning: commands will be executed using /bin/sh
at> systemctl restart httpd
at> 此处请同时按下<Ctrl>+<d>键来结束编写计划任务
job 3 at Wed Oct 14 22:50:00 2020
```

------

还有些时候，我们希望Linux系统能够周期性地、有规律地执行某些具体的任务，那么Linux系统中默认启用的crond服务简直再适合不过了。创建、编辑计划任务的命令为crontab -e，查看当前计划任务的命令为crontab -l，删除某条计划任务的命令为crontab  -r。另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务。crontab命令中的参数及其作用如表4-7所示。

表4-7                        crontab命令的参数及其作用

| 参数 | 作用         |
| ---- | ------------ |
| -e   | 编辑计划任务 |
| -u   | 指定用户名称 |
| -l   | 列出任务列表 |
| -r   | 删除计划任务 |



在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式（其格式见表4-8）。需要注意的是，如果有些字段没有被设置，则需要使用星号（*****）占位，如图4-24所示。![第4章 Vim编辑器与Shell命令脚本第4章 Vim编辑器与Shell命令脚本](https://www.linuxprobe.com/wp-content/uploads/2015/02/cron计划任务的参数.png)

图4-24 使用crond设置任务的参数格式

表4-8                    使用crond设置任务的参数字段说明

| 字段 | 说明                                     |
| ---- | ---------------------------------------- |
| 分钟 | 取值为0～59的整数                        |
| 小时 | 取值为0～23的任意整数                    |
| 日期 | 取值为1～31的任意整数                    |
| 月份 | 取值为1～12的任意整数                    |
| 星期 | 取值为0～7的任意整数，其中0与7均为星期日 |
| 命令 | 要执行的命令或程序脚本                   |



假设在每周一、三、五的凌晨3:25，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。我们可以使用crontab -e命令来创建计划任务，为自己创建计划任务时无须使用-u参数。crontab –e命令的具体实现效果和crontab -l命令的结果如下所示：

```
[root@linuxprobe ~]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
```

需要说明的是，除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示8月、9月和12月。还可以用减号（-）来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。还可以用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔2分钟执行一次任务）。

如果在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再添加一条计划任务，它的功能是每周一至周五的凌晨1点自动清空/tmp目录内的所有文件。尤其需要注意的是，在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询。rm命令的路径为下面输出信息中的加粗部分。

```
[root@linuxprobe ~]# whereis rm
rm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz
[root@linuxprobe ~]# crontab -e
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
0  1 * * 1-5   /usr/bin/rm -rf /tmp/*
```

总结一下使用计划服务的注意事项。

> 在crond服务的配置参数中，一般会像Shell脚本那样以#号开头写上注释信息，这样在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。
>
> 计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。

删除crond计划任务则非常简单，直接使用crontab -e命令进入编辑界面，删除里面的文本信息即可。也可以使用crontab -r命令直接进行删除：

```
[root@linuxprobe ~]# crontab -r
[root@linuxprobe ~]# crontab -l
no crontab for root
```

最后再啰唆一句，想必读者也已经发现了，诸如crond在内的很多服务默认调用的是Vim编辑器，相信大家现在能进一步体会到在Linux系统中掌握Vim文本编辑器的好处了吧。所以请大家一定要在彻底掌握Vim编码器之后再学习下一章。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．Vim编辑器的3种模式分别是什么？

**答：**命令模式、末行模式与输入模式（也叫编辑模式或插入模式）。

2．怎么从输入模式切换到末行模式？

**答：**需要先敲击Esc键退回到命令模式，然后敲击冒号（:）键后进入末行模式。

3．一个完整的Shell脚本应该包含哪些内容？

**答：**应该包括脚本声明、注释信息和可执行语句（即命令）。

4．分别解释Shell脚本中$0与$3变量的作用。

**答：**在Shell脚本中，$0代表脚本文件的名称，$3则代表该脚本在执行时接收的第3个参数。

5．if条件测试语句有几种结构，最灵活且最复杂的是哪种结构？

**答：**if条件测试语句包括单分支、双分支与多分支等3种结构，其中多分支结构是最灵活且最复杂的结构，其结构形式为if…then…elif…then…else…fi。

6．for条件循环语句的循环结构是什么样子的？

**答：**for条件循环语句的结构为“for变量名in取值列表do命令序列done”，如图4-21所示。

7．若在while条件循环语句中使用true作为循环条件，那么会发生什么事情？

**答：**由于条件测试值永久为true，因此脚本中的循环部分会无限地重复执行下去，直到碰到exit命令才会结束。

8．如果需要依据用户的输入参数执行不同的操作，最方便的条件测试语句是什么？

**答：**case条件语句。

9．Linux系统的长期计划任务所使用的服务是什么，其参数格式是什么？

**答：**长期计划任务需要使用crond服务程序，参数格式是“分、时、日、月、星期 命令”。

本文原创地址：https://www.linuxprobe.com/basic-learning-04.html编辑：刘遄，审核员：暂

# [第5章 用户身份与文件权限](https://www.linuxprobe.com/basic-learning-05.html)

​		

[![img](https://www.linuxprobe.com/imgs/peixun.jpg)](https://www.linuxprobe.com/training)

**Linux系统技术交流QQ群（3963859）验证问题答案：刘遄**[![Linux就该这么学](https://www.linuxprobe.com/wp-content/uploads/2018/02/QQ群.png)](https://www.linuxprobe.com/links/qun.html)

**章节简述：**

[Linux](https://www.linuxprobe.com/)是一个多用户、多任务的操作系统，具有很好的稳定性与安全性，在幕后保障[Linux系统](https://www.linuxprobe.com/)的安全则是一系列复杂的配置工作。本章将详细讲解文件的所有者、所属组以及其他人可对文件进行的读（r）、写（w）、执行（x）等操作，还将介绍如何在Linux系统中添加、删除、修改用户账户信息。

我们还可以使用SUID、SGID与SBIT特殊权限更加灵活地设置系统权限，来弥补对文件设置一般操作权限时所带来的不足。隐藏权限能够给系统增加一层隐形的防护层，让黑客最多只能查看关键日志信息，而不能篡改或删除。而文件访问控制列表（Access Control List，ACL）可以进一步让单一用户、用户组对单一文件或目录进行特殊的权限设置，让文件具有能满足工作需求的最小权限。

本章最后还会讲解如何使用su[命令](https://www.linuxcool.com/)与sudo服务让普通用户具备管理员的权限，这不仅能够满足日常的工作需求，还可以确保系统的安全性。

本章目录结构

- [5.1 用户身份与能力](https://www.linuxprobe.com/basic-learning-05.html#51)
- [5.2 文件权限与归属](https://www.linuxprobe.com/basic-learning-05.html#52)
- [5.3 文件的特殊权限](https://www.linuxprobe.com/basic-learning-05.html#53)
- [5.4 文件的隐藏属性](https://www.linuxprobe.com/basic-learning-05.html#54)
- [5.5 文件访问控制列表](https://www.linuxprobe.com/basic-learning-05.html#55)
- [5.6 su命令与sudo服务](https://www.linuxprobe.com/basic-learning-05.html#56_susudo)

##### **5.1 用户身份与能力**

受到20世纪70年代计算机发展的影响，Linux系统的设计初衷之一就是为了满足多个用户同时工作的需求，因此必须具备很好的安全性，尤其是不能因为一两个服务出错而影响到整台服务器。在第1章学习安装Linux操作系统时，特别要求设置root管理员的密码，这个root管理员就是存在于所有类UNIX系统中的超级用户。它拥有最高的系统所有权，能够管理系统的各项功能，如添加/删除用户、启动/关闭服务进程、开启/禁用硬件设备等。虽然以root管理员的身份工作时不会受到系统的限制，但俗话讲“能力越大，责任就越大”，因此一旦使用这个高能的root管理员权限执行了错误的[命令](https://www.linuxcool.com/)，可能会直接毁掉整个系统。使用与否，确实需要好好权衡一下。

在学习时是否要使用root管理员权限来控制整个系统呢？对于这个问题，网络上有很多文章建议以普通用户的身份来操作—这是一个更安全也更“无责任”的回答。今天，[刘遄](https://www.linuxprobe.com/)老师就要冒天下之大不韪给出自己的心得—强烈推荐大家在学习时使用root管理员权限！

这种为root管理员正名的决绝态度在网络中应该还是很少见的，我之所以力荐root管理员权限，原因很简单。因为在Linux的学习过程中如果使用普通用户身份进行操作，则在配置服务之后出现错误时很难判断是系统自身的问题还是因为权限不足而导致的；这无疑会给大家的学习过程徒增坎坷。更何况我们的实验环境是使用VMware虚拟机软件搭建的，可以将安装好的系统设置为一次快照，这样即便系统彻底崩溃了，也可以在5秒的时间内快速还原出一台全新的系统，而不用担心数据丢失。

总之，[刘遄](https://www.linuxprobe.com/)老师在培训时都推荐每位学生使用root管理员权限来学习Linux系统，等到工作时再根据生产环境决定使用哪个用户权限；这些仅与选择相关，而非技术性问题。

另外，很多图书或培训机构的老师会讲到，Linux系统中的管理员就是root。这其实是错误的，Linux系统的管理员之所以是root，并不是因为它的名字叫root，而是因为该用户的身份号码即UID（User  IDentification）的数值为0。在Linux系统中，UID就像我们的身份证号码一样具有唯一性，因此可通过用户的UID值来判断用户身份。在RHEL 8系统中，用户身份有下面这些。

> **管理员UID为0**：系统的管理员用户。
>
> **系统用户UID为1～999**：Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会由独立的系统用户负责运行，进而有效控制被破坏范围。
>
> **普通用户UID从1000开始**：是由管理员创建的用于日常工作的用户。

需要注意的是，UID是不能冲突的，而且管理员创建的普通用户的UID默认是从1000开始的（即使前面有闲置的号码）。

为了方便管理属于同一组的用户，Linux系统中还引入了用户组的概念。通过使用用户组号码（GID，Group  IDentification），可以把多个用户加入到同一个组中，从而方便为组中的用户统一规划权限或指定任务。假设一个公司中有多个部门，每个部门中又有很多员工，如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。

另外，在Linux系统中创建每个用户时，将自动创建一个与其同名的基本用户组，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为扩展用户组。一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。

### **Tips**

基本用户组就像是原生家庭，是在创建账号（出生）时就自动生成的；而扩展用户组则像工作单位，为了完成工作，需要加入到各个不同的群体中，这是需要手动添加的。

**1.  id命令**

id命令用于显示用户的详细信息，语法格式为“id用户名”。

这个id命令是一个在创建用户前需要仔细学习的命令，它能够简单轻松地查看用户的基本信息，例如用户ID、基本组与扩展组GID，以便于我们判别某个用户是否已经存在，以及查看相关信息。

下面使用id命令查看一个名称为linuxprobe的用户信息：

```
[root@linuxprobe ~]# id linuxprobe
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe)
```

**2.  useradd命令**

useradd命令用于创建新的用户账户，语法格式为“useradd [参数] 用户名”。

可以使用useradd命令创建用户账户。使用该命令创建用户账户时，默认的用户家目录会被存放在/home目录中，默认的[Shell](https://www.linuxcool.com/)解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组。这些默认设置可以根据表5-1中的useradd命令参数自行修改。

表5-1                    useradd命令中的参数以及作用

| 参数 | 作用                                     |
| ---- | ---------------------------------------- |
| -d   | 指定用户的家目录（默认为/home/username） |
| -e   | 账户的到期时间，格式为YYYY-MM-DD.        |
| -u   | 指定该用户的默认UID                      |
| -g   | 指定一个初始的用户基本组（必须已存在）   |
| -G   | 指定一个或多个扩展用户组                 |
| -N   | 不创建与用户同名的基本用户组             |
| -s   | 指定该用户的默认Shell解释器              |



下面使用useradd命令创建一个名称为linuxcool的用户，并使用id命令确认信息：

```
[root@linuxprobe ~]# useradd linuxcool
[root@linuxprobe ~]# id linuxcool
uid=1001(linuxcool) gid=1001(linuxcool) groups=1001(linuxcool)
```

下面我们提高难度，创建一个普通用户并指定家目录的路径、用户的UID以及Shell解释器。在下面的命令中，请注意/sbin/nologin，它是终端解释器中的一员，与Bash解释器有着天壤之别。一旦用户的解释器被设置为nologin，则代表该用户不能登录到系统中：

```
[root@linuxprobe ~]# useradd -d /home/linux -u 8888 -s /sbin/nologin linuxdown
[root@linuxprobe ~]# id linuxdown
uid=8888(linuxdown) gid=8888(linuxdown) groups=8888(linuxdown)
```

**3.  groupadd命令**

groupadd命令用于创建新的用户组，语法格式为“groupadd [参数] 群组名”。

为了能够更加高效地指派系统中各个用户的权限，在工作中常常会把几个用户加入到同一个组里面，这样便可以针对一类用户统一安排权限。例如在工作中成立一个部门组，当有新的同事加入时就把他的账号添加到这个部门组中，这样新同事的权限就自动跟其他同事一模一样了，从而省去了一系列烦琐的操作。

创建用户组的步骤非常简单，例如使用如下命令创建一个用户组ronny：

```
[root@linuxprobe ~]# groupadd ronny
```

**4.  usermod命令**

usermod命令用于修改用户的属性，英文全称为“user modify”，语法格式为“usermod [参数] 用户名”。

前文曾反复强调，Linux系统中的一切都是文件，因此在系统中创建用户也就是修改配置文件的过程。用户的信息保存在/etc/passwd文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以用usermod命令修改已经创建的用户信息，比如用户的UID、基本/扩展用户组、默认终端等。usermod命令的参数以及作用如表5-2所示。

表5-2                      usermod命令中的参数以及作用

| 参数  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| -c    | 填写用户账户的备注信息                                       |
| -d -m | 参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去 |
| -e    | 账户的到期时间，格式为YYYY-MM-DD                             |
| -g    | 变更所属用户组                                               |
| -G    | 变更扩展用户组                                               |
| -L    | 锁定用户禁止其登录系统                                       |
| -U    | 解锁用户，允许其登录系统                                     |
| -s    | 变更默认终端                                                 |
| -u    | 修改用户的UID                                                |



大家不要被这么多参数吓坏了。我们先来看一下账户linuxprobe的默认信息：

```
[root@linuxprobe ~]# id linuxprobe
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe)
```

然后将用户linuxprobe加入到root用户组中，这样扩展组列表中则会出现root用户组的字样，而基本组不会受到影响：

```
[root@linuxprobe ~]# usermod -G root linuxprobe
[root@linuxprobe ~]# id linuxprobe
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe),0(root)
```

再来试试用-u参数修改linuxprobe用户的UID号码值：

```
[root@linuxprobe ~]# usermod -u 8888 linuxprobe
[root@linuxprobe ~]# id linuxprobe
uid=8888(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe),0(root)
```

除此之外，同学们最关心的肯定是如果把用户的解释器终端由默认的/bin/bash修改为/sbin/nologin后会有什么样的效果呢？我们来试试吧：

```
[root@linuxprobe ~]# usermod -s /sbin/nologin linuxprobe
[root@linuxprobe ~]# su - linuxprobe
This account is currently not available.
```

效果很直观！将用户的终端设置成/sbin/nologin后用户马上就不能登录了（切换身份也不行），但这个用户依然可以被某个服务所调用，管理某个具体的服务。这样的好处是当黑客通过这个服务入侵成功后，破坏的范围也仅仅局限于这个特定的服务，而不能使用这个用户身份登录到整台服务器上，从而尽可能地把损失降至最小化。

**5.  passwd命令**

passwd命令用于修改用户的密码、过期时间等信息，英文全称为“password”，语法格式为“passwd [参数] 用户名”。

普通用户只能使用passwd命令修改自己的系统密码，而root管理员则有权限修改其他所有人的密码。更酷的是，root管理员在Linux系统中修改自己或他人的密码时不需要验证旧密码，这一点特别方便。既然root管理员能够修改其他用户的密码，就表示其完全拥有该用户的管理权限。passwd命令中的参数以及作用如表5-3所示。

表5-3                      passwd命令中的参数以及作用

| 参数    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| -l      | 锁定用户，禁止其登录                                         |
| -u      | 解除锁定，允许用户登录                                       |
| --stdin | 允许通过标准输入修改用户密码，如echo "NewPassWord" \| passwd --stdin Username |
| -d      | 使该用户可用空密码登录系统                                   |
| -e      | 强制用户在下次登录时修改密码                                 |
| -S      | 显示用户的密码是否被锁定，以及密码所采用的加密算法名称       |



要修改自己的密码，只需要输入命令后敲击回车键即可：

```
[root@linuxprobe ~]# passwd
Changing password for user root.
New password: 此处输入密码值
Retype new password: 再次输入进行确认
passwd: all authentication tokens updated successfully.
```

要修改其他人的密码，则需要先检查当前是否为root管理员权限，然后在命令后指定要修改密码的那位用户的名称：

```
[root@linuxprobe ~]# passwd linuxprobe
Changing password for user linuxprobe.
New password:此处输入密码值
Retype new password: 再次输入进行确认
passwd: all authentication tokens updated successfully.
```

假设您有位同事正在度假，而且假期很长，那么可以使用passwd命令禁止该用户登录系统，等假期结束回归工作岗位时，再使用该命令允许用户登录系统，而不是将其删除。这样既保证了这段时间内系统的安全，也避免了频繁添加、删除用户带来的麻烦：

```
[root@linuxprobe ~]# passwd -l linuxprobe
Locking password for user linuxprobe.
passwd: Success
[root@linuxprobe ~]# passwd -S linuxprobe
linuxprobe LK 1969-12-31 0 99999 7 -1 (Password locked.)
```

在解锁时，记得也要使用管理员的身份；否则，如果普通用户也有锁定权限，系统肯定会乱成一锅粥：

```
[root@linuxprobe ~]# passwd -u linuxprobe
Unlocking password for user linuxprobe.
passwd: Success
[root@linuxprobe ~]# passwd -S linuxprobe
linuxprobe PS 1969-12-31 0 99999 7 -1 (Password set, SHA512 crypt.)
```

**6.  userdel命令**

userdel命令用于删除已有的用户账户，英文全称为“user delete”，语法格式为“userdel [参数] 用户名”。

如果确认某位用户后续不会再登录到系统中，则可以通过userdel命令删除该用户的所有信息。在执行删除操作时，该用户的家目录默认会保留下来，此时可以使用-r参数将其删除。userdel命令的参数以及作用如表5-4所示。

表5-4                       userdel命令中的参数以及作用

| 参数 | 作用                     |
| ---- | ------------------------ |
| -f   | 强制删除用户             |
| -r   | 同时删除用户及用户家目录 |



在删除一个用户时，一般会建议保留他的家目录数据，以免有重要的数据被误删除。所以在使用userdel命令时可以不加参数，写清要删除的用户名称就行：

```
[root@linuxprobe ~]# userdel linuxprobe
[root@linuxprobe ~]# id linuxprobe
id: linuxprobe: no such user
```

虽然此时该用户已被删除，但家目录数据会继续存放在/home目录中，等确认未来不再使用时将其手动删除即可：

```
[root@linuxprobe ~]# cd /home
[root@linuxprobe home]# ls
linuxprobe linuxcool linuxdown
[root@linuxprobe home]# rm -rf linuxprobe
[root@linuxprobe home]# ls 
linuxcool linuxdown
```

##### **5.2 文件权限与归属**

在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个[脚本](https://www.linuxcool.com/)程序。但是，对于目录文件来说，理解其权限设置就不那么容易了。很多资深Linux用户其实也没有真正搞明白。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。

可读、可写、可执行权限对应的命令在文件和目录上是有区别的，具体可参考表5-5。

表5-5                       读写执行权限对于文件与目录可执行命令的区别

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/读写执行权限对于文件与目录的作用-1024x168.png)

文件的可读、可写、可执行权限的英文全称分别是read、write、execute，可以简写为r、w、x，亦可分别用数字4、2、1来表示，文件所有者、文件所属组及其他用户权限之间无关联，如表5-6所示。

表5-6                       文件权限的字符与数字表示

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/文件权限的字符与数字表示-1024x201.png)

文件权限的数字表示法基于字符（rwx）的权限计算而来，其目的是简化权限的表示方式。例如，若某个文件的权限为7，则代表可读、可写、可执行（4+2+1）；若权限为6，则代表可读、可写（4+2）。我们来看一个例子。现在有这样一个文件，其所有者拥有可读、可写、可执行的权限，其文件所属组拥有可读、可写的权限；其他人只有可读的权限。那么，这个文件的权限就是rwxrw-r--，数字法表示即为764。不过大家千万别再将这3个数字相加，计算出7+6+4=17的结果，这是小学的数学加减法，不是Linux系统的权限数字表示法，三者之间没有互通关系。

这里以rw-r-x-w-权限为例来介绍如何将字符表示的权限转换为数字表示的权限。首先，要将各个位上的字符替换为数字，如图5-1所示。

减号是占位符，代表这里没有权限，在数字表示法中用0表示。也就是说，rw-转换后是420，r-x转换后是401，-w-转换后是020。然后，将这3组数字之间的每组数字进行相加，得出652，这便是转换后的数字表示权限。

将数字表示权限转换回字母表示权限的难度相对来说就大一些了，这里以652权限为例进行讲解。首先，数字6是由4+2得到的，不可能是4+1+1（因为每个权限只会出现一次，不可能同时有两个x执行权限）；数字5则是4+1得到的；数字2是本身，没有权限即是空值0。接下来按照表5-6所示的格式进行书写，得到420401020这样一串数字。有了这些信息就好办了，就可以把这串数字转换成字母了，如图5-2所示。

大家一定要心中牢记，文件的所有者、所属组和其他用户的权限之间无关联。一定不要写成rrwwx----的样子，一定要把rwx权限位对应到正确的位置，写成rw-r-x-w-。

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/权限转换-300x136.jpg)

图5-1 字符与数字权限转换示意图

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/数字转换-300x136.jpg)

图5-2 数字与字符权限转换示意图

Linux系统的文件权限相当复杂，但是用途很广泛，建议大家把它彻底搞清楚之后再学习下一节的内容。现在来练习一下。请各位读者分别计算数字表示法764、652、153、731所对应的字符表示法，然后再把rwxrw-r--、rw--w--wx、rw-r--r--转换成数字表示法。

下面我们利用上文讲解的知识，一起分析图5-3中所示的文件信息。

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2015/02/文件权限.png)

图5-3 通过ls命令查看到的文件属性信息

在图5-3中，包含了文件的类型、访问权限、所有者（属主）、所属组（属组）、占用的磁盘大小、最后修改时间和文件名称等信息。通过分析可知，该文件的类型为普通文件，所有者权限为可读、可写（rw-），所属组权限为可读（r--），除此以外的其他人也只有可读权限（r--），文件的磁盘占用大小是34298字节，最近一次的修改时间为4月2日的0:23，文件的名称为install.log。

排在权限前面的减号（-）是文件类型（减号表示普通文件），新手经常会把它跟“无权限”混淆。尽管在Linux系统中一切都是文件，但是不同的文件由于作用不同，因此类型也不尽相同（有一点像Windows系统的后缀名）。常见的文件类型包括普通文件（-）、目录文件（d）、链接文件（l）、管道文件（p）、块设备文件（b）以及字符设备文件（c）。

普通文件的范围特别广泛，比如纯文本信息、服务配置信息、日志信息以及Shell[脚本](https://www.linuxcool.com/)等，都属于普通文件。几乎在每个目录下都能看到普通文件（-）和目录文件（d）的身影。块设备文件（b）和字符设备文件（c）一般是指硬件设备，比如鼠标、键盘、光驱、硬盘等，在/dev/目录中最为常见。应该很少有人会对鼠标、键盘进行硬件级别的管理吧。

##### **5.3 文件的特殊权限**

在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。

下面具体解释这3个特殊权限位的功能以及用法。

**1.  SUID**

SUID是一种对二进制程序进行设置的特殊权限，能够让二进制程序的执行者临时拥有所有者的权限（仅对拥有执行权限的二进制程序有效）。例如，所有用户都可以执行passwd命令来修改自己的用户密码，而用户密码保存在/etc/shadow文件中。仔细查看这个文件就会发现它的默认权限是000，也就是说除了root管理员以外，所有用户都没有查看或编辑该文件的权限。但是，在使用passwd命令时如果加上SUID特殊权限位，就可让普通用户临时获得程序所有者的身份，把变更的密码信息写入到shadow文件中。这很像在古装剧中见到的手持尚方宝剑的钦差大臣，他手持的尚方宝剑代表的是皇上的权威，因此可以惩戒贪官，但这并不意味着他永久成为了皇上。因此这只是一种有条件的、临时的特殊权限授权方法。

查看passwd命令属性时发现所有者的权限由rwx变成了rws，其中x改变成s就意味着该文件被赋予了SUID权限。另外有读者会好奇，那么如果原本的权限是rw-呢？如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。

```
[root@linuxprobe ~]# ls -l /etc/shadow
----------. 1 root root 1312 Jul 21 05:08 /etc/shadow
[root@linuxprobe ~]# ls -l /bin/passwd 
-rwsr-xr-x. 1 root root 34512 Aug 13 2018 /bin/passwd
```

### **Tips**

加粗显示的字体用来告诫用户一定要小心这个权限，因为一旦某个命令文件被设置了SUID权限，就意味着凡是执行该文件的人都可以临时获取到文件所有者所对应的更高权限。因此，千万不要将SUID权限设置到vim、cat、rm等命令上面！！！

**2.  SGID**

SGID特殊权限有两种应用场景：当对二进制程序进行设置时，能够让执行者临时获取文件所属组的权限；当对目录进行设置时，则是让目录内新创建的文件自动继承该目录原有用户组的名称。

SGID的第一种功能是参考SUID而设计的，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，而是获取到文件所属组的权限。举例来说，在早期的Linux系统中，/dev/kmem是一个字符设备文件，用于存储内核程序要访问的数据，权限为：

> **cr--r-----**  1 root system 2, 1 Feb 11 2017  kmem

大家看出问题了吗？除了root管理员或属于system组的成员外，所有用户都没有读取该文件的权限。由于在平时需要查看系统的进程状态，为了能够获取进程的状态信息，可在用于查看系统进程状态的ps命令文件上增加SGID特殊权限位。下面查看ps命令文件的属性信息：

> -r-xr-**s**r-x  1 bin system 59346 Feb 11 2017  ps

这样一来，由于ps命令被增加了SGID特殊权限位，所以当用户执行该命令时，也就临时获取到了system用户组的权限，从而顺利地读取到了设备文件。

前文提到，每个文件都有其归属的所有者和所属组，当创建或传送一个文件后，这个文件就会自动归属于执行这个操作的用户（即该用户是文件的所有者）。如果现在需要在一个部门内设置共享目录，让部门内的所有人员都能够读取目录中的内容，那么就可以在创建部门共享目录后，在该目录上设置SGID特殊权限位。这样，部门内的任何人员在里面创建的任何文件都会归属于该目录的所属组，而不再是自己的基本用户组。此时，用到的就是SGID的第二个功能，即在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。

```
[root@linuxprobe ~]# cd /tmp
[root@linuxprobe tmp]# mkdir testdir
[root@linuxprobe tmp]# ls -ald testdir
drwxr-xr-x. 2 root root 6 Oct 27 23:44 testdir
[root@linuxprobe tmp]# chmod -R 777 testdir
[root@linuxprobe tmp]# chmod -R g+s testdir
[root@linuxprobe tmp]# ls -ald testdir
drwxrwsrwx. 2 root root 6 Oct 27 23:44 testdir
```

在使用上述命令设置好目录的777权限（确保普通用户可以向其中写入文件），并为该目录设置了SGID特殊权限位后，就可以切换至一个普通用户，然后尝试在该目录中创建文件，并查看新创建的文件是否会继承新创建的文件所在的目录的所属组名称：

```
[root@linuxprobe tmp]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ cd /tmp/testdir
[linuxprobe@linuxprobe testdir]$ echo "linuxprobe.com" > test
[linuxprobe@linuxprobe testdir]$ ls -al test 
-rw-rw-r--. 1 linuxprobe root 15 Oct 27 23:47 test
```

除了上面提到的SGID的这两个功能，再介绍两个与本节内容相关的命令：chmod和chown。

chmod命令用于设置文件的一般权限及特殊权限，英文全称为“change mode”，语法格式为“chmod [参数] 文件名”。

这是一个与文件权限的日常设置强相关的命令。例如，要把一个文件的权限设置成其所有者可读可写可执行、所属组可读可写、其他人没有任何权限，则相应的字符法表示为rwxrw----，其对应的数字法表示为760。

```
[root@linuxprobe ~]# ls -l anaconda-ks.cfg 
-rw-------. 1 root root 1407 Jul 21 05:09 anaconda-ks.cfg
[root@linuxprobe ~]# chmod 760 anaconda-ks.cfg 
[root@linuxprobe ~]# ls -l anaconda-ks.cfg 
-rwxrw----. 1 root root 1407 Jul 21 05:09 anaconda-ks.cfg
```

chown命令用于设置文件的所有者和所有组，英文全称为change own，语法格式为“chown所有者:所有组 文件名”。

chmod和chown命令是用于修改文件属性和权限的最常用命令，它们还有一个特别的共性，就是针对目录进行操作时需要加上大写参数-R来表示递归操作，即对目录内所有的文件进行整体操作。

下面使用“所有者:所有组”的格式把前面那个文件的所属信息轻松修改一下，变更后的效果如下：

```
[root@linuxprobe ~]# chown linuxprobe:linuxprobe anaconda-ks.cfg 
[root@linuxprobe ~]# ls -l anaconda-ks.cfg 
-rwxrw----. 1 linuxprobe linuxprobe 1407 Jul 21 05:09 anaconda-ks.cfg
```

**3.  SBIT**

现在，大学里的很多老师都要求学生将作业上传到服务器的特定共享目录中，但总是有几个“破坏分子”喜欢删除其他同学的作业，这时就要设置SBIT（Sticky  Bit）特殊权限位了（也可以称之为特殊权限位之粘滞位）。SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。

最初不知道是哪位非资深技术人员将Sticky  Bit直译成了“粘滞位”，刘遄老师建议将其称为“保护位”，这既好记，又能立刻让人了解它的作用。RHEL  8系统中的/tmp作为一个共享文件的目录，默认已经设置了SBIT特殊权限位，因此除非是该目录的所有者，否则无法删除这里面的文件。

与前面所讲的SUID和SGID权限显示方法不同，当目录被设置SBIT特殊权限位后，文件的其他用户权限部分的x执行权限就会被替换成t或者T—原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。

由下可知，/tmp目录上的SBIT权限默认已经存在，这体现为“其他用户”权限字段的权限变为rwt：

```
[root@linuxprobe ~]# ls -ald /tmp
drwxrwxrwt. 17 root root 4096 Oct 28 00:29 /tmp
```

其实，文件能否被删除并不取决于自身的权限，而是看其所在目录是否有写入权限（其原理会在下一章讲到）。为了避免现在很多读者不放心，所以下面的命令还是赋予了这个test文件最大的777权限（rwxrwxrwx）：

```
[root@linuxprobe ~]# cd /tmp
[root@linuxprobe tmp]# echo "Welcome to linuxprobe.com" > test
[root@linuxprobe tmp]# chmod 777 test
[root@linuxprobe tmp]# ls -al test 
-rwxrwxrwx. 1 root root 26 Oct 29 14:29 test
```

随后，切换到一个普通用户身份下，尝试删除这个由其他人创建的文件，这时就会发现，即便读、写、执行权限全开，但是由于SBIT特殊权限位的缘故，依然无法删除该文件：

```
[root@linuxprobe tmp]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ cd /tmp
[linuxprobe@linuxprobe tmp]$ rm -f test
rm: cannot remove 'test': Operation not permitted
```

在工作中，若能善加使用特殊权限，就能实现很多巧妙的功能。使用chmod命令设置特殊权限的参数如表5-7所示。

表5-7                     SUID、SGID、SBIT特殊权限的设置参数

| 参数 | 作用         |
| ---- | ------------ |
| u+s  | 设置SUID权限 |
| u-s  | 取消SUID权限 |
| g+s  | 设置SGID权限 |
| g-s  | 取消SGID权限 |
| o+t  | 设置SBIT权限 |
| o-t  | 取消SBIT权限 |



切换回root管理员的身份下，在家目录中创建一个名为linux的新目录，随后为其设置SBIT权限：

```
[linuxprobe@linuxprobe tmp]$ exit
Logout
[root@linuxprobe tmp]# cd ~
[root@linuxprobe ~]# mkdir linux
[root@linuxprobe ~]# chmod -R o+t linux/
[root@linuxprobe ~]# ls -ld linux/
drwxr-xr-t. 2 root root 6 Feb 11 19:34 linux/
```

上述代码中的o+t参数是在一般权限已经设置完毕的前提下，又新增了一项特殊权限。如果我们想将一般权限和特殊权限一起设置，有什么高效率的方法么？

其实，SUID、SGID与SBIT也有对应的数字表示法，分别为4、2、1。也就是说777还不是最大权限，最大权限应该是7777，其中第1个数字代表的是特殊权限位。既然知道了数字表示法是由“特殊权限+一般权限”构成的，现在就以上面linux目录的权限为例，为大家梳理一下计算方法。

在rwxr-xr-t权限中，最后一位是t，这说明该文件的一般权限为rwxr-xr-x，并带有SBIT特殊权限。对于可读（r）、可写（w）、可执行（x）权限的数字计算方法大家应该很熟悉了—rwxr-xr-x即755，而SBIT特殊权限位是1，则合并后的结果为1755。

再增加点难度，如果权限是“rwsrwSr--”呢？首先不要慌，大写S表示原先没有执行权限，因此一般权限为rwxrw-r--，将其转换为数字表示法后结果是764。带有的SUID和SGID特殊权限的数字法表示是4和2，心算得出结果是6，合并后的结果为6764。这个示例确实难度大一些，大家可以学习参考图5-4的计算过程，在搞明白后再往下看。

将权限的数字表示法转换成字符表示法的难度略微高一些，这里以5537为例讲解。首先，特殊权限的5是由4+1组成的，意味着有SUID和SBIT。SUID和SGID的写法是，原先有执行权限则是小写s，如果没有执行权限则是大写S；而SBIT的写法则是，原先有执行权限是小写t，没有执行权限是大写T。一般权限的537进行字符转换后应为r-x-wxrwx，然后在此基础上增加SUID和SBIT特殊权限，合并后的结果是r-s-wxrwt。大家可以参考图5-5所示的计算过程来帮助理解。

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/特殊权限数字法计算-300x244.jpg)

图5-4 权限的字符表示法转数字表示法

![第5章 用户身份与文件权限第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/特殊权限字符法计算-1-300x223.jpg)

图5-5 权限的数字表示法转字符标识法

### Tips

在Linux系统中，文件的权限位有点像北京的房价，寸土寸金，一个权限位竟能有这么多含义，大家工作中一定要小心谨慎。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

##### **5.4 文件的隐藏属性**

Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。有用户曾经在生产环境和RHCE考试题目中碰到过明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容的情况，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件权限也保障了Linux系统的安全性。

既然叫隐藏权限，那么使用常规的ls命令肯定不能看到它的真面目。隐藏权限的专用设置命令是chattr，专用查看命令是lsattr。

**1.  chattr命令**

chattr命令用于设置文件的隐藏权限，英文全称为change attributes，语法格式为“chattr [参数] 文件名称”。

如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。chattr命令中可供选择的隐藏权限参数非常丰富，具体如表5-8所示。

表5-8                 chattr命令中的参数及其作用

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）      |
| A    | 不再修改这个文件或目录的最后访问时间（atime）                |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用dump命令备份时忽略本文件/目录                            |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |



为了让读者能够更好地见识隐藏权限的效果，我们先来创建一个普通文件，然后立即尝试删除（这个操作肯定会成功）：

```
[root@linuxprobe ~]# echo "for Test" > linuxprobe
[root@linuxprobe ~]# rm linuxprobe
rm: remove regular file ‘linuxprobe’? y
```

实践是检验真理的唯一标准。如果您没有亲眼见证过隐藏权限强大功能的美妙，就一定不会相信原来Linux系统会如此安全。接下来再次新建一个普通文件，并为其设置“不允许删除与覆盖”（+a参数）权限，然后再尝试将这个文件删除：

```
[root@linuxprobe ~]# echo "for Test" > linuxprobe
[root@linuxprobe ~]# chattr +a linuxprobe
[root@linuxprobe ~]# rm linuxprobe
rm: remove regular file ‘linuxprobe’? y
rm: cannot remove ‘linuxprobe’: Operation not permitted
```

可见，上述操作失败了。

**2.  lsattr命令**

lsattr命令用于查看文件的隐藏权限，英文全称为“list attributes”，语法格式为“lsattr [参数] 文件名称”。

在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪：

```
[root@linuxprobe ~]# ls -al linuxprobe
-rw-r--r--. 1 root root 9 Feb 12 11:42 linuxprobe
```

一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露：

```
[root@linuxprobe ~]# lsattr linuxprobe
-----a---------- linuxprobe
```

此时按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉：

```
[root@linuxprobe ~]# chattr -a linuxprobe
[root@linuxprobe ~]# lsattr linuxprobe 
---------------- linuxprobe
[root@linuxprobe ~]# rm linuxprobe 
rm: remove regular file ‘linuxprobe’? y
```

我们一般会将-a参数设置到日志文件（/var/log/messages）上，这样可在不影响系统正常写入日志的前提下，防止黑客擦除自己的作案证据。如果希望彻底地保护某个文件，不允许任何人修改和删除它的话，不妨加上-i参数试试，效果特别好。

在美剧《越狱》的第一季中，主人公迈克尔·斯科菲尔德把装有越狱计划的硬盘开窗扔进了湖中，结果在第二季被警探打捞出来恢复了数据，然后就有了第二季、第三季、第四季、第五季，他和哥哥的逃亡故事。所以，要想彻底删除某个文件，可以使用-s参数来保证其被删除后不可恢复—硬盘上的文件数据会被用零块重新填充，那就更保险了。

##### **5.5 文件访问控制列表**

不知道大家是否发现，前文讲解的一般权限、特殊权限、隐藏权限其实有一个共性—权限是针对某一类用户设置的，能够对很多人同时生效。如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限，更加精准地派发权限。另外，如果针对某个目录设置了ACL，则目录中的文件会继承其ACL权限；若针对文件设置了ACL，则文件不再继承其所在目录的ACL权限。

为了更直观地看到ACL对文件权限控制的强大效果，我们先切换到普通用户，然后尝试进入root管理员的家目录中。在没有针对普通用户为root管理员的家目录设置ACL之前，其执行结果如下所示：

```
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ cd /root
-bash: cd: /root: Permission denied
[linuxprobe@linuxprobe root]$ exit
```

**1.  setfacl命令**

setfacl命令用于管理文件的ACL权限规则，英文全称为“set files ACL”，语法格式为“setfacl [参数] 文件名称”。

ACL权限提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制。使用setfacl命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。其中，针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；如果想要删除某个文件的ACL，则可以使用-b参数。setfacl命令的常用参数如表5-9所示。

表5-9                       setfacl命令中的参数以及作用

| 参数 | 作用             |
| ---- | ---------------- |
| -m   | 修改权限         |
| -M   | 从文件中读取权限 |
| -x   | 删除某个权限     |
| -b   | 删除全部权限     |
| -R   | 递归子目录       |



例如，我们原本是无法进入/root目录中的，现在为普通用户单独设置一下权限：

```
[root@linuxprobe ~]# setfacl -Rm u:linuxprobe:rwx /root
```

随后再切换到这位普通用户的身份下，现在能正常进入了：

```
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ cd /root
[linuxprobe@linuxprobe root]$ ls
anaconda-ks.cfg  Documents  initial-setup-ks.cfg  Pictures  Templates
Desktop          Downloads  Music                 Public    Videos
[linuxprobe@linuxprobe root]$ exit
```

是不是觉得效果很酷呢？但是现在有这样一个小问题—怎么去查看文件是否设置了ACL呢？常用的ls命令是看不到ACL信息的，但是却可以看到文件权限的最后一个点（**.**）变成了加号（**+**），这就意味着该文件已经设置了ACL。现在大家是不是感觉学得越多，越不敢说自己精通Linux系统了吧？就这么一个不起眼的点（.），竟然还表示这么一种重要的权限。

```
[root@linuxprobe ~]# ls -ld /root
dr-xrwx---+ 14 root root 4096 May 4 2020 /root
```

**2.  getfacl命令**

getfacl命令用于查看文件的ACL权限规则，英文全称为“get files ACL”，语法格式为“getfacl [参数] 文件名称”。

Linux系统中的命令就是这么又可爱又好记。想要设置ACL，用的是setfacl命令；要想查看ACL，则用的是getfacl命令。下面使用getfacl命令显示在root管理员家目录上设置的所有ACL信息：

```
[root@linuxprobe ~]# getfacl /root
ggetfacl: Removing leading '/' from absolute path names
# file: root
# owner: root
# group: root
user::r-x
user:linuxprobe:rwx
group::r-x
mask::rwx
other::---
```

ACL权限还可以针对某个用户组进行设置。例如，允许某个组的用户都可以读写/etc/fstab文件：

```
[root@linuxprobe ~]# setfacl -m g:linuxprobe:rw /etc/fstab
[root@linuxprobe ~]# getfacl /etc/fstab 
getfacl: Removing leading '/' from absolute path names
# file: etc/fstab
# owner: root
# group: root
user::rw-
group::r--
group:linuxprobe:rw-
mask::rw-
other::r--
```

设置错了想删除？没问题！要清空所有ACL权限，请用-b参数；要删除某一条指定的权限，就用-x参数：

```
[root@linuxprobe ~]# setfacl -x g:linuxprobe /etc/fstab
[root@linuxprobe ~]# getfacl /etc/fstab 
getfacl: Removing leading '/' from absolute path names
# file: etc/fstab
# owner: root
# group: root
user::rw-
group::r--
mask::r--
other::r--
```

ACL权限的设置都是立即且永久生效的，不需要再编辑什么配置文件，这一点特别方便。但是，这也带来了一个安全隐患。如果我们不小心设置错了权限，就会覆盖掉文件原始的权限信息，并且永远都找不回来了。

**操作前备份一下，总是好的习惯**

例如，在备份/home目录上的ACL权限时，可使用-R递归参数，这样不仅能够把目录本身的权限进行备份，还能将里面的文件权限也自动备份。另外，再加上第3章学习过的输出重定向操作，可以轻松实现权限的备份。需要注意，getfacl在备份目录权限时不能使用绝对路径的形式，因此我们需要先切换到最上层根目录，然后再进行操作。

```
[root@linuxprobe ~]# cd /
[root@linuxprobe /]# getfacl -R home > backup.acl
[root@linuxprobe /]# ls -l 
-rw-r--r--. 1 root root 834 Jul 18 14:14 backup.acl
```

ACL权限的恢复也很简单，使用的是--restore参数。由于在备份时已经指定是对/home目录进行操作，所以不需要写对应的目录名称，它能够自动找到要恢复的对象：

```
[root@linuxprobe /]# setfacl --restore backup.acl
```

##### **5.6 su命令与sudo服务**

各位读者在实验环境中很少遇到安全问题，并且为了避免因权限因素导致配置服务失败，从而建议使用root管理员的身份来学习本书。但是，在生产环境中还是要对安全多一份敬畏之心，不要用root管理员的身份去做所有事情。因为一旦执行了错误的命令，可能会直接导致系统崩溃。这样一来，不但客户指责、领导批评，没准奖金也会鸡飞蛋打。但转头一想，尽管Linux系统为了安全性考虑，使得许多系统命令和服务只能被root管理员来使用，但是这也让普通用户受到了更多的权限束缚，从而导致无法顺利完成特定的工作任务。

su命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从root管理员切换至普通用户：

```
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ id
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

细心的读者一定会发现，上面的su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。

另外，当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了；这也是一个必要的安全检查：

```
[linuxprobe@linuxprobe ~]$ su - root
Password: 此处输入管理员密码
[root@linuxprobe ~]# 
```

尽管像上面这样使用su命令后，普通用户可以完全切换到root管理员的身份来完成相应工作，但这将暴露root管理员的密码，从而增大了系统密码被黑客获取的概率；这并不是最安全的方案。

刘遄老师接下来将介绍如何使用sudo命令把特定命令的执行权限赋予指定用户，这样既可保证普通用户能够完成特定的工作，也可以避免泄露root管理员密码。我们要做的就是合理配置sudo服务，以便兼顾系统的安全性和用户的便捷性。

### **Tips**

**授权原则：**在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。

sudo命令用于给普通用户提供额外的权限，语法格式为“sudo [参数] 用户名”。

使用sudo命令可以给普通用户提供额外的权限来完成原本只有root管理员才能完成的任务，可以限制用户执行指定的命令，记录用户执行过的每一条命令，集中管理用户与权限（/etc/sudoers），以及可以在验证密码后的一段时间无须让用户再次验证密码。常见的sudo命令的可用参数如表5-10所示。

表5-10                     sudo命令中的可用参数以及作用

| 参数             | 作用                                                   |
| ---------------- | ------------------------------------------------------ |
| -h               | 列出帮助信息                                           |
| -l               | 列出当前用户可执行的命令                               |
| -u 用户名或UID值 | 以指定的用户身份执行命令                               |
| -k               | 清空密码的有效时间，下次执行sudo时需要再次进行密码验证 |
| -b               | 在后台执行指定的命令                                   |
| -p               | 更改询问密码的提示语                                   |



当然，如果担心直接修改配置文件会出现问题，则可以使用sudo命令提供的visudo命令来配置用户权限。

visudo命令用于编辑、配置用户sudo的权限文件，语法格式为“visudo [参数]”。

这是一条会自动调用vi编辑器来配置/etc/sudoers权限文件的命令，能够解决多个用户同时修改权限而导致的冲突问题。不仅如此，visudo命令还可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错提醒。这要比用户直接修改文件更友好、安全、方便。

```
>>> /etc/sudoers: syntax error near line 1 <<<
What now? 
Options are:
(e)dit sudoers file again
e(x)it without saving changes to sudoers file
(Q)uit and save changes to sudoers file (DANGER!)
```

使用visudo命令配置权限文件时，其操作方法与Vim编辑器中用到的方法完全一致，因此在编写完成后记得在末行模式下保存并退出。在配置权限文件时，按照下面的格式在第101行（大约）填写上指定的信息。

> **谁可以使用 允许使用的主机 = （以谁的身份） 可执行命令的列表**
>
> **谁可以使用：**稍后要为哪位用户进行命令授权。
>
> **允许使用的主机：**可以填写ALL表示不限制来源的主机，亦可填写如192.168.10.0/24这样的网段限制来源地址，使得只有从允许网段登录时才能使用sudo命令。
>
> **以谁的身份：**可以填写ALL表示系统最高权限，也可以是另外一位用户的名字。
>
> **可执行命令的列表：**可以填写ALL表示不限制命令，亦可填写如/usr/bin/cat这样的文件名称来限制命令列表，多个命令文件之间用逗号（,）间隔。

在Linux系统中配置服务文件时，虽然没有硬性规定，但从经验来讲新增参数的位置不建议太靠上，以免我们新填写的参数在执行时失败，导致一些必要的服务功能没有成功加载。一般建议在配置文件中找一下相似的参数，然后在相邻位置进行新的修改，或者在文件的中下部位置进行添加后修改。

```
[root@linuxprobe ~]# visudo
 99 ## Allow root to run any commands anywhere
100 root ALL=(ALL) ALL
101 linuxprobe ALL=(ALL) ALL
```

在填写完毕后记得要先保存再退出，然后切换至指定的普通用户身份，此时就可以用sudo -l命令查看所有可执行的命令了（在下面的命令中，验证的是普通用户的密码，而不是root管理员的密码，请读者不要搞混了）：

```
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ sudo -l
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for linuxprobe: 此处输入linuxprobe用户的密码
Matching Defaults entries for linuxprobe on localhost:
    !visiblepw, always_set_home, match_group_by_gid, always_query_group_plugin,
    env_reset, env_keep="COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS",
    env_keep+="MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE",
    env_keep+="LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES",
    env_keep+="LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE",
    env_keep+="LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY",
    secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin

User linuxprobe may run the following commands on localhost:
    (ALL) ALL
```

接下来是见证奇迹的时刻！作为一名普通用户，是肯定不能看到root管理员的家目录（/root）中的文件信息的，但是，只需要在想执行的命令前面加上sudo命令就行了：

```
[linuxprobe@linuxprobe ~]$ ls /root
ls: cannot open directory '/root': Permission denied
[linuxprobe@linuxprobe ~]$ sudo ls /root
anaconda-ks.cfg  Documents  initial-setup-ks.cfg  Pictures  Templates
Desktop		 Downloads  Music		  Public    Videos
```

效果立竿见影！但是考虑到生产环境中不允许某个普通用户拥有整个系统中所有命令的最高执行权（这也不符合前文提到的权限赋予原则，即尽可能少地赋予权限），ALL参数就有些不合适了。因此只能赋予普通用户具体的命令以满足工作需求，这也受到了必要的权限约束。如果需要让某个用户只能使用root管理员的身份执行指定的命令，切记一定要给出该命令的绝对路径，否则系统会识别不出来。这时，可以先使用whereis命令找出命令所对应的保存路径：

```
[linuxprobe@linuxprobe ~]$ exit 
logout 
[root@linuxprobe ~]# whereis cat 
cat: /usr/bin/cat /usr/share/man/man1/cat.1.gz /usr/share/man/man1p/cat.1p.gz
[root@linuxprobe ~]# whereis reboot
reboot: /usr/sbin/reboot /usr/share/man/man2/reboot.2.gz /usr/share/man/man8/reboot.8.gz
```

然后使用visudo命令继续编辑权限文件，将原先第101行所新增的参数作如下修改，且多个命令之间用逗号（,）间隔：

```
[root@linuxprobe ~]# visudo
 99 ## Allow root to run any commands anywhere
100 root ALL=(ALL) ALL
101 linuxprobe ALL=(ALL) /usr/bin/cat,/usr/sbin/reboot
```

在编辑好后依然是先保存再退出。再次切换到指定的普通用户，然后尝试正常查看某个系统文件的内容，此时系统提示没有权限（Permission denied）。这时再使用sudo命令就能顺利地查看文件内容了：

```
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ cat /etc/shadow
cat: /etc/shadow: Permission denied
[linuxprobe@linuxprobe ~]$ sudo cat /etc/shadow
[sudo] password for linuxprobe: 此处输入linuxprobe用户的密码
root:$6$tTbuw5DkOPYqq.vI$RMk9FCGHoJOq2qAPRURTQm.Qok2nN3yFn/i4f/falVGgGND9XoiYFbrxDn16WWiziaSJ0/cR06U66ipEoGLPJ.::0:99999:7:::
bin:*:17784:0:99999:7:::
daemon:*:17784:0:99999:7:::
adm:*:17784:0:99999:7:::
lp:*:17784:0:99999:7:::
sync:*:17784:0:99999:7:::
shutdown:*:17784:0:99999:7:::
halt:*:17784:0:99999:7:::
………………省略部分输出信息………………
[linuxprobe@linuxprobe ~]$ exit 
logout
```

大家千万不要以为到这里就结束了，刘遄老师还有更压箱底的宝贝。不知大家是否发觉在每次执行sudo命令后都会要求验证一下密码。虽然这个密码就是当前登录用户的密码，但是每次执行sudo命令都要输入一次密码其实也挺麻烦的，这时可以添加NOPASSWD参数，使得用户下次再执行sudo命令时就不用密码验证：

```
[root@linuxprobe ~]# visudo
 99 ## Allow root to run any commands anywhere
100 root ALL=(ALL) ALL
101 linuxprobe ALL=(ALL) NOPASSWD:/usr/bin/cat,/usr/sbin/reboot
```

这样，当切换到普通用户后再执行命令时，就不用再频繁地验证密码了，我们在日常工作中也就痛快至极了。

```
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ reboot
User root is logged in on tty2.
Please retry operation after closing inhibitors and logging out other users.
Alternatively, ignore inhibitors and users with 'systemctl reboot -i'.
[linuxprobe@linuxprobe ~]$ sudo reboot
```

请同学们仔细留意上面的用户身份变换，visudo命令只有root管理员才可以执行，普通用户在使用时会提示权限不足。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．在RHEL 8系统中，root管理员是谁？

**答：**是UID为0的用户，是权限最大、限制最小的管理员。

2．如何使用Linux系统的命令行来添加和删除用户？

**答：**添加和删除用户的命令分别是useradd与userdel。

3．若某个文件的所有者具有文件的读/写/执行权限，其余人仅有读权限，那么用数字法表示应该是什么?

**答：**所有者权限为rwx，所属组和其他人的权限为r--，因此数字法表示应该是744。

4．某文件的字符权限为rwxrw-r--，那么对应的数字法权限应该是多少？

**答：**数字法权限应该是764。

5．某链接文件的权限用数字法表示为755，那么相应的字符法表示是什么呢？

**答：**在Linux系统中，不同文件具有不同的类型，因此这里应写成lrwxr-xr-x。

6．如果希望用户执行某命令时临时拥有该命令所有者的权限，应该设置什么特殊权限？

**答：**特殊权限中的SUID。

7．若对文件设置了隐藏权限（+i参数），则意味着什么？

**答：**无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件。

8．使用访问控制列表（ACL）来限制linuxprobe用户组，使得该组中的所有成员不得在/tmp目录中写入内容。

**答：**想要设置用户组的ACL，则需要把u改成g，即setfacl -Rm g:linuxprobe:r-x /tmp。

9．当普通用户使用sudo命令时是否需要验证密码？

**答：**系统在默认情况下需要验证当前登录用户的密码，若不想验证，可添加NOPASSWD参数。

本文原创地址：https://www.linuxprobe.com/basic-learning-05.html编辑：刘遄，审核员：暂无

- asic-learning-11.html)  				       2021-03-02 				       [0 个评论](https://www.linuxprobe.com/basic-learning-11.html#SOHUCS) 				   

- ​					       [![第17章 使用iSCSI服务部署网络存储](https://www.linuxprobe.com/wp-content/uploads/2015/09/ISCSI-HBA卡.jpg)](https://www.linuxprobe.com/basic-learning-17.html) 				   

  ​					       [第17章 使用iSCSI服务部署网络存储](https://www.linuxprobe.com/basic-learning-17.html)  				       2021-04-25 				       [0 个评论](https://www.linuxprobe.com/basic-learning-17.html#SOHUCS) 				   

- ​					       [![第12章 使用Samba或NFS实现文件共享](https://www.linuxprobe.com/wp-content/uploads/2015/06/samba服务logo.jpg)](https://www.linuxprobe.com/basic-learning-12.html) 				   

  ​					       [第12章 使用Samba或NFS实现文件共享](https://www.linuxprobe.com/basic-learning-12.html)  				       2021-03-05 				       [0 个评论](https://www.linuxprobe.com/basic-learning-12.html#SOHUCS) 				   

- ​					       [![第9章 使用ssh服务管理远程主机](https://www.linuxprobe.com/wp-content/uploads/2021/01/1-24.png)](https://www.linuxprobe.com/basic-learning-09.html) 				   

  ​					       [第9章 使用ssh服务管理远程主机](https://www.linuxprobe.com/basic-learning-09.html)  				       2021-01-26 				       [0 个评论](https://www.linuxprobe.com/basic-learning-09.html#SOHUCS) 				   

- 帽RHCSA、RHCE、RHCA认证。](https://www.linuxprobe.com/redhat-certificate/)




# [第6章 存储结构与管理硬盘](https://www.linuxprobe.com/basic-learning-06.html)

​		

[![img](https://www.linuxprobe.com/imgs/peixun.jpg)](https://www.linuxprobe.com/training)

**Linux系统技术交流QQ群（3963859）验证问题答案：刘遄**[![Linux就该这么学](https://www.linuxprobe.com/wp-content/uploads/2018/02/QQ群.png)](https://www.linuxprobe.com/links/qun.html)

**章节简述：**

[Linux系统](https://www.linuxprobe.com/)中颇具特色的文件存储结构常常搞得新手头昏脑涨，本章将从[Linux](https://www.linuxprobe.com/)系统中的文件存储结构开始，讲述文件系统层次标准（Filesystem Hierarchy Standard，FHS）、udev硬件命名规则以及硬盘设备的原理。

为了让读者更好地理解文件系统的作用，[刘遄](https://www.linuxprobe.com/)老师将在本章详细地分析Linux系统中最常见的Ext3、Ext4与XFS文件系统的不同之处，并带领各位读者着重练习硬盘设备分区、格式化以及挂载等常用的硬盘管理操作，以便熟练掌握文件系统的使用方法。

在打下坚实的理论基础并完成一些相关的实践练习后，我们将进一步完整地部署交换（SWAP）分区、配置quota磁盘配额服务、使用VDO（虚拟数据优化）技术，以及掌握ln[命令](https://www.linuxcool.com/)带来的软硬链接。相信各位读者在学习完本章后，会对Linux系统以及Windows系统中的磁盘存储以及文件系统有深入的理解。

本章目录结构

- [6.1 一切从“/”开始](https://www.linuxprobe.com/basic-learning-06.html#61)
- [6.2 物理设备的命名规则](https://www.linuxprobe.com/basic-learning-06.html#62)
- [6.3 文件系统与数据资料](https://www.linuxprobe.com/basic-learning-06.html#63)
- [6.4 挂载硬件设备](https://www.linuxprobe.com/basic-learning-06.html#64)
- [6.5 添加硬盘设备](https://www.linuxprobe.com/basic-learning-06.html#65)
- [6.6 添加交换分区](https://www.linuxprobe.com/basic-learning-06.html#66)
- [6.7 磁盘容量配额](https://www.linuxprobe.com/basic-learning-06.html#67)
- [6.8 VDO虚拟数据优化](https://www.linuxprobe.com/basic-learning-06.html#68_VDO)
- [6.9 软硬方式链接](https://www.linuxprobe.com/basic-learning-06.html#69)

##### **6.1 一切从“/”开始**

在Linux系统中，目录、字符设备、套接字、硬盘、光驱、打印机等都被抽象成文件形式，即[刘遄](https://www.linuxprobe.com/)老师一直强调的“Linux系统中一切都是文件”。既然平时我们打交道的都是文件，那么又应该如何找到它们呢？在Windows操作系统中，想要找到一个文件，要依次进入该文件所在的磁盘分区（也叫盘符），然后再进入该分区下的具体目录，最终找到这个文件。但是在Linux系统中并不存在C、D、E、F等盘符，Linux系统中的一切文件都是从“根”目录（/）开始的，并按照文件系统层次标准（FHS）采用倒树状结构来存放文件，以及定义了常见目录的用途。

另外，Linux系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT均代表不同的目录，并且文件名称中不得包含斜杠（/）。Linux系统中的文件存储结构如图6-1所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/Linux存储架构.png)

图6-1 Linux系统中的文件存储结构

前文提到的FHS是根据以往无数Linux系统用户和开发者的经验而总结出来的，是用户在Linux系统中存储文件时需要遵守的规则，用于指导用户应该把文件保存到什么位置，以及告诉用户应该在何处找到所需的文件。但是，FHS对于用户来讲只能算是一种道德上的约束，有些用户就是懒得遵守，依然会把文件到处乱放，有些甚至从来没有听说过它。这里并不是号召各位读者去谴责他们，而是建议大家要灵活运用所学的知识，千万不要认准这个FHS协定只讲死道理，不然吃亏的可就是自己了。在Linux系统中，最常见的目录以及所对应的存放内容如表6-1所示。

表6-1                 Linux系统中常见的目录名称以及相应内容

| 目录名称    | 应放置文件的内容                                             |
| ----------- | ------------------------------------------------------------ |
| /boot       | 开机所需文件—内核、开机菜单以及所需配置文件等                |
| /dev        | 以文件形式存放任何设备与接口                                 |
| /etc        | 配置文件                                                     |
| /home       | 用户主目录                                                   |
| /bin        | 存放单用户模式下还可以操作的[命令](https://www.linuxcool.com/) |
| /lib        | 开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数    |
| /sbin       | 开机过程中需要的命令                                         |
| /media      | 用于挂载设备文件的目录                                       |
| /opt        | 放置第三方的软件                                             |
| /root       | 系统管理员的家目录                                           |
| /srv        | 一些网络服务的数据文件目录                                   |
| /tmp        | 任何人均可使用的“共享”临时目录                               |
| /proc       | 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等       |
| /usr/local  | 用户自行安装的软件                                           |
| /usr/sbin   | Linux系统开机时不会使用到的软件/命令/[脚本](https://www.linuxcool.com/) |
| /usr/share  | 帮助与说明文件，也可放置共享文件                             |
| /var        | 主要存放经常变化的文件，如日志                               |
| /lost+found | 当文件系统发生错误时，将一些丢失的文件片段存放在这里         |



在Linux系统中另外还有一个重要的概念—路径。路径指的是如何定位到某个文件，分为绝对路径与相对路径。绝对路径指的是从根目录（/）开始写起的文件或目录名称，而相对路径则指的是相对于当前路径的写法。我们来看下面这个例子，以帮助大家理解。假如有位外国游客来到北京潘家园旅游，当前内急但是找不到洗手间，特意向您问路，那么咱们有两种正确的指路方法。

> **绝对路径（absolute path）**：首先坐飞机来到中国，到了北京后出首都机场，坐机场快轨到三元桥，然后换乘10号线到潘家园站，出站后坐34路公交车到农光里，下车后路口左转。
>
> **相对路径（relative path）**：前面路口左转。

这两种方法都正确。如果您说的是绝对路径，那么任何一位外国游客都可以按照这个提示找到潘家园的洗手间，但是太繁琐了。如果说的是相对路径，虽然表达很简练，但是这位外国游客只能从当前位置（不见得是潘家园）出发找到洗手间，因此并不能保证在前面的路口左转后可以找到洗手间。由此可见，相对路径不具备普适性。

如果各位读者现在还是不能理解相对路径和绝对路径的区别，也不要着急，以后通过实践练习肯定可以彻底搞明白。当前建议大家先记住FHS中规定的目录作用，这将在以后派上用场。

##### **6.2 物理设备的命名规则**

在Linux系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。系统内核中的udev设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。另外，udev设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev目录下的设备文件。Linux系统中常见的硬件设备及其文件名称如表6-2所示。

表6-2                       常见的硬件设备及其文件名称

| 硬件设备      | 文件名称           |
| ------------- | ------------------ |
| IDE设备       | /dev/hd[a-d]       |
| SCSI/SATA/U盘 | /dev/sd[a-z]       |
| virtio设备    | /dev/vd[a-z]       |
| 软驱          | /dev/fd[0-1]       |
| 打印机        | /dev/lp[0-15]      |
| 光驱          | /dev/cdrom         |
| 鼠标          | /dev/mouse         |
| 磁带机        | /dev/st0或/dev/ht0 |



由于现在的IDE设备已经很少见了，所以一般的硬盘设备都是以“/dev/sd”开头。而一台主机上可以有多块硬盘，因此系统采用a～z来代表26块不同的硬盘（默认从a开始分配），而且硬盘的分区编号也很有讲究：

> 主分区或扩展分区的编号从1开始，到4结束；
>
> 逻辑分区从编号5开始。

国内很多Linux培训讲师以及很多知名Linux图书在讲到设备和分区名称时，总会讲错两个知识点。第一个知识点是设备名称的理解错误。很多培训讲师和Linux技术图书中会提到，比如/dev/sda表示主板上第一个插槽上的存储设备，学员或读者在实践操作的时候会发现果然如此，因此也就对这条理论知识更加深信不疑。但真相不是这样的，/dev目录中sda设备之所以是a，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的插槽顺序就是系统内核的识别顺序，因此才会被命名为/dev/sda。大家以后在使用iSCSI网络存储设备时就会发现，明明主板上第二个插槽是空着的，但系统却能识别到/dev/sdb这个设备—就是这个道理。

第二个知识点是对分区名称的理解错误。很多Linux培训讲师会告诉学员，分区的编号代表分区的个数。比如sda3表示这是设备上的第3个分区，而学员在做实验的时候确实也会得出这样的结果。但是这个理论知识是错误的，因为分区的数字编码不一定是强制顺延下来的，也有可能是手工指定的。因此sda3只能表示是编号为3的分区，而不能判断sda设备上已经存在了3个分区。

在填了这两个“坑”之后，再来分析一下/dev/sda5这个设备文件名称包含哪些信息，如图6-2所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/硬盘命名规则.png)

图6-2 设备文件名称

首先，/dev/目录中保存的应当是硬件设备文件；其次，sd表示的是存储设备；然后，a表示系统中同类接口中第一个被识别到的设备；最后，5表示这个设备是一个逻辑分区。一言以蔽之，“/dev/sda5”表示的就是“这是系统中第一块被识别到的硬件设备中分区编号为5的逻辑分区的设备文件”。考虑到很多读者完全没有Linux基础，不太容易理解前面所说的主分区、扩展分区和逻辑分区的概念，因此接下来简单科普一下硬盘相关的知识。

正是因为计算机有了硬盘设备，我们才能够在玩游戏的过程中或游戏通关之后随时存档，而不用每次重头开始。硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节。其中第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，主引导记录需要占用446字节，分区表占用64字节，结束符占用2字节；其中分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，这4个分区就是4个主分区。第一个扇区中的数据信息如图6-3所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/第一个扇区中的数据信息-1.jpg)

图6-3 第一个扇区中的数据信息

现在，问题来了—每块硬盘最多只能创建出4个分区？这明显不合情理也不够用。

于是为了解决分区个数不够的问题，可以将第一个扇区的分区表中16字节（原本要写入主分区信息）的空间（称之为扩展分区）拿出来指向另外一个分区。也就是说，扩展分区其实并不是一个真正的分区，而更像是一个占用16字节分区表空间的指针—一个指向另外一个分区的指针。这样一来，用户一般会选择使用3个主分区加1个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于4个）的需求。当然，就目前来讲大家只要明白为什么主分区不能超过4个就足够了。主分区、扩展分区、逻辑分区可以像图6-4那样来规划。

### **Tips**

所谓扩展分区，严格地讲它不是一个实际意义的分区，而仅仅是一个指向其他分区的指针，这种指针结构将形成一个单向链表。因此扩展分区自身不能存储数据，用户需要在其指向的对应分区（称之为逻辑分区）上进行操作。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2015/02/逻辑分区.png)

图6-4 硬盘分区的规划

**大家可以试着解读一下/dev/hdc8代表着什么？** （**答案模式**）

**答案：**这是第3块IDE设备（现在比较少见）中编号为8的逻辑分区。

对了！如果大家参加[红帽](https://www.linuxprobe.com/)[RHCE](https://www.linuxprobe.com/)考试或者购买了一台云主机，还会看到类似于/dev/vda、/dev/vdb这样的设备。这种以vd开头的设备叫作Virtio设备，简单来说就是一种虚拟化设备。像KVM、Xen这种虚拟机监控器（Hypervisor）默认就都是这种设备，等大家步入工作岗位后可能会见到更多。

##### **6.3 文件系统与数据资料**

同学们可以拿出一张A4纸，然后横过来在上面随便写上几行字，在书写过程中慢慢就会发现字写得越来越歪，最终整行文字都会向上或向下倾斜。为了能让字写得更工整，阅读得更舒服一些，文具店里提供了各种不同的本本—单线本、双线本、田格本、五线谱本等。这也说明，离开了格式约束之后的内容，完全不受我们的主观控制。而用户在硬件存储设备中执行的文件建立、写入、读取、修改、转存与控制等操作都是依靠文件系统来完成的。文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。

Linux系统支持数十种文件系统，而最常见的文件系统如下所示。

**Ext2**：最早可追溯到1993年，是Linux系统的第一个商业级文件系统，它基本沿袭了UNIX文件系统的设计标准。但由于不包含日志读写功能，数据丢失的可能性很大，因此大家能不用就不用，或者顶多建议用于SD存储卡或U盘。

**Ext3**：是一款日志文件系统，它会把整个硬盘的每个写入动作的细节都预先记录下来，然后再进行实际操作，以便在发生异常宕机后能回溯追踪到被中断的部分。Ext3能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能100%地保证资料不会丢失。

**Ext4**：Ext3的改进版本，作为RHEL  6系统中默认的文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block（块），从而极大地提高了读写效率。现在很多主流服务器也会使用Ext4文件系统。

**XFS**：是一种高性能的日志文件系统，而且是RHEL 7/8中默认的文件管理系统。它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只需花费极低的计算和存储性能。它支持的最大存储容量为18EB，这几乎满足了所有需求。

RHEL 7/8系统中一个比较大的变化就是使用了XFS作为文件系统，这不同于RHEL  6使用的Ext4。从红帽公司官方发布的说明来看，这确实是一个不小的进步，但是刘遄老师在实测中发现并不完全属实。因为单纯就测试一款文件系统的“读取”性能来说，到底要读取多少个文件，每个文件的大小是多少，读取文件时的CPU、内存等系统资源的占用率如何，以及不同的硬件配置是否会有不同的影响，这些因素都是不确定的，因此实在不敢直接照抄红帽官方的介绍。我个人认为XFS虽然在性能方面比Ext4有所提升，但绝不是压倒性的，因此XFS文件系统最卓越的亮点应该当属可支持高达18EB的存储容量吧。

18EB等于18,874,368TB。假设每块硬盘的容量是100TB，那么大概需要19万块硬盘才能把18EB的数据都装下。总之，当用了XFS之后，文件的存储上限就不再取决于技术层面，而是钱包了。过去常常跟同学们开玩笑，“如果有18EB的数据在上海机房，想以最快的方式传送到北京，我们有什么好办法呢？”答案是“乘坐京沪高铁”。

在拿到一块新的硬盘存储设备后，先需要分区，然后再格式化文件系统，最后才能挂载并正常使用。硬盘的分区操作取决于您的需求和硬盘大小；也可以选择不进行分区，但是必须对硬盘进行格式化处理。

------

### **Tips**

就像拿到了一张未裁切的完整纸张那样，首先要进行裁切以方便使用（**分区**），接下来在裁切后的纸张上画格以便能书写工整（格式化），最后是正式的使用（**挂载**）。

接下来向大家简单地科普一下硬盘在格式化后发生的事情。再次强调，大家不用刻意去记住，只要能看懂就行了。

日常需要保存在硬盘中的数据实在太多了，因此Linux系统中有一个名为super  block的“硬盘地图”。Linux并不是把文件内容直接写入到这个“硬盘地图”里面，而是在里面记录着整个文件系统的信息。因为如果把所有的文件内容都写入到这里面，它的体积将变得非常大，而且文件内容的查询与写入速度也会变得很慢。Linux只是把每个文件的权限与属性记录在inode中，而且每个文件占用一个独立的inode表格，该表格的大小默认为128字节，里面记录着如下信息：

> 该文件的访问权限（read、write、execute）；
>
> 该文件的所有者与所属组（owner、group）；
>
> 该文件的大小（size）；
>
> 该文件的创建或内容修改时间（Ctime）；
>
> 该文件的最后一次访问时间（Atime）；
>
> 该文件的修改时间（Mtime）；
>
> 文件的特殊权限（SUID、SGID、SBIT）；
>
> 该文件的真实数据地址（point）。

而文件的实际内容则保存在block块中（大小一般是1KB、2KB或4KB），一个inode的默认大小仅为128字节，记录一个block则消耗4字节。当文件的inode被写满后，Linux系统会自动分配出一个block，专门用于像inode那样记录其他block块的信息，这样把各个block块的内容串到一起，就能够让用户读到完整的文件内容了。对于存储文件内容的block块，有下面两种常见的情况（以4KB大小的block为例进行说明）。

> 情况1：文件很小（1KB），但依然会占用一个block，因此会潜在地浪费3KB。
>
> 情况2：文件很大（5KB），那么会占用两个block（5KB−4KB后剩下的1KB也要占用一个block）。

大家看到这里，是不是觉得Linux系统好浪费啊？为什么最后一个block块容量总不能被完全使用呢？其实每个系统都是一样的，只不过大家此前没有留意过罢了。同学们可以随手查看一个电脑中已有的文件，看看文件的实际大小与占用空间是否一致，如图6-5所示。

计算机系统在发展过程中产生了众多的文件系统，为了使用户在读取或写入文件时不用关心底层的硬盘结构，Linux内核中的软件层为用户程序提供了一个虚拟文件系统（Virtual File  System，VFS）接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了。图6-6所示为VFS的架构示意图。从中可见，实际文件系统在VFS下隐藏了自己的特性和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令在任何文件系统中进行各种操作了（比如使用cp命令来复制文件）。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/文件的占用大小.png)

图6-5 文件的实际大小与占用空间![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/VFS的架构示意图-1.jpg)

图6-6 VFS的架构示意图

VFS也有点像一个翻译官。我们不需要知道对方的情况，只要告诉VFS想进行的操作是什么，它就会自动判断对方能够听得懂什么指令，然后翻译并交代下去。这可以让用户不用操心这些“小事情”，专注于自己的操作。

### **Tips**

在医学圈里有句这样一句话，“当您开始关注身体某个器官的时候，大概率是它最近不舒服了”。由于VFS真的太好用了，而且几乎不会出现任何问题，所以如果不在这里讲一下它的理论，相信很多同学很可能在多年后都不知道自己用过它。

##### **6.4 挂载硬件设备**

我们在用惯了Windows系统后总觉得一切都是理所当然的，平时把U盘插入到电脑后也从来没有考虑过Windows系统做了哪些事情，才使得我们可以访问这个U盘的。接下来我们会逐一学习在Linux系统中挂载和卸载存储设备的方法，以便大家更好地了解Linux系统添加硬件设备的工作原理和流程。前面讲到，在拿到一块全新的硬盘存储设备后要先分区，然后格式化，最后才能挂载并正常使用。“分区”和“格式化”大家以前经常听到，但“挂载”又是什么呢？

刘遄老师在这里给您一个最简单、最贴切的解释—当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”。下文将向读者逐步讲解如何使用硬盘设备，但是鉴于与挂载相关的理论知识比较复杂，而且很重要，因此决定再拿出一个小节单独讲解，这次希望大家不仅要看懂，而且还要记住。

mount命令用于挂载文件系统，格式为“mount文件系统  挂载目录”。mount命令中可用的参数及作用如表6-3所示。挂载是在使用硬件设备前所执行的最后一步操作。只需使用mount命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。对于比较新的Linux系统来讲，一般不需要使用-t参数来指定文件系统的类型，Linux系统会自动进行判断。而mount中的-a参数则厉害了，它会在执行后自动检查/etc/fstab文件中有无被疏漏挂载的设备文件，如果有，则进行自动挂载操作。

表6-3                       mount命令中的参数以及作用

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -a   | 挂载所有在/etc/fstab中定义的文件系统 |
| -t   | 指定文件系统的类型                   |



例如，要把设备/dev/sdb2挂载到/backup目录，只需要在mount命令中填写设备与挂载目录参数就行，系统会自动判断要挂载文件的类型，命令如下：

```
[root@linuxprobe ~]# mount /dev/sdb2 /backup
```

如果在工作中要挂载一块网络存储设备，该设备的名字可能会变来变去，这样再写为sdb就不太合适了。这时推荐用UUID（Universally  Unique  Identifier，通用唯一识别码）进行挂载操作。UUID是一串用于标识每块独立硬盘的字符串，具有唯一性及稳定性，特别适合用来挂载网络设备。那么，怎么才能得知独立硬盘的UUID呢？答案是使用blkid命令。

blkid命令用于显示设备的属性信息，英文全称为“block id”，语法格式为“blkid [设备名]”。使用blkid命令来查询设备UUID的示例如下：

```
[root@linuxprobe ~]# blkid
/dev/sdb1: UUID="2db66eb4-d9c1-4522-8fab-ac074cd3ea0b" TYPE="xfs" PARTUUID="eb23857a-01"
/dev/sdb2: UUID="478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG" TYPE="ext4" PARTUUID="eb23857a-02"
```

有了设备的UUID值之后，就可以用它挂载网络设备了：

```
[root@linuxprobe ~]# mount UUID=478fRb-1pOc-oPXv-fJOS-tTvH-KyBz-VaKwZG /backup
```

虽然按照上面的方法执行mount命令后就能立即使用文件系统了，但系统在重启后挂载就会失效，也就是说需要每次开机后都手动挂载一下。这肯定不是我们想要的效果，如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份  是否自检”（各字段的意义见表6-4）写入到/etc/fstab文件中。这个文件中包含着挂载所需的诸多信息项目，一旦配置好之后就能一劳永逸了。

表6-4            用于挂载信息的指定填写格式中，各字段所表示的意义

| 字段     | 意义                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 指定要挂载到的目录，需在挂载前创建好                         |
| 格式类型 | 指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等 |
| 权限选项 | 若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async |
| 是否备份 | 若为1则开机后使用dump进行磁盘备份，为0则不备份               |
| 是否自检 | 若为1则开机后自动进行磁盘自检，为0则不自检                   |



如果想将文件系统为Ext4的硬件设备/dev/sdb2在开机后自动挂载到/backup目录上，并保持默认权限且无须开机自检，就需要在/etc/fstab文件中写入下面的信息，这样在系统重启后也会成功挂载。

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                     /        xfs     defaults    0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot    xfs     defaults    0 0
/dev/mapper/rhel-swap                     swap     swap    defaults    0 0
/dev/sdb2                                 /backup  ext4    defaults    0 0
```

由于后面需要使用系统镜像制作Yum/DNF软件仓库，我们提前把光盘设备挂载到/media/cdrom目录中。光盘设备的文件系统格式是iso9660：

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                     /              xfs        defaults       0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot          xfs        defaults       0 0
/dev/mapper/rhel-swap                     swap           swap       defaults       0 0
/dev/sdb2                                 /backup        ext4       defaults       0 0
/dev/cdrom                                /media/cdrom   iso9660    defaults       0 0
```

写入到/etc/fstab文件中的设备信息并不会立即生效，需要使用mount -a参数进行自动挂载：

```
[root@linuxprobe ~]# mount -a
```

df命令用于查看已挂载的磁盘空间使用情况，英文全称为“disk free”，语法格式为“df -h”。

如果想查看当前系统中设备的挂载情况，非常推荐大家试试df命令。它不仅能够列出系统中正在使用的设备有哪些，还可以用-h参数便捷地对存储容量进行“进位”操作。例如，在遇到10240K的时候会自动进位写成10M，非常方便我们的阅读。

```
[root@linuxprobe~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M   18M  966M   2% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sda1             1014M  152M  863M  15% /boot
/dev/sdb2              480M   20M  460M   4% /backup
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
```

对了！说到网络存储设备，建议您在fstab文件挂载信息中加上_netdev参数。加上后系统会等联网成功后再尝试挂载这块网络存储设备，从而避免了开机时间过长或失败的情况（第17章学习iSCSI技术时可以用上）。

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /              xfs       defaults            0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b   /boot          xfs       defaults            0 0
/dev/mapper/rhel-swap                       swap           swap      defaults            0 0
/dev/sdb2                                   /backup        ext4      defaults,_netdev    0 0
/dev/cdrom                                  /media/cdrom   iso9660   defaults            0 0
```

挂载文件系统的目的是为了使用硬件资源，而卸载文件系统则意味不再使用硬件的设备资源。既然挂载操作就是把硬件设备与目录两者进行关联的动作，那么卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。

umount命令用于卸载设备或文件系统，英文全称为“un mount”，语法格式为“umount [设备文件/挂载目录]”。

```
[root@linuxprobe ~]# umount /dev/sdb2
```

如果我们当前就处于设备所挂载的目录，系统会提示该设备繁忙，此时只需要退出到其他目录后再尝试一次就行了。轻松搞定。

```
[root@linuxprobe ~]# cd /media/cdrom/
[root@linuxprobe cdrom]# umount /dev/cdrom
umount: /media/cdrom: target is busy.
[root@linuxprobe  cdrom]# cd ~
[root@linuxprobe ~]# umount /dev/cdrom
[root@linuxprobe ~]#
```

### **Tips**

挂载操作就像两人结为夫妻，双方需要同时到场，信息一旦被登记到民政局的系统中，再想重婚（重复挂载某设备）可就不行喽。

最后再教给同学们一个小技巧。如果系统中硬盘特别多，分区特别多，我们都不知道它们是否有被使用，又或者是做了些什么。此时，就可以用lsblk命令以树状图的形式列举一下了。

lsblk命令用于查看已挂载的磁盘的空间使用情况，英文全称为“list block id”，输入该命令后按回车键执行即可。

```
[root@linuxprobe ~]# lsblk 
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0   20G  0 disk 
├─sda1          8:1    0    1G  0 part /boot
└─sda2          8:2    0   19G  0 part 
  ├─rhel-root 253:0    0   17G  0 lvm  /
  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
sr0            11:0    1  6.6G  0 rom  /media/cdrom
```

##### **6.5 添加硬盘设备**

根据前文讲解的与管理硬件设备相关的理论知识，我们先来理清一下添加硬盘设备的操作思路：首先需要在虚拟机中模拟添加入一块新的硬盘存储设备，然后再进行分区、格式化、挂载等操作，最后通过检查系统的挂载状态并真实地使用硬盘来验证硬盘设备是否成功添加。

鉴于我们不需要为了做这个实验而特意买一块真实的硬盘，而是通过虚拟机软件进行硬件模拟，因此这再次体现出了使用虚拟机软件的好处。具体的操作步骤如下。

首先把虚拟机系统关机，稍等几分钟会自动返回到虚拟机管理主界面，然后单击“编辑虚拟机设置”选项，在弹出的界面中单击“添加”按钮，新增一块硬件设备，如图6-7所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/1-23-1024x709.png)

图6-7 在虚拟机系统中添加硬件设备

选择想要添加的硬件类型为“硬盘”，然后单击“下一步”按钮就可以了，如图6-8所示。这确实没有什么需要进一步解释的。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/2-20.png)

图6-8 选择添加硬件类型

选择虚拟硬盘的类型为SATA，并单击“下一步”按钮，如图6-9所示。这样虚拟机中的设备名称过一会儿后应该为/dev/sdb。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/硬盘类型.png)

图6-9 选择硬盘设备类型

选中“创建新虚拟磁盘”单选按钮（而不是其他选项），再次单击“下一步”按钮，如图6-10所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/4-6.png)

图6-10 选择“创建新虚拟磁盘”选项

将“最大磁盘大小”设置为默认的20GB。这个数值是限制这台虚拟机所使用的最大硬盘空间，而不是立即将其填满，因此默认20GB就很合适了。单击“下一步”按钮，如图6-11所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/5-5.png)

图6-11 设置硬盘的最大使用空间

设置磁盘文件的文件名和保存位置（这里采用默认设置即可，无须修改），直接单击“完成”按钮，如图6-12所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/磁盘名称.png)

图6-12 设置磁盘文件的文件名和保存位置

将新硬盘添加好后就可以看到设备信息了。这里不需要做任何修改，直接单击“确定”按钮后就可以启虚拟机了，如图6-13所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/硬件一览.png)

图6-13 查看虚拟机硬件设置信息

在虚拟机中模拟添加了硬盘设备后就应该能看到抽象后的硬盘设备文件了。按照前文讲解的udev服务命名规则，第二个被识别的SATA设备应该会被保存为/dev/sdb，这个就是硬盘设备文件了。但在开始使用该硬盘之前还需要进行分区操作，例如从中取出一个2GB的分区设备以供后面的操作使用。

fdisk命令用于新建、修改及删除磁盘的分区表信息，英文全称为“format disk”，语法格式为“fdisk磁盘名称”。

在Linux系统中，管理硬盘设备最常用的方法就当属fdisk命令了。它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”。不过与前面讲解的直接写到命令后面的参数不同，这条命令的参数（见表6-5）是交互式的一问一答的形式，因此在管理硬盘设备时特别方便，可以根据需求动态调整。

表6-5                       fdisk命令中的参数以及作用

| 参数 | 作用                   |
| ---- | ---------------------- |
| m    | 查看全部可用的参数     |
| n    | 添加新的分区           |
| d    | 删除某个分区信息       |
| l    | 列出所有可用的分区类型 |
| t    | 改变某个分区的类型     |
| p    | 查看分区表信息         |
| w    | 保存并退出             |
| q    | 不保存直接退出         |



首先使用fdisk命令来尝试管理/dev/sdb硬盘设备。在看到提示信息后输入参数p来查看硬盘设备内已有的分区信息，其中包括了硬盘的容量大小、扇区个数等信息：

```
[root@linuxprobe ~]# fdisk /dev/sdb

Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0x88b2c2b0.

Command (m for help): p
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0
```

输入参数n尝试添加新的分区。系统会要求用户是选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：

```
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
```

在确认创建一个主分区后，系统要求用户先输入主分区的编号。在前文得知，主分区的编号范围是1～4，因此这里输入默认的1就可以了。接下来系统会提示定义起始的扇区位置，这不需要改动，敲击回车键保留默认设置即可，系统会自动计算出最靠前的空闲扇区的位置。最后，系统会要求定义分区的结束扇区位置，这其实就是要去定义整个分区的大小是多少。我们不用去计算扇区的个数，只需要输入+2G即可创建出一个容量为2GB的硬盘分区。

```
Partition number (1-4, default 1): 1
First sector (2048-41943039, default 2048): 此处敲击回车即可
Last sector, +sectors or +size{K,M,G,T,P} (2048-41943039, default 41943039): +2G

Created a new partition 1 of type 'Linux' and of size 2 GiB.
```

再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时千万不要直接关闭窗口，而应该敲击参数w后按回车键，这样分区信息才是真正地写入成功啦。

```
Command (m for help): p
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0

Device     Boot Start     End Sectors Size Id Type
/dev/sdb1        2048 4196351 4194304   2G 83 Linux

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

分区信息中第6个字段的Id值是一个编码，用于标识该分区的作用，可帮助用户快速了解该分区的作用，一般没必要修改。使用l参数查看一下磁盘编码都有哪些，然后在6.6节进行SWAP操作时再修改吧：

```
Command (m for help): l  

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden or  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx         
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data    
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi ea  Rufus alignment
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         eb  BeOS fs        
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ee  GPT            
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        ef  EFI (FAT-12/16/
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f0  Linux/PA-RISC b
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f1  SpeedStor      
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f4  SpeedStor      
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      f2  DOS secondary  
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fb  VMware VMFS    
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fc  VMware VMKCORE 
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fd  Linux raid auto
1c  Hidden W95 FAT3 75  PC/IX           bc  Acronis FAT32 L fe  LANstep        
1e  Hidden W95 FAT1 80  Old Minix       be  Solaris boot    ff  BBT   
```

在上述步骤执行完毕之后，Linux系统会自动把这个硬盘主分区抽象成/dev/sdb1设备文件。可以使用file命令查看该文件的属性，但我在讲课和工作中发现，有些时候系统并没有自动把分区信息同步给Linux内核，而且这种情况似乎还比较常见（但不能算作严重的bug）。可以输入partprobe命令手动将分区信息同步到内核，而且一般推荐连续两次执行该命令，效果会更好。如果使用这个命令都无法解决问题，那么就重启计算机吧，这个“杀手锏”百试百灵，一定会有用的。

```
[root@linuxprobe ]# file /dev/sdb1
/dev/sdb1: cannot open `/dev/sdb1' (No such file or directory)
[root@linuxprobe ]# partprobe
[root@linuxprobe ]# partprobe
[root@linuxprobe ]# file /dev/sdb1
/dev/sdb1: block special
```

如果硬件存储设备没有进行格式化，则Linux系统无法得知怎么在其上写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。在Linux系统中用于格式化操作的命令是mkfs。这条命令很有意思，因为在Shell终端中输入mkfs名后再敲击两下用于补齐命令的Tab键，会有如下所示的效果：

```
[root@linuxprobe ~]# mkfs
mkfs         mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat    
mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs     
```

对！这个mkfs命令很贴心地把常用的文件系统名称用后缀的方式保存成了多个命令文件，用起来也非常简单—mkfs.文件类型名称。例如要将分区为XFS的文件系统进行格式化，则命令应为mkfs.xfs /dev/sdb1。

```
[root@linuxprobe ~]# mkfs.xfs /dev/sdb1
meta-data=/dev/sdb1              isize=512    agcount=4, agsize=131072 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1
data     =                       bsize=4096   blocks=524288, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

终于完成了存储设备的分区和格式化操作，接下来就是要来挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。

```
[root@linuxprobe ~]# mkdir /newFS
[root@linuxprobe ~]# mount /dev/sdb1 /newFS
[root@linuxprobe ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  974M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sdb1              2.0G   47M  2.0G   3% /newFS
```

du命令用查看分区或目录所占用的磁盘容量大小，英文全称为“disk usage”，语法格式为“du -sh目录名称”。

既然存储设备已经顺利挂载，接下来就可以尝试通过挂载点目录向存储设备中写入文件了。在写入文件之前，先来看一个用于查看文件数据占用量的du命令。简单来说，该命令就是用来查看一个或多个文件占用了多大的硬盘空间。

在使用Window系统时，我们总会遇到“C盘容量不足，清理垃圾后又很快被占满”的情况。在Linux系统中可以使用du -sh /*命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小，在1s之内就能找到哪个目录占用的空间最多：

```
[root@linuxprobe ~]# du -sh /*
0	/bin
113M	/boot
0	/dev
29M	/etc
12K	/home
0	/lib
0	/lib64
6.7G	/media
0	/mnt
0	/newFS
0	/opt
0	/proc
8.6M	/root
9.6M	/run
0	/sbin
0	/srv
0	/sys
12K	/tmp
3.5G	/usr
155M	/var
```

先从某些目录中复制过来一批文件，然后查看这些文件总共占用了多大的容量：

```
[root@linuxprobe ~]# cp -rf /etc/* /newFS
[root@linuxprobe ~]# ls /newFS
adjtime                     hostname                  profile.d
aliases                     hosts                     protocols
alsa                        hosts.allow               pulse
alternatives                hosts.deny                qemu-ga
anacrontab                  hp                        qemu-kvm
asound.conf                 idmapd.conf               radvd.conf
………………省略部分输入信息………………
[root@linuxprobe ~]# du -sh /newFS
39M /newFS/
```

细心的读者一定还记得，前面在讲解mount命令时提到，使用mount命令挂载的设备文件会在系统下一次重启的时候失效。如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入配置文件中：

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                     /                      xfs      defaults        0 0
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot                  xfs      defaults        0 0
/dev/mapper/rhel-swap                     swap                   swap     defaults        0 0
/dev/cdrom                                /media/cdrom           iso9660  defaults        0 0 
/dev/sdb1                                 /newFS                 xfs      defaults        0 0 
```

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

##### **6.6 添加交换分区**

交换（SWAP）分区是一种通过在硬盘中预先划分一定的空间，然后把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。通俗来讲就是让硬盘帮内存分担压力。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。

交换分区的创建过程与前文讲到的挂载并使用存储设备的过程非常相似。在对/dev/sdb存储设备进行分区操作前，有必要先说一下交换分区的划分建议：在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍。为了让大家更明显地感受交换分区空间的变化，这里取出一个大小为5GB的主分区作为交换分区资源：

```
[root@linuxprobe ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.32.1).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2): 敲击回车即可
First sector (4196352-41943039, default 4196352): 敲击回车即可
Last sector, +sectors or +size{K,M,G,T,P} (4196352-41943039, default 41943039): +5G

Created a new partition 2 of type 'Linux' and of size 5 GiB.
```

在上面的操作结束后，我们就得到了一个容量为5GB的新分区。然后尝试修改硬盘的标识码，这里将其改成82（Linux swap）以方便以后知道它的作用：

```
Command (m for help): t
Partition number (1,2, default 2): 2
Hex code (type L to list all codes): 82

Changed type of partition 'Linux' to 'Linux swap / Solaris'.

Command (m for help): p 
Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x88b2c2b0

Device     Boot   Start      End  Sectors Size Id Type
/dev/sdb1          2048  4196351  4194304   2G 83 Linux
/dev/sdb2       4196352 14682111 10485760   5G 82 Linux swap / Solaris
```

搞定！敲击w参数退出分区表编辑工具：

```
Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

下面来看一下两个与交换分区相关的简单命令。

mkswap命令用于对新设备进行交换分区格式化，英文全称为“make swap”，语法格式为“mkswap设备名称”。

```
[root@linuxprobe ~]# mkswap /dev/sdb2
Setting up swapspace version 1, size = 5 GiB (5368705024 bytes)
no label, UUID=45a4047c-49bf-4c88-9b99-f6ac93908485
```

swapon命令用于激活新的交换分区设备，英文全称为“swap on”，语法格式为“swapon设备名称”。

使用swapon命令把准备好的SWAP硬盘设备正式挂载到系统中。可以使用free -m命令查看交换分区的大小变化（由2047MB增加到7167MB）：

```
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1391         105          12         469         384
Swap:          2047           9        2038
[root@linuxprobe ~]# swapon /dev/sdb2
[root@linuxprobe ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1395         101          12         469         380
Swap:          7167           9        7158
```

为了能够让新的交换分区设备在重启后依然生效，需要按照下面的格式将相关信息写入配置文件中，并记得保存：

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                        /               xfs        defaults    1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b    /boot           xfs        defaults    1 2
/dev/mapper/rhel-swap                        swap            swap       defaults    0 0
/dev/cdrom                                   /media/cdrom    iso9660    defaults    0 0 
/dev/sdb1                                    /newFS          xfs        defaults    0 0 
/dev/sdb2                                    swap            swap       defaults    0 0 
```

##### **6.7 磁盘容量配额**

本书在前面曾经讲到，Linux系统的设计初衷就是让许多人一起使用并执行各自的任务，从而成为多用户、多任务的操作系统。但是，硬件资源是固定且有限的，如果某些用户不断地在Linux系统上创建文件或者存放电影，硬盘空间总有一天会被占满。针对这种情况，root管理员就需要使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用。可以使用quota技术进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota技术还有软限制和硬限制的功能。

> **软限制**：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。
>
> **硬限制**：当达到硬限制时会提示用户，且强制终止用户的操作。

RHEL 8系统中已经安装了quota磁盘容量配额服务程序包，但存储设备却默认没有开启对quota技术的支持，此时需要手动编辑配置文件并重启一次系统，让系统中的启动目录（/boot）能够支持quota磁盘配额技术。

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                        /             xfs        defaults         1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b    /boot         xfs        defaults,uquota  1 2
/dev/mapper/rhel-swap                        swap          swap       defaults         0 0
/dev/cdrom                                   /media/cdrom  iso9660    defaults         0 0 
/dev/sdb1                                    /newFS        xfs        defaults         0 0 
/dev/sdb2                                    swap          swap       defaults         0 0 
[root@linuxprobe ~]# reboot
```

另外，对于学习过早期的Linux系统，或者具有RHEL  5/6系统使用经验的读者来说，这里需要特别注意。早期的Linux系统要想让硬盘设备支持quota磁盘容量配额服务，使用的是usrquota参数，而RHEL 7/8系统使用的则是uquota参数。在重启系统后使用mount命令查看，即可发现/boot目录已经支持quota磁盘配额技术了：

```
[root@linuxprobe ~]# mount | grep boot
/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,usrquota)
```

接下来创建一个用于检查quota磁盘容量配额效果的用户tom，并针对/boot目录增加其他人的写权限，保证用户能够正常写入数据：

```
[root@linuxprobe ~]# useradd tom
[root@linuxprobe ~]# chmod -R o+w /boot
```

xfs_quota命令用于管理设备的磁盘容量配额，语法格式为“xfs_quota [参数] 配额 文件系统”。

这是一个专门针对XFS文件系统来管理quota磁盘容量配额服务而设计的命令。其中，-c参数用于以参数的形式设置要执行的命令；-x参数是专家模式，让运维人员能够对quota服务进行更多复杂的配置。接下来使用xfs_quota命令来设置用户tom对/boot目录的quota磁盘容量配额。具体的限额控制包括：硬盘使用量的软限制和硬限制分别为3MB和6MB；创建文件数量的软限制和硬限制分别为3个和6个。

```
[root@linuxprobe ~]# xfs_quota -x -c 'limit bsoft=3m bhard=6m isoft=3 ihard=6 tom' /boot
[root@linuxprobe ~]# xfs_quota -x -c report /boot
User quota on /boot (/dev/sda1)
                               Blocks                     
User ID          Used       Soft       Hard    Warn/Grace     
---------- -------------------------------------------------- 
root           114964          0          0     00 [--------]
tom                 0       3072       6144     00 [--------]
```

上面所使用的参数分为两组，分别是isoft/ihard与bsoft/bhard，下面深入讲解一下。在6.3节中曾经讲过，在Linux系统中每个文件都会使用一个独立的inode信息块来保存属性信息，一个文件对应一个inode信息块，所以isoft和ihard就是通过限制系统最大使用的inode个数来限制了文件数量。bsoft和bhard则是代表文件所占用的block大小，也就是文件占用的最大容量的总统计。

soft是软限制，超过该限制后也只是将操作记录写到日志中，不对用户行为进行限制。而hard是硬限制，一旦超过系统就会马上禁止，用户再也不能创建或新占任何的硬盘容量。

当配置好上述各种软硬限制后，尝试切换到一个普通用户，然后分别尝试创建一个体积为5MB和8MB的文件。可以发现，在创建8MB的文件时受到了系统限制：

```
[root@linuxprobe ~]# su - tom
[tom@linuxprobe ~]$ cd /boot
[tom@linuxprobe boot]$ dd if=/dev/zero of=/boot/tom bs=5M count=1
1+0 records in
1+0 records out
5242880 bytes (5.2 MB, 5.0 MiB) copied, 0.00298178 s, 1.8 GB/s
[tom@linuxprobe boot]$ dd if=/dev/zero of=/boot/tom bs=8M count=1
dd: error writing '/boot/tom': Disk quota exceeded
1+0 records in
0+0 records out
4194304 bytes (4.2 MB, 4.0 MiB) copied, 0.00398607 s, 1.1 GB/s
```

edquota命令用于管理系统的磁盘配额，英文全称为“edit quota”，语法格式为“edquota [参数] 用户名”。

在为用户设置了quota磁盘容量配额限制后，可以使用edquota命令按需修改限额的数值。其中，-u参数表示要针对哪个用户进行设置；-g参数表示要针对哪个用户组进行设置，如表6-6所示。

表6-6                       edquota命令中可用的参数以及作用

| 参数 | 作用                        |
| ---- | --------------------------- |
| -u   | 对某个用户进行设置          |
| -g   | 对某个用户组进行设置        |
| -p   | 复制原有的规则到新的用户/组 |
| -t   | 限制宽限期限                |



edquota命令会调用Vi或Vim编辑器来让root管理员修改要限制的具体细节，记得用wq保存退出。下面把用户tom的硬盘使用量的硬限额从5MB提升到8MB：

```
[tom@linuxprobe ~]$ exit
[root@linuxprobe ~]# edquota -u tom
Disk quotas for user tom (uid 1001):
  Filesystem                   blocks       soft       hard     inodes     soft     hard
  /dev/sda1                      4096       3072       8192          1        3        6
[root@linuxprobe ~]# su - tom
[tom@linuxprobe ~]$ cd /boot
[tom@linuxprobe boot]$ dd if=/dev/zero of=/boot/tom bs=8M count=1
1+0 records in
1+0 records out
8388608 bytes (8.4 MB, 8.0 MiB) copied, 0.0185476 s, 452 MB/s
```

##### **6.8 VDO虚拟数据优化**

VDO（Virtual Data  Optimize，虚拟数据优化）是一种通过压缩或删除存储设备上的数据来优化存储空间的技术。VDO是红帽公司收购了Permabit公司后获取的新技术，并与2019-2020年前后，多次在RHEL 7.5/7.6/7.7上进行测试，最终随RHEL  8系统正式公布。VDO技术的关键就是对硬盘内原有的数据进行删重操作，它有点类似于我们平时使用的网盘服务，在第一次正常上传文件时速度特别慢，在第二次上传相同的文件时仅作为一个数据指针，几乎可以达到“秒传”的效果，无须再多占用一份空间，也不用再漫长等待。除了删重操作，VDO技术还可以对日志和数据库进行自动压缩，进一步减少存储浪费的情况。VDO针对各种类型文件的压缩效果如表6-7所示。

表6-7                      对各种类型文件压缩效果汇总表

| 文件名  | 描述                            | 类型              | 原始大小（KB） | 实际占用空间（KB） |
| ------- | ------------------------------- | ----------------- | -------------- | ------------------ |
| dickens | 狄更斯文集                      | 英文原文          | 9953           | 9948               |
| mozilla | Mozilla的1.0可执行文件          | 执行程序          | 50020          | 33228              |
| mr      | 医用resonanse图像               | 图片              | 9736           | 9272               |
| nci     | 结构化的化学数据库              | 数据库            | 32767          | 10168              |
| ooffice | Open Office.org 1.01 DLL        | 可执行程序        | 6008           | 5640               |
| osdb    | 基准测试用的MySQL格式示例数据库 | 数据库            | 9849           | 9824               |
| reymont | 瓦迪斯瓦夫·雷蒙特的书           | PDF               | 6471           | 6312               |
| samba   | samba源代码                     | src源码           | 21100          | 11768              |
| sao     | 星空数据                        | 天文格式的bin文件 | 7081           | 7036               |
| webster | 辞海                            | HTML              | 40487          | 40144              |
| xml     | XML文件                         | HTML              | 5220           | 2180               |
| x-ray   | 透视医学图片                    | 医院数据          | 8275           | 8260               |



VDO技术支持本地存储和远程存储，可以作为本地文件系统、iSCSI或Ceph存储下的附加存储层使用。红帽公司在VDO介绍页面中提到，在部署虚拟机或容器时，建议采用逻辑存储与物理存储为10∶1的比例进行配置，即1TB物理存储对应10TB逻辑存储；而部署对象存储时 （例如使用Ceph）则采用逻辑存储与物理存储为3∶1的比例进行配置，即使用1TB物理存储对应3TB逻辑存储。

简而言之，VDO技术能省空间！

有两种特殊情况需要提前讲一下。其一，公司服务器上已有的dm-crypt之类的技术是可以与VDO技术兼容的，但记得要先对卷进行加密再使用VDO。因为加密会使重复的数据变得有所不同，因此删重操作无法实现。要始终记得把加密层放到VDO之下，如图6-14所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/VDO.jpg)

图6-14 VDO技术拓扑图

其二，VDO技术不可叠加使用，1TB的物理存储提升成10TB的逻辑存储没问题，但是再用10TB翻成100TB就不行了。左脚踩右脚，真的没法飞起来。

通过6.5节的学习，相信同学们已经把对硬盘进行分区、格式化、挂载操作的方法拿捏得死死的了。我们把虚拟机关闭，添加一块容量为20GB的新SATA硬盘进来，开机后就能看到这块名称为/dev/sdc的新硬盘了：

```
[root@linuxprobe ~]# ls -l /dev/sdc
brw-rw----. 1 root disk 8, 32 Jan 6 22:26 /dev/sdc
```

RHEL/CentOS 8系统中默认已经启用了VDO技术。VDO技术现在是红帽公司自己的技术，兼容性自然没得说。如果您所用的系统没有安装VDO的话也不要着急，用dnf命令即可完成安装：

```
[root@linuxprobe ~]# dnf install kmod-kvdo vdo
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:01:56 ago on Wed 06 Jan 2021 10:37:19 PM CST.
Package kmod-kvdo-6.2.0.293-50.el8.x86_64 is already installed.
Package vdo-6.2.0.293-10.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
```

首先，创建一个全新的VDO卷。

新添加进来的物理设备就是使用vdo命令来管理的，其中name参数代表新的设备卷的名称；device参数代表由哪块磁盘进行制作；vdoLogicalSize参数代表制作后的设备大小。依据红帽公司推荐的原则，20GB硬盘将翻成200GB的逻辑存储：

```
[root@linuxprobe ~]# vdo create --name=storage --device=/dev/sdc --vdoLogicalSize=200G
Creating VDO storage
Starting VDO storage
Starting compression on VDO storage
VDO instance 0 volume is ready at /dev/mapper/storage
```

### **Tips**

Linux命令行严格区别大小写，vdoLogicalSize参数中的L与S字母必须大写。

在创建成功后，使用status参数查看新建卷的概述信息：

```
[root@linuxprobe ~]# vdo status --name=storage
VDO status:
  Date: '2021-01-06 22:51:33+08:00'
  Node: linuxprobe.com
Kernel module:
  Loaded: true
  Name: kvdo
  Version information:
    kvdo version: 6.2.0.293
Configuration:
  File: /etc/vdoconf.yml
  Last modified: '2021-01-06 22:49:33'
VDOs:
  storage:
    Acknowledgement threads: 1
    Activate: enabled
    Bio rotation interval: 64
    Bio submission threads: 4
    Block map cache size: 128M
    Block map period: 16380
    Block size: 4096
    CPU-work threads: 2
    Compression: enabled
    Configured write policy: auto
    Deduplication: enabled
………………省略部分输出信息………………
```

有上可见，在输出信息中包含了VDO卷创建的时间、主机名、版本、是否压缩（Compression）及是否删重（Deduplication）等关键信息。

接下来，对新建卷进行格式化操作并挂载使用。

新建的VDO卷设备会被乖乖地存放在/dev/mapper目录下，并以设备名称命名，对它操作就行。另外，挂载前可以用udevadm settle命令对设备进行一次刷新操作，避免刚才的配置没有生效：

```
[root@linuxprobe ~]# mkfs.xfs /dev/mapper/storage 
meta-data=/dev/mapper/storage    isize=512    agcount=4, agsize=13107200 blks
         =                       sectsz=4096  attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1
data     =                       bsize=4096   blocks=52428800, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=25600, version=2
         =                       sectsz=4096  sunit=1 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
[root@linuxprobe ~]# udevadm settle
[root@linuxprobe ~]# mkdir /storage
[root@linuxprobe ~]# mount /dev/mapper/storage /storage
```

如果想查看设备的实际使用情况，使用vdostats命令即可。human-readable参数的作用是将存储容量自动进位，以人们更易读的方式输出（比如，显示20G而不是20971520K）：

```
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.0G     16.0G  20%           99%
```

这里显示的Size是实际物理存储的空间大小（即20.0GB是硬盘的大小），如果想看逻辑存储空间，可以使用df命令进行查看：

```
[root@linuxprobe ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  974M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/sdb1              2.0G   47M  2.0G   3% /newFS
/dev/mapper/storage    200G  2.4G  198G   2% /storage
```

随便复制一个大文件过来，看看占用了多少容量，以及空间节省率（Space saving）是多少：

```
[root@linuxprobe ~]# ls -lh /media/cdrom/images/install.img 
-r--r--r--. 1 root root 448M Apr 4 2019 /media/cdrom/images/install.img
[root@linuxprobe ~]# cp /media/cdrom/images/install.img /storage/
[root@linuxprobe ~]# ls -lh /storage/install.img 
-r--r--r--. 1 root root 448M Jan  6 23:06 /storage/install.img
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.4G     15.6G  22%           18%
```

效果不明显，再复制一份相同的文件过来，看看这次占用了多少空间：

```
[root@linuxprobe ~]# cp /media/cdrom/images/install.img /storage/rhel.img
[root@linuxprobe ~]# vdostats --human-readable
Device                    Size      Used Available Use% Space saving%
/dev/mapper/storage      20.0G      4.5G     15.5G  22%           55%
```

是不是感觉很棒？！原先448MB的文件这次只占用了不到100MB的容量，空间节省率也从18%提升到了55%。当然这还仅仅是两次操作而已，好处就已经如此明显了。

最后，将设备设置成永久挂载生效，一直提供服务。

VDO设备卷在创建后会一直存在，但需要手动编辑/etc/fstab文件后才能在下一次重启后自动挂载生效，为我们所用。对于这种逻辑存储设备，其实不太建议使用/dev/mapper/storage作为设备名进行挂载。不如试试前面所说的UUID吧：

```
[root@linuxprobe ~]# blkid /dev/mapper/storage 
/dev/mapper/storage: UUID="cd4e9f12-e16a-415c-ae76-8de069076713" TYPE="xfs"
```

打开/etc/fstab文件，把对应的字段填写完整。建议再加上_netdev参数，表示等系统及网络都启动后再挂载VDO设备卷，以保证万无一失。

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                        /             xfs        defaults           1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b    /boot         xfs        defaults,uquota    1 2
/dev/mapper/rhel-swap                        swap          swap       defaults           0 0
/dev/cdrom                                   /media/cdrom  iso9660    defaults           0 0 
/dev/sdb1                                    /newFS        xfs        defaults           0 0 
/dev/sdb2                                    swap          swap       defaults           0 0 
UUID=cd4e9f12-e16a-415c-ae76-8de069076713    /storage      xfs        defaults,_netdev   0 0 
```

##### **6.9 软硬方式链接**

在引领大家学习完本章所有的硬盘管理知识之后，刘遄老师终于可以放心大胆地讲解Linux系统中的“快捷方式”了。在Windows系统中，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方，会导致链接文件失效。但是，这个看似简单的东西在Linux系统中可不太一样。

Linux系统中存在软链接和硬链接两种不同的类型。

**软链接（soft link）：**也叫符号链接（symbolic  link），仅仅包含所链接文件的名称和路径，很像一个记录地址的标签。当原始文件被删除或移动后，新的链接文件也会随之失效，不能被访问。可以针对文件、目录设置软链接，跨文件系统进行链接也不是问题。从这一点来看，它与Windows系统的“快捷方式”具有一样的性质。用户访问软链接的效果如图6-15所示。

**硬链接（hard link）：**可以将它理解为一个“指向原始文件block的指针”，系统会创建出一个与原来一模一样的inode信息块。所以，硬链接文件与原始文件其实是一模一样的，只是名字不同。每添加一个硬链接，该文件的inode个数就会增加1；而且只有当该文件的inode个数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件block的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，不能跨分区对目录文件进行硬链接。用户访问硬链接的效果如图6-16所示。

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/软链接.jpg)

图6-15 软链接原理示意图

![第6章 存储结构与管理硬盘第6章 存储结构与管理硬盘](https://www.linuxprobe.com/wp-content/uploads/2020/12/硬链接.jpg)

图6-16 硬链接原理示意图

### **Tips**

大家翻开手头这本书的目录页，看一下目录标题和对应的页码就应该能够理解了。链接文件就是指向实际内容所在位置的一个标签，通过这个标签，可以找到对应的数据。

ln命令用于创建文件的软硬链接，英文全称为“link”，语法格式为“ln [参数]原始文件名 链接文件名”。

ln命令的可用参数以及作用如表6-8所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。

表6-8                       ln命令中可用的参数以及作用

| 参数 | 作用                                               |
| ---- | -------------------------------------------------- |
| -s   | 创建“符号链接”（如果不带-s参数，则默认创建硬链接） |
| -f   | 强制创建文件或目录的链接                           |
| -i   | 覆盖前先询问                                       |
| -v   | 显示创建链接的过程                                 |



为了更好地理解软链接、硬链接的不同性质，我们先创建出一个文件，为其创建一个软链接：

```
[root@linuxprobe ~]# echo "Welcome to linuxprobe.com" > old.txt
[root@linuxprobe ~]# ln -s old.txt new.txt
[root@linuxprobe ~]# cat old.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat new.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l old.txt 
-rw-r--r-- 1 root root 26 Jan 11 00:08 old.txt
```

原始文件名为old，新的软链接文件名为new。删掉原始文件后，软链接文件立刻就无法读取了：

```
[root@linuxprobe ~]# rm -f old.txt 
[root@linuxprobe ~]# cat new.txt 
cat: readit.txt: No such file or directory
```

接下来针对原始文件old创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针。这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取了。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。

```
[root@linuxprobe ~]# echo "Welcome to linuxprobe.com" > old.txt
[root@linuxprobe ~]# ln old.txt new.txt
[root@linuxprobe ~]# cat old.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat new.txt 
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l old.txt 
-rw-r--r-- 2 root root 26 Jan 11 00:13 old.txt
```

这是一个非常有意思的现象。创建的硬链接文件竟然会让文件属性第二列的数字变成了2，这个数字表示的是文件的inode信息块的数量。相信同学们已经非常肯定地知道，即便删除了原始文件，新的文件也会一如既往地可以读取，因为只有当文件inode数量被“清零”时，才真正代表这个文件被删除了。

```
[root@linuxprobe ~]# rm -f old.txt 
[root@linuxprobe ~]# cat new.txt 
Welcome to linuxprobe.com
```

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．/home目录与/root目录内存放的文件有何相同点以及不同点？

**答：**这两个目录都是用来存放用户家目录数据的，但是，/root目录存放的是root管理员的家目录数据。

2．假如一个设备的文件名称为/dev/sdb，可以确认它是主板第二个插槽上的设备吗？

**答：**不一定，因为设备的文件名称是由系统的识别顺序来决定的。

3．如果硬盘中需要5个分区，则至少需要几个逻辑分区？

**答：**可以选用创建3个主分区+1个扩展分区的方法，然后把扩展分区再分成2个逻辑分区，即有了5个分区。

4．/dev/sda5是主分区还是逻辑分区？

**答：**逻辑分区。

5．哪个服务决定了设备在/dev目录中的名称？

**答：**udev设备管理器服务。

6．用一句话来描述挂载操作。

**答：**当用户需要使用硬盘设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就是“挂载”。

7．在配置quota磁盘容量配额服务时，软限制数值必须小于硬限制数值么？

**答：**不一定，软限制数值可以小于等于硬限制数值。

8．VDO技术能够提升硬盘的物理存储空间么？

**答：**不可以，VDO是通过压缩或删重操作来提高硬盘的逻辑空间大小。

9．若原始文件被改名，那么之前创建的硬链接还能访问到这个原始文件么？

**答：**可以。

- ​			   

- ​					       [![第5章 用户身份与文件权限](https://www.linuxprobe.com/wp-content/uploads/2020/05/读写执行权限对于文件与目录的作用-1024x168.png)](https://www.linuxprobe.com/basic-learning-05.html) 				   

  ​					       [第5章 用户身份与文件权限](https://www.linuxprobe.com/basic-learning-05.html)  				       2020-05-06 				       [0 个评论](https://www.linuxprobe.com/basic-learning-05.html#SOHUCS) 				   

- ​					       [![第3章 管道符、重定向与环境变量](https://www.linuxprobe.com/wp-content/uploads/2020/05/任意门.gif)](https://www.linuxprobe.com/basic-learning-03.html) 			   

  ​					       [第3章 管道符、重定向与环境变量](https://www.linuxprobe.com/basic-learning-03.html)  				       2020-05-06 				       [0 个评论](https://www.linuxprobe.com/basic-learning-03.html#SOHUCS) 				   

- ​					       [![第10章 使用Apache服务部署静态网站](https://www.linuxprobe.com/wp-content/uploads/2015/05/页面请求过程.png)](https://www.linuxprobe.com/basic-learning-10.html) 				   

  ​					       [第10章 使用Apache服务部署静态网站](https://www.linuxprobe.com/basic-learning-10.html)  				       2020-05-06 				       [0 个评论](https://www.linuxprobe.com/basic-learning-10.html#SOHUCS) 				   

  

  第7章 使用RAID与LVM磁盘阵列技术		

[![img](https://www.linuxprobe.com/imgs/peixun.jpg)](https://www.linuxprobe.com/training)

**Linux系统技术交流QQ群（3963859）验证问题答案：刘遄**[![Linux就该这么学](https://www.linuxprobe.com/wp-content/uploads/2018/02/QQ群.png)](https://www.linuxprobe.com/links/qun.html)

**章节简述：**

在学习了第6章讲解的硬盘设备分区、格式化、挂载等知识后，本章将深入讲解各个常用RAID（Redundant Array of  Independent Disks，独立冗余磁盘阵列）技术方案的特性，并通过实际部署RAID 10、RAID  5+备份盘等方案来更直观地查看RAID的强大效果，以便进一步满足生产环境对硬盘设备的IO读写速度和数据冗余备份机制的需求。同时，考虑到用户可能会动态调整存储资源，本章还将介绍LVM（Logical Volume  Manager，逻辑卷管理器）的部署、扩容、缩小、快照以及卸载删除的相关知识。相信读者在学完本章内容后，可以在企业级生产环境中灵活运用RAID和LVM来满足对存储资源的高级管理需求。

本章目录结构

- 7.1 RAID磁盘冗余阵列
  - [7.1.1 部署磁盘阵列](https://www.linuxprobe.com/basic-learning-07.html#711)
  - [7.1.2 损坏磁盘阵列及修复](https://www.linuxprobe.com/basic-learning-07.html#712)
  - [7.1.3 磁盘阵列+备份盘](https://www.linuxprobe.com/basic-learning-07.html#713)
  - [7.1.4 删除磁盘阵列](https://www.linuxprobe.com/basic-learning-07.html#714)
- 7.2 LVM逻辑卷管理器
  - [7.2.1 部署逻辑卷](https://www.linuxprobe.com/basic-learning-07.html#721)
  - [7.2.2 扩容逻辑卷](https://www.linuxprobe.com/basic-learning-07.html#722)
  - [7.2.3 缩小逻辑卷](https://www.linuxprobe.com/basic-learning-07.html#723)
  - [7.2.4 逻辑卷快照](https://www.linuxprobe.com/basic-learning-07.html#724)
  - [7.2.5 删除逻辑卷](https://www.linuxprobe.com/basic-learning-07.html#725)

##### **7.1 RAID磁盘冗余阵列**

近年来，CPU的处理性能保持着高速增长。2017年，Intel公司发布了i9-7980XE处理器芯片，率先让家用电脑达到了18核心36线程。2020年末，AMD公司又推出了“线程撕裂者”系统处理器3990X，家用电脑自此也可以轻松驾驭64核心128线程的处理器小怪兽了。但与此同时，硬盘设备的性能提升却不是很大，逐渐成为当代计算机整体性能的瓶颈。而且，由于硬盘设备需要进行持续、频繁、大量的IO操作，相较于其他设备，其损坏几率也大幅增加，导致重要数据丢失的几率也随之增加。

硬盘设备是计算机中较容易出现故障的元器件之一，加之由于其需要存储数据的特殊性质，不能像CPU、内存、电源甚至主板那样在出现故障后更换新的就好，所以在生产环境中一定要未雨绸缪，提前做好数据的冗余及异地备份等工作。

1988年，美国加利福尼亚大学伯克利分校首次提出并定义了RAID技术的概念。RAID技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。

任何事物都有它的两面性。RAID技术确实具有非常好的数据冗余备份功能，但是它也相应地提高了成本支出。就像原本我们只有一个电话本，但是为了避免遗失，我们把联系人号码信息写成了两份，自然要为此多买一个电话本，这也就相应地提升了成本支出。RAID技术的设计初衷是减少因为采购硬盘设备带来的费用支出，但是与数据本身的价值相比较，现代企业更看重的则是RAID技术所具备的冗余备份机制以及带来的硬盘吞吐量的提升。也就是说，RAID不仅降低了硬盘设备损坏后丢失数据的几率，还提升了硬盘设备的读写速度，所以它在绝大多数运营商或大中型企业中得到了广泛部署和应用。

出于成本和技术方面的考虑，需要针对不同的需求在数据可靠性及读写性能上做出权衡，制定出满足各自需求的不同方案。目前已有的RAID磁盘阵列的方案至少有十几种，而[刘遄](https://www.linuxprobe.com/)老师接下来会详细讲解RAID 0、RAID 1、RAID 5与RAID 10这4种最常见的方案。这4种方案的对比如表7-1所示，其中*n*代表硬盘总数。

表7-3                          RAID 0、1、5、10方案技术对比

| RAID级别 | 最少硬盘 | 可用容量 | 读写性能 | 安全性 | 特点                                                         |
| -------- | -------- | -------- | -------- | ------ | ------------------------------------------------------------ |
| 0        | 2        | n        | n        | 低     | 追求最大容量和速度，任何一块盘损坏，数据全部异常。           |
| 1        | 2        | n/2      | n        | 高     | 追求最大安全性，只要阵列组中有一块硬盘可用，数据不受影响。   |
| 5        | 3        | n-1      | n-1      | 中     | 在控制成本的前提下，追求硬盘的最大容量、速度及安全性，允许有一块硬盘异常，数据不受影响。 |
| 10       | 4        | n/2      | n/2      | 高     | 综合RAID1和RAID0的优点，追求硬盘的速度和安全性，允许有一半硬盘异常（不可同组），数据不受影响 |



**1. RAID 0**

RAID  0技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障，将导致整个系统的数据都受到破坏。通俗来说，RAID  0技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。如图7-1所示，数据被分别写入到不同的硬盘设备中，即硬盘A和硬盘B设备会分别保存数据资料，最终实现提升读取、写入速度的效果。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-0-1.jpg)

图7-1 RAID 0技术示意图

**2. RAID 1**

尽管RAID  0技术提升了硬盘设备的读写速度，但它是将数据依次写入到各个物理硬盘中。也就是说，它的数据是分开存放的，其中任何一块硬盘发生故障都会损坏整个系统的数据。因此，如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，就需要用到RAID 1技术了。

在图7-2所示的RAID 1技术示意图中可以看到，它是把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-1-1.jpg)

图7-2 RAID 1技术示意图

考虑到在进行写入操作时因硬盘切换带来的开销，因此RAID 1的速度会比RAID  0有微弱地降低。但在读取数据的时候，操作系统可以分别从两块硬盘中读取信息，因此理论读取速度的峰值可以是硬盘数量的倍数。另外，平时只要保证有一块硬盘稳定运行，数据就不会出现损坏的情况，可靠性较高。

RAID  1技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数据，因此硬盘设备的利用率得以下降。从理论上来说，图7-2所示的硬盘空间的真实可用率只有50%，由3块硬盘设备组成的RAID 1磁盘阵列的可用率只有33%左右；以此类推。而且，由于需要把数据同时写入到两块以上的硬盘设备，这无疑也在一定程度上增大了系统计算功能的负载。

那么，有没有一种RAID方案既考虑到了硬盘设备的读写速度和数据安全性，还兼顾了成本问题呢？实际上，单从数据安全和成本问题上来讲，就不可能在保持原有硬盘设备的利用率且还不增加新设备的情况下，能大幅提升数据的安全性。[刘遄](https://www.linuxprobe.com/)老师也没有必要忽悠各位读者，下面将要讲解的RAID 5技术虽然在理论上兼顾了三者（读写速度、数据安全性、成本），但实际上更像是对这三者的“相互妥协”。

**3. RAID 5**

如图7-3所示，RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID  5磁盘阵列中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上。这样的好处是，其中任何一设备损坏后不至于出现致命缺陷。图7-3中Parity部分存放的就是数据的奇偶校验信息。换句话说，就是RAID  5技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-5-1.jpg)

图7-3 RAID5技术示意图

RAID 5最少由3块硬盘组成，使用的是硬盘切割（Disk Striping）技术。相较于RAID  1级别，好处就在于保存的是奇偶校验信息而不是一模一样的文件内容，所以当重复写入某个文件时，RAID  5级别的磁盘阵列组只需要对应一个奇偶校验信息就可以，效率更高，存储成本也会随之降低。

**4.  RAID 10**

RAID 5技术是出于硬盘设备的成本问题对读写速度和数据的安全性能有了一定的妥协，但是大部分企业更在乎的是数据本身的价值而非硬盘价格，因此在生产环境中主要使用RAID 10技术。

顾名思义，RAID 10技术是RAID 1+RAID 0技术的一个“组合体”。如图7-4所示，RAID  10技术需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID  0技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一阵列中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID 10技术继承了RAID 0的高读写速度和RAID 1的数据安全性，在不考虑成本的情况下RAID 10的性能也超过了RAID  5，因此当前成为广泛使用的一种存储技术。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/RAID-10-2.jpg)

图7-4 RAID 10技术示意图

### **Tips**

由于RAID 10是由RAID 1和RAID 0组成的，因此正确的叫法是“RAID一零”，而不是“RAID十”。

仔细查看图7-4可以发现，RAID 10是先对信息进行分割，然后再两两一组制作镜像。也就是先将RAID  1作为最低级别的组合，然后再使用RAID 0技术将RAID 1磁盘阵列组合到一起，将它们视为“一整块”硬盘。而RAID  01则相反，它是先将硬盘分为两组，然后使用RAID 0作为最低级别的组合，再将这两组RAID 0硬盘通过RAID 1技术组合到一起。

RAID 10技术和RAID 01技术的区别非常明显。在RAID  10中，任何一块硬盘损坏都不会影响到数据安全性，其余硬盘均会正常运作。但在RAID 01中，只要有任何一块硬盘损坏，最低级别的RAID  0磁盘阵列马上会停止运作，这可能造成严重隐患。所以RAID 10远比RAID 01常见，很多主板甚至不支持RAID 01。

###### **7.1.1 部署磁盘阵列**

在具备了第6章的硬盘设备管理基础之后，再来部署RAID和LVM就变得十分轻松了。首先，需要在虚拟机中添加4块硬盘设备来制作一个RAID  10磁盘阵列，如图7-5所示。这里不再详述添加硬盘的步骤，大家自己操作就行。记得硬盘要用SCSI或SATA接口的类型，大小默认20GB就可以。

这几块硬盘设备是模拟出来的，不需要特意去买几块真实的物理硬盘插到电脑上。需要注意的是，一定要记得在关闭系统之后，再在虚拟机中添加硬盘设备，否则可能会因为计算机架构的不同而导致虚拟机系统无法识别新添加的硬盘设备。

当前，生产环境中用到的服务器一般都配备RAID阵列卡，尽管服务器的价格越来越便宜，但是我们没有必要为了做一个实验而去单独购买一台服务器，而是可以学会使用mdadm[命令](https://www.linuxcool.com/)在[Linux系统](https://www.linuxprobe.com/)中创建和管理软件RAID磁盘阵列，而且它涉及的理论知识和操作过程与生产环境中的完全一致。

mdadm[命令](https://www.linuxcool.com/)用于创建、调整、监控和管理RAID设备，英文全称为“multiple devices admin”，语法格式为“mdadm参数 硬盘名称”。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/添加四块硬盘设备-1.png)

图7-5 添加四块硬盘设备

mdadm命令中的常用参数及作用如表7-2所示。

表7-2                      mdadm命令的常用参数和作用

| 参数 | 作用             |
| ---- | ---------------- |
| -a   | 检测设备名称     |
| -n   | 指定设备数量     |
| -l   | 指定RAID级别     |
| -C   | 创建             |
| -v   | 显示过程         |
| -f   | 模拟设备损坏     |
| -r   | 移除设备         |
| -Q   | 查看摘要信息     |
| -D   | 查看详细信息     |
| -S   | 停止RAID磁盘阵列 |



接下来，使用mdadm命令创建RAID 10，名称为“/dev/md0”。

第6章中讲到，udev是[Linux](https://www.linuxprobe.com/)系统内核中用来给硬件命名的服务，其命名规则也非常简单。我们可以通过命名规则猜测到第二个SCSI存储设备的名称会是/dev/sdb，然后依此类推。使用硬盘设备来部署RAID磁盘阵列很像是将几位同学组成一个班级，但总不能将班级命名为/dev/sdbcde吧。尽管这样可以一眼看出它是由哪些元素组成的，但是并不利于记忆和阅读。更何况如果使用10、50、100个硬盘来部署RAID磁盘阵列呢？

此时，就需要使用mdadm中的参数了。其中，-C参数代表创建一个RAID阵列卡；-v参数显示创建的过程，同时在后面追加一个设备名称/dev/md0，这样/dev/md0就是创建后的RAID磁盘阵列的名称；-n 4参数代表使用4块硬盘来部署这个RAID磁盘阵列；而-l 10参数则代表RAID 10方案；最后再加上4块硬盘设备的名称就搞定了。

```
[root@linuxprobe ~]# mdadm -Cv /dev/md0 -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde
mdadm: layout defaults to n2
mdadm: layout defaults to n2
mdadm: chunk size defaults to 512K
mdadm: size set to 20954112K
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
```

初始化过程大约需要1分钟左右，期间可以用-D参数进行查看。也可以用-Q参数查看简要信息：

```
[root@linuxprobe ~]# mdadm -Q /dev/md0
/dev/md0: 39.97GiB raid10 4 devices, 0 spares. Use mdadm --detail for more detail.
```

同学们可能会好奇，为什么4块20GB大小的硬盘组成的磁盘阵列组，可用空间只有39.97GB呢？

这里不得不提到RAID 10技术的原理。它通过两两一组硬盘组成的RAID 1磁盘阵列保证了数据的可靠性，其中每一份数据都会被保存两次，因此导致硬盘存在50%的使用率和50%的冗余率。这样一来，80GB的硬盘容量也就只有一半了。

等两三分钟后，把制作好的RAID磁盘阵列格式化为Ext4格式：

```
[root@linuxprobe ~]# mkfs.ext4 /dev/md0
mke2fs 1.44.3 (10-July-2018)
Creating filesystem with 10477056 4k blocks and 2621440 inodes
Filesystem UUID: d1c68318-a919-4211-b4dc-c4437bcfe9da
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
	4096000, 7962624

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (65536 blocks): done
Writing superblocks and filesystem accounting information: done   
```

随后，创建挂载点，将硬盘设备进行挂载操作：

```
[root@linuxprobe ~]# mkdir /RAID
[root@linuxprobe ~]# mount /dev/md0 /RAID
[root@linuxprobe ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  975M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/md0                40G   49M   38G   1% /RAID
```

再来查看/dev/md0磁盘阵列设备的详细信息，确认RAID级别（Raid Level）、阵列大小（Array Size）和总硬盘数（Total Devices）都是否正确：

```
[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Wed Jan 13 08:24:58 2021
        Raid Level : raid10
        Array Size : 41908224 (39.97 GiB 42.91 GB)
     Used Dev Size : 20954112 (19.98 GiB 21.46 GB)
      Raid Devices : 4
     Total Devices : 4
       Persistence : Superblock is persistent

       Update Time : Thu Jan 14 04:49:57 2021
             State : clean 
    Active Devices : 4
   Working Devices : 4
    Failed Devices : 0
     Spare Devices : 0

            Layout : near=2
        Chunk Size : 512K

Consistency Policy : resync

              Name : localhost.localdomain:0  (local to host linuxprobe.com)
              UUID : 289f501b:3f5f70f9:79189d77:f51ca11a
            Events : 17

    Number   Major   Minor   RaidDevice State
       0       8       16        0      active sync set-A   /dev/sdb
       1       8       32        1      active sync set-B   /dev/sdc
       2       8       48        2      active sync set-A   /dev/sdd
       3       8       64        3      active sync set-B   /dev/sde
```

如果想让创建好的RAID磁盘阵列能够一直提供服务，不会因每次的重启操作而取消，那么一定要记得将信息添加到/etc/fstab文件中，这样可以确保在每次重启后RAID磁盘阵列都是有效的。

```
[root@linuxprobe ~]# echo "/dev/md0 /RAID ext4 defaults 0 0" >> /etc/fstab
[root@linuxprobe ~]# cat /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /                 xfs         defaults      0 0
UUID=2db66eb4-d9c1-4522-8fab-ac074cd3ea0b   /boot             xfs         defaults      0 0
/dev/mapper/rhel-swap                       swap              swap        defaults      0 0
/dev/cdrom                                  /media/cdrom      iso9660     defaults      0 0 
/dev/md0                                    /RAID             ext4        defaults      0 0
```

###### **7.1.2 损坏磁盘阵列及修复**

之所以在生产环境中部署RAID  10磁盘阵列，就是为了提高存储设备的IO读写速度及数据的安全性，但因为我们的硬盘设备是在虚拟机中模拟出来的，所以对于读写速度的改善可能并不直观。下面决定给同学们讲解一下RAID磁盘阵列损坏后的处理方法，以确保大家以后在步入运维岗位后不会因为突发事件而手忙脚乱。

在确认有一块物理硬盘设备出现损坏而不能再继续正常使用后，应该使用mdadm命令将其移除，然后查看RAID磁盘阵列的状态，可以发现状态已经改变：

```
[root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdb
mdadm: set /dev/sdb faulty in /dev/md0
[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Thu Jan 14 05:12:20 2021
        Raid Level : raid10
        Array Size : 41908224 (39.97 GiB 42.91 GB)
     Used Dev Size : 20954112 (19.98 GiB 21.46 GB)
      Raid Devices : 4
     Total Devices : 4
       Persistence : Superblock is persistent

       Update Time : Thu Jan 14 05:33:06 2021
             State : clean, degraded 
    Active Devices : 3
   Working Devices : 3
    Failed Devices : 1
     Spare Devices : 0

            Layout : near=2
        Chunk Size : 512K

Consistency Policy : resync

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : 81ee0668:7627c733:0b170c41:cd12f376
            Events : 19

    Number   Major   Minor   RaidDevice State
       -       0        0        0      removed
       1       8       32        1      active sync set-B   /dev/sdc
       2       8       48        2      active sync set-A   /dev/sdd
       3       8       64        3      active sync set-B   /dev/sde

       0       8       16        -      faulty   /dev/sdb
```

刚刚使用的-f参数是让硬盘模拟损坏的效果。为了能够彻底地将故障盘移除，还要再执行一步操作：

```
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdb
mdadm: hot removed /dev/sdb from /dev/md0
```

在RAID 10级别的磁盘阵列中，当RAID 1磁盘阵列中存在一个故障盘时并不影响RAID  10磁盘阵列的使用。当购买了新的硬盘设备后再使用mdadm命令予以替换即可，在此期间可以在/RAID目录中正常地创建或删除文件。由于我们是在虚拟机中模拟硬盘，所以先重启系统，然后再把新的硬盘添加到RAID磁盘阵列中。

更换硬盘后再次使用-a参数进行添加操作，系统默认会自动开始数据的同步工作。使用-D参数即可看到整个过程和进度（用百分比表示）：

```
[root@linuxprobe ~]# mdadm /dev/md0 -a /dev/sdb
mdadm: added /dev/sdb
[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Thu Jan 14 05:12:20 2021
        Raid Level : raid10
        Array Size : 41908224 (39.97 GiB 42.91 GB)
     Used Dev Size : 20954112 (19.98 GiB 21.46 GB)
      Raid Devices : 4
     Total Devices : 4
       Persistence : Superblock is persistent

       Update Time : Thu Jan 14 05:37:32 2021
             State : clean, degraded, recovering 
    Active Devices : 3
   Working Devices : 4
    Failed Devices : 0
     Spare Devices : 1

            Layout : near=2
        Chunk Size : 512K

Consistency Policy : resync

    Rebuild Status : 77% complete

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : 81ee0668:7627c733:0b170c41:cd12f376
            Events : 34

    Number   Major   Minor   RaidDevice State
       4       8       16        0      spare rebuilding    /dev/sdb
       1       8       32        1      active sync set-B   /dev/sdc
       2       8       48        2      active sync set-A   /dev/sdd
       3       8       64        3      active sync set-B   /dev/sde
```

这时候可能会有学生举手提问了：“老师，我们公司机房的阵列卡上有30多块硬盘呢，就算知道/dev/sdb硬盘发生了故障，我也不知道该替换哪一块啊，要是错拔了好设备那就麻烦了。”其实不用担心，因为一旦硬盘发生故障，服务器上相应的指示灯也会变成红灯（或者变成一直闪烁的黄灯），如图7-6所示。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/硬盘故障.png)

###### **7.1.3 磁盘阵列+备份盘**

RAID 10磁盘阵列中最多允许50%的硬盘设备发生故障，但是存在这样一种极端情况，即同一RAID  1磁盘阵列中的硬盘设备若全部损坏，也会导致数据丢失。换句话说，在RAID 10磁盘阵列中，如果RAID  1中的某一块硬盘出现了故障，而我们正在前往修复的路上，恰巧该RAID 1磁盘阵列中的另一块硬盘设备也出现故障，那么数据就被彻底丢失了。[刘遄](https://www.linuxprobe.com/)老师可真不是乌鸦嘴，这种RAID 1磁盘阵列中的硬盘设备同时损坏的情况还真被我的学生遇到过。

在这样的情况下，该怎么办呢？其实，完全可以使用RAID备份盘技术来预防这类事故。该技术的核心理念就是准备一块足够大的硬盘，这块硬盘平时处于闲置状态，一旦RAID磁盘阵列中有硬盘出现故障后则会马上自动顶替上去。这样很棒吧！

为了避免多个实验之间相互发生冲突，我们需要保证每个实验的相对独立性，为此需要大家自行将虚拟机还原到初始状态。另外，由于刚才已经演示了RAID 10磁盘阵列的部署方法，现在来看一下RAID 5的部署效果。部署RAID  5磁盘阵列时，至少需要用到3块硬盘，还需要再加一块备份硬盘（也叫热备盘），所以总计需要在虚拟机中模拟4块硬盘设备，如图7-7所示。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/添加四块硬盘设备-1.png)

图7-7 重置虚拟机后，再添加四块硬盘设备

现在创建一个RAID 5磁盘阵列+备份盘。在下面的命令中，参数-n 3代表创建这个RAID 5磁盘阵列所需的硬盘数，参数-l  5代表RAID的级别，而参数-x 1则代表有一块备份盘。当查看/dev/md0（即RAID  5磁盘阵列的名称）磁盘阵列的时候，就能看到有一块备份盘在等待中了。

```
[root@linuxprobe ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde
mdadm: layout defaults to left-symmetric
mdadm: layout defaults to left-symmetric
mdadm: chunk size defaults to 512K
mdadm: size set to 20954112K
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Thu Jan 14 06:12:32 2021
        Raid Level : raid5
        Array Size : 41908224 (39.97 GiB 42.91 GB)
     Used Dev Size : 20954112 (19.98 GiB 21.46 GB)
      Raid Devices : 3
     Total Devices : 4
       Persistence : Superblock is persistent

       Update Time : Thu Jan 14 06:14:16 2021
             State : clean 
    Active Devices : 3
   Working Devices : 4
    Failed Devices : 0
     Spare Devices : 1

            Layout : left-symmetric
        Chunk Size : 512K

Consistency Policy : resync

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : cf0c34b6:3b08edfb:85dfa14f:e2bffc1e
            Events : 18

    Number   Major   Minor   RaidDevice State
       0       8       16        0      active sync   /dev/sdb
       1       8       32        1      active sync   /dev/sdc
       4       8       48        2      active sync   /dev/sdd

       3       8       64        -      spare   /dev/sde
```

现在将部署好的RAID 5磁盘阵列格式化为Ext4文件格式，然后挂载到目录上，之后就能够使用了：

```
[root@linuxprobe ~]# mkfs.ext4 /dev/md0
mke2fs 1.44.3 (10-July-2018)
Creating filesystem with 10477056 4k blocks and 2621440 inodes
Filesystem UUID: ff016386-1126-4799-8a5b-d716242276ec
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
	4096000, 7962624

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (65536 blocks): done
Writing superblocks and filesystem accounting information: done   
[root@linuxprobe ~]# mkdir /RAID
[root@linuxprobe ~]# echo "/dev/md0 /RAID ext4 defaults 0 0" >> /etc/fstab
```

由3块硬盘组成的RAID 5磁盘阵列，其对应的可用空间是*n*-1，也就是40GB。热备盘的空间不计算进来，平时完全就是在“睡觉”，只有在意外出现时才会开始工作。

```
[root@linuxprobe ~]# mount -a
[root@linuxprobe ~]# df -h
Filesystem             Size  Used Avail Use% Mounted on
devtmpfs               969M     0  969M   0% /dev
tmpfs                  984M     0  984M   0% /dev/shm
tmpfs                  984M  9.6M  974M   1% /run
tmpfs                  984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root   17G  3.9G   14G  23% /
/dev/sr0               6.7G  6.7G     0 100% /media/cdrom
/dev/sda1             1014M  152M  863M  15% /boot
tmpfs                  197M   16K  197M   1% /run/user/42
tmpfs                  197M  3.5M  194M   2% /run/user/0
/dev/md0                40G   49M   38G   1% /RAID
```

最后是见证奇迹的时刻！我们再次把硬盘设备/dev/sdb移出磁盘阵列，然后迅速查看/dev/md0磁盘阵列的状态，就会发现备份盘已经被自动顶替上去并开始了数据同步。RAID中的这种备份盘技术非常实用，可以在保证RAID磁盘阵列数据安全性的基础上进一步提高数据可靠性。所以，如果公司不差钱的话，还是买上一块备份盘以防万一吧。

```
[root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdb
mdadm: set /dev/sdb faulty in /dev/md0
[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Thu Jan 14 06:12:32 2021
        Raid Level : raid5
        Array Size : 41908224 (39.97 GiB 42.91 GB)
     Used Dev Size : 20954112 (19.98 GiB 21.46 GB)
      Raid Devices : 3
     Total Devices : 4
       Persistence : Superblock is persistent

       Update Time : Thu Jan 14 06:24:38 2021
             State : clean 
    Active Devices : 3
   Working Devices : 3
    Failed Devices : 1
     Spare Devices : 0

            Layout : left-symmetric
        Chunk Size : 512K

Consistency Policy : resync

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : cf0c34b6:3b08edfb:85dfa14f:e2bffc1e
            Events : 37

    Number   Major   Minor   RaidDevice State
       3       8       64        0      active sync   /dev/sde
       1       8       32        1      active sync   /dev/sdc
       4       8       48        2      active sync   /dev/sdd

       0       8       16        -      faulty   /dev/sdb
```

是不是感觉很有意思呢？另外考虑到篇幅限制，我们一直没有复制、粘贴/RAID目录中文件的信息，有兴趣的同学可以自己动手试一下。里面的文件内容非常安全，不会出现丢失的情况。如果后面想再添加一块热备盘进来，使用-a参数就可以了。

###### **7.1.4 删除磁盘阵列**

在生产环境中，RAID磁盘阵列部署后一般不会被轻易停用。但万一赶上了，还是要知道怎么将磁盘阵列删除。前面那种RAID 5+热备盘损坏的情况是比较复杂的，所以以这种情形来进行讲解是再好不过了。

首先，需要将所有的磁盘都设置成停用状态：

```
[root@linuxprobe ~]# umount /RAID
[root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdc
mdadm: set /dev/sdc faulty in /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdd
mdadm: set /dev/sdd faulty in /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sde
mdadm: set /dev/sde faulty in /dev/md0
```

然后再逐一移除出去：

```
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdb
mdadm: hot removed /dev/sdb from /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdc
mdadm: hot removed /dev/sdc from /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sdd
mdadm: hot removed /dev/sdd from /dev/md0
[root@linuxprobe ~]# mdadm /dev/md0 -r /dev/sde
mdadm: hot removed /dev/sde from /dev/md0
```

如果着急，也可以用“mdadm /dev/md0 -f /dev/sdb -r /dev/sdb”这一条命令搞定。但是，在早期版本的服务器中，这条命令中的-f和-r不能一起使用，因此保守起见，还是一步步地操作吧。

将所有的硬盘都移除后，再来查看磁盘阵列组的状态：

```
[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Fri Jan 15 08:53:41 2021
        Raid Level : raid5
        Array Size : 41908224 (39.97 GiB 42.91 GB)
     Used Dev Size : 20954112 (19.98 GiB 21.46 GB)
      Raid Devices : 3
     Total Devices : 0
       Persistence : Superblock is persistent

       Update Time : Fri Jan 15 09:00:57 2021
             State : clean, FAILED 
    Active Devices : 0
    Failed Devices : 0
     Spare Devices : 0

            Layout : left-symmetric
        Chunk Size : 512K

Consistency Policy : resync

    Number   Major   Minor   RaidDevice State
       -       0        0        0      removed
       -       0        0        1      removed
       -       0        0        2      removed
```

很棒！下面继续停用整个RAID磁盘阵列，咱们的工作就彻底完成了：

```
[root@linuxprobe ~]# mdadm --stop /dev/md0
mdadm: stopped /dev/md0
[root@linuxprobe ~]# ls /dev/md0
ls: cannot access '/dev/md0': No such file or directory
```

在有一些老版本的服务器中，在使用--stop参数后依然会保留设备文件。这很明显是没有处理干净，这时再执行一下“mdadm --remove /dev/md0”命令即可。同学们可以记一下，以备不时之需。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

##### **7.2 LVM逻辑卷管理器**

前面学习的硬盘设备管理技术虽然能够有效地提高硬盘设备的读写速度以及数据的安全性，但是在硬盘分好区或者部署为RAID磁盘阵列之后，再想修改硬盘分区大小就不容易了。换句话说，当用户想要随着实际需求的变化调整硬盘分区的大小时，会受到硬盘“灵活性”的限制。这时就需要用到另外一项非常普及的硬盘设备资源管理技术了—逻辑卷管理器（Logical Volume Manager，LVM）。LVM允许用户对硬盘资源进行动态调整。

LVM是Linux系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。尽管对传统的硬盘分区进行强制扩容或缩容从理论上来讲是可行的，但是却可能造成数据的丢失。而LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整。LVM的技术架构如图7-8所示。

为了帮助大家理解，我们来看一个吃货的例子。比如小明家里想吃馒头，但是面粉不够了，于是妈妈从隔壁老王家、老李家、老张家分别借来一些面粉，准备蒸馒头吃。首先需要把这些面粉（物理卷[Physical Volume，PV]）揉成一个大面团（卷组[Volume Group]，VG），然后再把这个大面团分割成一个个小馒头（逻辑卷[Logical  Volume，LV]），而且每个小馒头的重量必须是每勺面粉（基本单元[Physical Extent，PE]）的倍数。

在日常的使用中，如果卷组（VG）的剩余容量不足，可以随时将新的物理卷（PV）加入到里面，进行不断地扩容。由于担心同学们还是不理解，这里准备了一张逻辑卷管理器的使用流程示意图，如图7-9所示。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/LVM逻辑卷管理器-1.jpg)

图7-8 逻辑卷管理器的技术结构

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/LVM逻辑卷管理期使用流程示意图-1-295x300.jpg)

图7-9 逻辑卷管理器使用流程图

物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列。卷组建立在物理卷之上，一个卷组能够包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。

###### **7.2.1 部署逻辑卷**

一般而言，在生产环境中无法在最初时就精确地评估每个硬盘分区在日后的使用情况，因此会导致原先分配的硬盘分区不够用。比如，伴随着业务量的增加，用于存放交易记录的数据库目录的体积也随之增加；因为分析并记录用户的行为从而导致日志目录的体积不断变大，这些都会导致原有的硬盘分区在使用上捉襟见肘。而且，还存在对较大的硬盘分区进行精简缩容的情况。

我们可以通过部署LVM来解决上述问题。部署时，需要逐个配置物理卷、卷组和逻辑卷，常用的部署命令如表7-3所示。

表7-3                          常用的LVM部署命令

| 功能/命令 | 物理卷管理 | 卷组管理  | 逻辑卷管理 |
| --------- | ---------- | --------- | ---------- |
| 扫描      | pvscan     | vgscan    | lvscan     |
| 建立      | pvcreate   | vgcreate  | lvcreate   |
| 显示      | pvdisplay  | vgdisplay | lvdisplay  |
| 删除      | pvremove   | vgremove  | lvremove   |
| 扩展      |            | vgextend  | lvextend   |
| 缩小      |            | vgreduce  | lvreduce   |



为了避免多个实验之间相互发生冲突，请大家自行将虚拟机还原到初始状态，并重新添加两块新硬盘设备，如图7-10所示。然后开机。

![第7章 使用RAID与LVM磁盘阵列技术第7章 使用RAID与LVM磁盘阵列技术](https://www.linuxprobe.com/wp-content/uploads/2020/05/添加两块新硬盘-1.png)

图7-10 在虚拟机中添加两块新的硬盘设备

在虚拟机中添加两块新硬盘设备的目的，是为了更好地演示LVM理念中用户无须关心底层物理硬盘设备的特性。我们先对这两块新硬盘进行创建物理卷的操作，可以将该操作简单理解成让硬盘设备支持LVM技术，或者理解成是把硬盘设备加入到LVM技术可用的硬件资源池中，然后对这两块硬盘进行卷组合并，卷组的名称允许由用户自定义。接下来，根据需求把合并后的卷组切割出一个约为150MB的逻辑卷设备，最后把这个逻辑卷设备格式化成Ext4文件系统后挂载使用。下文将对每一个步骤做一些简单的描述。

**第1步**：让新添加的两块硬盘设备支持LVM技术。

```
[root@linuxprobe ~]# pvcreate /dev/sdb /dev/sdc
  Physical volume "/dev/sdb" successfully created.
  Physical volume "/dev/sdc" successfully created.
```

**第2步**：把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。

```
[root@linuxprobe ~]# vgcreate storage /dev/sdb /dev/sdc
 Volume group "storage" successfully created
[root@linuxprobe ~]# vgdisplay
  --- Volume group ---
  VG Name               storage
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               39.99 GiB
  PE Size               4.00 MiB
  Total PE              10238
  Alloc PE / Size       0 / 0   
  Free  PE / Size       10238 / 39.99 GiB
  VG UUID               HPwsm4-lOvI-8O0Q-TG54-BkyI-ONYE-owlGLd
………………省略部分输出信息………………
```

**第3步**：再切割出一个约为150MB的逻辑卷设备。

这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L  150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l  37可以生成一个大小为37×4MB=148MB的逻辑卷。

```
[root@linuxprobe ~]# lvcreate -n vo -l 37 storage
 Logical volume "vo" created.
[root@linuxprobe ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/storage/vo
  LV Name                vo
  VG Name                storage
  LV UUID                AsDGJj-G6Uo-HG4q-auD6-lmyn-aLY0-o36HEj
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2021-01-15 00:47:35 +0800
  LV Status              available
  # open                 0
  LV Size                148.00 MiB
  Current LE             37
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2
………………省略部分输出信息………………
```

**第4步**：把生成好的逻辑卷进行格式化，然后挂载使用。

Linux系统会把LVM中的逻辑卷设备存放在/dev设备目录中（实际上就是个快捷方式），同时会以卷组的名称来建立一个目录，其中保存了逻辑卷的设备映射文件（即/dev/卷组名称/逻辑卷名称）。

```
[root@linuxprobe ~]# mkfs.ext4 /dev/storage/vo 
mke2fs 1.44.3 (10-July-2018)
Creating filesystem with 151552 1k blocks and 38000 inodes
Filesystem UUID: 429cbc28-4463-4a1b-b601-02a7cf81a1b2
Superblock backups stored on blocks: 
	8193, 24577, 40961, 57345, 73729

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done 
[root@linuxprobe ~]# mkdir /linuxprobe
[root@linuxprobe ~]# mount /dev/storage/vo /linuxprobe
```

对了，如果使用了逻辑卷管理器，则不建议用XFS文件系统，因为XFS文件系统自身就可以使用xfs_growfs命令进行磁盘扩容。这虽然不比LVM灵活，但起码也够用。在实测阶段我们发现，在有一些服务器上，XFS与LVM的兼容性并不好。

**第5步**：查看挂载状态，并写入配置文件，使其永久生效。

```
[root@linuxprobe ~]# df -h
Filesystem              Size  Used Avail Use% Mounted on
devtmpfs                969M     0  969M   0% /dev
tmpfs                   984M     0  984M   0% /dev/shm
tmpfs                   984M  9.6M  974M   1% /run
tmpfs                   984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root    17G  3.9G   14G  23% /
/dev/sr0                6.7G  6.7G     0 100% /media/cdrom
/dev/sda1              1014M  152M  863M  15% /boot
tmpfs                   197M   16K  197M   1% /run/user/42
tmpfs                   197M  3.4M  194M   2% /run/user/0
/dev/mapper/storage-vo  140M  1.6M  128M   2% /linuxprobe
[root@linuxprobe ~]# echo "/dev/storage/vo /linuxprobe ext4 defaults 0 0" >> /etc/fstab
[root@linuxprobe ~]# cat /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /                       xfs      defaults        0 0
UUID=2db66eb4-d9c1-4522-8fab-ac074cd3ea0b   /boot                   xfs      defaults        0 0
/dev/mapper/rhel-swap                       swap                    swap     defaults        0 0
/dev/cdrom                                  /media/cdrom            iso9660  defaults        0 0 
/dev/storage/vo                             /linuxprobe             ext4     defaults        0 0
```

### **Tips**

细心的同学应该又发现了一个小问题：刚刚明明写的是148MB，怎么这里只有140MB了呢？这是因为硬件厂商的制造标准是1GB=1,000MB、1MB＝1,000KB、1KB＝1,000B，而计算机系统的算法是1GB=1,024MB、1MB＝1,024KB、1KB＝1,024B，因此有3%左右的“缩水”是正常情况。

###### **7.2.2 扩容逻辑卷**

在前面的实验中，卷组是由两块硬盘设备共同组成的。用户在使用存储设备时感知不到设备底层的架构和布局，更不用关心底层是由多少块硬盘组成的，只要卷组中有足够的资源，就可以一直为逻辑卷扩容。扩容前请一定要记得卸载设备和挂载点的关联。

```
[root@linuxprobe ~]# umount /linuxprobe
```

**第1步**：把上一个实验中的逻辑卷vo扩展至290MB。

```
[root@linuxprobe ~]# lvextend -L 290M /dev/storage/vo
Rounding size to boundary between physical extents: 292.00 MiB.
Size of logical volume storage/vo changed from 148 MiB (37 extents) to 292 MiB (73 extents).
Logical volume storage/vo successfully resized.
```

**第2步**：检查硬盘的完整性，确认目录结构、内容和文件内容没有丢失。一般情况下没有报错，均为正常情况。

```
[root@linuxprobe ~]# e2fsck -f /dev/storage/vo
e2fsck 1.44.3 (10-July-2018)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/storage/vo: 11/38000 files (0.0% non-contiguous), 10453/151552 blocks
```

**第3步**：重置设备在系统中的容量。刚刚是对LV（逻辑卷）设备进行了扩容操作，但系统内核还没有同步到这部分新修改的信息，需要手动进行同步。

```
[root@linuxprobe ~]# resize2fs /dev/storage/vo
resize2fs 1.44.3 (10-July-2018)
Resizing the filesystem on /dev/storage/vo to 299008 (1k) blocks.
The filesystem on /dev/storage/vo is now 299008 (1k) blocks long.
```

**第4步**：重新挂载硬盘设备并查看挂载状态。

```
[root@linuxprobe ~]# mount -a
[root@linuxprobe ~]# df -h
Filesystem              Size  Used Avail Use% Mounted on
devtmpfs                969M     0  969M   0% /dev
tmpfs                   984M     0  984M   0% /dev/shm
tmpfs                   984M  9.6M  974M   1% /run
tmpfs                   984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root    17G  3.9G   14G  23% /
/dev/sr0                6.7G  6.7G     0 100% /media/cdrom
/dev/sda1              1014M  152M  863M  15% /boot
tmpfs                   197M   16K  197M   1% /run/user/42
tmpfs                   197M  3.4M  194M   2% /run/user/0
/dev/mapper/storage-vo  279M  2.1M  259M   1% /linuxprobe
```

###### **7.2.3 缩小逻辑卷**

相较于扩容逻辑卷，在对逻辑卷进行缩容操作时，数据丢失的风险更大。所以在生产环境中执行相应操作时，一定要提前备份好数据。另外，Linux系统规定，在对LVM逻辑卷进行缩容操作之前，要先检查文件系统的完整性（当然这也是为了保证数据的安全）。在执行缩容操作前记得先把文件系统卸载掉。

```
[root@linuxprobe ~]# umount /linuxprobe
```

**第1步**：检查文件系统的完整性。

```
[root@linuxprobe ~]# e2fsck -f /dev/storage/vo
e2fsck 1.44.3 (10-July-2018)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/storage/vo: 11/74000 files (0.0% non-contiguous), 15507/299008 blocks
```

**第2步**：通知系统内核将逻辑卷vo的容量减小到120MB。

```
[root@linuxprobe ~]# resize2fs /dev/storage/vo 120M
resize2fs 1.44.3 (10-July-2018)
Resizing the filesystem on /dev/storage/vo to 122880 (1k) blocks.
The filesystem on /dev/storage/vo is now 122880 (1k) blocks long.
```

**第3步**：将LV逻辑卷的容量修改为120M。

```
[root@linuxprobe ~]# lvreduce -L 120M /dev/storage/vo
  WARNING: Reducing active logical volume to 120.00 MiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce storage/vo? [y/n]: y
  Size of logical volume storage/vo changed from 292 MiB (73 extents) to 120 MiB (30 extents).
  Logical volume storage/vo successfully resized.
```

咦？缩容的步骤跟扩容的步骤不一样啊。缩容操作为什么是先通知系统内核设备的容量要改变成120MB，然后再正式进行缩容操作呢？举个例子大家就明白了。小强是一名初中生，开学后看到班里有位同学纹了身，他感觉很酷，自己也想纹但又怕家里责骂，于是他回家后就说：“妈妈，我纹身了。”如果妈妈的反应很平和，那么他就可以放心大胆地去纹身了。如果妈妈强烈不同意，他马上就可以哈哈一笑，说：“逗着玩呢。”这样也就不会挨打了。

缩容操作也是同样的道理，先通知系统内核自己想缩小逻辑卷，如果在执行resize2fs命令后系统没有报错，再正式操作。

**第4步**：重新挂载文件系统并查看系统状态。

```
[root@linuxprobe ~]# mount -a
[root@linuxprobe ~]# df -h
Filesystem              Size  Used Avail Use% Mounted on
devtmpfs                969M     0  969M   0% /dev
tmpfs                   984M     0  984M   0% /dev/shm
tmpfs                   984M  9.6M  974M   1% /run
tmpfs                   984M     0  984M   0% /sys/fs/cgroup
/dev/mapper/rhel-root    17G  3.9G   14G  23% /
/dev/sr0                6.7G  6.7G     0 100% /media/cdrom
/dev/sda1              1014M  152M  863M  15% /boot
tmpfs                   197M   16K  197M   1% /run/user/42
tmpfs                   197M  3.4M  194M   2% /run/user/0
/dev/mapper/storage-vo  113M  1.6M  103M   2% /linuxprobe
```

###### **7.2.4 逻辑卷快照**

LVM还具备有“快照卷”功能，该功能类似于虚拟机软件的还原时间点功能。例如，对某一个逻辑卷设备做一次快照，如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：

> 快照卷的容量必须等同于逻辑卷的容量；
>
> 快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。

在正式操作前，先看看VG（卷组）中的容量是否够用：

```
[root@linuxprobe ~]# vgdisplay
  --- Volume group ---
  VG Name               storage
  System ID             
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  4
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               39.99 GiB
  PE Size               4.00 MiB
  Total PE              10238
  Alloc PE / Size       30 / 120.00 MiB
  Free  PE / Size       10208 / <39.88 GiB
  VG UUID               k3ZnaP-wGPr-TQJ5-PCtA-0RgO-jvsi-9elZ5M
………………省略部分输出信息………………
```

通过卷组的输出信息可以清晰看到，卷组中已经使用了120MB的容量，空闲容量还有39.88GB。接下来用重定向往逻辑卷设备所挂载的目录中写入一个文件。

```
[root@linuxprobe ~]# echo "Welcome to Linuxprobe.com" > /linuxprobe/readme.txt
[root@linuxprobe ~]# ls -l /linuxprobe
total 14
drwx------. 2 root root 12288 Jan 15 01:11 lost+found
-rw-r--r--. 1 root root    26 Jan 15 07:01 readme.txt
```

**第1步**：使使用-s参数生成一个快照卷，使用-L参数指定切割的大小，需要与要做快照的设备容量保持一致。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作，稍后数据也会还原到这个相应的设备上。

```
[root@linuxprobe ~]# lvcreate -L 120M -s -n SNAP /dev/storage/vo
 Logical volume "SNAP" created
[root@linuxprobe ~]# lvdisplay
  --- Logical volume ---
  LV Path                /dev/storage/SNAP
  LV Name                SNAP
  VG Name                storage
  LV UUID                qd7l6w-3Iv1-6E3X-RGkC-t5xl-170r-rDZSEf
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2021-01-15 07:02:44 +0800
  LV snapshot status     active destination for vo
  LV Status              available
  # open                 0
  LV Size                120.00 MiB
  Current LE             30
  COW-table size         120.00 MiB
  COW-table LE           30
  Allocated to snapshot  0.01%
  Snapshot chunk size    4.00 KiB
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:5
………………省略部分输出信息………………
```

**第2步**：在逻辑卷所挂载的目录中创建一个100MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间的占用量上升了。

```
[root@linuxprobe ~]# dd if=/dev/zero of=/linuxprobe/files count=1 bs=100M
1+0 records in
1+0 records out
104857600 bytes (105 MB, 100 MiB) copied, 0.312057 s, 336 MB/s
[root@linuxprobe ~]# lvdisplay
  --- Logical volume ---
  LV Path                /dev/storage/SNAP
  LV Name                SNAP
  VG Name                storage
  LV UUID                qd7l6w-3Iv1-6E3X-RGkC-t5xl-170r-rDZSEf
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2021-01-15 07:02:44 +0800
  LV snapshot status     active destination for vo
  LV Status              available
  # open                 0
  LV Size                120.00 MiB
  Current LE             30
  COW-table size         120.00 MiB
  COW-table LE           30
  Allocated to snapshot  83.71%
  Snapshot chunk size    4.00 KiB
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:5
………………省略部分输出信息………………
```

**第3步**：为了校验快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载。

lvconvert命令用于管理逻辑卷的快照，语法格式为“lvconvert [参数]快照卷名称”。

使用lvconvert命令能自动回复逻辑卷的快照，在早期的RHEL/[CentOS](https://www.linuxprobe.com/) 5版本中要写全格式：“--mergesnapshot”，而从RHEL 6到RHEL 8，已经允许用户只输入--merge参数进行操作了，系统会自动分辨设备的类型。

```
[root@linuxprobe ~]# umount /linuxprobe
[root@linuxprobe ~]# lvconvert --merge /dev/storage/SNAP
  Merging of volume storage/SNAP started.
  storage/vo: Merged: 36.41%
  storage/vo: Merged: 100.00%
```

**第4步**：快照卷会被自动删除掉，并且刚刚在逻辑卷设备被执行快照操作后再创建出来的100MB的垃圾文件也被清除了。

```
[root@linuxprobe ~]# mount -a
[root@linuxprobe ~]# cd /linuxprobe/
[root@linuxprobe linuxprobe]# ls
lost+found readme.txt
[root@linuxprobe linuxprobe]# cat readme.txt 
Welcome to Linuxprobe.com
```

###### **7.2.5 删除逻辑卷**

当生产环境中想要重新部署LVM或者不再需要使用LVM时，则需要执行LVM的删除操作。为此，需要提前备份好重要的数据信息，然后依次删除逻辑卷、卷组、物理卷设备，这个顺序不可颠倒。

**第1步**：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。

```
[root@linuxprobe ~]# umount /linuxprobe
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2020
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /                       xfs      defaults        0 0
UUID=2db66eb4-d9c1-4522-8fab-ac074cd3ea0b   /boot                   xfs      defaults        0 0
/dev/mapper/rhel-swap                       swap                    swap     defaults        0 0
/dev/cdrom                                  /media/cdrom            iso9660  defaults        0 0 
/dev/storage/vo                             /linuxprobe             ext4     defaults        0 0
```

**第2步**：删除逻辑卷设备，需要输入y来确认操作。

```
[root@linuxprobe ~]# lvremove /dev/storage/vo 
Do you really want to remove active logical volume storage/vo? [y/n]: y
  Logical volume "vo" successfully removed
```

**第3步**：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。

```
[root@linuxprobe ~]# vgremove storage
  Volume group "storage" successfully removed
```

**第4步**：删除物理卷设备。

```
[root@linuxprobe ~]# pvremove /dev/sdb /dev/sdc
  Labels on physical volume "/dev/sdb" successfully wiped.
  Labels on physical volume "/dev/sdc" successfully wiped.
```

在上述操作执行完毕之后，再执行lvdisplay、vgdisplay、pvdisplay命令来查看LVM的信息时就不会再看到相关信息了（前提是上述步骤的操作是正确的）。干净利落！

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．RAID技术主要是为了解决什么问题？

**答：**RAID技术可以解决存储设备的读写速度问题及数据的冗余备份问题。

2．RAID 0和RAID 5哪个更安全？

**答：**RAID 0没有数据冗余功能，因此RAID 5更安全。

3．假设使用4块硬盘来部署RAID 10方案，外加一块备份盘，最多可以允许几块硬盘同时损坏呢？

**答：**最多允许5块硬盘设备中的3块设备同时损坏。

4．位于LVM最底层的是物理卷还是卷组？

**答：**最底层的是物理卷，然后再通过物理卷组成卷组。

5．LVM对逻辑卷的扩容和缩容操作有何异同点呢？

**答：**扩容和缩容操作都需要先取消逻辑卷与目录的挂载关联；扩容操作是先扩容后检查文件系统完整性，而缩容操作为了保证数据的安全，需要先检查文件系统完整性再缩容。

6．LVM的快照卷能使用几次？

**答：**只可使用一次，而且使用后即自动删除。

7．LVM的删除顺序是怎么样的？

**答：**依次移除逻辑卷、卷组和物理卷。

本文原创地址：https://www.linuxprobe.com/basic-learning-07.html编辑：刘遄，审核员：暂无



# [第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/basic-learning-08.html)

​		

[![img](https://www.linuxprobe.com/imgs/peixun.jpg)](https://www.linuxprobe.com/training)

**Linux系统技术交流QQ群（3963859）验证问题答案：刘遄**[![Linux就该这么学](https://www.linuxprobe.com/wp-content/uploads/2018/02/QQ群.png)](https://www.linuxprobe.com/links/qun.html)

**章节简述：**

保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用。考虑到大家还不了解RHEL 7/8中新增的firewalld防火墙与先前版本中iptables防火墙之间的区别，[刘遄](https://www.linuxprobe.com/)老师决定先带领读者从理论层面和实际层面正确地认识这两款防火墙之间的关系。

本章将分别使用iptables、firewall-cmd、firewall-config和TCP  Wrapper等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验。在学习完这些实验之后，各位读者不仅能够熟练地过滤请求的流量、基于服务程序的名称对流量进行允许和拒绝操作，还可以使用Cockpit轻松监控系统的运行状态，确保[Linux系统](https://www.linuxprobe.com/)的安全性万无一失。

本章目录结构

- [8.1 防火墙管理工具](https://www.linuxprobe.com/basic-learning-08.html#81)
- 8.2 Iptables
  - [8.2.1 策略与规则链](https://www.linuxprobe.com/basic-learning-08.html#821)
  - [8.2.2 基本的命令参数](https://www.linuxprobe.com/basic-learning-08.html#822)
- 8.3 Firewalld
  - [8.3.1 终端管理工具](https://www.linuxprobe.com/basic-learning-08.html#831)
  - [8.3.2 图形管理工具](https://www.linuxprobe.com/basic-learning-08.html#832)
- [8.4 服务的访问控制列表](https://www.linuxprobe.com/basic-learning-08.html#84)
- [8.5 Cockpit驾驶舱管理工具](https://www.linuxprobe.com/basic-learning-08.html#85_Cockpit)

##### **8.1 防火墙管理工具**

众所周知，相较于企业内网，外部的公网环境更加恶劣，罪恶丛生。在公网与企业内网之间充当保护屏障的防火墙（见图8-1）虽然有软件或硬件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。就像家里安装的防盗门一样，目的是保护亲人和财产安全。防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就能够保证仅有合法的流量在企业内网和外部公网之间流动了。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/防火墙作为公网与内网之间的保护屏障-2.jpg)

图8-1 防火墙作为公网与内网之间的保护屏障

从RHEL 7系统开始，firewalld防火墙正式取代了iptables防火墙。对于接触[Linux](https://www.linuxprobe.com/)系统比较早或学习过RHEL 5/6系统的读者来说，当他们发现曾经掌握的知识在RHEL  7/8中不再适用，需要全新学习firewalld时，难免会有抵触心理。其实，iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已；或者说，它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实存在多个防火墙管理工具，旨在方便运维人员管理Linux系统中的防火墙策略，我们只需要配置妥当其中的一个就足够了。

虽然这些工具各有优劣，但它们在防火墙策略的配置思路上是保持一致的。大家甚至可以不用完全掌握本章介绍的内容，只要在这多个防火墙管理工具中任选一款并将其学透，就足以满足日常的工作需求了。

##### **8.2 Iptables**

在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。考虑到iptables在当前生产环境中还具有顽强的生命力，以及为了使大家在求职面试过程中被问到iptables的相关知识时能胸有成竹，[刘遄](https://www.linuxprobe.com/)老师觉得还是有必要在本书中好好地讲解一下这项技术。更何况前文也提到，各个防火墙管理工具的配置思路是一致的，在掌握了iptables后再学习其他防火墙管理工具时，也有借鉴意义。

###### **8.2.1 策略与规则链**

防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。一般而言，防火墙策略规则的设置有两种：“通”（即放行）和“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。

iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：

> 在进行路由选择前处理数据包（PREROUTING）；
>
> 处理流入的数据包（INPUT）；
>
> 处理流出的数据包（OUTPUT）；
>
> 处理转发的数据包（FORWARD）；
>
> 在进行路由选择后处理数据包（POSTROUTING）。

一般来说，从内网向外网发送的流量一般都是可控且良性的，因此使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。

比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无须再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。

但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”“拒绝”“登记”“不理它”。这些动作对应到iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。

下面举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）。

### **Tips**

在[红帽](https://www.linuxprobe.com/)认证考试中必须用REJECT进行拒绝，好让用于判分的[脚本](https://www.linuxcool.com/)得到反应，以获得分值。而在工作中更多建议用DROP进行拒绝，这可以隐藏服务器的运行状态。这样做有很多好处。

当把Linux系统中的防火墙策略设置为REJECT动作后，流量发送方会看到端口不可达的响应：

```
[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
From 192.168.10.10 icmp_seq=1 Destination Port Unreachable
From 192.168.10.10 icmp_seq=2 Destination Port Unreachable
From 192.168.10.10 icmp_seq=3 Destination Port Unreachable
From 192.168.10.10 icmp_seq=4 Destination Port Unreachable
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms
```

而把Linux系统中的防火墙策略修改成DROP动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：

```
[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.

--- 192.168.10.10 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss, time 3000ms
```

###### **8.2.2 基本的[命令](https://www.linuxcool.com/)参数**

iptables是一款基于[命令](https://www.linuxcool.com/)行的防火墙策略管理工具，具有大量的参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无须深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。

根据OSI七层模型的定义，iptables属于数据链路层的服务，所以可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配；一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量。另外，再次提醒一下，防火墙策略规则的匹配顺序是从上到下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。表8-1总结归纳了常用的iptables命令参数。再次强调，无须死记硬背这些参数，只需借助下面的实验来理解掌握即可。

表8-1                      iptables中常用的参数以及作用

| 参数        | 作用                                         |
| ----------- | -------------------------------------------- |
| -P          | 设置默认策略                                 |
| -F          | 清空规则链                                   |
| -L          | 查看规则链                                   |
| -A          | 在规则链的末尾加入新规则                     |
| -I num      | 在规则链的头部加入新规则                     |
| -D num      | 删除某一条规则                               |
| -s          | 匹配来源地址IP/MASK，加叹号“!”表示除这个IP外 |
| -d          | 匹配目标地址                                 |
| -i 网卡名称 | 匹配从这块网卡流入的数据                     |
| -o 网卡名称 | 匹配从这块网卡流出的数据                     |
| -p          | 匹配协议，如TCP、UDP、ICMP                   |
| --dport num | 匹配目标端口号                               |
| --sport num | 匹配来源端口号                               |



**1．在iptables命令后添加-L参数查看已有的防火墙规则链。**

```
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootps
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:bootps

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  anywhere             192.168.122.0/24     ctstate RELATED,ESTABLISHED
ACCEPT     all  --  192.168.122.0/24     anywhere            
ACCEPT     all  --  anywhere             anywhere            
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable
REJECT     all  --  anywhere             anywhere             reject-with icmp-port-unreachable

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     udp  --  anywhere             anywhere             udp dpt:bootpc
```

**2．****在iptables命令后添加-F参数清空已有的防火墙规则链。**

```
[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

**3．****把INPUT规则链的默认策略设置为拒绝。**

```
[root@linuxprobe ~]# iptables -P INPUT DROP
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy DROP)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

前文提到，防火墙策略规则的设置无非有两种方式：“通”和“堵”。当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉。同学们需要留意的是，规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。

**4．****向INPUT链中添加允许ICMP流量进入的策略规则。**

在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。

```
[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT
[root@linuxprobe ~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.154 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.041 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.038 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.046 ms

--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 104ms
rtt min/avg/max/mdev = 0.038/0.069/0.154/0.049 ms
```

**5．删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许。**

使用-F参数会清空已有的所有防火墙策略；使用-D参数可以删除某一条指定的策略，因此更加安全和准确。

```
[root@linuxprobe ~]# iptables -D INPUT 1
[root@linuxprobe ~]# iptables -P INPUT ACCEPT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

**6．将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量。**

要对某台主机进行匹配，可直接写出它的IP地址；如需对网段进行匹配，则需要写为子网掩码的形式（比如192.168.10.0/24）。

```
[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT
[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh 
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
```

再次重申，防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。另外，这里提到的22号端口是ssh服务使用的（有关ssh服务，请见第9章），这里先挖个坑，等大家学完第9章后可再验证这个实验的效果。

在设置完上述INPUT规则链之后，使用IP地址在192.168.10.0/24网段内的主机访问服务器（即前面提到的设置了INPUT规则链的主机）的22端口，效果如下：

```
[root@Client A ~]# ssh 192.168.10.10
The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.
ECDSA key fingerprint is SHA256:5d52kZi1la/FJK4v4jibLBZhLqzGqbJAskZiME6ZXpQ.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.
root@192.168.10.10's password: 此处输入服务器密码
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Wed Jan 20 16:30:28 2021 from 192.168.10.1
```

然后，再使用IP地址在192.168.20.0/24网段内的主机访问服务器的22端口（虽网段不同，但已确认可以相互通信），效果如下：

```
[root@Client B ~]# ssh 192.168.10.10
Connecting to 192.168.10.10:22...
Could not connect to '192.168.10.10' (port 22): Connection failed.
```

由上可以看到，提示连接请求被拒绝了（Connection failed）。

**7．向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则。**

```
[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT
[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
```

**8．向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则。**

```
[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
 REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
………………省略部分输出信息………………
```

**9．向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则。**

前面在添加防火墙策略时，使用的是-I参数，它默认会把规则添加到最上面的位置，因此优先级是最高的。如果工作中需要添加一条最后“兜底”的规则，那就用-A参数吧。这两个参数的效果差别还是很大的：

```
[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -L
Chain INPUT (policy ACCEPT)
target prot opt source destination 
 REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachable
 ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:ssh
 REJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable
 REJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachable
 REJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable
………………省略部分输出信息………………
```

有关iptables命令的知识讲解到此就结束了，大家是不是意犹未尽？考虑到Linux防火墙的发展趋势，大家只要能把上面的实例吸收消化，就可以完全搞定日常的iptables配置工作了。但是请特别注意，使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：

```
[root@linuxprobe ~]# iptables-save 
# Generated by xtables-save v1.8.2 on Wed Jan 20 16:56:27 2021
………………省略部分输出信息………………
```

对了，如果公司服务器是5/6/7版本的话，对应的保存命令应该是：

```
[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ]
```

##### **8.3 Firewalld**

RHEL 8系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux  systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式。

相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑制定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。firewalld中常见的区域名称（默认为public）以及相应的策略规则如表8-2所示。

表8-2                   firewalld中常用的区域名称及策略规则

| 区域     | 默认规则策略                                                 |
| -------- | ------------------------------------------------------------ |
| trusted  | 允许所有的数据包                                             |
| home     | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量 |
| internal | 等同于home区域                                               |
| work     | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量 |
| public   | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量 |
| external | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量 |
| dmz      | 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量 |
| block    | 拒绝流入的流量，除非与流出的流量相关                         |
| drop     | 拒绝流入的流量，除非与流出的流量相关                         |



###### **8.3.1 终端管理工具**

第2章在讲解Linux命令时曾经提到，命令行终端是一种极富效率的工作方式，firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的。大家不要一听到长格式就头大，因为RHEL  8系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外，还可以用Tab键来补齐表8-3中所示的长格式参数。这太棒了！。

表8-3                  firewall-cmd命令中使用的参数以及作用

| 参数                          | 作用                                                 |
| ----------------------------- | ---------------------------------------------------- |
| --get-default-zone            | 查询默认的区域名称                                   |
| --set-default-zone=<区域名称> | 设置默认的区域，使其永久生效                         |
| --get-zones                   | 显示可用的区域                                       |
| --get-services                | 显示预先定义的服务                                   |
| --get-active-zones            | 显示当前正在使用的区域与网卡名称                     |
| --add-source=                 | 将源自此IP或子网的流量导向指定的区域                 |
| --remove-source=              | 不再将源自此IP或子网的流量导向某个指定区域           |
| --add-interface=<网卡名称>    | 将源自该网卡的所有流量都导向某个指定区域             |
| --change-interface=<网卡名称> | 将某个网卡与区域进行关联                             |
| --list-all                    | 显示当前区域的网卡配置参数、资源、端口以及服务等信息 |
| --list-all-zones              | 显示所有区域的网卡配置参数、资源、端口以及服务等信息 |
| --add-service=<服务名>        | 设置默认区域允许该服务的流量                         |
| --add-port=<端口号/协议>      | 设置默认区域允许该端口的流量                         |
| --remove-service=<服务名>     | 设置默认区域不再允许该服务的流量                     |
| --remove-port=<端口号/协议>   | 设置默认区域不再允许该端口的流量                     |
| --reload                      | 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则 |
| --panic-on                    | 开启应急状况模式                                     |
| --panic-off                   | 关闭应急状况模式                                     |



与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且会随着系统的重启而失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加--permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd --reload命令。

### **Tips**

Runtime：当前立即生效，重启后失效。

Permanent：当前不生效，重启后生效。

接下来的实验都很简单，但是提醒大家一定要仔细查看使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算正确配置了防火墙策略，也可能无法达到预期的效果。

**1．查看firewalld服务当前所使用的区域。**

这是一步非常重要的操作。在配置防火墙策略前，必须查看当前生效的是哪个区域，否则配置的防火墙策略将不会立即生效。

```
[root@linuxprobe ~]# firewall-cmd --get-default-zone
public
```

**2．查询指定网卡在firewalld服务中绑定的区域。**

在生产环境中，服务器大多不止有一块网卡。一般来说，充当网关的服务器有两块网卡，一块对公网，另外一块对内网，那么这两块网卡在审查流量时所用的策略肯定也是不一致的。因此，可以根据网卡针对的流量来源，为网卡绑定不同的区域，实现对防火墙策略的灵活管控。

```
[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160
public
```

**3．把网卡默认区域修改为external，并在系统重启后生效。**

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=ens160
The interface is under control of NetworkManager, setting zone to 'external'.
success
[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=ens160
external
```

**4．把firewalld服务的默认区域设置为public。**

默认区域也叫全局配置，指的是对所有网卡都生效的配置，优先级较低。在下面的代码中可以看到，当前默认区域为public，而ens160网卡的区域为external。此时便是以网卡的区域名称为准。

通俗来说，默认区域就是一种通用的政策。例如，食堂为所有人准备了一次性餐具，而环保主义者则会自己携带碗筷。如果您自带了碗筷，就可以用自己的；反之就用食堂统一提供的。

```
[root@linuxprobe ~]# firewall-cmd --set-default-zone=public
Warning: ZONE_ALREADY_SET: public
success
[root@linuxprobe ~]# firewall-cmd --get-default-zone 
public
[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=ens160
externa
```

**5．启动和关闭firewalld防火墙服务的应急状况模式。**

如果想在1s的时间内阻断一切网络连接，有什么好办法呢？大家下意识地会说：“拔掉网线！”这是一个物理级别的高招。但是，如果人在北京，服务器在异地呢？panic紧急模式在这个时候就派上用场了。使用--panic-on参数会立即切断一切网络连接，而使用--panic-off则会恢复网络连接。切记，紧急模式会切断一切网络连接，因此在远程管理服务器时，在按下回车键前一定要三思。

```
[root@linuxprobe ~]# firewall-cmd --panic-on
success
[root@linuxprobe ~]# firewall-cmd --panic-off
success
```

**6．查询SSH和HTTPS协议的流量是否允许放行。**

在工作中可以不使用--zone参数指定区域名称，firewall-cmd命令会自动依据默认区域进行查询，从而减少用户输入量。但是，如果默认区域与网卡所绑定的不一致时，就会发生冲突，因此规范写法的zone参数是一定要加的。

```
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=ssh
yes
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
no
```

**7．把HTTPS协议的流量设置为永久允许放行，并立即生效。**

默认情况下进行的修改都属于Runtime模式，即当前生效而重启后失效，因此在工作和考试中尽量避免使用。而在使用--permanent参数时，则是当前不会立即看到效果，而在重启或重新加载后方可生效。于是，在添加了允许放行HTTPS流量的策略后，查询当前模式策略，发现依然是不允许放行HTTPS协议的流量：

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=https
success
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
no
```

不想重启服务器的话，就用--reload参数吧：

```
[root@linuxprobe ~]# firewall-cmd --reload
success
[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=https
yes
```

**8．把HTTP协议的流量设置为永久拒绝，并立即生效。**

由于在默认情况下HTTP协议的流量就没有被允许，所以会有“Warning: NOT_ENABLED: http”这样的提示信息，因此对实际操作没有影响。

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http
Warning: NOT_ENABLED: http
success
[root@linuxprobe ~]# firewall-cmd --reload 
success
```

**9．把访问8080和8081端口的流量策略设置为允许，但仅限当前生效。**

```
[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp
success
[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports
8080-8081/tcp
```

**10．把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效。**

第9章介绍的SSH远程控制协议是基于TCP/22端口传输控制指令的，如果想让用户通过其他端口号也能访问ssh服务，就可以试试端口转发技术了。通过这项技术，新的端口号在收到用户请求后会自动转发到原本服务的端口上，使得用户能够通过新的端口访问到原本的服务。

来举个例子帮助大家理解。假设小强是电子厂的工人，他喜欢上了三号流水线上的工人小花，但不好意思表白，于是写了一封情书并交给门卫张大爷，希望由张大爷转交给小花。这样一来，情书（信息）的传输由从小强到小花，变成了小强到张大爷再到小花，情书（信息）依然能顺利送达。

使用firewall-cmd命令实现端口转发的格式有点长，这里为大家总结好了：

> firewall-cmd --permanent --zone=**<区域>** --add-forward-port=port=<源端口号>:proto=**<协议>**:toport=**<目标端口号>**:toaddr=**<目标IP地址>**

上述命令中的目标IP地址一般是服务器本机的IP地址：

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10
success
[root@linuxprobe ~]# firewall-cmd --reload
success
```

在客户端使用ssh命令尝试访问192.168.10.10主机的888端口，访问成功：

```
[root@client A ~]# ssh -p 888 192.168.10.10
The authenticity of host '[192.168.10.10]:888 ([192.168.10.10]:888)' can't be established.
ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[192.168.10.10]:888' (ECDSA) to the list of known hosts.
root@192.168.10.10's password:此处输入远程root管理员的密码
Last login: Sun Jul 19 21:43:48 2021 from 192.168.10.10
```

**11．**富规则的设置。

富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）：

```
[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule="rule family="ipv4" source address="192.168.10.0/24" service name="ssh" reject"
success
[root@linuxprobe ~]# firewall-cmd --reload
success
```

在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）：

```
[root@client A ~]# ssh 192.168.10.10
Connecting to 192.168.10.10:22...
Could not connect to '192.168.10.10' (port 22): Connection failed.
```

### **Tips**

“一个男人”和“一个高个子、大眼睛、脸右侧有个酒窝的男人”相比，很明显后者的描述更加精准，减少了错误匹配的概率，应该优先匹配。

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

###### **8.3.2 图形管理工具**

在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张地说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 8中的防火墙策略。但在默认情况下系统并没有提供firewall-config命令，我们需要自行用dnf命令进行安装，所以需要先配置软件仓库。

首先将虚拟机的“CD/DVD（SATA）”光盘选项设置为“使用ISO映像文件”，然后选择已经下载好的系统镜像，如图8-2所示。

> **随书配套的软件资源请在这里下载：**https://www.linuxprobe.com/tools/
>
> **RedHatEnterpriseLinux [RHEL]8.0——红帽操作系统（必需）：**
>
> 由开源软件及全球服务性系统开发商红帽公司出品，最稳定出色的Linux操作系统。
>
> **培训课程介绍视频：https://www.linuxprobe.com/training**

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/挂载系统镜像.png)

8-2  将虚拟机的光盘设备指向ISO镜像

### **Tips**

下载后的系统镜像是以.iso结尾的文件，选中即可，无须解压。

然后，把光盘设备中的系统镜像挂载到/media/cdrom目录：

```
[root@linuxprobe ~]# mkdir -p /media/cdrom
[root@linuxprobe ~]# mount /dev/cdrom /media/cdrom
mount: /media/cdrom: WARNING: device write-protected, mounted read-only.
```

为了能够让软件仓库一直为用户提供服务，更加严谨的做法是将系统镜像文件的挂载信息写入到/etc/fstab文件中，以保证万无一失：

```
[root@linuxprobe ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Tue Jul 21 05:03:40 2021
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/rhel-root                       /                  xfs       defaults        0 0
UUID=2db66eb4-d9c1-4522-8fab-ac074cd3ea0b   /boot              xfs       defaults        0 0
/dev/mapper/rhel-swap                       swap               swap      defaults        0 0
/dev/cdrom                                  /media/cdrom       iso9660   defaults        0 0 
```

最后，使用Vim文本编辑器创建软件仓库的配置文件。与之前版本的系统不同，RHEL 8需要配置两个软件仓库（即[BaseOS]与[AppStream]），且缺一不可。下述命令中用到的具体参数的含义，可参见4.1.4节。

```
[root@linuxprobe ~]# vim /etc/yum.repos.d/rhel8.repo
[BaseOS]
name=BaseOS
baseurl=file:///media/cdrom/BaseOS
enabled=1
gpgcheck=0
[AppStream]
name=AppStream
baseurl=file:///media/cdrom/AppStream
enabled=1
gpgcheck=0
```

在正确配置完软件仓库文件后，就可以开始用yum或dnf命令安装软件了。这两个命令在实际操作中除了名字不同外，执行方法完全一致，大家可随时用yum来替代dnf命令。下面安装firewalld图形用户界面工具：

```
[root@linuxprobe ~]# dnf install firewall-config
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream                                       3.1 MB/s | 3.2 kB     00:00    
BaseOS                                          2.7 MB/s | 2.7 kB     00:00    
Dependencies resolved.
================================================================================
 Package                Arch          Version            Repository        Size
================================================================================
Installing:
 firewall-config        noarch        0.6.3-7.el8        AppStream        157 k

Transaction Summary
================================================================================
Install  1 Package

Total size: 157 k
Installed size: 1.1 M
Is this ok [y/N]: y
Downloading Packages:
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : firewall-config-0.6.3-7.el8.noarch                     1/1 
  Running scriptlet: firewall-config-0.6.3-7.el8.noarch                     1/1 
  Verifying        : firewall-config-0.6.3-7.el8.noarch                     1/1 
Installed products updated.

Installed:
  firewall-config-0.6.3-7.el8.noarch                                            

Complete!
```

安装成功后，firewall-config工具的界面如图8-3所示，其功能具体如下。

> **1：**选择运行时（Runtime）或永久（Permanent）模式的配置。
>
> **2**：可选的策略集合区域列表。
>
> **3**：常用的系统服务列表。
>
> **4：**主机地址的黑白名单。
>
> **5**：当前正在使用的区域。
>
> **6**：管理当前被选中区域中的服务。
>
> **7**：管理当前被选中区域中的端口。
>
> **8：**设置允许被访问的协议。
>
> **9：**设置允许被访问的端口。
>
> **10**：开启或关闭SNAT（源网络地址转换）技术。
>
> **11**：设置端口转发策略。
>
> **12**：控制请求icmp服务的流量。
>
> **13**：管理防火墙的富规则。
>
> **14**：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。
>
> **15**：firewall-config工具的运行状态。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/firewall-config的图形界面-1.jpg)

图8-3 firewall-config的图形界面

除了图8-3中列出的功能，还有用于将网卡与区域绑定的Interfaces选项，以及用于将IP地址与区域绑定的Sources选项。另外再啰唆一句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。

**下面进行动手实践环节。**

先将当前区域中请求http服务的流量设置为允许放行，但仅限当前生效。具体配置如图8-4所示。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/放行请求http服务的流量-1024x591.png)

图8-4 允许放行请求http服务的流量

尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照图8-5所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效（见图8-6）。这与在命令行中使用--reload参数的效果一样。

前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address  Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当通过家中的网关设备（无线路由器）访问本书配套站点[www.linuxprobe.com](https://www.linuxprobe.com/)时，就用到了SNAT技术。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/放行访问8080～8088端口的流量-1024x589.png)

图8-5 放行访问8080～8088端口的流量

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/让配置的防火墙策略规则立即生效-1024x590.png)

图8-6 让配置的防火墙策略规则立即生效

大家可以看一下在网络中不使用SNAT技术（见图8-7）和使用SNAT技术（见图8-8）时的情况。在图8-7所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在图8-8所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2015/03/未用SNAT1.png)

图8-7 没有使用SNAT技术的网络

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2015/03/使用SNAT1.png)

图8-8 使用SNAT技术处理过的网络

使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照图8-9进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/开启防火墙的SNAT技术.png)

图8-9 开启防火墙的SNAT技术

为了让大家直观查看不同工具在实现相同功能时的区别，针对前面使用firewall-cmd配置的防火墙策略规则，这里使用firewall-config工具进行了重新演示：将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如图8-10和图8-11所示。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/配置本地的端口转发-1024x590.png)

图8-10 配置本地的端口转发

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/让防火墙效策略规则立即生效-1024x591.png)

图8-11 让防火墙效策略规则立即生效

用命令配置富规则可真辛苦，幸好我们现在有了图形用户界面的工具。让192.168.10.20主机访问本机的1234端口号，如图8-12所示。其中Element选项能够根据服务名称、端口号、协议等信息进行匹配；Source与Destination选项后的inverted复选框代表反选功能，将其选中则代表对已填写信息进行反选，即选中填写信息以外的主机地址；Log复选框在选中后，日志不仅会被记录到日志文件中，而且还可以在设置日志的级别（Level）后，再将日志记录到日志文件中，以方便后续的筛查。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/配置防火墙富规则策略-1-1024x590.png)

图8-12 配置防火墙富规则策略

如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定（见图8-13和图8-14），这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行有针对性的监控，效果会更好。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/把网卡与防火墙策略区域进行绑定-1024x591.png)

图8-13 把网卡与防火墙策略区域进行绑定 ![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/网卡与策略区域绑定完成-1024x590.png)

图8-14 网卡与策略区域绑定完成

最后再提一句，firewall-config工具真的非常实用，很多原本复杂的长命令被图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。

##### **8.4 服务的访问控制列表**

TCP Wrapper是RHEL 6/7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序做出允许或拒绝的操作。在RHEL 8版本中，它已经被firewalld正式替代。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrapper服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。

TCP  Wrapper服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则会进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件都没有匹配到，则默认放行流量。

由于RHEL 8版本已经不再支持TCP Wrapper服务程序，因此我们接下来选择在一台老版本的服务器上进行实验。TCP Wrapper服务的控制列表文件配置起来并不复杂，常用的参数如表8-4所示。

表8-4              TCP Wrappers服务的控制列表文件中常用的参数

| 客户端类型     | 示例                       | 满足示例的客户端列表               |
| -------------- | -------------------------- | ---------------------------------- |
| 单一主机       | 192.168.10.10              | IP地址为192.168.10.10的主机        |
| 指定网段       | 192.168.10.                | IP段为192.168.10.0/24的主机        |
| 指定网段       | 192.168.10.0/255.255.255.0 | IP段为192.168.10.0/24的主机        |
| 指定DNS后缀    | .linuxprobe.com            | 所有DNS后缀为.linuxprobe.com的主机 |
| 指定主机名称   | www.linuxprobe.com         | 主机名称为www.linuxprobe.com的主机 |
| 指定所有客户端 | ALL                        | 所有主机全部包括在内               |



在配置TCP Wrapper服务时需要遵循两个原则：

> 编写拒绝策略规则时，填写的是服务名称，而非协议名称；
>
> 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。

下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须修改/etc/hosts.deny文件中原有的注释信息）：

```
[root@linuxprobe ~]# vim /etc/hosts.deny
#
# hosts.deny This file contains access rules which are used to
# deny connections to network services that either use
# the tcp_wrappers library or that have been
# started through a tcp_wrappers-enabled xinetd.
#
# The rules in this file can also be set up in
# /etc/hosts.allow with a 'deny' option instead.
#
# See 'man 5 hosts_options' and 'man 5 hosts_access'
# for information on rule syntax.
# See 'man tcpd' for information on tcp_wrappers
sshd:*
[root@linuxprobe ~]# ssh 192.168.10.10
ssh_exchange_identification: read: Connection reset by peer
```

接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，且访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观：

```
[root@linuxprobe ~]# vim /etc/hosts.allow
#
# hosts.allow This file contains access rules which are used to
# allow or deny connections to network services that
# either use the tcp_wrappers library or that have been
# started through a tcp_wrappers-enabled xinetd.
#
# See 'man 5 hosts_options' and 'man 5 hosts_access'
# for information on rule syntax.
# See 'man tcpd' for information on tcp_wrappers
sshd:192.168.10.

[root@linuxprobe ~]# ssh 192.168.10.10
The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.
ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.
root@192.168.10.10's password: 
Last login: Wed May 4 07:56:29 2021
[root@linuxprobe ~]# 
```

##### **8.5 Cockpit驾驶舱管理工具**

首先，Cockpit是一个英文单词，即“（飞机、船或赛车的）驾驶舱、驾驶座”（见图8-15），它用名字传达出了功能丰富的特性。其次，Cockpit是一个基于Web的图形化服务管理工具，对用户相当友好，即便是新手也可以轻松上手。而且它天然具备很好的跨平台性，因此被广泛应用于服务器、容器、虚拟机等多种管理场景。最后，红帽公司对Cockpit也十分看重，直接将它默认安装到了RHEL 8系统中，由此衍生的CentOS和Fedora也都标配有Cockpit。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/Cockpit.jpg)

图8-15 驾驶舱示意图

Cockpit在默认情况下就已经被安装到系统中。下面执行dnf命令对此进行确认：

```
[root@linuxprobe ~]# dnf install cockpit
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
AppStream                                       3.1 MB/s | 3.2 kB     00:00    
BaseOS                                          2.7 MB/s | 2.7 kB     00:00    
Package cockpit-185-2.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
```

但是，Cockpit服务程序在RHEL 8版本中没有自动运行，下面将它开启并加入到开机启动项中：

```
[root@linuxprobe ~]# systemctl start cockpit
[root@linuxprobe ~]# systemctl enable cockpit.socket
Created symlink /etc/systemd/system/sockets.target.wants/cockpit.socket → /usr/lib/systemd/system/cockpit.socket.
```

在Cockpit服务启动后，打开系统自带的浏览器，在地址栏中输入“本机地址:9090”即可访问。由于访问Cockpit的流量会使用HTTPS进行加密，而证书又是在本地签发的，因此还需要进行添加并信任本地证书的操作，如图8-16与图8-17所示。进入Cockpit的登录界面后，输入root管理员的账号与系统密码，单击Log In按钮后即可进入，如图8-18所示。

进入Cockpit的Web界面，发现里面可谓“别有洞天”。Cockpit总共分为13个功能模块：系统状态（System）、日志信息（Logs）、硬盘存储（Storage）、网卡网络（Networking）、账户安全（Accounts）、服务程序（Services）、软件仓库（Applications）、报告分析（Diagnostic Reports）、内核排错（Kernel Dump）、SElinux、更新软件（Software  Updates）、订阅服务（Subscriptions）、终端界面（Terminal）。下面逐一进行讲解。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/1-58-1024x593.png)

图8-16 添加额外允许的证书

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/2-37.png)

图8-17 确认信任本地证书

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/3-14-1024x588.png)

图8-18 输入登录账号与系统密码

进入到Cockpit网页界面后可谓是别有洞天，总共分为十三个功能模块，即：系统状态、日志信息、硬盘存储、网卡网络、账户安全、服务程序、软件仓库、报告分析、内核排错、SElinux、更新软件、订阅服务、终端界面。逐一为同学们进行讲解。

**1．System**

进入Cockpit界面后默认显示的便是System（系统）界面，在该界面中能够看到系统架构、版本、主机名与时间等信息，还能够动态地展现出CPU、硬盘、内存和网络的复杂情况，这有点类似于Web版的“Winodws系统任务管理器”，属实好用，如图8-19所示。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/1-59-1024x502.png)

图8-19 系统状态界面

**2．Logs**

这个模块能够提供系统的全部日志，但是同学们可能会好奇，“为什么图8-20中的内容这么有限呢”？原因出在图8-20中的两个选项中：时间和日志级别。通过这两个选项可以让用户更快地找到所需信息，而不是像/var/log/message文件那样一股脑儿地都抛给用户。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/2-38-1024x502.png)

图8-20 日志信息界面

**3．Storage**

这个功能模块是同学们最喜欢的一个模块，原因不是这个模块显示了硬盘的I/O读写负载情况，而是可以让用户通过该界面，用鼠标创建出RAID、LVM、VDO和iSCSI等存储设备，如图8-21所示。是的，您没有看错，RAID和LVM都可以用鼠标进行创建了，是不是很开心呢？

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/3-15-1024x504.png)

图8-21 硬盘存储界面

**4．Networking**

既然名为Networking模块，那么动态看网卡的输出和接收值肯定是这个模块的标配功能了。如图8-22所示，我们不仅可以在这里进行网卡的绑定（Bonding）和聚合（Team），还可以创建桥接网卡及添加VLAN。图8-22的最下方会单独列出与网卡相关的日志信息。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/4-9-1024x498.png)

8-22 网卡网络界面

**5．**Accounts

大家千万别小看Accounts模块，虽然它的功能界面有些简陋（见图8-23），只有一个用于创建账户的按钮，但只要点击进入某个用户的管理界面中，马上会发现“别有洞天”，如图8-24所示。这个界面中的功能非常丰富，我们在这里可以对用户进行重命名，设置用户的权限，还可以锁定、修改密码以及创建SSH密钥信息。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/5-9-1024x502.png)

图8-23 账户安全界面

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/5B-1024x502.png)

图8-24 账户管理界面

**6．Services**

在Services功能模块的界面中（见图8-25），可以查看系统中已有的服务列表和运行状态。单击某一服务，进入该服务的管理界面后（见图8-26），可以对具体的服务进行开启、关闭操作。在Services功能模块中设置了服务并将其加入到开机启动项后，在系统重启后也依然会为用户提供服务。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/6-3-1024x501.png)

图8-25 服务程序界面

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/6B-1024x502.png)

图8-26 服务管理界面

**7．Applications**

后期采用Cockpit或红帽订阅服务安装的软件都会显示在这个功能模块中，如图8-27所示。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/7-3-1024x499.png)

图8-27 软件仓库界面

**8．Diagnostic Report**

Diagnostic Report模块的功能是帮助用户收集及分析系统的信息，找到系统出现问题的原因，界面如图8-28所示。单击Create  Report按钮后大约两分钟左右，会出现如图8-29所示的界面。好吧，摊牌了，这个功能其实很鸡肋，就是将sosreport命令做成了一个网页按钮。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/8-1024x502.png)

图8-28 报告分析界面

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/8B-1024x502.png)

图8-29 报告生成完毕

**9．Kernel Dump**

Kernel  Dump（Kdump）是一个在系统崩溃、死锁或死机时用来收集内核参数的一个服务。举例来说，如果有一天系统崩溃了，这时Kdump服务就会开始工作，将系统的运行状态和内核数据收集到一个名为dump  core的文件中，以便后续让运维人员分析并找出问题所在。由于我们在安装系统时没有启动该服务，所以可以等到后续使用时再开启该功能界面（见图8-30）。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/9-2-1024x501.png)

图8-30 内核排错界面

**10．SElinux**

图8-31所示为SELinux服务的控制按钮和警告信息界面，第10章将详细介绍SELinux安全子系统，这里暂时略过。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/10-1024x500.png)

图8-29 SElinux管理界面

**11．Software Updates**

Software Updates功能模块的界面如图8-32所示。但是，这里提到的Software  Updates并不是我们用来更新其他常规软件的一个界面，而是用来对红帽客户订阅的服务进行更新的界面。用户只有在购买了红帽第三方服务后才能使用这里面的功能。在购买了红帽订阅服务后，用户便可以在这里下载到相应服务程序的最新版本和稳定版本。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/11-5-1024x502.png)

图8-30 更新软件界面

**12．Subscriptions**

Subscriptions功能模块的界面如图8-33所示。这里依然是一则红帽公司的“小广告”—如果想成为尊贵的红帽服务用户，要付费购买订阅服务。个人用户无须购买，而且这对我们的后续实验没有任何影响。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/12-3-1024x500.png)

图8-31 订阅服务界面

**13．Terminal**

压轴的总是在最后。Terminal功能模块的界面如图8-34所示。Cockpit服务提供了Shell终端的在线控制平台，可方便用户通过网页上的终端功能管理服务器。这个功能深受运维人员喜爱。

![第8章 使用Iptables与Firewalld防火墙第8章 使用Iptables与Firewalld防火墙](https://www.linuxprobe.com/wp-content/uploads/2020/05/13-2-1024x500.png)

图8-32 终端管理界面

至此，相信各位读者已经充分掌握了防火墙的管理能力。防火墙管理工具有很多种，我们任选其一即可。在配置后续的服务前，大家要记得检查网络和防火墙的状态，以避免出现服务明明配置正确，但无法从外部访问的情况，最终影响实验效果。

好了，休息一下，准备下一章的学习！

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

1．在RHEL 8系统中，iptables是否已经被firewalld服务彻底取代？

**答：**没有，iptables和firewalld服务均可用于RHEL 8系统。

2．请简述防火墙策略规则中DROP和REJECT的不同之处。

**答：**DROP的动作是丢包，不响应；REJECT是拒绝请求，同时向发送方回送拒绝信息。

3．如何把iptables服务的INPUT规则链默认策略设置为DROP？

**答：**执行命令iptables -P INPUT DROP即可。

4．怎样编写一条防火墙策略规则，使得iptables服务可以禁止源自192.168.10.0/24网段的流量访问本机的sshd服务（22端口）？

**答：**执行命令iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j REJECT即可。

5．请简述firewalld中区域的作用。

**答：**可以依据不同的工作场景来调用不同的firewalld区域，实现大量防火墙策略规则的快速切换。

6．如何在firewalld中把默认的区域设置为dmz？

**答：**执行命令firewall-cmd --set-default-zone=dmz即可。

7．如何让firewalld中以永久（Permanent）模式配置的防火墙策略规则立即生效？

**答：**执行命令firewall-cmd --reload。

8．使用SNAT技术的目的是什么？

**答：**SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。

9． TCP Wrapper服务分别有允许策略配置文件和拒绝策略配置文件，请问匹配顺序是怎么样的？

**答：**TCP Wrapper会先依次匹配允许策略配置文件，然后再依次匹配拒绝策略配置文件；如果都没有匹配到，则默认放行流量。

10．默认情况下如何使用Cockpit服务？

**答：**Cockpit服务默认占用9090端口号，可直接用浏览器访问Cockpit的Web界面。





其实，使用源码包来安装服务程序具有两个优势。

> 源码包的可移植性非常好，几乎可以在任何Linux系统中安装使用，而RPM软件包是针对特定系统和架构编写的指令集，必须严格地符合执行环境才能顺利安装（即只会去“生硬地”安装服务程序）。
>
> 使用源码包安装服务程序时会有一个编译过程，因此能够更好地适应安装主机的系统环境，运行效率和优化程度都会强于使用RPM软件包安装的服务程序。也就是说，可以将采用源码包安装服务程序的方式看作是针对系统的“量体裁衣”。

一般来讲，在安装软件时，如果能通过软件仓库来安装，就用dnf[命令](https://www.linuxcool.com/)搞定它；反之则去寻找合适的RPM软件包来安装；如果实在没有资源可用，那就只能使用源码包来安装了。使用源码包安装服务程序的过程看似复杂，其实在归纳汇总后只需要4～5个步骤即可完成安装。接下来会对每一个步骤进行详解。

### **Tips**

需要提前说明的是，在使用源码包安装程序时，会输出大量的过程信息，这些信息的意义并不大，因此本章会省略这部分输出信息而不作特殊备注，请大家在具体操作时以实际为准。

**第1步**：下载及解压源码包文件。为了方便在网络中传输，源码包文件通常会在归档后使用gzip或bzip2等格式进行压缩，因此一般会具有.tar.gz或.tar.bz2的后缀。要想使用源码包安装服务程序，必须先把里面的内容解压出来，然后再切换到源码包文件的目录中：

> [root@linuxprobe ~]# tar xzvf FileName**.tar.gz**
>
> [root@linuxprobe ~]# cd FileDirectory

**第2步**：编译源码包代码。在正式使用源码包安装服务程序之前，还需要使用编译[脚本](https://www.linuxcool.com/)针对当前系统进行一系列的评估工作，包括对源码包文件、软件之间及函数库之间的依赖关系、编译器、汇编器及链接器进行检查。我们还可以根据需要来追加--prefix参数，以指定稍后源码包程序的安装路径，从而对服务程序的安装过程更加可控。当编译工作结束后，如果系统环境符合安装要求，一般会自动在当前目录下生成一个Makefile安装文件。

> [root@linuxprobe ~]# ./configure --prefix=/usr/local/program

**第3步**：生成二进制安装程序。刚刚生成的Makefile文件中会保存与系统环境、软件依赖关系和安装规则等相关的内容，接下来便可以使用make命令来根据Makefile文件内容提供的合适规则编译生成出真正可供用户安装服务程序的二进制可执行文件了。

> [root@linuxprobe ~]# make

**第4步**：运行二进制的服务程序安装包。由于不需要再检查系统环境，也不需要再编译代码，因此运行二进制的服务程序安装包应该是速度最快的步骤。如果在源码包编译阶段使用了--prefix参数，那么此时服务程序就会被安装到那个目录；如果没有自行使用参数定义目录的话，一般会被默认安装到/usr/local/bin目录中。

> [root@linuxprobe ~]# make install

**第5步**：清理源码包临时文件。由于在安装服务程序的过程中进行了代码编译的工作，因此在安装后目录中会遗留下很多临时垃圾文件，本着尽量不要浪费磁盘存储空间的原则，可以使用make clean命令对临时文件进行彻底的清理。

> [root@linuxprobe ~]# make clean





使用源码包安装服务程序之前，首先要让安装主机具备编译程序源码的环境。这需要具备C语言、C++语言、Perl语言的编译器，以及各种常见的编译支持函数库程序。因此请先配置妥当软件仓库，然后把下面列出的这些软件包都统统安装上：

```
[root@linuxprobe ~]# dnf -y install apr* autoconf automake numactl bison bzip2-devel cpp curl-devel fontconfig-devel freetype-devel gcc gcc-c++ gd-devel gettext-devel kernel-headers keyutils-libs-devel krb5-devel libcom_err-devel  libpng-devel  libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libxml2-devel libXpm* libxml* libXaw-devel libXmu-devel libtiff* make openssl-devel patch pcre-devel perl php-common php-gd telnet zlib-devel libtirpc-devel gtk* ntpstat na* bison* lrzsz cmake ncurses-devel libzip-devel libxslt-devel gdbm-devel readline-devel gmp-devel

Updating Subscription Management repositories.
Unable to read consumer identity
AppStream                                       3.1 MB/s | 3.2 kB     00:00    
BaseOS                                          2.0 MB/s | 2.7 kB     00:00    
………………省略部分输出信息………………
  Running scriptlet: mariadb-connector-c-3.0.7-1.el8.x86_64                 1/1 
  Preparing        :                                                        1/1 
  Installing       : xorg-x11-proto-devel-2018.4-1.el8.noarch             1/261 
  Installing       : perl-version-6:0.99.24-1.el8.x86_64                  2/261 
  Installing       : zlib-devel-1.2.11-10.el8.x86_64                      3/261 
  Installing       : perl-Time-HiRes-1.9758-1.el8.x86_64                  4/261 
  Installing       : libpng-devel-2:1.6.34-5.el8.x86_64                   5/261 
  Installing       : perl-CPAN-Meta-Requirements-2.140-396.el8.noarch     6/261 
  Installing       : perl-ExtUtils-ParseXS-1:3.35-2.el8.noarch            7/261 
  Installing       : perl-ExtUtils-Manifest-1.70-395.el8.noarch           8/261 
  Installing       : cmake-filesystem-3.11.4-3.el8.x86_64                 9/261 
  Installing       : perl-Test-Harness-1:3.42-1.el8.noarch               10/261 
  Installing       : perl-Module-CoreList-1:5.20181130-1.el8.noarch      11/261 
  Installing       : perl-Module-Metadata-1.000033-395.el8.noarch        12/261 
  Installing       : perl-SelfLoader-1.23-416.el8.noarch                 13/261 
  Installing       : perl-Perl-OSType-1.010-396.el8.noarch               14/261 
  Installing       : perl-Module-Load-1:0.32-395.el8.noarch              15/261 
  Installing       : perl-JSON-PP-1:2.97.001-3.el8.noarch                16/261 
  Installing       : perl-Filter-2:1.58-2.el8.x86_64                     17/261 
  Installing       : perl-Compress-Raw-Zlib-2.081-1.el8.x86_64           18/261 
  Installing       : perl-encoding-4:2.22-3.el8.x86_64                   19/261 
  Installing       : perl-Text-Balanced-2.03-395.el8.noarch              20/261 
………………省略部分输出信息………………
Complete!
```

如果条件允许，建议适当增大虚拟机的内存上限，让稍后的编译过程更快一些。而且由于接下来还需要从外部网络中获取Nginx、MySQL、PHP及WordPress等一系列的安装包，因此需要配置虚拟机，将其连接到互联网。

将已经调整为桥接模式的网卡，通过nmtui或nm-connection-editor命令修改为以DHCP模式自动获取网络信息，如图20-2所示。此时，大多数情况下虚拟机就可以接入互联网。若依然不可访问互联网，则考虑外部环境是否有特殊的限制，然后将虚拟机内网卡配置成跟物理机一致即可。

```
[root@linuxprobe ~]# ping -c 4 www.linuxprobe.com
PING www.linuxprobe.com.w.kunlunno.com (202.97.231.16) 56(84) bytes of data.
64 bytes from www.linuxprobe.com (202.97.231.16): icmp_seq=1 ttl=55 time=27.5 ms
64 bytes from www.linuxprobe.com (202.97.231.16): icmp_seq=2 ttl=55 time=27.10 ms
64 bytes from www.linuxprobe.com (202.97.231.16): icmp_seq=3 ttl=55 time=27.4 ms
64 bytes from www.linuxprobe.com (202.97.231.16): icmp_seq=4 ttl=55 time=28.9 ms

--- www.linuxprobe.com.w.kunlunno.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 8ms
rtt min/avg/max/mdev = 27.354/27.913/28.864/0.593 ms
```

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/设置网卡模式.png)

图20-2 设置网卡为DHCP自动获取模式

刘遄老师已经把安装LNMP动态网站部署架构所需的4个软件源码包和1个用于检查效果的博客系统软件包上传到与本书配套的站点服务器上。大家可以在Windows系统中下载后通过ssh服务传送到打算部署LNMP动态网站架构的Linux服务器中，也可以直接在Linux服务器中使用wget命令下载这些源码包文件。为了更好地找到它们，我们统一放到/lnmp目录下保存：

```
[root@linuxprobe ~]# mkdir /lnmp
[root@linuxprobe ~]# cd /lnmp
[root@linuxprobe lnmp]# wget https://www.linuxprobe.com/Software/rpcsvc-proto-1.4.tar.gz
[root@linuxprobe lnmp]# wget https://www.linuxprobe.com/Software/nginx-1.16.0.tar.gz
[root@linuxprobe lnmp]# wget https://www.linuxprobe.com/Software/mysql-8.0.18.tar.xz
[root@linuxprobe lnmp]# wget https://www.linuxprobe.com/Software/php-7.3.5.tar.gz
[root@linuxprobe lnmp]# wget https://www.linuxprobe.com/Software/wordpress.tar.gz
[root@linuxprobe lnmp]# ls
rpcsvc-proto-1.4.tar.gz       nginx-1.16.0.tar.gz   mysql-8.0.18.tar.xz
php-7.3.5.tar.gz              wordpress.tar.gz
```

下面我们准备小试牛刀。rpcsvc-proto是一款包含rcpsvc协议文件的支持软件包名称，rcpsvc协议在后续Nginx与MySQL服务程序的部署过程中都需要被调用到。要想通过源码包安装服务程序，就一定要严格遵守上面总结的安装步骤：下载及解压源码包文件、编译源码包代码、生成二进制安装程序、运行二进制的服务程序安装包。在解压、编译各个软件包源码程序时，都会生成大量的输出信息，下文中会将其省略，请读者以实际操作为准。

```
[root@linuxprobe lnmp]# tar xzvf rpcsvc-proto-1.4.tar.gz 
[root@linuxprobe lnmp]# cd rpcsvc-proto-1.4/
[root@linuxprobe rpcsvc-proto-1.4]# ./configure
[root@linuxprobe rpcsvc-proto-1.4]# make 
[root@linuxprobe rpcsvc-proto-1.4]# make install
[root@linuxprobe rpcsvc-proto-1.4]# cd ..
[root@linuxprobe lnmp]#
```

由于本章涉及的软件较多，频繁地切换工作目录在所难免。一方面我们会在每次操作后尽可能地返回到/lnmp目录下待命，另一方面也请读者仔细看清所在的目录路径，以免因为找不到文件而影响心情。

###### **20.2.1 配置Nginx服务**

Nginx是一款相当优秀的用于部署动态网站的轻量级服务程序，它最初是为俄罗斯的一家门户站点而开发的，因其稳定性、功能丰富、占用内存少且并发能力强而备受用户的信赖。目前国内诸如新浪、网易、腾讯等门户站点均已使用了此服务。

Nginx服务程序的稳定性源自于采用了分阶段的资源分配技术，降低了CPU与内存的占用率，所以使用Nginx程序部署的动态网站环境不仅十分稳定、高效，而且消耗的系统资源也很少。此外，Nginx具备的模块数量与Apache具备的模块数量几乎相同，而且现在已经完全支持proxy、rewrite、mod_fcgi、ssl、vhosts等常用模块。更重要的是，Nginx还支持热部署技术，可以7×24小时不间断提供服务，还可以在不暂停服务的情况下直接对Nginx服务程序进行升级。

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2015/11/Nginx与Apache.png)

坦白来讲，虽然Nginx程序的代码质量非常高，代码很规范，技术成熟，模块扩展也很容易，但依然存在不少问题。比如，Nginx是由俄罗斯人开发的，资料文档还不完善，中文资料的质量更是鱼龙混杂。但是Nginx服务程序在近年来增长势头迅猛，相信会在轻量级Web服务器市场具有不错的未来。



**第1步：**创建用于管理网站服务的系统账户。这是在Linux系统创建之初就植入的基因片段—为了能够让操作系统更加安全，需要由不同的系统用户来管理不同的服务程序。这样即便有黑客通过网站服务侵入了服务器，也无法提权到更高权限，或是对系统进行更大的破坏，甚至都无法登录ssh服务，因为他拿到的仅仅是一个系统账号。不同以往，这次在新建账户时应使用-M参数不创建对应的家目录，以及使用-s参数指定登录后的Shell解释器为/sbin/nologin，确保任何人都不能通过这个账号登录主机。

```
[root@linuxprobe lnmp]# useradd nginx -M -s /sbin/nologin
[root@linuxprobe lnmp]# id nginx
uid=1001(nginx) gid=1001(nginx) groups=1001(nginx)
```

**第2步：**编译安装Nginx网站服务程序。为了能够让网站服务支持更多的功能，需要在编译过程中添加额外的参数，其中较为重要的是使用prefix参数指定服务将被安装到哪个目录，方便后面找到和调用它。其次，考虑到HTTPS协议的使用越来越广泛，所以这里用with-http_ssl_module参数来开启Nginx服务的SSL加密模块，以便日后开启HTTPS协议功能：

```
[root@linuxprobe lnmp]# tar zxvf nginx-1.16.0.tar.gz
[root@linuxprobe lnmp]# cd nginx-1.16.0/
[root@linuxprobe nginx-1.16.0]# ./configure --prefix=/usr/local/nginx --with-http_ssl_module 
[root@linuxprobe nginx-1.16.0]# make 
[root@linuxprobe nginx-1.16.0]# make install
[root@linuxprobe nginx-1.16.0]# cd ..
```

相对来说，编译脚本文件（configure）比生成二进制文件（make）要快，而安装程序（make  install）则是最快的，它相当于以双击的方式运行二进制安装包。在编译、生成、安装三阶段中，屏幕上会输出各式各样的信息，主要包含软件包的概要情况、当前系统的软件依赖关系，以及是否有条件进行安装操作。但只要进程没有被强制终止，或是没有输出明显报错信息，则都是正常情况。

**第3步：**安装完毕后进入最终配置阶段。既然在编译环境中使用prefix参数指定了安装路径，那么Nginx服务程序配置文件一定会乖乖地在/usr/local/nginx目录中等我们。

我们总共要进行3处修改，首先是把第2行的注释符（#）删除，然后在后面写上负责运行网站服务程序的账户名称和用户组名称。这里假设由nginx用户及nginx用户组负责管理网站服务。

```
[root@linuxprobe lnmp]# vim /usr/local/nginx/conf/nginx.conf 
  1 
  2 user  nginx nginx;
```

其次是修改第45行的首页文件名称，在里面添加index.php的名字。这个文件也是让用户浏览网站时第一眼看到的文件，也叫首页文件。

```
 43         location / {
 44             root   html;
 45             index  index.php index.html index.htm;
 46         }
```

最后再删除第65～71行前面的注释符（#）来启用虚拟主机功能，然后将第69行后面对应的网站根目录修改为/usr/local/nginx/html，其中的fastcgi_script_name参数用于指代脚本名称，也就是用户请求的URL。只有信息填写正确了，才能使Nginx服务正确解析用户请求，否则访问的页面会提示“404 Not Found”的错误。

```
 63         # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
 64         #
 65         location ~ \.php$ {
 66             root           html;
 67             fastcgi_pass   127.0.0.1:9000;
 68             fastcgi_index  index.php;
 69             fastcgi_param  SCRIPT_FILENAME  /usr/local/nginx/html$fastcgi_script_name;
 70             include        fastcgi_params;
 71         }
```

**第4步**：通过编译源码方式安装的服务默认不能被systemctl命令所管理，而要使用Nginx服务本身的管理工具进行操作，相应命令所在的目录是/usr/local/nginx/sbin。由于使用绝对路径的形式输入命令未免会太麻烦，建议将/usr/local/nginx/sbin路径加入到PATH变量中，让Bash解释器在后续执行命令时自动搜索到它。然后在source命令后加载配置文件，让参数立即生效。下次就只需要输入nginx命令即可启动网站服务了。

```
[root@linuxprobe lnmp]# vim ~/.bash_profile
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
	. ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin:/usr/local/nginx/sbin

export PATH
[root@linuxprobe lnmp]# source ~/.bash_profile
[root@linuxprobe lnmp]# nginx 
```

操作完毕！重启服务程序，并在浏览器中输入本机的IP地址，即可访问到Nginx网站服务程序的默认界面，如图20-3所示。相较于Apache服务程序的红色默认页面，Nginx服务程序的默认页面显得更加简洁。

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/访问网站成功-1.png)

图20-3 Nginx服务程序的默认页面



![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/mysql-300x155.png)

在使用软件仓库安装服务程序时，系统会自动根据RPM软件包中的指令集完成软件配置等工作。但是一旦选择使用源码包的方式来安装，这一切就需要自己来完成了。对于MySQL数据库来说，我们需要在系统中创建一个名为mysql的用户，专门用于负责运行MySQL数据库。请记得要把这类账户的Bash终端设置成nologin解释器，避免黑客通过该用户登录到服务器中，从而提高系统安全性。

接下来准备配置MySQL服务。

```
[root@linuxprobe lnmp]# useradd mysql -M -s /sbin/nologin
```

**第1步**：解压MySQL安装软件包。将解压出的程序目录改名并移动到/usr/local目录下，对其进行初始化操作后便可使用。需要注意的是，以.tar.xz结尾的压缩包软件，不应用z参数进行解压。

```
[root@linuxprobe lnmp]# tar xvf mysql-8.0.18.tar.xz
[root@linuxprobe lnmp]# mv mysql-8.0.18-linux-glibc2.12-x86_64 mysql
[root@linuxprobe lnmp]# mv mysql /usr/local
```

**第2步**：在生产环境中管理MySQL数据库时，有两个比较常用的目录。一个是/usr/local/mysql目录，这是用于保存MySQL数据库程序文件的路径。还有一个是/usr/local/mysql/data目录，它用于存储数据库的具体内容，每个数据库的内容会被单独存放到一个目录内。对于存放实际数据库文件的data目录，用户需要先手动创建出来：

```
[root@linuxprobe lnmp]# cd /usr/local/mysql
[root@linuxprobe mysql]# mkdir data
```

**第3步**：初始化MySQL服务程序，对目录进行授权，保证数据能够被mysql系统用户读取。在初始化阶段，应使用mysqld命令确认管理MySQL数据库服务的用户名称、数据保存目录及编码信息。在信息确认无误后开始进行初始化。在初始化的最后阶段，系统会给用户分配一个初始化的临时密码，大家一定要保存好，例如下面示例中分配的密码是qfroRs,Ei4Ls。

```
[root@linuxprobe mysql]# chown -R mysql:mysql /usr/local/mysql
[root@linuxprobe mysql]# cd bin
[root@linuxprobe bin]# ./mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
2021-05-06T07:07:06.243270Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.18) initializing of server in progress as process 7606
2021-05-06T07:07:08.116268Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: qfroRs,Ei4Ls
```

**第4步**：与Nginx服务相似，MySQL数据库的二进制可执行命令也单独存放在自身的程序目录/usr/local/mysql/bin中。若每次在执行命令之前都要先切换到这个目录，则着实有些麻烦，要能也加入到PATH变量中可就方便太多了。说干就干！

```
[root@linuxprobe bin]# vim ~/.bash_profile
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin:/usr/local/nginx/sbin:/usr/local/mysql/bin

export PATH
[root@linuxprobe bin]# source ~/.bash_profile
```

在这样设置后，即便返回到源码目录，也可以继续执行MySQL数据库的管理命令。不过先别着急！既然是手动安装服务，那么让文件“归位”的重任就只得亲力亲为了—将启动脚本mysql.server放入到/etc/init.d目录中，让服务器每次重启后都能自动启动数据库，并给予可执行权限。

libtinfo.so.5文件是MySQL数据库在8.0版本后新添加的重要的函数库文件，但默认不存在，需要将libtinfo.so.6.1文件复制过来或者作为链接文件才能正常启动：

```
[root@linuxprobe bin]# cd /usr/local/mysql
[root@linuxprobe mysql]# cp -a support-files/mysql.server /etc/init.d/
[root@linuxprobe mysql]# chmod a+x /etc/init.d/mysql.server
[root@linuxprobe mysql]# ln -s /usr/lib64/libtinfo.so.6.1 /usr/lib64/libtinfo.so.5 
```

**第5步**：执行MySQL数据库服务启动文件，并进行初始化工作。为了安全着想，MySQL自8.0版本起不再允许用户使用临时密码来管理数据库内容，也不能进行远程控制，用户必须修改初始化密码后才能使用MySQL数据库。数据库作为系统重要的组成服务，密码位数不建议少于20位。例如，下面将密码修改为“PObejCBeDzTRCncXwgBy”。

```
[root@linuxprobe mysql]# /etc/init.d/mysql.server start 
Starting MySQL.Logging to '/usr/local/mysql/data/linuxprobe.com.err'.
. SUCCESS! 
[root@linuxprobe mysql]# mysql -u root -p
Enter password: 输入初始化时给的原始密码
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 8.0.18

Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> alter user 'root'@'localhost' identified by 'PObejCBeDzTRCncXwgBy'; 
Query OK, 0 rows affected (0.01 sec)

mysql> 
```

但这样还是不行，还需要继续切换到mysql数据库中，修改user表单的密码值。这也是从MySQL数据库8.0版本之后才有的新安全要求，看过本书上一版的读者应该记得在MySQL 5/6版本中就没有这么麻烦。

```
mysql> use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+---------------------------+
| Tables_in_mysql           |
+---------------------------+
| columns_priv              |
| tables_priv               |
| time_zone                 |
| time_zone_leap_second     |
| time_zone_name            |
| time_zone_transition      |
| time_zone_transition_type |
| user                      |
| …………省略部分输出信息…………  |
+---------------------------+
33 rows in set (0.00 sec)

mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'PObejCBeDzTRCncXwgBy';
Query OK, 0 rows affected (0.01 sec)
```

由于20.4节将会安装部署WordPress网站系统，因此现在需要提前把数据库新建出来：

```
mysql> create database linuxcool;
Query OK, 1 row affected (0.00 sec)

mysql> exit
Bye
```

###### **20.2.3 配置php服务**

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/PHP.png)

PHP（Hypertxt Preprocessor，超文本预处理器）是一种通用的开源脚本语言，发明于1995年，它吸取了C语言、Java语言及Perl语言的很多优点，具有开源、免费、快捷、跨平台性强、效率高等优良特性，是目前Web开发领域最常用的语言之一。

使用源码包的方式编译安装PHP语言环境其实并不复杂，难点在于解决PHP的程序包和其他软件的依赖关系。

**第1步**：解压php安装包软件并编译安装。在编译期间，需要使用prefix参数指定安装路径，使用--with-mysqli等参数开启对数据库的支持模块，为后面的在线安装网站做好准备。

```
[root@linuxprobe mysql]# cd /lnmp
[root@linuxprobe lnmp]# tar xvf php-7.3.5.tar.gz
[root@linuxprobe lnmp]# cd php-7.3.5/
[root@linuxprobe php-7.3.5]# ./configure --prefix=/usr/local/php --enable-fpm --with-mysqli --with-curl --with-pdo_mysql --with-pdo_sqlite --enable-mysqlnd --enable-mbstring --with-gd
```

使用下述命令生成二进制文件并进行安装，时间大约为10～20分钟，耐心等待即可：

```
[root@linuxprobe php-7.3.5]# make
[root@linuxprobe php-7.3.5]# make install
```

**第2步**：将生成的php服务配置文件复制到安装目录中（/usr/local/php/），让其生效。现在主配置文件有了，接下来还需要php-fpm的配置文件，好在/usr/local/php/etc/目录中也已经提供，只需要复制模板即可：

```
[root@linuxprobe php-7.3.5]# cp php.ini-development /usr/local/php/lib/php.ini
[root@linuxprobe php-7.3.5]# cd /usr/local/php/etc/
[root@linuxprobe etc]# mv php-fpm.conf.default php-fpm.conf
```

复制一个模板文件到php-fpm.d的目录中，用于后续控制网站的连接性能：

```
[root@linuxprobe etc]# mv php-fpm.d/www.conf.default php-fpm.d/www.conf
```

**第3步**：把php服务加入到启动项中，使其重启后依然生效：

```
[root@linuxprobe etc]# cd /lnmp/php-7.3.5
[root@linuxprobe php-7.3.5]# cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
[root@linuxprobe php-7.3.5]# chmod 755 /etc/init.d/php-fpm
```

**第4步**：由于php服务程序的配置参数会对Web服务的运行环境造成影响，如果默认开启了一些不必要且高危的功能（如允许用户在网页中执行Linux命令），则会降低网站被入侵的难度，甚至会让入侵人员拿到整台Web服务器的管理权限。因此需要编辑php.ini配置文件，在第310行的disable_functions参数后面追加上要禁止的功能。下面的禁用功能名单是刘遄老师依据本书配套站点的运行经验而定制的，不见得适合每个生产环境，建议大家在此基础上根据自身工作需求酌情删减：

```
[root@linuxprobe php-7.3.5]# vim /usr/local/php/lib/php.ini
 307 ; This directive allows you to disable certain functions for security reasons.
 308 ; It receives a comma-delimited list of function names.
 309 ; http://php.net/disable-functions
 310 disable_functions = passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server
```

**第5步**：LNMP架构源码编译工作就此结束。准备享受胜利成果吧。

```
[root@linuxprobe php-7.3.5]# /etc/init.d/php-fpm start
Starting php-fpm done
```

##### **20.3 搭建Wordpress博客**

为了检验LNMP动态网站架构环境是否配置妥当，可以在上面部署WordPress博客系统，然后查看效果。如果能够在LNMP动态网站环境中成功安装并使用WordPress网站系统，也就意味着这套架构是可用的。WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设自己的网站。WordPress具有丰富的插件和模板系统，是当前最受欢迎的网站内容管理系统。截至2021年5月，全球排名前1000万的网站中已有超过41%使用了WordPress。

下面准备搭建WordPress博客。

把Nginx服务程序根目录的内容清空后，将WordPress解压后的网站文件复制进去：

```
[root@linuxprobe php-7.3.5]# cd ..
[root@linuxprobe lnmp]# rm -f /usr/local/nginx/html/*
[root@linuxprobe lnmp]# tar xzvf wordpress.tar.gz 
[root@linuxprobe lnmp]# mv wordpress/* /usr/local/nginx/html/
```

为了能够让网站文件被Nginx服务程序顺利读取，应设置目录所有权的身份及可读写的权限：

```
[root@linuxprobe lnmp]# chown -Rf nginx:nginx /usr/local/nginx/html 
[root@linuxprobe lnmp]# chmod -Rf 777 /usr/local/nginx/html
```

随后输入本机IP地址访问WordPress网站的首页面，如图20-4所示。该页面提醒了用户稍后需要的安装信息。

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/1-1-1024x624.png)

图20-4 WordPress网站系统安装首页面

单击图20-4中的“现在就开始”按钮，在随后出现的界面中依次输入刚刚建立的数据库名称、用户名及重置过的密码值。由于WordPress会要求用户自行创建好数据库，因此请确保网页中填写的数据库名称与刚才创建的一致，如图20-5所示。单击“提交”按钮进行确认后，便进入最终的安装阶段，如图20-6所示。

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/2-1-1024x624.png)

图20-5 填写安装信息

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/3-1-1024x624.png)

图20-6 确认安装WordPress网站系统

顺利安装完毕后，WordPress网站系统会要求用户填写站点标题、用户名及密码等信息，如图20-7所示。这些信息均可自行填写，建议密码稍微复杂一些。在检查无误后即可单击“安装WordPress”按钮进行安装。安装成功后的界面如图20-8所示。

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/4-1024x624.png)

图20-7 填网站标题及管理员名称

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/5-1024x624.png)

图20-8 安装完成界面

WordPress的登录界面将在用户填写完账号及密码且单击“登录”按钮后自动出现，如图20-9所示。

![第20章 使用LNMP架构部署动态网站环境第20章 使用LNMP架构部署动态网站环境](https://www.linuxprobe.com/wp-content/uploads/2021/05/6-1024x624.png)

图20-9 填写网站账号和密码

##### **20.4 选购服务器主机**

> **虚拟主机**：在一台服务器中划分一定的磁盘空间供用户放置网站信息、存放数据等；仅提供基础的网站访问、数据存放与传输功能；能够极大地降低用户费用，也几乎不需要用户来维护网站以外的服务；适合小型网站。
>
> **VPS（Virtual Private Server，虚拟专用服务器）**：在一台服务器中利用OpenVZ、Xen或KVM等虚拟化技术模拟出多台“主机”（即VPS），每个主机都有独立的IP地址、操作系统；不同VPS之间的磁盘空间、内存、CPU、进程与系统配置完全隔离，用户可自由使用分配到的主机中的所有资源，为此需要具备一定的维护系统的能力；适合小型网站。
>
> **ECS（Elastic Compute Service，弹性计算服务[通常称为云服务器]）**：是一种整合了计算、存储、网络，能够做到弹性伸缩的计算服务；使用起来与VPS几乎一样，差别是云服务器是建立在一组集群服务器中，每个服务器都会保存一个主机的镜像（备份），从而大大提升了安全性和稳定性；另外还具备灵活性与扩展性；用户只需按使用量付费即可；适合大中小型网站。
>
> **独立服务器**：这台服务器仅提供给用户一个人使用，其使用方式分为租用方式与托管方式。租用方式是用户将服务器的硬件配置要求告知IDC服务商，按照月、季、年为单位来租用它们的硬件设备。这些硬件设备由IDC服务商的机房负责维护，用户一般需要自行安装相应的软件并部署网站服务，这减轻了用户在硬件设备上的投入，比较适合大中型网站。托管方式则是用户需要自行购置服务器硬件设备，并将其交给IDC服务商进行管理（需要缴纳管理服务费）。用户对服务器硬件配置有完全的控制权，自主性强，但需要自行维护、修理服务器硬件设备；比较适合大中型网站。





3．LNMP动态网站部署架构通常包含了哪些服务程序？

**答：**LNMP动态网站部署架构通常包含Linux系统、Nginx网站服务、MySQL数据库管理系统，以及PHP脚本语言。

4．在MySQL数据库服务程序中，/usr/local/mysql与/usr/local/mysql/data目录的作用是什么？

**答：**/usr/local/mysql用于保存MySQL数据库服务程序的目录，/usr/local/mysql/var则用于保存真实数据库文件的目录。

6．如何禁止php服务程序中不安全的功能？

**答：**编辑php服务程序的配置文件（/usr/local/php/etc/php.ini），把要禁用的功能追加到disable_functions参数之后即可。





- [网站首页](https://www.linuxprobe.com/)
- [开始读书](https://www.linuxprobe.com/basic-learning-00.html)
- [下载](https://www.linuxprobe.com/basic-learning-19.html#)
- [Linux资讯](https://www.linuxprobe.com/news)
- [Linux命令](https://www.linuxcool.com/)
- [Linux培训](https://www.linuxprobe.com/training)
- [培训记录](https://www.linuxprobe.com/train)
- [技术干货](https://www.linuxprobe.com/thread)
- [Linux书籍](https://www.linuxprobe.com/books)
- [投稿](https://www.linuxprobe.com/tougao)
- [红帽认证](https://www.linuxprobe.com/redhat-certificate)
- [登录](https://www.linuxprobe.com/wp-login.php)



# [第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/basic-learning-19.html)

​		

[![img](https://www.linuxprobe.com/imgs/peixun.jpg)](https://www.linuxprobe.com/training)

**Linux系统技术交流QQ群（3963859）验证问题答案：刘遄**[![Linux就该这么学](https://www.linuxprobe.com/wp-content/uploads/2018/02/QQ群.png)](https://www.linuxprobe.com/links/qun.html)

**章节概述：**

刚入职的运维新手经常会被要求去做一些安装操作系统的工作。如果按照第1章讲解的用光盘镜像来安装操作系统，其效率会相当低下。本章将介绍能够用来实现无人值守安装服务的PXE + Kickstart服务程序，并带领大家动手安装部署PXE + TFTP + FTP + DHCP +  Kickstart等服务程序，从而搭建出一套可批量安装[Linux系统](https://www.linuxprobe.com/)的无人值守安装系统。在学完本章内容之后，运维新手就可以避免枯燥乏味的重复性工作，大大提高系统安装的效率。

本章目录结构

- [19.1 无人值守系统](https://www.linuxprobe.com/basic-learning-19.html#191)
- 19.2 部署相关服务程序
  - [19.2.1 配置DHCP服务程序](https://www.linuxprobe.com/basic-learning-19.html#1921_DHCP)
  - [19.2.2 配置TFTP服务程序](https://www.linuxprobe.com/basic-learning-19.html#1922_TFTP)
  - [19.2.3 配置SYSLinux服务程序](https://www.linuxprobe.com/basic-learning-19.html#1923_SYSLinux)
  - [19.2.4 配置VSFtpd服务程序](https://www.linuxprobe.com/basic-learning-19.html#1924_VSFtpd)
  - [19.2.5 创建KickStart应答文件](https://www.linuxprobe.com/basic-learning-19.html#1925_KickStart)
- [19.3 自动部署客户机](https://www.linuxprobe.com/basic-learning-19.html#193)

##### **19.1 无人值守系统**

本书在第1章讲解了使用光盘镜像来安装[Linux](https://www.linuxprobe.com/)系统的方法，坦白讲，该方法适用于只安装少量[Linux](https://www.linuxprobe.com/)系统的情况。如果生产环境中有数百台服务器都需要安装系统，这种方式就不合时宜了。这时，就需要使用PXE + TFTP + FTP + DHCP +  Kickstart服务搭建出一个无人值守安装系统。这种无人值守安装系统可以自动地为数十台甚至上百台的服务器安装系统，这一方面将运维人员从重复性的工作中解救出来，另外一方面也大大提升了系统安装的效率。

无人值守安装系统的工作流程如图19-1所示。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2015/10/无人值守安装流程-1.png)

图19-1 无人值守安装系统的工作流程

PXE（Preboot eXecute  Environment，预启动执行环境）是由Intel公司开发的技术，能够让计算机通过网络来启动操作系统（前提是计算机上安装的网卡支持PXE技术），主要用于在无人值守安装系统中引导客户端主机安装Linux操作系统。Kickstart是一种无人值守的安装方式，其工作原理是预先把原本需要运维人员手工填写的参数保存成一个ks.cfg文件，当安装过程中需要填写参数时则自动匹配Kickstart生成的文件。所以只要Kickstart文件包含了安装过程中需要人工填写的所有参数，那么从理论上来讲完全不需要运维人员的干预，就可以自动完成安装工作。TFTP、FTP以及DHCP服务程序的配置与部署已经在第11章和第14章进行了详细讲解，这里不再赘述。

由于当前的客户端主机并没有完整的操作系统，因此也就不能完成FTP协议的验证了，所以需要使用TFTP协议帮助客户端获取引导及驱动文件。vsftpd服务程序用于将完整的系统安装镜像通过网络传输给客户端。当然，只要能将系统安装镜像成功传输给客户端即可，因此也可以使用httpd来替代vsftpd服务程序。

##### **19.2 部署相关服务程序**

在本章，我们来会部署多款服务，这些服务以及作用如表19-1所示。由于其中某些服务的配置过程在前面的章节中有详细的介绍，因此下文在涉及相应服务的配置部署时，节奏会比较快。如有需要，大家可以返回到前面的章节进行重温。

表19-1                    接下来实验中即将用到的服务及作用

| 服务名称    | 主要作用                       |
| ----------- | ------------------------------ |
| dhcpd       | 分配网卡信息及指引获取驱动文件 |
| tftp-server | 提供驱动及引导文件的传输       |
| SYSLinux    | 提供驱动及引导文件             |
| VSFtpd      | 提供完整系统镜像的传输         |
| KickStart   | 提供安装过程中选项的问答设置   |



###### **19.2.1 配置DHCP服务程序**

DHCP服务程序用于为客户端主机分配可用的IP地址，而且这是服务器与客户端主机进行文件传输的基础，因此要先行配置DHCP服务程序。首先按照表19-2为无人值守系统设置IP地址，然后按照图19-2和图19-3在虚拟机的虚拟网络编辑器中关闭自身的DHCP服务，避免与自己配置的服务冲突。

表19-2                     无人值守系统与客户端的设置

| 主机名称     | 操作系统       | IP地址        |
| ------------ | -------------- | ------------- |
| 无人值守系统 | RHEL 8         | 192.168.10.10 |
| 客户端       | 未安装操作系统 | -             |



![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/打开虚拟机的虚拟网络编辑器-1024x153.png)

图19-2 打开虚拟机的虚拟网络编辑器

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/关闭虚拟机自带的DHCP服务.png)

图19-3 关闭虚拟机自带的DHCP服务

除了上面提及的服务之外，PXE + KickStart无人值守安装系统还会用到诸如sips、slp、mountd等多项相关的服务协议，因此本实验会临时关闭firewalld防火墙，以便数据能够正常地传送：

```
[root@linuxprobe pub]# iptables -F
[root@linuxprobe pub]# systemctl stop firewalld
```

当挂载好光盘镜像并把仓库文件配置妥当后，就可以安装DHCP服务程序软件包了：

```
[root@linuxprobe ~]# dnf install -y dhcp-server
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:00:22 ago on Fri 30 Apr 2021 01:03:26 AM CST.
Dependencies resolved.
================================================================================
 Package            Arch          Version                   Repository     Size
================================================================================
Installing:
 dhcp-server        x86_64        12:4.3.6-30.el8           BaseOS        529 k

Transaction Summary
================================================================================
Install  1 Package
………………省略部分输出信息………………
Installed:
  dhcp-server-12:4.3.6-30.el8.x86_64                                                                                                        

Complete!
```

第14章已经详细讲解了DHCP服务程序的配置以及部署方法，相信各位读者对相关的配置参数还有一些印象。但是，我们在这里使用的配置文件与第14章中的配置文件有两个主要区别：允许了BOOTP引导程序协议，旨在让局域网内暂时没有操作系统的主机也能获取静态IP地址；在配置文件的最下面加载了引导驱动文件pxelinux.0（这个文件会在下面的步骤中创建），其目的是让客户端主机获取到IP地址后主动获取引导驱动文件，自行进入下一步的安装过程。

```
[root@linuxprobe ~]# vim /etc/dhcp/dhcpd.conf
allow booting;
allow bootp;
ddns-update-style none;
ignore client-updates;
subnet 192.168.10.0 netmask 255.255.255.0 {
        option subnet-mask                 255.255.255.0;
        option domain-name-servers         192.168.10.10;
        range dynamic-bootp 192.168.10.100 192.168.10.200;
        default-lease-time                 21600;
        max-lease-time                     43200;
        next-server                        192.168.10.10;
        filename                           "pxelinux.0";
}
```

### **Tips**

当前pxelinux.0文件不存在，不过不用担心，后面会找到它的。

在确认DHCP服务程序的参数都填写正确后，重新启动该服务程序，并将其添加到开机启动项中。这样在设备下一次重启之后，可以在无须人工干预的情况下，自动为客户端主机安装系统。

```
[root@linuxprobe ~]# systemctl restart dhcpd
[root@linuxprobe ~]# systemctl enable  dhcpd
Created symlink /etc/systemd/system/multi-user.target.wants/dhcpd.service → /usr/lib/systemd/system/dhcpd.service.
```

与以往的[红帽](https://www.linuxprobe.com/)企业版不同，RHEL 8系统中存在一些“讨厌”的服务，它们的参数错误会导致服务启动失败，但有时却不会在屏幕上向用户显示任何提示信息。建议在启动dhcpd后查看一下服务状态，以免后续实验中客户端分配不到网卡信息。若输出状态为“**active (running)**”则表示服务已经正常运行：

```
[root@linuxprobe ~]# systemctl status dhcpd
● dhcpd.service - DHCPv4 Server Daemon
   Loaded: loaded (/usr/lib/systemd/system/dhcpd.service; enabled; vendor preset: disabled)
   Active: active (running) since Fri 2021-04-30 01:10:51 CST; 3min 15s ago
     Docs: man:dhcpd(8)
           man:dhcpd.conf(5)
 Main PID: 30964 (dhcpd)
   Status: "Dispatching packets..."
    Tasks: 1 (limit: 12390)
   Memory: 8.8M
   CGroup: /system.slice/dhcpd.service
           └─30964 /usr/sbin/dhcpd -f -cf /etc/dhcp/dhcpd.conf -user dhcpd -group dhcpd --no-pid
………………省略部分输出信息………………
```

###### **19.2.2 配置TFTP服务程序**

我们曾经在第11章中学习过vsftpd服务与TFTP服务。vsftpd是一款功能丰富的文件传输服务程序，允许用户以匿名开放模式、本地用户模式、虚拟用户模式来进行访问认证。但是，当前的客户端主机还没有安装操作系统，该如何进行登录认证呢？TFTP作为一种基于UDP协议的简单文件传输协议，不需要进行用户认证即可获取到所需的文件资源。因此接下来配置TFTP服务程序，为客户端主机提供引导及驱动文件。当客户端主机有了基本的驱动程序之后，再通过vsftpd服务程序将完整的光盘镜像文件传输过去。

```
[root@linuxprobe ~]# dnf install -y tftp-server xinetd
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:00:34 ago on Fri 30 Apr 2021 01:38:09 AM CST.
Dependencies resolved.
================================================================================
 Package           Arch      Version             Repository          Size
================================================================================
Installing:
 tftp-server       x86_64    5.2-24.el8          AppStream           50 k
 xinetd            x86_64    2:2.3.15-23.el8     AppStream          135 k

Transaction Summary
================================================================================
Install  2 Packages
………………省略部分输出信息………………

Installed:
  tftp-server-5.2-24.el8.x86_64                xinetd-2:2.3.15-23.el8.x86_64               

Complete!
```

TFTP是一种非常精简的文件传输服务程序，它的运行和关闭是由xinetd网络守护进程服务来管理的。xinetd服务程序会同时监听系统的多个端口，然后根据用户请求的端口号调取相应的服务程序来响应用户的请求。需要开启TFTP服务程序时，只需在xinetd服务程序的配置文件中把disable参数改成no就可以了。如果配置文件不存在，则复制下面的内容进来，手动创建一下：

```
[root@linuxprobe ~]# vim /etc/xinetd.d/tftp
service tftp
{
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /var/lib/tftpboot
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
}
```

保存配置文件并退出，然后重启xinetd服务程序，并将其加入到开机启动项中。

```
[root@linuxprobe ~]# systemctl restart xinetd
[root@linuxprobe ~]# systemctl enable  xinetd
```

###### **19.2.3 配置SYSLinux服务程序**

SYSLinux是一个用于提供引导加载的服务程序。与其说SYSLinux是一个服务程序，不如说是一个包含了很多引导文件的文件夹。在安装好SYSLinux服务程序后，/usr/share/syslinux目录中会出现很多引导文件。

```
[root@linuxprobe ~]# dnf install -y syslinux
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:07:57 ago on Fri 30 Apr 2021 01:47:18 AM CST.
Dependencies resolved.
================================================================================
 Package                     Arch       Version         Repository     Size
================================================================================
Installing:
 syslinux                    x86_64     6.04-1.el8      BaseOS        576 k
Installing dependencies:
 syslinux-nonlinux           noarch     6.04-1.el8      BaseOS        554 k

Transaction Summary
================================================================================
Install  2 Packages
………………省略部分输出信息………………

Installed:
  syslinux-6.04-1.el8.x86_64              syslinux-nonlinux-6.04-1.el8.noarch             

Complete!
```

我们首先需要把SYSLinux提供的引导文件（也就是前文提到的文件pxelinux.0）复制到TFTP服务程序的默认目录中，这样客户端主机就能够顺利地获取到引导文件了。另外在RHEL 8系统光盘镜像中也有一些需要调取的引导文件。确认光盘镜像已经被挂载到/media/cdrom目录后，使用复制[命令](https://www.linuxcool.com/)将光盘镜像中自带的一些引导文件也复制到TFTP服务程序的默认目录中。

```
[root@linuxprobe ~]# cd /var/lib/tftpboot
[root@linuxprobe tftpboot]# cp /usr/share/syslinux/pxelinux.0 .
[root@linuxprobe tftpboot]# cp /media/cdrom/images/pxeboot/* .
[root@linuxprobe tftpboot]# cp /media/cdrom/isolinux/* .
cp: overwrite './initrd.img'? y
cp: overwrite './TRANS.TBL'? y
cp: overwrite './vmlinuz'? y
```

cp[命令](https://www.linuxcool.com/)后面接的句点（.）表示当前工作目录。也就是说，上述cp[命令](https://www.linuxcool.com/)表示将文件复制到当前工作目录（即/var/lib/tftpboot）中。在复制过程中，若多个目录保存着相同的文件，则可手动敲击y键进行覆盖即可。

然后在TFTP服务程序的目录中新建pxelinux.cfg目录。虽然该目录的名字带有后缀，但依然也是目录，而非文件！将系统光盘中的开机选项菜单复制到该目录中，并命名为default。这个default文件就是开机时的选项菜单，如图19-4所示。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2020/05/RHEL-8%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.png)

图19-4 Linux系统的引导菜单界面

```
[root@linuxprobe tftpboot]# mkdir pxelinux.cfg
[root@linuxprobe tftpboot]# cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default
```

默认的开机菜单中有3个选项：安装系统、对安装介质进行检验、排错模式。既然已经确定采用无人值守的方式安装系统，若还需要为每台主机手动选择相应的选项，则未免与我们的主旨（无人值守安装）相悖。

现在我们编辑这个default文件，把第1行的default参数修改为linux，这样系统在开机时就会默认执行那个名称为linux的选项了。对应的linux选项大约在第64行，将默认的光盘镜像安装方式修改成FTP文件传输方式，并指定好光盘镜像的获取网址以及Kickstart应答文件的获取路径：

```
[root@linuxprobe tftpboot]# vim pxelinux.cfg/default
  1 default linux
  2 timeout 600
  3 
  4 display boot.msg
  5 
  6 # Clear the screen when exiting the menu, instead of leaving the menu displayed.
  7 # For vesamenu, this means the graphical background is still displayed without
  8 # the menu itself for as long as the screen remains in graphics mode.
  9 menu clear
 10 menu background splash.png
 11 menu title Red Hat Enterprise Linux 8.0.0
 12 menu vshift 8
 13 menu rows 18
 14 menu margin 8
 15 #menu hidden
 16 menu helpmsgrow 15
 17 menu tabmsgrow 13
 18 
 19 # Border Area
 20 menu color border * #00000000 #00000000 none
 21 
 22 # Selected item
 23 menu color sel 0 #ffffffff #00000000 none
 24 
 25 # Title bar
 26 menu color title 0 #ff7ba3d0 #00000000 none
 27 
 28 # Press [Tab] message
 29 menu color tabmsg 0 #ff3a6496 #00000000 none
 30 
 31 # Unselected menu item
 32 menu color unsel 0 #84b8ffff #00000000 none
 33 
 34 # Selected hotkey
 35 menu color hotsel 0 #84b8ffff #00000000 none
 36 
 37 # Unselected hotkey
 38 menu color hotkey 0 #ffffffff #00000000 none
 39 
 40 # Help text
 41 menu color help 0 #ffffffff #00000000 none
 42 
 43 # A scrollbar of some type? Not sure.
 44 menu color scrollbar 0 #ffffffff #ff355594 none
 45 
 46 # Timeout msg
 47 menu color timeout 0 #ffffffff #00000000 none
 48 menu color timeout_msg 0 #ffffffff #00000000 none
 49 
 50 # Command prompt text
 51 menu color cmdmark 0 #84b8ffff #00000000 none
 52 menu color cmdline 0 #ffffffff #00000000 none
 53 
 54 # Do not display the actual menu unless the user presses a key. All that is displayed is a timeout message.
 55 
 56 menu tabmsg Press Tab for full configuration options on menu items.
 57 
 58 menu separator # insert an empty line
 59 menu separator # insert an empty line
 60 
 61 label linux
 62   menu label ^Install Red Hat Enterprise Linux 8.0.0
 63   kernel vmlinuz
 64   append initrd=initrd.img inst.stage2=ftp://192.168.10.10 ks=ftp://192.168.10.10/pub/ks.cfg quiet
 65 ………………省略部分输出信息………………
```

建议在安装源的后面加入quiet参数，意为使用静默安装方式，不再需要用户进行确认。文件修改完毕后保存即可。开机选项菜单是被调用的文件，因此不需要单独重启任何服务。

###### **19.2.4 配置VSFtpd服务程序**

在这套无人值守安装系统的服务中，光盘镜像是通过FTP协议传输的，因此势必要用到vsftpd服务程序。当然，也可以使用httpd服务程序来提供Web网站访问的方式，只要能确保将光盘镜像顺利传输给客户端主机即可。如果打算使用Web网站服务来提供光盘镜像，一定记得将上面配置文件中的光盘镜像获取网址和Kickstart应答文件获取网址修改一下。

```
[root@linuxprobe tftpboot]# dnf install -y vsftpd
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:28:28 ago on Fri 30 Apr 2021 01:47:18 AM CST.
Dependencies resolved.
===============================================================================
 Package       Arch       Version           Repository        Size
===============================================================================
Installing:
 vsftpd        x86_64     3.0.3-28.el8      AppStream         180 k

Transaction Summary
===============================================================================
Install  1 Package
………………省略部分输出信息………………

Installed:
  vsftpd-3.0.3-28.el8.x86_64                                                                     

Complete!
```

RHEL 8系统版本的vsftpd服务默认不允许匿名公开访问模式，因此需要手动进行开启：

```
[root@linuxprobe ~ ]# vim /etc/vsftpd/vsftpd.conf
# Example config file /etc/vsftpd/vsftpd.conf
#
# The default compiled in settings are fairly paranoid. This sample file
# loosens things up a bit, to make the ftp daemon more usable.
# Please see vsftpd.conf.5 for all compiled in defaults.
#
# READ THIS: This example file is NOT an exhaustive list of vsftpd options.
# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's
# capabilities.
#
# Allow anonymous FTP? (Beware - allowed by default if you comment this out).
anonymous_enable=YES
………………省略部分输出信息………………
```

[刘遄](https://www.linuxprobe.com/)老师再啰嗦一句，在配置文件修改正确之后，一定将相应的服务程序添加到开机启动项中，这样无论是在生产环境中还是在[红帽](https://www.linuxprobe.com/)认证考试中，都可以在设备重启之后依然能提供相应的服务。希望各位读者一定养成这个好习惯。

```
[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable  vsftpd
Created symlink /etc/systemd/system/multi-user.target.wants/vsftpd.service → /usr/lib/systemd/system/vsftpd.service.
```

在确认系统光盘镜像已经正常挂载到/media/cdrom目录后，把目录中的光盘镜像文件全部复制到vsftpd服务程序的工作目录中：

```
[root@linuxprobe ~]# cp -r /media/cdrom/* /var/ftp
```

这个过程大约需要3～5分钟。在此期间，咱们也别闲着，将SELinux安全子系统中放行FTP传输协议的允许策略，设置成on（开启）。

```
[root@linuxprobe ~]# setsebool -P ftpd_connect_all_unreserved=on
```

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

###### **19.2.5 创建KickStart应答文件**

毕竟，我们使用PXE +  Kickstart部署的是一套“无人值守安装系统服务”，而不是“无人值守传输系统光盘镜像服务”，因此还需要让客户端主机能够一边获取光盘镜像，一边自动帮用户填写好安装过程中出现的选项。简单来说，如果生产环境中有100台服务器，它们需要安装相同的系统环境，那么在安装过程中单击的按钮和填写的信息也应该都是相同的。那么，为什么不创建一个类似于备忘录的需求清单呢？这样，在无人值守安装系统时，会从这个需求清单中找到相应的选项值，从而免去了手动输入之苦。更重要的是，这也彻底解放了人的干预，彻底实现无人值守自动安装系统，而不是单纯地传输系统光盘镜像。

有了上文做铺垫，相信大家现在应该可以猜到Kickstart其实并不是一个服务程序，而是一个应答文件了。是的！Kickstart应答文件中包含了系统安装过程中需要使用的选项和参数信息，系统可以自动调取这个应答文件的内容，从而彻底实现无人值守安装系统。那么，既然这个文件如此重要，该去哪里找呢？其实在root管理员的家目录中有一个名为anaconda-ks.cfg的文件，它就是应答文件。下面将这个文件复制到vsftpd服务程序的工作目录中（在开机选项菜单的配置文件中已经定义了该文件的获取路径，也就是vsftpd服务程序数据目录中的pub子目录）。使用chmod[命令](https://www.linuxcool.com/)设置该文件的权限，确保所有人都有可读的权限，以保证客户端主机顺利获取到应答文件及里面的内容：

```
[root@linuxprobe ~]# cp ~/anaconda-ks.cfg /var/ftp/pub/ks.cfg
[root@linuxprobe ~]# chmod +r /var/ftp/pub/ks.cfg
```

Kickstart应答文件并没有想象中的那么复杂，它总共只有44行左右的参数和注释内容，大家完全可以通过参数的名称及介绍来快速了解每个参数的作用。[刘遄](https://www.linuxprobe.com/)老师在这里挑选几个比较有代表性的参数进行讲解，其他参数建议大家自行修改测试。

其中，第1～10行表示安装硬盘的名称为sda及使用LVM技术。这便要求我们在后续新建客户端虚拟机时，硬盘一定要选择SCSI或SATA类型的（见图19-5），否则会变成/dev/hd或/dev/nvme开头的名称，进而会因找不到硬盘设备而终止安装进程。

第8行的软件仓库，应改为由FTP服务器提供的网络路径。第10行的安装源，也需要由CDROM改为网络安装源：

```
  1 #version=RHEL8
  2 ignoredisk --only-use=sda
  3 autopart --type=lvm
  4 # Partition clearing information
  5 clearpart --none --initlabel
  6 # Use graphical install
  7 graphical
  8 repo --name="AppStream" --baseurl=ftp://192.168.10.10/AppStream
  9 # Use CDROM installation media
 10 url --url=ftp://192.168.10.10/BaseOS
```

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/设备类型.png)

图19-5 选择SCSI或SATA硬盘类型

在第11～20行，keyboard参数为硬盘类型，一般都不需要修改。但一定要注意第17行的网卡信息，一定要让网卡默认处于DHCP模式，否则在几十、上百台主机同时被创建出来后，会因为IP地址相互冲突而导致后续无法管理。

```
 11 # Keyboard layouts
 12 keyboard --vckeymap=us --xlayouts='us'
 13 # System language
 14 lang en_US.UTF-8
 15 
 16 # Network information
 17 network  --bootproto=dhcp --device=ens160 --onboot=on --ipv6=auto --activate
 18 network  --hostname=linuxprobe.com
 19 # Root password
 20 rootpw --iscrypted $6$EzIFyouUyBvWRIXv$y3bW3JZ2vD4c8bwVyKt7J90gyjULALTMLrnZZmvVujA75EpCCn50rlYm64MHAInbMAXAgn2Bmlgou/pYjUZzL1
```

在第21行～30行，timezone参数定义了系统默认时区为“上海”。如果大家的服务器时间不准确，则按照如下修改即可。在第29行，创建了一个普通用户，密码值可复制/etc/shadow文件中的加密密文，它由系统自动创建。

```
 21 # X Window System configuration information
 22 xconfig  --startxonboot
 23 # Run the Setup Agent on first boot
 24 firstboot --enable
 25 # System services
 26 services --disabled="chronyd"
 27 # System timezone
 28 timezone Asia/Shanghai --isUtc --nontp
 29 user --name=linuxprobe --password=$6$a5fEjghDXGPvEoQc$HQqzvBlGVyhsJjgKFDTpiCEavS.inAwNTLZm/I5R5ALLKaMdtxZoKgb4/EaDyiPSSNNHGqrEkRnfJWap56m./. --iscrypted --gecos="linuxprobe"
 30 
```

最后的第31～44行表示要安装的软件来源。graphical-server-environment即带有图形化界面的服务器环境，它对应的是安装界面中的Server With GUI选项。

```
 31 %packages
 32 @^graphical-server-environment
 33 
 34 %end
 35 
 36 %addon com_redhat_kdump --disable --reserve-mb='auto'
 37 
 38 %end
 39 
 40 %anaconda
 41 pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
 42 pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
 43 pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
 44 %end
```

由上可知，实际算下来的修改并不多，默认参数就已经非常合适了。最后预览一下ks.cfg文件的全貌。如果大家在生产环境中需要用到这个文件，则可以直接复制并使用下面的内容：

```
[root@linuxprobe ~ ]# cat /var/ftp/pub/ks.cfg
#version=RHEL8
ignoredisk --only-use=sda
autopart --type=lvm
# Partition clearing information
clearpart --none --initlabel
# Use graphical install
graphical
repo --name="AppStream" --baseurl=ftp://192.168.10.10/AppStream
# Use CDROM installation media
url --url=ftp://192.168.10.10/BaseOS
# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8

# Network information
network  --bootproto=dhcp --device=ens160 --onboot=on --ipv6=auto --activate
network  --hostname=linuxprobe.com
# Root password
rootpw --iscrypted $6$EzIFyouUyBvWRIXv$y3bW3JZ2vD4c8bwVyKt7J90gyjULALTMLrnZZmvVujA75EpCCn50rlYm64MHAInbMAXAgn2Bmlgou/pYjUZzL1
# X Window System configuration information
xconfig  --startxonboot
# Run the Setup Agent on first boot
firstboot --enable
# System services
services --disabled="chronyd"
# System timezone
timezone Asia/Shanghai --isUtc --nontp
user --name=linuxprobe --password=$6$a5fEjghDXGPvEoQc$HQqzvBlGVyhsJjgKFDTpiCEavS.inAwNTLZm/I5R5ALLKaMdtxZoKgb4/EaDyiPSSNNHGqrEkRnfJWap56m./. --iscrypted --gecos="linuxprobe"

%packages
@^graphical-server-environment

%end

%addon com_redhat_kdump --disable --reserve-mb='auto'

%end

%anaconda
pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
%end
                                                                                          
```

Kickstart应答文件将使用FTP服务进行传输，然后由安装向导进行调用，因此也不需要重启任何服务。

##### **19.3 自动部署客户机**

在按照上文讲解的方法成功部署各个相关的服务程序后，就可以使用PXE +  Kickstart无人值守安装系统了。在采用下面的步骤建立虚拟主机时，一定要把客户端的网络模式设定成与服务端一致的“仅主机模式”，否则两台设备无法进行通信，也就更别提自动安装系统了。其余硬件配置选项并没有强制性要求，大家可参考这里的配置选项来设定。

**第1步**：打开“新建虚拟机向导”程序，选择“自定义（高级）”配置类型，然后单击“下一步”按钮，如图19-6所示。在随后的虚拟机硬件兼容性选项中，选择默认的“Workstation 16.x”，步骤省略。

**第2步**：将虚拟机操作系统的安装来源设置为“稍后安装操作系统”。这样做的目的是让虚拟机真正从网络中获取系统安装镜像，同时也可避免VMware Workstation虚拟机软件按照内设的方法自行安装系统。单击“下一步”按钮，如图19-7所示。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/创建虚拟机.png)

图19-6  选择虚拟机的配置类型

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/稍后安装操作系统.png)

图19-7 设置虚拟机操作系统的安装来源

**第3步**：将“客户机操作系统”设置为Linux，版本为“Red Hat Enterprise Linux 8 64位”，然后单击“下一步”按钮，如图19-8所示。

**第4步**：对虚拟机进行命名并设置安装位置。大家可自行定义虚拟机的名称，而安装位置则尽量选择磁盘空间较大的分区。然后单击“下一步”按钮，如图19-9所示。在随后设置虚拟机处理器的个数及核心数、内存容量值时，请大家根据实际情况自行选择，步骤省略。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/设置操作系统的版本.png)

图19-8 选择客户端主机的操作系统

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/设置虚拟机名称.png)

图19-9 命名虚拟机并设置虚拟机的安装位置

**第5步**：设置虚拟机主机的网络连接类型为“使用仅主机模式网络”，如图19-10所示。一定要确保服务器与客户端同处于相同的网络模式，否则客户端无法获得从服务器传送过来的系统镜像及应答文件。随后的SCSI控制器类型选择默认的LSI Logic，步骤省略。

**第6步**：设置硬盘类型并指定容量。设置“虚拟磁盘类型”为SCSI或SATA，如图19-11所示。随后在硬盘创建确认界面，选择“创建新虚拟磁盘”选项，步骤省略。

这里将“最大磁盘大小”设置为20GB。需要说明的是，这个20GB指的是虚拟机系统能够使用的最大上限，而不是会被立即占满，因此设置得稍微大一些也没有关系。然后单击“下一步”按钮，如图19-12所示。随后的确认硬盘文件名称界面选择默认值即可，步骤省略。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/设置网络连接模式.png)

图19-10 设置客户端的网络模式

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/设置硬盘类型.png)

图19-11 设置虚拟硬盘类型为SCSI或SATA

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/设置虚拟硬盘容量.png)

图19-12 将磁盘容量指定为20GB

**第7步**：结束“新建虚拟机向导程序”后，先不要着急打开虚拟机系统。大家还需要单击图19-13中的“自定义硬件”按钮，在弹出的如图19-14所示的界面中，把“网络适配器”设备同样也设置为“仅主机模式”（这个步骤非常重要），移除其他不需要的硬件，然后单击“确定”按钮。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/自定义硬件.png)

图19-13 单击虚拟机的“自定义硬件”按钮

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/硬件配置一览.png)

图19-14 设置虚拟机网络适配器设备为仅主机模式

现在，我们就同时准备好了PXE +  Kickstart无人值守安装系统与虚拟主机。在生产环境中，大家只需要将配置妥当的服务器上架，接通服务器和客户端主机之间的网线，然后启动客户端主机即可。接下来就会按照图19-15～图19-17那样，开始传输光盘镜像文件并进行自动安装了—期间完全无须人工干预，直到安装完毕时才需要运维人员进行简单的初始化工作。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/1-22-1024x704.png)

图19-15 自动传输光盘镜像文件并安装系统

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/2-18-1024x705.png)

图19-16 根据应答文件自动填写安装信息

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/3-7-1024x704.png)

图19-17 自动安装系统，无须人工干预

由此可见，当生产环境工作中有数百台服务器需要批量安装系统时，使用无人值守安装系统的便捷性是不言而喻的。但是为了避免法律风险，[红帽](https://www.linuxprobe.com/)公司对于许可界面还不允许用应答文件自动完成，需要人工单击“I accept the license agreement”复选框后方可继续安装，如图19-18和图19-19所示，我们通过网络安装的客户端就搞定了。

![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/4-3-1024x704.png)

图19-18 手动点击接受许可协议的按钮
 ![第19章 使用PXE+Kickstart无人值守安装服务第19章 使用PXE+Kickstart无人值守安装服务](https://www.linuxprobe.com/wp-content/uploads/2021/04/5-3-1024x704.png)

图19-19 顺利进入到新系统中

**出现问题?大胆提问!**

> 因读者们硬件不同或操作错误都可能导致实验配置出错，请耐心再仔细看看操作步骤吧，不要气馁~
>
> Linux技术交流学习请加读者群（**推荐**）：https://www.linuxprobe.com/club
>
> *本群特色：确保每一位群友都是《Linux就该这么学》的读者，答疑更有针对性，不定期领取定制礼品。

**本章节的复习作业(答案就在问题的下一行哦，用鼠标选中即可看到的~)**

 

1．部署无人值守安装系统时，需要用到哪些服务程序和文件？

**答：**需要用到SYSLinux引导服务、DHCP服务、vsftpd文件传输服务（或httpd网站服务）、TFTP服务以及Kickstart应答文件。

2．在VMware Workstation虚拟机软件中，DHCP服务总是分配错误IP地址的原因可能是什么？

**答：**虚拟机的虚拟网络编辑器中自带的DHCP服务可能没有关闭，由此产生了错误分配IP地址的情况。

3．如何启用TFTP服务？

**答：**需要在xinetd服务程序的配置文件中把disable参数改成no。

4．成功安装SYSLinux服务程序后，可以在哪个目录中找到引导文件？

**答：**在安装好SYSLinux服务程序软件包后，在/usr/share/syslinux目录中会出现很多引导文件。

5．在开机选项菜单文件中，把default参数设置成linux的作用是什么？

**答：**目的是让系统自动开始安装过程，而不需要运维人员再去选择是安装系统还是校验镜像文件。

6．安装vsftpd文件传输服务或httpd网站服务的作用是什么？

**答：**把光盘镜像文件完整、顺利地传送到客户端主机。

7．Kickstart应答文件的作用是什么？

**答：**Kickstart应答文件中包含了系统安装过程中需要使用的选项和参数信息，客户端主机在安装系统的过程中可以自动调取这个应答文件的内容，从而彻底实现无人值守安装系统。

MariaDB是由MySQL项目创始人Michael Widenius带领着团队开发的。根据MariaDB官网的介绍，Michael  Widenius有两个可爱的小天使女儿，大女儿叫My，而二女儿叫Maria，因此MariaDB成为他用亲人名字命名的第二款软件（第一款显然是MySQL）。

```
Why is the Software Called MariaDB?

The 'MySQL' name is trademarked by Oracle, and they have chosen to keep that trademark to themselves. The name MySQL (just like the MyISAM storage engine) comes from Monty's first daughter My. The first part of 'MySQL' is pronounced like the English adjective, even if this doesn't match the correct pronunciation of the Finnish name.

MariaDB continues this tradition by being named after his younger daughter, Maria.

The name Maria was initially given to a storage engine. After MariaDB was started, to avoid confusion, it was renamed to Aria. The new name was decided as a result of a contest.
```

MariaDB当前由开源社区进行维护，是MySQL的分支产品，而且与MySQL具有高度的兼容性，与MySQL API和[命令](https://www.linuxcool.com/)均保持一致。并且MariaDB还自带了一个新的存储引擎Aria，用于替代MyISAM。

##### **18.2 初始化mariaDB服务**

相较于MySQL，MariaDB数据库管理系统有了很多新鲜的扩展特性，例如对微秒级别的支持、线程池、子查询优化、进程报告等。在配置妥当软件仓库后，即可安装部署MariaDB数据库主程序及服务端程序了。

```
[root@linuxprobe ~]# dnf install -y mariadb mariadb-server
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 0:00:19 ago on Tue 27 Apr 2021 05:04:27 PM CST.
Dependencies resolved.
===========================================================================================
 Package                    Arch   Version              Repository             Size
===========================================================================================
Installing:
 mariadb                    x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream 6.2 M
 mariadb-server             x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream  16 M
Installing dependencies:
 mariadb-common             x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream  62 k
 mariadb-connector-c        x86_64 3.0.7-1.el8                             AppStream 148 k
 mariadb-connector-c-config noarch 3.0.7-1.el8                             AppStream  13 k
 mariadb-errmsg             x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream 232 k
 perl-DBD-MySQL             x86_64 4.046-2.module+el8+2515+0650e81c        AppStream 156 k
Installing weak dependencies:
 mariadb-backup             x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream 6.2 M
 mariadb-gssapi-server      x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream  49 k
 mariadb-server-utils       x86_64 3:10.3.11-1.module+el8+2765+cfa4f87b    AppStream 1.6 M
Enabling module streams:
 mariadb                           10.3                                                   
 perl-DBD-MySQL                    4.046                                                  

Transaction Summary
===========================================================================================
Install  10 Packages
………………省略部分输出信息………………
Installed:
  mariadb-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                                      
  mariadb-server-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                               
  mariadb-backup-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                               
  mariadb-gssapi-server-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                        
  mariadb-server-utils-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                         
  mariadb-common-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                               
  mariadb-connector-c-3.0.7-1.el8.x86_64                                                   
  mariadb-connector-c-config-3.0.7-1.el8.noarch                                            
  mariadb-errmsg-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64                               
  perl-DBD-MySQL-4.046-2.module+el8+2515+0650e81c.x86_64                                   

Complete!
```

在安装完毕后，记得启动服务程序，并将其加入到开机启动项中：

```
[root@linuxprobe ~]# systemctl start  mariadb 
[root@linuxprobe ~]# systemctl enable mariadb 
Created symlink /etc/systemd/system/mysql.service → /usr/lib/systemd/system/mariadb.service.
Created symlink /etc/systemd/system/mysqld.service → /usr/lib/systemd/system/mariadb.service.
Created symlink /etc/systemd/system/multi-user.target.wants/mariadb.service → /usr/lib/systemd/system/mariadb.service.
```

在确认mariadb数据库软件程序安装完毕并成功启动后请不要立即使用。为了确保数据库的安全性和正常运转，需要先对数据库程序进行初始化操作。这个初始化操作涉及下面5个步骤。

> 设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值默认应该为空，可直接按回车键）。
>
> 设置root管理员在数据库中的专有密码。
>
> 删除匿名用户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。
>
> 删除默认的测试数据库，取消测试数据库的一系列访问权限。
>
> 刷新授权列表，让初始化的设定立即生效。

对于上述数据库初始化的操作步骤，刘遄老师已经在下面的输出信息旁边进行了简单注释，确保各位读者更直观地了解要输入的内容：

```
[root@linuxprobe ~]# mysql_secure_installation 

NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!

In order to log into MariaDB to secure it, we'll need the current
password for the root user.  If you've just installed MariaDB, and
you haven't set the root password yet, the password will be blank,
so you should just press enter here.

Enter current password for root (enter for none): 输入管理员原始密码，默认为空值，直接回车即可
OK, successfully used password, moving on...

Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.

Set root password? [Y/n] y（设置管理员密码）
New password: 输入新的密码
Re-enter new password: 再次输入密码
Password updated successfully!
Reloading privilege tables..
 ... Success!


By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them.  This is intended only for testing, and to make the installation
go a bit smoother.  You should remove them before moving into a
production environment.

Remove anonymous users? [Y/n] y（删除匿名账户）
 ... Success!

Normally, root should only be allowed to connect from 'localhost'.  This
ensures that someone cannot guess at the root password from the network.

Disallow root login remotely? [Y/n] y（禁止管理员从远程登录）
 ... Success!

By default, MariaDB comes with a database named 'test' that anyone can
access.  This is also intended only for testing, and should be removed
before moving into a production environment.

Remove test database and access to it? [Y/n] y（删除测试数据库及其访问权限）
 - Dropping test database...
 ... Success!
 - Removing privileges on test database...
 ... Success!

Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.

Reload privilege tables now? [Y/n] y（刷新授权表，让初始化后的设定立即生效）
 ... Success!

Cleaning up...

All done!  If you've completed all of the above steps, your MariaDB
installation should now be secure.

Thanks for using MariaDB!
```

在很多生产环境中都需要使用站库分离的技术（即网站和数据库不在同一个服务器上），如果需要让root管理员远程访问数据库，可在上面的初始化操作中设置策略，以允许root管理员从远程访问。然后还需要设置防火墙，使其放行对数据库服务程序的访问请求。数据库服务程序默认会占用3306端口，在防火墙策略中服务名称统一叫作mysql：

```
[root@linuxprobe ~]# firewall-cmd --permanent --add-service=mysql
success
[root@linuxprobe ~]# firewall-cmd --reload
success
```

一切准备就绪。现在我们将首次登录MariaDB数据库。管理数据库的命令为mysql，其中，-u参数用来指定以root管理员的身份登录，而-p参数用来验证该用户在数据库中的密码值。

```
[root@linuxprobe ~]# mysql -u root -p
Enter password: 输入刚才设置的管理员密码后敲击回车
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 16
Server version: 10.3.11-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
```

初次使用数据库管理工具的读者，可以输入help命令查看mariadb服务能做的操作，语句的用法与MySQL一模一样：

```
MariaDB [(none)]> help

General information about MariaDB can be found at http://mariadb.org

List of all MySQL commands:
Note that all text commands must be first on line and end with ';'
?         (\?) Synonym for `help'.
clear     (\c) Clear the current input statement.
connect   (\r) Reconnect to the server. Optional arguments are db and host.
delimiter (\d) Set statement delimiter.
edit      (\e) Edit command with $EDITOR.
ego       (\G) Send command to mysql server, display result vertically.
exit      (\q) Exit mysql. Same as quit.
go        (\g) Send command to mysql server.
help      (\h) Display this help.
nopager   (\n) Disable pager, print to stdout.
notee     (\t) Don't write into outfile.
pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.
print     (\p) Print current command.
prompt    (\R) Change your mysql prompt.
quit      (\q) Quit mysql.
rehash    (\#) Rebuild completion hash.
source    (\.) Execute an SQL script file. Takes a file name as an argument.
status    (\s) Get status information from the server.
system    (\!) Execute a system shell command.
tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.
use       (\u) Use another database. Takes database name as argument.
charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.
warnings  (\W) Show warnings after every statement.
nowarning (\w) Don't show warnings after every statement.

For server side help, type 'help contents'
```

在登录MariaDB数据库后执行数据库命令时，都需要在命令后面用分号（;）结尾，这也是与Linux命令最显著的区别。大家需要慢慢习惯数据库命令的这种设定。下面执行如下命令查看数据库管理系统中当前都有哪些数据库：

```
MariaDB [(none)]> SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.000 sec)
```

小试牛刀过后，接下来使用数据库命令将root管理员在数据库管理系统中的密码值修改为linuxprobe。这样退出后再尝试登录，如果还坚持输入原先的密码，则将提示访问失败。

```
MariaDB [(none)]> SET password = PASSWORD('linuxprobe');
Query OK, 0 rows affected (0.001 sec)

MariaDB [(none)]> exit
Bye
[root@linuxprobe ~]# mysql -u root -p
Enter password: 此处输入管理员在数据库中的旧密码
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
```

输入新密码（linuxprobe）后，便可顺利进入数据库管理工具中：

```
[root@linuxprobe ~]# mysql -u root -p
Enter password: 此处输入管理员在数据库中的新密码
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 20
Server version: 10.3.11-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
```



##### **18.3 管理用户以及授权**

在生产环境中总不能一直“死啃”root管理员。为了保障数据库系统的安全性，以及让其他用户协同管理数据库，可以在MariaDB数据库管理系统中为他们创建多个专用的数据库管理用户，然后再分配合理的权限，以满足他们的工作需求。为此，可使用root管理员登录数据库管理系统，然后按照“CREATE USER用户名@主机名IDENTIFIED BY  '密码';”的格式创建数据库管理用户。再次提醒大家，一定不要忘记每条数据库命令后面的分号（;）。

```
MariaDB [(none)]> CREATE USER luke@localhost IDENTIFIED BY 'linuxprobe';
Query OK, 0 rows affected (0.00 sec)
```

创建的用户信息可以使用SELECT命令语句来查询。下面命令查询的是用户luke的主机名称、用户名称以及经过加密的密码值信息：

```
MariaDB [(none)]> use mysql;
Database changed
MariaDB [mysql]> SELECT HOST,USER,PASSWORD FROM user WHERE USER="luke";
+-----------+------+-------------------------------------------+
| HOST      | USER | PASSWORD                                  |
+-----------+------+-------------------------------------------+
| localhost | luke | *55D9962586BE75F4B7D421E6655973DB07D6869F |
+-----------+------+-------------------------------------------+
1 row in set (0.001 sec)
```

不过，用户luke仅仅是一位普通用户，没有数据库的任何操作权限。不信的话，可以切换到luke用户来查询数据库管理系统中当前都有哪些数据库。可以发现，该用户甚至没法查看完整的数据库列表（刚才使用root用户时可以查看到3个数据库列表）：

```
MariaDB [mysql]> exit
Bye
[root@linuxprobe ~]# mysql -u luke -p
Enter password: 输入luke用户的数据库密码
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 21
Server version: 10.3.11-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
+--------------------+
1 row in set (0.001 sec)
```

数据库管理系统所使用的命令一般都比较复杂。我们以GRANT命令为例进行说明。GRANT命令用于为用户进行授权，其常见格式如表18-1所示。在使用GRANT命令时需要写上要赋予的权限、数据库及表单名称，以及对应的用户及主机信息。其实，只要理解了命令中每个字段的功能含义，也就不觉得命令复杂难懂了。

表18-1                    GRANT命令的常见格式以及解释

| 命令                                           | 作用                                             |
| ---------------------------------------------- | ------------------------------------------------ |
| GRANT 权限 ON 数据库.表单名称 TO 用户名@主机名 | 对某个特定数据库中的特定表单给予授权             |
| GRANT 权限 ON 数据库.* TO 用户名@主机名        | 对某个特定数据库中的所有表单给予授权             |
| GRANT 权限 ON *.* TO 用户名@主机名             | 对所有数据库及所有表单给予授权                   |
| GRANT 权限1,权限2 ON 数据库.* TO 用户名@主机名 | 对某个数据库中的所有表单给予多个授权             |
| GRANT ALL PRIVILEGES ON *.* TO 用户名@主机名   | 对所有数据库及所有表单给予全部授权（需谨慎操作） |

当然，用户的授权工作肯定是需要数据库管理员来执行的。下面以root管理员的身份登录到数据库管理系统中，针对mysql数据库中的user表单向用户luke授予查询、更新、删除以及插入等权限。

刘遄老师特别懂同学们现在心里想什么。我起初也觉得在每条数据库命令后都要加上分号（;）特别不方便，时常还会忘记，但敲的命令多了也就自然习惯了。

```
[root@linuxprobe ~]# mysql -u root -p
Enter password: 输入管理员的数据库密码
MariaDB [(none)]> use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [mysql]> GRANT SELECT,UPDATE,DELETE,INSERT ON mysql.user TO luke@localhost;
Query OK, 0 rows affected (0.001 sec)
```

在执行完上述授权操作之后，我们再查看一下用户luke的权限：

```
MariaDB [(none)]>  SHOW GRANTS FOR luke@localhost;
+---------------------------------------------------------------------------------------------+
| Grants for luke@localhost                                                                   |
+---------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'luke'@'localhost' IDENTIFIED BY PASSWORD '*55D9962586BE75F4B7D421E6655973DB07D6869F' |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `mysql`.`user` TO 'luke'@'localhost'                |
+---------------------------------------------------------------------------------------------+
2 rows in set (0.000 sec)
```

上面输出信息中显示用户luke已经拥有了针对mysql数据库中user表单的一系列权限了。这时我们再切换到用户luke，此时就能够看到mysql数据库了，而且还能看到表单user（其余表单会因无权限而被继续隐藏）：

```
[root@linuxprobe ~]# mysql -u luke -p
Enter password: 输入luke用户的数据库密码

MariaDB [(none)]> SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
+--------------------+
2 rows in set (0.000 sec)

MariaDB [(none)]> use mysql;
Database changed

MariaDB [mysql]> SHOW tables;
+-----------------+
| Tables_in_mysql |
+-----------------+
| user            |
+-----------------+
1 row in set (0.001 sec)

MariaDB [mysql]> exit
Byes
```

大家不要心急，我们接下来会慢慢学习数据库内容的修改方法。当前，先切换回root管理员用户，移除刚才的授权。

```
[root@linuxprobe ~]# mysql -u root -p
Enter password: 输入管理员的数据库密码
MariaDB [(none)]> use mysql;
Database changed
MariaDB [(none)]> REVOKE SELECT,UPDATE,DELETE,INSERT ON mysql.user FROM luke@localhost;
Query OK, 0 rows affected (0.00 sec)
```

可以看到，除了移除授权的命令（REVOKE）与授权命令（GRANTS）不同之外，其余部分都是一致的。这不仅好记而且也容易理解。执行移除授权命令后，再来查看用户luke的信息：

```
MariaDB [(none)]> SHOW GRANTS FOR luke@localhost;
+---------------------------------------------------------------------------------------------+
| Grants for luke@localhost                                                                   |
+---------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'luke'@'localhost' IDENTIFIED BY PASSWORD '*55D9962586BE75F4B7D421E6655973DB07D6869F' |
+---------------------------------------------------------------------------------------------+
1 row in set (0.001 sec)
```

不再需要某个用户时，可以直接用DROP命令将其删除：

```
MariaDB [(none)]> DROP user luke@localhost;
Query OK, 0 rows affected (0.000 sec)
```

##### **18.4 创建数据库与表单**

在MariaDB数据库管理系统中，一个数据库可以存放多个数据表，数据表单是数据库中最重要最核心的内容。我们可以根据自己的需求自定义数据库表结构，然后在其中合理地存放数据，以便后期轻松地维护和修改。表18-2罗列了后文中将使用到的数据库命令以及对应的作用。

表18-2                    用于创建数据库的命令以及作用

| 命令用法                                                     | 作用                   |
| ------------------------------------------------------------ | ---------------------- |
| CREATE database 数据库名称。                                 | 创建新的数据库         |
| DESCRIBE 表单名称;                                           | 描述表单               |
| UPDATE 表单名称 SET attribute=新值 WHERE attribute > 原始值; | 更新表单中的数据       |
| USE 数据库名称;                                              | 指定使用的数据库       |
| SHOW databases;                                              | 显示当前已有的数据库   |
| SHOW tables;                                                 | 显示当前数据库中的表单 |
| SELECT * FROM 表单名称;                                      | 从表单中选中某个记录值 |
| DELETE FROM 表单名 WHERE attribute=值;                       | 从表单中删除某个记录值 |

建立数据库是管理数据的起点。现在尝试创建一个名为linuxprobe的数据库，然后再查看数据库列表，此时就能看到它了：

```
MariaDB [(none)]>  CREATE DATABASE linuxprobe;
Query OK, 1 row affected (0.001 sec)

MariaDB [(none)]>  SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| linuxprobe         |
| mysql              |
| performance_schema |
+--------------------+
4 rows in set (0.001 sec)
```

MariaDB与MySQL同属于关系型数据库（Relational Database Management System，RDBMS）。关系型数据库有些类似于表格的概念，一个关系型数据库由一个或多个表格/表单组成，如图18-2所示。

在图18-2中，表头表示每一列的名称；列表示具有相同数据类型的数据集合；行表示用来描述事物的具体信息；值表示行的具体信息，每个值均与该列的其他数据类型相同；键表示用来识别某个特定事物的方法，在当前列中具有唯一性。

![第18章 使用MariaDB数据库管理系统第18章 使用MariaDB数据库管理系统](https://www.linuxprobe.com/wp-content/uploads/2021/04/数据库概念.png)

图18-2 数据库存储概念

比如，在新建的linuxprobe数据库中创建表单mybook，然后进行表单的初始化，即定义存储数据内容的结构。我们分别定义3个字段项，其中，字符型字段name（长度为15字符）用来存放图书名称，整型字段price和pages分别存储图书的价格和页数。当执行完下述命令之后，就可以看到表单的结构信息了：

```
MariaDB [(none)]> use linuxprobe;
Database changed
MariaDB [linuxprobe]> CREATE TABLE mybook (name char(15),price int,pages int);
Query OK, 0 rows affected (0.009 sec)

MariaDB [linuxprobe]> DESCRIBE mybook;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(15) | YES  |     | NULL    |       |
| price | int(11)  | YES  |     | NULL    |       |
| pages | int(11)  | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.002 sec)
```

##### **18.5 管理表单及数据**

接下来向mybook数据表单中插入一条图书信息。为此需要使用INSERT命令，并在命令中写清表单名称以及对应的字段项。执行该命令之后即可完成图书写入信息。下面使用该命令插入一条图书信息，其中书名为linuxprobe，价格和页数分别是60元和518页。在命令执行后也就意味着图书信息已经成功写入到数据表单中，然后就可以查询表单中的内容了。在使用SELECT命令查询表单内容时，需要加上想要查询的字段；如果想查看表单中的所有内容，则可以使用星号（*）通配符来显示：

```
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxprobe','60', '518');
Query OK, 1 row affected (0.001 sec)

MariaDB [linuxprobe]> SELECT * from mybook;
+------------+-------+-------+
| name       | price | pages |
+------------+-------+-------+
| linuxprobe |    60 |   518 |
+------------+-------+-------+
1 row in set (0.000 sec)
```

对数据库运维人员来讲，需要做好4门功课—增、删、改、查。这意味着创建数据表单并在其中插入内容仅仅是第一步，还需要掌握数据表单内容的修改方法。例如，可以使用UPDATE命令将刚才插入的linuxprobe图书信息的价格修改为55元，然后再使用SELECT命令查看该图书的名称和定价信息。注意，因为这里只查看图书的名称和定价，而不涉及页码，所以无须再用星号通配符来显示所有内容。

```
MariaDB [linuxprobe]> UPDATE mybook SET price=55 ;
Query OK, 1 row affected (0.002 sec)
Rows matched: 1  Changed: 1  Warnings: 0

MariaDB [linuxprobe]> SELECT name,price FROM mybook;
+------------+-------+
| name       | price |
+------------+-------+
| linuxprobe |    55 |
+------------+-------+
1 row in set (0.000 sec)
```

想修改指定的某一条记录？没问题的，用WHERE命令进行限定即可。我们先插入两条图书信息：

```
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxcool','85', '300');
Query OK, 1 row affected (0.001 sec)
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxdown','105', '500');
Query OK, 1 row affected (0.001 sec)
```

然后使用WHERE命令仅将名称为linuxcool的图书价格修改为60元，不影响其他图书信息：

```
MariaDB [linuxprobe]> UPDATE mybook SET price=60 where name='linuxcool';
Query OK, 1 row affected (0.001 sec)
Rows matched: 1  Changed: 1  Warnings: 0

MariaDB [linuxprobe]> select * from mybook;
+------------+-------+-------+
| name       | price | pages |
+------------+-------+-------+
| linuxprobe |    55 |   518 |
| linuxcool  |    60 |   300 |
| linuxdown  |   105 |   500 |
+------------+-------+-------+
3 rows in set (0.001 sec)
```

还可以使用DELETE命令删除某个数据表单中的内容。下面使用DELETE命令删除数据表单mybook中的所有内容，然后再查看该表单中的内容，可以发现该表单内容为空了：

```
MariaDB [linuxprobe]> DELETE FROM mybook;
Query OK, 3 row affected (0.001 sec)

MariaDB [linuxprobe]> SELECT * FROM mybook;
Empty set (0.000 sec)
```

一般来讲，数据表单中会存放成千上万条数据信息。比如我们刚刚创建的用于保存图书信息的mybook表单，随着时间的推移，里面的图书信息也会越来越多。在这样的情况下，如果只想查看其价格大于某个数值的图书，又该如何定义查询语句呢？

下面先使用INSERT插入命令依次插入4条图书信息：

```
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxprobe1','30','518');
Query OK, 1 row affected (0.05 sec)
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxprobe2','50','518');
Query OK, 1 row affected (0.05 sec)
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxprobe3','80','518');
Query OK, 1 row affected (0.01 sec)
MariaDB [linuxprobe]> INSERT INTO mybook(name,price,pages) VALUES('linuxprobe4','100','518');
Query OK, 1 row affected (0.00 sec)
```

要想让查询结果更加精准，就需要结合使用SELECT与WHERE命令了。其中，WHERE命令是在数据库中进行匹配查询的条件命令。通过设置查询条件，就可以仅查找出符合该条件的数据。表18-3列出了WHERE命令中常用的查询参数以及作用。

表18-3                    where命令中使用的参数以及作用

| 参数    | 作用             |
| ------- | ---------------- |
| =       | 相等             |
| <>或!=  | 不相等           |
| >       | 大于             |
| <       | 小于             |
| >=      | 大于或等于       |
| <=      | 小于或等于       |
| BETWEEN | 在某个范围内     |
| LIKE    | 搜索一个例子     |
| IN      | 在列中搜索多个值 |

现在进入动手环节。分别在mybook表单中查找出价格大于75元或价格不等于80元的图书，其对应的命令如下所示。在熟悉了这两个查询条件之后，大家可以自行尝试精确查找图书名为linuxprobe2的图书信息。

```
MariaDB [linuxprobe]> SELECT * FROM mybook WHERE price>75;
+-------------+-------+-------+
| name        | price | pages |
+-------------+-------+-------+
| linuxprobe3 |    80 |   518 |
| linuxprobe4 |   100 |   518 |
+-------------+-------+-------+
2 rows in set (0.001 sec)

MariaDB [linuxprobe]> SELECT * FROM mybook WHERE price!=80;
+-------------+-------+-------+
| name        | price | pages |
+-------------+-------+-------+
| linuxprobe1 |    30 |   518 |
| linuxprobe2 |    50 |   518 |
| linuxprobe4 |   100 |   518 |
+-------------+-------+-------+
3 rows in set (0.000 sec)
```

匹配的条件越多，获得的信息就越精准。在WHERE命令的后面追加AND操作符，可以进行多次匹配。例如，执行下述命令，找到价格为30元、页数为518的图书的名称：

```
MariaDB [linuxprobe]> SELECT * from mybook WHERE price=30 AND pages=518 ;
+-------------+-------+-------+
| name        | price | pages |
+-------------+-------+-------+
| linuxprobe1 |    30 |   518 |
+-------------+-------+-------+
1 row in set (0.000 sec)
```

##### **18.6 数据库的备份及恢复**

前文提到，本书的技术主线是Linux系统的运维方向，不会对数据库管理系统的操作进行深入的讲解，因此大家掌握了上面这些基本的数据库操作命令之后就足够了。下面要讲解的是数据库的备份以及恢复，这些知识比较实用，希望大家能够掌握。

mysqldump命令用于备份数据库数据，格式为“mysqldump [参数]  [数据库名称]”。其中参数与mysql命令大致相同，-u参数用于定义登录数据库的用户名称，-p参数表示密码提示符。下面将linuxprobe数据库中的内容导出为一个文件，并保存到root管理员的家目录中：

```
[root@linuxprobe ~]# mysqldump -u root -p linuxprobe > /root/linuxprobeDB.dump
Enter password: 输入管理员的数据库密码
```

然后进入MariaDB数据库管理系统，彻底删除linuxprobe数据库，这样mybook数据表单也将被彻底删除。然后重新建立linuxprobe数据库：

```
[root@linuxprobe ~]# mysql -u root -p
Enter password: 输入管理员的数据库密码

MariaDB [(none)]> DROP DATABASE linuxprobe;
Query OK, 1 row affected (0.04 sec)

MariaDB [(none)]> SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.02 sec)

MariaDB [(none)]> CREATE DATABASE linuxprobe;
Query OK, 1 row affected (0.00 sec)
```

接下来是见证数据恢复效果的时刻！使用输入重定向符把刚刚备份的数据库文件导入到mysql命令中，然后执行该命令。接下来登录MariaDB数据库，就又能看到linuxprobe数据库以及mybook数据表单了。数据库恢复成功！

```
[root@linuxprobe ~]# mysql -u root -p linuxprobe < /root/linuxprobeDB.dump 
Enter password: 输入管理员的数据库密码
[root@linuxprobe ~]# mysql -u root -p
Enter password: 输入管理员的数据库密码
MariaDB [(none)]> use linuxprobe;
Database changed

MariaDB [linuxprobe]> SHOW tables;
+----------------------+
| Tables_in_linuxprobe |
+----------------------+
| mybook               |
+----------------------+
1 row in set (0.000 sec)

MariaDB [linuxprobe]> describe mybook;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(15) | YES  |     | NULL    |       |
| price | int(11)  | YES  |     | NULL    |       |
| pages | int(11)  | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.002 sec)
```



2．初始化MariaDB或MySQL数据库管理系统的命令是什么？

**答：**是mysql_secure_installation命令，建议每次安装MariaDB或MySQL数据库管理系统后都执行这条命令。

3．用来查看已有数据库或数据表单的命令是什么？

**答：**要查看当前已有的数据库列表，需执行SHOW databases;命令；要查看已有的数据表单列表，则需执行SHOW tables;命令。

4．切换至某个指定数据库的命令是什么？

**答：**执行“use数据库名称”命令即可切换成功。

5．若想针对某个用户进行授权或取消授权操作，应该执行什么命令？

**答：**针对用户进行授权，需执行GRANT命令；取消授权则需执行REVOKE命令。

6．若只想查看mybook表单中的name字段，应该执行什么命令？

**答：**应执行SELECT name FROM mybook命令。

7．若只想查看mybook表单中价格大于75元的图书信息，应该执行什么命令？

**答：**应执行SELECT * FROM mybook WHERE price>75命令。

8． 要想把linuxprobe数据库中的内容导出为一个文件（保存到root管理员的家目录中），应该执行什么命令？

**答：**应执行mysqldump -u root -p linuxprobe > /root/linuxprobeDB.dump命令。

