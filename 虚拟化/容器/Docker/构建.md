# 使用 Docker 构建

Welcome! This guide is an introduction and deep-dive into building software with Docker.
欢迎！本指南是对使用 Docker 构建软件的介绍和深入探讨。

Whether you’re just getting started, or you’re already an advanced Docker user, this guide aims to provide useful pointers into the possibilities and best practices of Docker's build features.
无论您是刚入门，还是已经是 Docker 的高级用户，本指南都旨在提供有用的指针，了解 Docker 构建功能的可能性和最佳实践。

Topics covered in this guide include:
本指南涵盖的主题包括：

- Introduction to build concepts
  构建概念简介
- Image size optimization 图像尺寸优化
- Build speed performance improvements
  构建速度性能改进
- Building and exporting binaries
  构建和导出二进制文件
- Cache mounts and bind mounts
  缓存挂载和绑定挂载
- Software testing 软件测试
- Multi-platform builds 多平台构建

Throughout this guide, an example application written in Go is used to illustrate how the build features work. You don’t need to know the Go programming language to follow this guide.
在本指南中，我们将使用一个用 Go 编写的示例应用程序来说明构建功能的工作原理。您无需了解 Go 编程语言即可遵循本指南。

The guide starts off with a simple Dockerfile example, and builds from there. Some of the later sections in this guide describe advanced concepts and workflows. You don't need to complete this entire guide from start to finish. Follow the sections that seem relevant to you, and save the advanced sections at the end for later, when you need them.
本指南从一个简单的 Dockerfile 示例开始，然后从那里构建。本指南后面的一些部分介绍了高级概念和工作流。您无需从头到尾完成整个指南。按照看起来与您相关的部分进行操作，并在末尾保存高级部分，以备以后需要时使用。

[Get started 开始使用](https://docs.docker.com/build/guide/intro/)



[Edit this page 编辑本页](https://github.com/docker/docs/edit/main/content/build/guide/_index.md)

# Introduction 介绍

The starting resources for this guide include a simple Go project and a Dockerfile. From this starting point, the guide illustrates various ways that you can improve how you build the application with Docker.
本指南的起始资源包括一个简单的 Go 项目和 Dockerfile。从这个起点出发，本指南演示了各种方法，您可以改进使用 Docker 构建应用程序的方式。

## [Environment setup 环境设置](https://docs.docker.com/build/guide/intro/#environment-setup)

To follow this guide: 要遵循本指南，请执行以下操作：

1. Install [Docker Desktop or Docker Engine](https://docs.docker.com/get-docker/)
   安装 Docker Desktop 或 Docker Engine
2. Clone or create a new repository from the [application example on GitHub](https://github.com/dockersamples/buildme)

1. 
   从 GitHub 上的应用程序示例克隆或创建新存储库

## [The application 应用程序](https://docs.docker.com/build/guide/intro/#the-application)

The example project for this guide is a client-server application for translating messages to a fictional language.
本指南的示例项目是一个客户端-服务器应用程序，用于将消息翻译成虚构语言。

Here’s an overview of the files included in the project:
以下是项目中包含的文件的概述：

```text
.
├── Dockerfile
├── cmd
│   ├── client
│   │   ├── main.go
│   │   ├── request.go
│   │   └── ui.go
│   └── server
│       ├── main.go
│       └── translate.go
├── go.mod
└── go.sum
```

The `cmd/` directory contains the code for the two application components: client and server. The client is a user interface for writing, sending, and receiving messages. The server receives messages from clients, translates them, and sends them back to the client.
该 `cmd/` 目录包含两个应用程序组件的代码：客户端和服务器。客户端是用于编写、发送和接收消息的用户界面。服务器从客户端接收消息，翻译它们，然后将它们发送回客户端。

## [The Dockerfile](https://docs.docker.com/build/guide/intro/#the-dockerfile)

A Dockerfile is a text document in which you define the build steps for your application. You write the Dockerfile in a domain-specific language, called the Dockerfile syntax.
Dockerfile 是一个文本文档，您可以在其中定义应用程序的构建步骤。使用特定于域的语言编写 Dockerfile，称为 Dockerfile 语法。

Here's the Dockerfile used as the starting point for this guide:
下面是用作本指南起点的 Dockerfile：Here's the Dockerfile used as the starting point for this guide：

```dockerfile
# syntax=docker/dockerfile:1
FROM golang:1.21-alpine
WORKDIR /src
COPY . .
RUN go mod download
RUN go build -o /bin/client ./cmd/client
RUN go build -o /bin/server ./cmd/server
ENTRYPOINT [ "/bin/server" ]
```

Here’s what this Dockerfile does:
以下是此 Dockerfile 的作用：

1. `# syntax=docker/dockerfile:1`

   This comment is a [Dockerfile parser directive](https://docs.docker.com/reference/dockerfile/#parser-directives). It specifies which version of the Dockerfile syntax to use. This file uses the `dockerfile:1` syntax which is best practice: it ensures that you have access to the latest Docker build features.
   此注释是 Dockerfile 解析器指令。它指定要使用的 Dockerfile 语法版本。此文件使用最佳实践的 `dockerfile:1` 语法：它确保您有权访问最新的 Docker 构建功能。

2. `FROM golang:1.21-alpine`

   The `FROM` instruction uses version `1.21-alpine` of the `golang` official image.
   该 `FROM` 指令使用 `golang` 官方图像的版本 `1.21-alpine` 。

3. `WORKDIR /src`

   Creates the `/src` working directory inside the container.
   在容器内创建 `/src` 工作目录。

4. `COPY . .`

   Copies the files in the build context to the working directory in the container.
   将生成上下文中的文件复制到容器中的工作目录。

5. `RUN go mod download`

   Downloads the necessary Go modules to the container. Go modules is the dependency management tool for the Go programming language, similar to `npm install` for JavaScript, or `pip install` for Python.
   将必要的 Go 模块下载到容器中。Go modules 是 Go 编程语言的依赖项管理工具，类似于 `npm install` JavaScript 或 `pip install` Python。

6. `RUN go build -o /bin/client ./cmd/client`

   Builds the `client` binary, which is used to send messages to be translated, into the `/bin` directory.
   将 `client` 二进制文件（用于发送要翻译的消息）构建到 `/bin` 目录中。

7. `RUN go build -o /bin/server ./cmd/server`

   Builds the `server` binary, which listens for client translation requests, into the `/bin` directory.
   将侦听客户端翻译请求的 `server` 二进制文件构建到 `/bin` 目录中。

8. `ENTRYPOINT [ "/bin/server" ]`

   Specifies a command to run when the container starts. Starts the server process.
   指定容器启动时要运行的命令。启动服务器进程。

## [Build the image 构建映像](https://docs.docker.com/build/guide/intro/#build-the-image)

To build an image using a Dockerfile, you use the `docker` command-line tool. The command for building an image is `docker build`.
要使用 Dockerfile 构建映像，请使用 `docker` 命令行工具。用于构建映像的命令是 `docker build` 。

Run the following command to build the image.
运行以下命令以构建映像。



```console
 docker build --tag=buildme .
```

This creates an image with the tag `buildme`. An image tag is the name of the image.
这将创建一个带有标签 `buildme` 的图像。图像标签是图像的名称。

## [Run the container 运行容器](https://docs.docker.com/build/guide/intro/#run-the-container)

The image you just built contains two binaries, one for the server and one for the client. To see the translation service in action, run a container that hosts the server component, and then run another container that invokes the client.
您刚刚构建的映像包含两个二进制文件，一个用于服务器，另一个用于客户端。若要查看翻译服务的运行情况，请运行托管服务器组件的容器，然后运行另一个调用客户端的容器。

To run a container, you use the `docker run` command.
要运行容器，请使用以下 `docker run` 命令。

1. Run a container from the image in detached mode.
   在分离模式下从映像运行容器。

```console
 docker run --name=buildme --rm --detach buildme
```

This starts a container named `buildme`.
这将启动一个名为 `buildme` 的容器。

Run a new command in the `buildme` container that invokes the client binary.
在 `buildme` 容器中运行一个新命令，以调用客户端二进制文件。



1. ```console
    docker exec -it buildme /bin/client
   ```

The `docker exec` command opens a terminal user interface where you can submit messages for the backend (server) process to translate.
该 `docker exec` 命令将打开一个终端用户界面，您可以在其中提交消息以供后端（服务器）进程进行翻译。

When you're done testing, you can stop the container:
完成测试后，可以停止容器：



```console
 docker stop buildme
```

## [Summary 总结](https://docs.docker.com/build/guide/intro/#summary)

This section gave you an overview of the example application used in this guide, an introduction to Dockerfiles and building. You've successfully built a container image and created a container from it.
本部分概述了本指南中使用的示例应用程序，并介绍了 Dockerfiles 和构建。您已成功生成容器映像，并从中创建了容器。

Related information: 相关信息：

- [Dockerfile reference Dockerfile 参考](https://docs.docker.com/reference/dockerfile/)
- [`docker build` CLI reference `docker build` CLI 参考](https://docs.docker.com/reference/cli/docker/buildx/build/)
- [`docker run` CLI reference `docker run` CLI 参考](https://docs.docker.com/reference/cli/docker/container/run/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/intro/#next-steps)

The next section explores how you can use layer cache to improve build speed.
下一节将探讨如何使用图层缓存来提高构建速度。

[Layers 层](https://docs.docker.com/build/guide/layers/)

# Layers 层

The order of Dockerfile instructions matters. A Docker build consists of a series of ordered build instructions. Each instruction in a Dockerfile roughly translates to an image layer. The following diagram illustrates how a Dockerfile translates into a stack of layers in a container image.
Dockerfile 指令的顺序很重要。Docker 构建由一系列有序的构建指令组成。Dockerfile 中的每条指令大致转换为一个图像层。下图演示了 Dockerfile 如何转换为容器映像中的层堆栈。

![From Dockerfile to layers](https://docs.docker.com/build/guide/images/layers.png)

## [Cached layers 缓存图层](https://docs.docker.com/build/guide/layers/#cached-layers)

When you run a build, the builder attempts to reuse layers from earlier builds. If a layer of an image is unchanged, then the builder picks it up from the build cache. If a layer has changed since the last build, that layer, and all layers that follow, must be rebuilt.
当您运行构建时，构建器会尝试重用早期构建中的层。如果图像的图层未更改，则构建器将从构建缓存中选取它。如果某个层自上次构建以来发生更改，则必须重新构建该层以及随后的所有层。

The Dockerfile from the previous section copies all project files to the container (`COPY . .`) and then downloads application dependencies in the following step (`RUN go mod download`). If you were to change any of the project files, then that would invalidate the cache for the `COPY` layer. It also invalidates the cache for all of the layers that follow.
上一部分中的 Dockerfile 将所有项目文件复制到容器 （ `COPY . .` ），然后在下一步 （ ） 中下载应用程序依赖项 `RUN go mod download` 。如果要更改任何工程文件，则会使 `COPY` 图层的缓存失效。它还会使后续所有图层的缓存失效。

![Layer cache is bust](https://docs.docker.com/build/guide/images/cache-bust.png)

Because of the current order of the Dockerfile instructions, the builder must download the Go modules again, despite none of the packages having changed since the last time.
由于 Dockerfile 指令的当前顺序，构建器必须再次下载 Go 模块，尽管自上次以来没有任何包更改。

## [Update the instruction order 更新指示顺序](https://docs.docker.com/build/guide/layers/#update-the-instruction-order)

You can avoid this redundancy by reordering the instructions in the Dockerfile. Change the order of the instructions so that downloading and installing dependencies occur before the source code is copied over to the container. In that way, the builder can reuse the "dependencies" layer from the cache, even when you make changes to your source code.
您可以通过对 Dockerfile 中的指令重新排序来避免这种冗余。更改说明的顺序，以便在将源代码复制到容器之前下载和安装依赖项。这样，即使您对源代码进行了更改，构建器也可以重用缓存中的“依赖项”层。

Go uses two files, called `go.mod` and `go.sum`, to track dependencies for a project. These files are to Go, what `package.json` and `package-lock.json` are to JavaScript. For Go to know which dependencies to download, you need to copy the `go.mod` and `go.sum` files to the container. Add another `COPY` instruction before `RUN go mod download`, this time copying only the `go.mod` and `go.sum` files.
Go 使用两个名为 `go.mod` 和 `go.sum` 的文件来跟踪项目的依赖项。这些文件是 Go、what `package.json` 和 `package-lock.json` JavaScript。为了让 Go 知道要下载哪些依赖项，您需要将 `go.mod` and `go.sum` 文件复制到容器中。在 之前添加另一 `COPY` 条指令，这次只复制 `go.mod` 和 `go.sum` `RUN go mod download` 文件。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine
  WORKDIR /src
- COPY . .
+ COPY go.mod go.sum .
  RUN go mod download
+ COPY . .
  RUN go build -o /bin/client ./cmd/client
  RUN go build -o /bin/server ./cmd/server
  ENTRYPOINT [ "/bin/server" ]
```

Now if you edit your source code, building the image won't cause the builder to download the dependencies each time. The `COPY . .` instruction appears after the package management instructions, so the builder can reuse the `RUN go mod download` layer.
现在，如果您编辑源代码，构建图像不会导致构建器每次都下载依赖项。该 `COPY . .` 指令显示在包管理指令之后，因此构建器可以重用该 `RUN go mod download` 层。

![Reordered](https://docs.docker.com/build/guide/images/reordered-layers.png)

## [Summary 总结](https://docs.docker.com/build/guide/layers/#summary)

Ordering your Dockerfile instructions appropriately helps you avoid unnecessary work at build time.
适当地对 Dockerfile 指令进行排序有助于避免在生成时进行不必要的工作。

Related information: 相关信息：

- [Docker build cache Docker 构建缓存](https://docs.docker.com/build/cache/)
- [Dockerfile best practices
  Dockerfile 最佳实践](https://docs.docker.com/build/building/best-practices/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/layers/#next-steps)

The next section shows how you can make the build run faster, and make the resulting output smaller, using multi-stage builds.
下一部分将介绍如何使用多阶段生成来加快生成运行速度，并使生成的输出更小。

# Multi-stage 多级

This section explores multi-stage builds. There are two main reasons for why you’d want to use multi-stage builds:
本部分探讨多阶段生成。想要使用多阶段构建的原因有两个主要：There are two main reasons for why you'd want to use multi-stage builds：

- They allow you to run build steps in parallel, making your build pipeline faster and more efficient.
  它们允许您并行运行构建步骤，从而使您的构建管道更快、更高效。
- They allow you to create a final image with a smaller footprint, containing only what's needed to run your program.
  它们允许您创建占用空间更小的最终图像，仅包含运行程序所需的内容。

In a Dockerfile, a build stage is represented by a `FROM` instruction. The Dockerfile from the previous section doesn’t leverage multi-stage builds. It’s all one build stage. That means that the final image is bloated with resources used to compile the program.
在 Dockerfile 中，构建阶段由指令 `FROM` 表示。上一部分的 Dockerfile 不利用多阶段构建。这都是一个构建阶段。这意味着最终图像中充满了用于编译程序的资源。

```console
 docker build --tag=buildme .
 docker images buildme
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
buildme      latest    c021c8a7051f   5 seconds ago   150MB
```

The program compiles to executable binaries, so you don’t need Go language utilities to exist in the final image.
该程序编译为可执行二进制文件，因此您不需要在最终图像中存在 Go 语言实用程序。

## [Add stages 添加阶段](https://docs.docker.com/build/guide/multi-stage/#add-stages)

Using multi-stage builds, you can choose to use different base images for your build and runtime environments. You can copy build artifacts from the build stage over to the runtime stage.
使用多阶段构建，您可以选择为构建和运行时环境使用不同的基础映像。您可以将构建项目从构建阶段复制到运行时阶段。

Modify the Dockerfile as follows. This change creates another stage using a minimal `scratch` image as a base. In the final `scratch` stage, the binaries built in the previous stage are copied over to the filesystem of the new stage.
按如下方式修改 Dockerfile。此更改使用最小 `scratch` 图像作为基础创建另一个阶段。在最后 `scratch` 阶段，在上一阶段构建的二进制文件将被复制到新阶段的文件系统中。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine
  WORKDIR /src
  COPY go.mod go.sum .
  RUN go mod download
  COPY . .
  RUN go build -o /bin/client ./cmd/client
  RUN go build -o /bin/server ./cmd/server
+
+ FROM scratch
+ COPY --from=0 /bin/client /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Now if you build the image and inspect it, you should see a significantly smaller number:
现在，如果生成映像并进行检查，应会看到一个明显较小的数字：

```console
 docker build --tag=buildme .
 docker images buildme
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
buildme      latest    436032454dd8   7 seconds ago   8.45MB
```

The image went from 150MB to only just 8.45MB in size. That’s because the resulting image only contains the binaries, and nothing else.
图像的大小从 150MB 增加到只有 8.45MB。这是因为生成的图像仅包含二进制文件，而不包含其他任何内容。

## [Parallelism 排比](https://docs.docker.com/build/guide/multi-stage/#parallelism)

You've reduced the footprint of the image. The following step shows how you can improve build speed with multi-stage builds, using parallelism. The build currently produces the binaries one after the other. There is no reason why you need to build the client before building the server, or vice versa.
您已经减少了图像的占用空间。以下步骤演示如何使用并行性通过多阶段生成提高生成速度。该版本当前会一个接一个地生成二进制文件。没有理由需要在构建服务器之前构建客户端，反之亦然。

You can split the binary-building steps into separate stages. In the final `scratch` stage, copy the binaries from each corresponding build stage. By segmenting these builds into separate stages, Docker can run them in parallel.
您可以将二进制构建步骤拆分为多个单独的阶段。在最后 `scratch` 阶段，从每个相应的生成阶段复制二进制文件。通过将这些构建划分为单独的阶段，Docker 可以并行运行它们。

The stages for building each binary both require the Go compilation tools and application dependencies. Define these common steps as a reusable base stage. You can do that by assigning a name to the stage using the pattern `FROM image AS stage_name`. This allows you to reference the stage name in a `FROM` instruction of another stage (`FROM stage_name`).
构建每个二进制文件的阶段都需要 Go 编译工具和应用程序依赖项。将这些常见步骤定义为可重用的基础阶段。您可以通过使用 pattern `FROM image AS stage_name` 为舞台分配名称来执行此操作。这允许您在另一个阶段 （ `FROM stage_name` ） 的 `FROM` 指令中引用阶段名称。

You can also assign a name to the binary-building stages, and reference the stage name in the `COPY --from=stage_name` instruction when copying the binaries to the final `scratch` image.
您还可以为二进制文件构建阶段分配名称，并在将二进制文件复制到最终 `scratch` 映像时在指令中 `COPY --from=stage_name` 引用阶段名称。



```diff
  # syntax=docker/dockerfile:1
- FROM golang:1.21-alpine
+ FROM golang:1.21-alpine AS base
  WORKDIR /src
  COPY go.mod go.sum .
  RUN go mod download
  COPY . .
+
+ FROM base AS build-client
  RUN go build -o /bin/client ./cmd/client
+
+ FROM base AS build-server
  RUN go build -o /bin/server ./cmd/server

  FROM scratch
- COPY --from=0 /bin/client /bin/server /bin/
+ COPY --from=build-client /bin/client /bin/
+ COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Now, instead of first building the binaries one after the other, the `build-client` and `build-server` stages are executed simultaneously.
现在，不是先一个接一个地构建二进制文件，而是同时执行 `build-client` 和 `build-server` 阶段。

![Stages executing in parallel](https://docs.docker.com/build/guide/images/parallelism.gif)

## [Build targets 构建目标](https://docs.docker.com/build/guide/multi-stage/#build-targets)

The final image is now small, and you’re building it efficiently using parallelism. But this image is slightly strange, in that it contains both the client and the server binary in the same image. Shouldn’t these be two different images?
现在，最终的图像很小，您可以使用并行性有效地构建它。但是这个图像有点奇怪，因为它在同一图像中同时包含客户端和服务器二进制文件。这不应该是两个不同的图像吗？

It’s possible to create multiple different images using a single Dockerfile. You can specify a target stage of a build using the `--target` flag. Replace the unnamed `FROM scratch` stage with two separate stages named `client` and `server`.
可以使用单个 Dockerfile 创建多个不同的映像。您可以使用标志 `--target` 指定生成的目标阶段。将未命名 `FROM scratch` 的阶段替换为名为 `client` 和 `server` 的两个独立阶段。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
  COPY go.mod go.sum .
  RUN go mod download
  COPY . .

  FROM base AS build-client
  RUN go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN go build -o /bin/server ./cmd/server

- FROM scratch
- COPY --from=build-client /bin/client /bin/
- COPY --from=build-server /bin/server /bin/
- ENTRYPOINT [ "/bin/server" ]

+ FROM scratch AS client
+ COPY --from=build-client /bin/client /bin/
+ ENTRYPOINT [ "/bin/client" ]

+ FROM scratch AS server
+ COPY --from=build-server /bin/server /bin/
+ ENTRYPOINT [ "/bin/server" ]
```

And now you can build the client and server programs as separate Docker images (tags):
现在，您可以将客户端和服务器程序构建为单独的 Docker 镜像（标签）：

```console
 docker build --tag=buildme-client --target=client .
 docker build --tag=buildme-server --target=server .
 docker images "buildme*" 
REPOSITORY       TAG       IMAGE ID       CREATED          SIZE
buildme-client   latest    659105f8e6d7   20 seconds ago   4.25MB
buildme-server   latest    666d492d9f13   5 seconds ago    4.2MB
```

The images are now even smaller, about 4 MB each.
现在，这些图像甚至更小，每个图像约为 4 MB。

This change also avoids having to build both binaries each time. When selecting to build the `client` target, Docker only builds the stages leading up to that target. The `build-server` and `server` stages are skipped if they’re not needed. Likewise, building the `server` target skips the `build-client` and `client` stages.
此更改还避免了每次都必须构建两个二进制文件。在选择构建 `client` 目标时，Docker 仅构建导致该目标的阶段。如果不需要 `build-server` and `server` 阶段，则跳过它们。同样，构建 `server` 目标会跳过 `build-client` and `client` 阶段。

## [Summary 总结](https://docs.docker.com/build/guide/multi-stage/#summary)

Multi-stage builds are useful for creating images with less bloat and a smaller footprint, and also helps to make builds run faster.
多阶段生成对于创建体积较小且占用空间较小的映像非常有用，并且还有助于提高生成运行速度。

Related information: 相关信息：

- [Multi-stage builds 多阶段构建](https://docs.docker.com/build/building/multi-stage/)
- [Base images 基础图像](https://docs.docker.com/build/building/base-images/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/multi-stage/#next-steps)

The next section describes how you can use file mounts to further improve build speeds.
下一节将介绍如何使用文件挂载来进一步提高构建速度。

# Mounts 坐骑

This section describes how to use cache mounts and bind mounts with Docker builds.
本节介绍如何在 Docker 构建中使用缓存挂载和绑定挂载。

Cache mounts let you specify a persistent package cache to be used during builds. The persistent cache helps speed up build steps, especially steps that involve installing packages using a package manager. Having a persistent cache for packages means that even if you rebuild a layer, you only download new or changed packages.
通过缓存挂载，您可以指定在构建期间使用的持久性包缓存。持久性缓存有助于加快构建步骤，尤其是涉及使用包管理器安装包的步骤。拥有包的持久缓存意味着，即使您重建了层，也只需下载新的或更改的包。

Cache mounts are created using the `--mount` flag together with the `RUN` instruction in the Dockerfile. To use a cache mount, the format for the flag is `--mount=type=cache,target=<path>`, where `<path>` is the location of the cache directory that you wish to mount into the container.
缓存挂载是使用该 `--mount` 标志和 Dockerfile 中的 `RUN` 指令创建的。要使用缓存挂载，标志的格式为 `--mount=type=cache,target=<path>` ，其中 `<path>` 是您希望挂载到容器中的缓存目录的位置。

## [Add a cache mount 添加缓存挂载](https://docs.docker.com/build/guide/mounts/#add-a-cache-mount)

The target path to use for the cache mount depends on the package manager you’re using. The application example in this guide uses Go modules. That means that the target directory for the cache mount is the directory where the Go module cache gets written to. According to the [Go modules reference](https://go.dev/ref/mod#module-cache)

, the default location for the module cache is `$GOPATH/pkg/mod`, and the default value for `$GOPATH` is `/go`.
用于缓存装载的目标路径取决于您正在使用的包管理器。本指南中的应用程序示例使用 Go 模块。这意味着缓存挂载的目标目录是写入 Go 模块缓存的目录。根据 Go 模块参考，模块缓存的默认位置是 `$GOPATH/pkg/mod` ，而 的 `$GOPATH` 默认值是 `/go` 。

Update the build steps for downloading packages and compiling the program to mount the `/go/pkg/mod` directory as a cache mount:
更新下载包和编译程序的构建步骤，以将 `/go/pkg/mod` 目录挂载为缓存挂载：

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
  COPY go.mod go.sum .
- RUN go mod download
+ RUN --mount=type=cache,target=/go/pkg/mod/ \
+     go mod download -x
  COPY . .

  FROM base AS build-client
- RUN go build -o /bin/client ./cmd/client
+ RUN --mount=type=cache,target=/go/pkg/mod/ \
+     go build -o /bin/client ./cmd/client

  FROM base AS build-server
- RUN go build -o /bin/server ./cmd/server
+ RUN --mount=type=cache,target=/go/pkg/mod/ \
+     go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

The `-x` flag added to the `go mod download` command prints the download executions that take place. Adding this flag lets you see how the cache mount is being used in the next step.
添加到命令中 `-x`  `go mod download` 的标志将打印发生的下载执行。通过添加此标志，您可以查看下一步中如何使用缓存装载。

## [Rebuild the image 重建映像](https://docs.docker.com/build/guide/mounts/#rebuild-the-image)

Before you rebuild the image, clear your build cache. This ensures that you're starting from a clean slate, making it easier to see exactly what the build is doing.
在重新生成映像之前，请清除生成缓存。这可确保您从头开始，从而更容易准确地看到构建正在执行的操作。



```console
 docker builder prune -af
```

Now it’s time to rebuild the image. Invoke the build command, this time together with the `--progress=plain` flag, while also redirecting the output to a log file.
现在是时候重建映像了。调用 build 命令，这次与 `--progress=plain` 标志一起调用，同时将输出重定向到日志文件。

```console
 docker build --target=client --progress=plain . 2> log1.txt
```

When the build has finished, inspect the `log1.txt` file. The logs show how the Go modules were downloaded as part of the build.
生成完成后，检查 `log1.txt` 文件。日志显示了如何在构建过程中下载 Go 模块。

```console
 awk '/proxy.golang.org/' log1.txt
11 0.168 # get https://proxy.golang.org/github.com/charmbracelet/lipgloss/@v/v0.6.0.mod
11 0.168 # get https://proxy.golang.org/github.com/aymanbagabas/go-osc52/@v/v1.0.3.mod
11 0.168 # get https://proxy.golang.org/github.com/atotto/clipboard/@v/v0.1.4.mod
11 0.168 # get https://proxy.golang.org/github.com/charmbracelet/bubbletea/@v/v0.23.1.mod
11 0.169 # get https://proxy.golang.org/github.com/charmbracelet/bubbles/@v/v0.14.0.mod
11 0.218 # get https://proxy.golang.org/github.com/charmbracelet/bubbles/@v/v0.14.0.mod: 200 OK (0.049s)
11 0.218 # get https://proxy.golang.org/github.com/aymanbagabas/go-osc52/@v/v1.0.3.mod: 200 OK (0.049s)
11 0.218 # get https://proxy.golang.org/github.com/containerd/console/@v/v1.0.3.mod
11 0.218 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.0.mod
11 0.219 # get https://proxy.golang.org/github.com/charmbracelet/bubbletea/@v/v0.23.1.mod: 200 OK (0.050s)
11 0.219 # get https://proxy.golang.org/github.com/atotto/clipboard/@v/v0.1.4.mod: 200 OK (0.051s)
11 0.219 # get https://proxy.golang.org/github.com/charmbracelet/lipgloss/@v/v0.6.0.mod: 200 OK (0.051s)
...
```

Now, in order to see that the cache mount is being used, change the version of one of the Go modules that your program imports. By changing the module version, you're forcing Go to download the new version of the dependency the next time you build. If you weren’t using cache mounts, your system would re-download all modules. But because you've added a cache mount, Go can reuse most of the modules and only download the package versions that doesn't already exist in the `/go/pkg/mod` directory.
现在，为了查看正在使用缓存挂载，请更改程序导入的其中一个 Go 模块的版本。通过更改模块版本，您将强制 Go  在下次构建时下载依赖项的新版本。如果您没有使用缓存挂载，您的系统将重新下载所有模块。但是，由于您添加了缓存挂载，因此 Go  可以重用大部分模块，并且只下载目录中尚不存在的 `/go/pkg/mod` 包版本。

Update the version of the `chi` package that the server component of the application uses:
更新应用程序的服务器组件使用的 `chi` 包版本：



```console
 docker run -v $PWD:$PWD -w $PWD golang:1.21-alpine \
    go get github.com/go-chi/chi/v5@v5.0.8
```

Now, run another build, and again redirect the build logs to a log file:
现在，运行另一个生成，并再次将生成日志重定向到日志文件：



```console
 docker build --target=client --progress=plain . 2> log2.txt
```

Now if you inspect the `log2.txt` file, you’ll find that only the `chi` package that was changed has been downloaded:
现在，如果您检查该文件 `log2.txt` ，您会发现只有已更改的 `chi` 包已被下载：

```console
 awk '/proxy.golang.org/' log2.txt
10 0.143 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.mod
10 0.190 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.mod: 200 OK (0.047s)
10 0.190 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.info
10 0.199 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.info: 200 OK (0.008s)
10 0.201 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.zip
10 0.209 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.zip: 200 OK (0.008s)
```

## [Add bind mounts 添加绑定挂载](https://docs.docker.com/build/guide/mounts/#add-bind-mounts)

There are a few more small optimizations that you can implement to improve the Dockerfile. Currently, it's using the `COPY` instruction to pull in the `go.mod` and `go.sum` files before downloading modules. Instead of copying those files over to the container’s filesystem, you can use a bind mount. A bind mount makes the files available to the container directly from the host. This change removes the need for the additional `COPY` instruction (and layer) entirely.
您可以实施一些小的优化来改进 Dockerfile。目前，它正在使用指令 `COPY` 在下载模块之前拉入 `go.mod` and `go.sum` 文件。您可以使用绑定挂载，而不是将这些文件复制到容器的文件系统中。绑定挂载使文件可直接从主机提供给容器。此更改完全消除了对额外 `COPY` 指令（和层）的需求。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
- COPY go.mod go.sum .
  RUN --mount=type=cache,target=/go/pkg/mod/ \
+     --mount=type=bind,source=go.sum,target=go.sum \
+     --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x
  COPY . .

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Similarly, you can use the same technique to remove the need for the second `COPY` instruction as well. Specify bind mounts in the `build-client` and `build-server` stages for mounting the current working directory.
同样，您也可以使用相同的技术来消除对第二 `COPY` 条指令的需求。在 `build-client` 和 `build-server` 阶段中指定绑定挂载，以挂载当前工作目录。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x
- COPY . .

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
+     --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN --mount=type=cache,target=/go/pkg/mod/ \
+     --mount=type=bind,target=. \
      go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

## [Summary 总结](https://docs.docker.com/build/guide/mounts/#summary)

This section has shown how you can improve your build speed using cache and bind mounts.
本部分介绍了如何使用缓存和绑定挂载来提高构建速度。

Related information: 相关信息：

- [Dockerfile reference Dockerfile 参考](https://docs.docker.com/reference/dockerfile/#run---mount)
- [Bind mounts 绑定挂载](https://docs.docker.com/storage/bind-mounts/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/mounts/#next-steps)

The next section of this guide is an introduction to making your builds configurable, using build arguments.
本指南的下一部分将介绍如何使用构建参数使构建可配置。

[Build arguments 构建参数](https://docs.docker.com/build/guide/build-args/)

# Build arguments 构建参数

Build arguments is a great way to add flexibility to your builds. You can pass build arguments at build-time, and you can set a default value that the builder uses as a fallback.
构建参数是增加构建灵活性的好方法。您可以在构建时传递构建参数，并且可以设置构建器用作回退的默认值。

## [Change runtime versions 更改运行时版本](https://docs.docker.com/build/guide/build-args/#change-runtime-versions)

A practical use case for build arguments is to specify runtime versions for build stages. Your image uses the `golang:1.21-alpine` image as a base image. But what if someone wanted to use a different version of Go for building the application? They could update the version number inside the Dockerfile, but that’s inconvenient, it makes switching between versions more tedious than it has to be. Build arguments make life easier:
构建参数的一个实际用例是指定构建阶段的运行时版本。您的映像使用该 `golang:1.21-alpine` 映像作为基础映像。但是，如果有人想使用不同版本的 Go 来构建应用程序怎么办？他们可以更新 Dockerfile 内的版本号，但这很不方便，它使得在版本之间切换比必须的更繁琐。构建参数让生活更轻松：

```diff
  # syntax=docker/dockerfile:1
- FROM golang:1.21-alpine AS base
+ ARG GO_VERSION=1.21
+ FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

The `ARG` keyword is interpolated in the image name in the `FROM` instruction. The default value of the `GO_VERSION` build argument is set to `1.21`. If the build doesn't receive a `GO_VERSION` build argument, the `FROM` instruction resolves to `golang:1.21-alpine`.
 `ARG` 关键字在 `FROM` 指令中的图像名称中插入。 `GO_VERSION` build 参数的默认值设置为 `1.21` 。如果构建未收到 `GO_VERSION` 构建参数，则指令 `FROM` 将解析为 `golang:1.21-alpine` 。

Try setting a different version of Go to use for building, using the `--build-arg` flag for the build command:
尝试设置一个不同版本的 Go 用于构建，使用 build 命令的标志 `--build-arg` ：

```console
 docker build --build-arg="GO_VERSION=1.19" .
```

Running this command results in a build using the `golang:1.19-alpine` image.
运行此命令将导致使用映像 `golang:1.19-alpine` 的生成。

## [Inject values 注入值](https://docs.docker.com/build/guide/build-args/#inject-values)

You can also make use of build arguments to modify values in the source code of your program, at build time. This is useful for dynamically injecting information, avoiding hard-coded values. With Go, consuming external values at build time is done using linker flags, or `-ldflags`.
您还可以在构建时使用构建参数来修改程序源代码中的值。这对于动态注入信息非常有用，可以避免硬编码的值。使用 Go 时，在构建时使用外部值是使用链接器标志或 `-ldflags` 来完成的。

The server part of the application contains a conditional statement to print the app version, if a version is specified:
如果指定了版本，则应用程序的服务器部分包含一个条件语句，用于打印应用程序版本：

```go
// cmd/server/main.go
var version string

func main() {
	if version != "" {
		log.Printf("Version: %s", version)
	}
```

You could declare the version string value directly in the code. But, updating the version to line up with the release version of the application would require updating the code ahead of every release. That would be both tedious and error-prone. A better solution is to pass the version string as a build argument, and inject the build argument into the code.
您可以直接在代码中声明版本字符串值。但是，更新版本以与应用程序的发布版本保持一致需要在每次发布之前更新代码。这将是既乏味又容易出错的。更好的解决方案是将版本字符串作为构建参数传递，并将构建参数注入到代码中。

The following example adds an `APP_VERSION` build argument to the `build-server` stage. The Go compiler uses the value of the build argument to set the value of a variable in the code.
以下示例将生成 `APP_VERSION` 参数添加到 `build-server` 舞台。Go 编译器使用 build 参数的值来设置代码中变量的值。

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
  FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
+ ARG APP_VERSION="v0.0.0+unknown"
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
-     go build -o /bin/server ./cmd/server
+     go build -ldflags "-X main.version=$APP_VERSION" -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Now the version of the server is injected when building the binary, without having to update the source code. To verify this, you can build the `server` target and start a container with `docker run`. The server outputs `v0.0.1` as the version on startup.
现在，在构建二进制文件时会注入服务器的版本，而无需更新源代码。要验证这一点，您可以使用 构建目标 `server` 并启动容器 `docker run` 。服务器在启动时 `v0.0.1` 输出为版本。

```console
 docker build --target=server --build-arg="APP_VERSION=v0.0.1" --tag=buildme-server .
 docker run buildme-server
2023/04/06 08:54:27 Version: v0.0.1
2023/04/06 08:54:27 Starting server...
2023/04/06 08:54:27 Listening on HTTP port 3000
```

## [Summary 总结](https://docs.docker.com/build/guide/build-args/#summary)

This section showed how you can use build arguments to make builds more configurable, and inject values at build-time.
本部分展示了如何使用构建参数来使构建更具可配置性，并在构建时注入值。

Related information: 相关信息：

- [`ARG` Dockerfile reference
   `ARG` Dockerfile 参考](https://docs.docker.com/reference/dockerfile/#arg)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/build-args/#next-steps)

The next section of this guide shows how you can use Docker builds to create not only container images, but executable binaries as well.
本指南的下一部分将介绍如何使用 Docker 构建来创建容器映像，以及创建可执行二进制文件。

# Export binaries 导出二进制文件

Did you know that you can use Docker to build your application to standalone binaries? Sometimes, you don’t want to package and distribute your application as a Docker image. Use Docker to build your application, and use exporters to save the output to disk.
您知道可以使用 Docker 将应用程序构建为独立的二进制文件吗？有时，您不希望将应用程序打包并分发为 Docker 映像。使用 Docker 构建应用程序，并使用导出器将输出保存到磁盘。

The default output format for `docker build` is a container image. That image is automatically loaded to your local image store, where you can run a container from that image, or push it to a registry. Under the hood, this uses the default exporter, called the `docker` exporter.
的 `docker build` 默认输出格式是容器图像。该映像会自动加载到本地映像存储中，您可以在其中从该映像运行容器，或将其推送到注册表。在后台，它使用默认导出器，称为 `docker` 导出器。

To export your build results as files instead, you can use the `local` exporter. The `local` exporter saves the filesystem of the build container to the specified directory on the host machine.
要将生成结果导出为文件，可以使用 `local` 导出器。 `local` 导出器将构建容器的文件系统保存到主机上的指定目录中。

## [Export binaries 导出二进制文件](https://docs.docker.com/build/guide/export/#export-binaries)

To use the `local` exporter, pass the `--output` option to the `docker build` command. The `--output` flag takes one argument: the destination on the host machine where you want to save the files.
要使用导出器， `local` 请将选项 `--output` 传递给 `docker build` 命令。该 `--output` 标志接受一个参数：主机上要保存文件的目标。

The following commands exports the files from of the `server` target to the current working directory on the host filesystem:
以下命令将 `server` 目标中的文件导出到主机文件系统上的当前工作目录：

```console
 docker build --output=. --target=server .
```

Running this command creates a binary at `./bin/server`. It’s created under the `bin/` directory because that’s where the file was located inside the build container.
运行此命令会在 处 `./bin/server` 创建一个二进制文件。它是在目录 `bin/` 下创建的，因为这是文件位于构建容器内的位置。

```console
 ls -l ./bin
total 14576
-rwxr-xr-x  1 user  user  7459368 Apr  6 09:27 server
```

If you want to create a build that exports both binaries, you can create another build stage in the Dockerfile that copies both of the binaries from each build stage:
如果要创建导出两个二进制文件的生成，可以在 Dockerfile 中创建另一个生成阶段，从每个生成阶段复制两个二进制文件：

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
  FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base as build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base as build-server
  ARG APP_VERSION="0.0.0+unknown"
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -ldflags "-X main.version=$APP_VERSION" -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
+
+ FROM scratch AS binaries
+ COPY --from=build-client /bin/client /
+ COPY --from=build-server /bin/server /
```

Now you can build the `binaries` target using the `--output` option to export both the client and server binaries.
现在，您可以使用导出客户端和服务器二进制文件的 `--output` 选项来构建 `binaries` 目标。

```console
 docker build --output=bin --target=binaries .
 ls -l ./bin
total 29392
-rwxr-xr-x  1 user  user  7581933 Apr  6 09:33 client
-rwxr-xr-x  1 user  user  7459368 Apr  6 09:33 server
```

## [Summary 总结](https://docs.docker.com/build/guide/export/#summary)

This section has demonstrated how you can use Docker to build and export standalone binaries. These binaries can be distributed freely, and don’t require a container runtime like the Docker daemon.
本部分演示了如何使用 Docker 来构建和导出独立二进制文件。这些二进制文件可以自由分发，并且不需要像 Docker 守护程序那样的容器运行时。

The binaries you've generated so far are Linux binaries. That's because the build environment is Linux. If your host OS is Linux, you can run these files. Building binaries that work on Mac or Windows machines requires cross-compilation. This is explored later on in this guide.
到目前为止，您生成的二进制文件是 Linux 二进制文件。那是因为构建环境是 Linux。如果您的主机操作系统是 Linux，则可以运行这些文件。构建在 Mac 或 Windows 计算机上运行的二进制文件需要交叉编译。本指南稍后将对此进行探讨。

Related information: 相关信息：

- [`docker build --output` CLI reference `docker build --output` CLI 参考](https://docs.docker.com/reference/cli/docker/buildx/build/#output)
- [Build exporters 建立导出器](https://docs.docker.com/build/exporters/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/export/#next-steps)

The next topic of this guide is testing: how you can use Docker to run application tests.
本指南的下一个主题是测试：如何使用 Docker 运行应用程序测试。

# Test 测试

This section focuses on testing. The example in this section focuses on linting, but the same principles apply for other kinds of tests as well, such as unit tests. Code linting is a static analysis of code that helps you detect errors, style violations, and anti-patterns.
本部分重点介绍测试。本节中的示例重点介绍 linting，但相同的原则也适用于其他类型的测试，例如单元测试。代码 linting 是对代码的静态分析，可帮助您检测错误、样式冲突和反模式。

The exact steps for how to test your code can vary a lot depending on the programming language or framework that you use. The example application used in this guide is written in Go. You will add a build step that uses `golangci-lint`, a popular linters runner for Go.
如何测试代码的确切步骤可能会有很大差异，具体取决于您使用的编程语言或框架。本指南中使用的示例应用程序是用 Go 编写的。您将添加一个使用 `golangci-lint` 的构建步骤，这是一个流行的 Go linters 运行器。

## [Run tests 运行测试](https://docs.docker.com/build/guide/test/#run-tests)

The `golangci-lint` tool is available as an image on Docker Hub. Before you add the lint step to the Dockerfile, you can try it out using a `docker run` command.
该 `golangci-lint` 工具在 Docker Hub 上以图像的形式提供。在将 lint 步骤添加到 Dockerfile 之前，可以使用 `docker run` 命令进行尝试。

```console
 docker run -v $PWD:/test -w /test \
  golangci/golangci-lint golangci-lint run
```

You will notice that `golangci-lint` works: it finds an issue in the code where there's a missing error check.
您会注意到它 `golangci-lint` 有效：它在代码中发现了一个问题，其中缺少错误检查。

```text
cmd/server/main.go:23:10: Error return value of `w.Write` is not checked (errcheck)
		w.Write([]byte(translated))
		      ^
```

Now you can add this as a step to the Dockerfile.
现在，您可以将此步骤作为一个步骤添加到 Dockerfile。

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
+ ARG GOLANGCI_LINT_VERSION=v1.59
  FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  ARG APP_VERSION="0.0.0+unknown"
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -ldflags "-X main.version=$APP_VERSION" -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]

  FROM scratch AS binaries
  COPY --from=build-client /bin/client /
  COPY --from=build-server /bin/server /
+
+ FROM golangci/golangci-lint:${GOLANGCI_LINT_VERSION} as lint
+ WORKDIR /test
+ RUN --mount=type=bind,target=. \
+     golangci-lint run
```

The added `lint` stage uses the `golangci/golangci-lint` image from Docker Hub to invoke the `golangci-lint run` command with a bind-mount for the build context.
添加 `lint` 的阶段使用 Docker Hub 中的 `golangci/golangci-lint` 映像通过 bind-mount 调用 `golangci-lint run` 构建上下文的命令。

The lint stage is independent of any of the other stages in the Dockerfile. Therefore, running a regular build won’t cause the lint step to run. To lint the code, you must specify the `lint` stage:
lint 阶段独立于 Dockerfile 中的任何其他阶段。因此，运行常规构建不会导致 lint 步骤运行。要对代码进行 lint 处理，必须指定 `lint` 阶段：



```console
 docker build --target=lint .
```

## [Export test results 导出测试结果](https://docs.docker.com/build/guide/test/#export-test-results)

In addition to running tests, it's sometimes useful to be able to export the results of a test to a test report.
除了运行测试之外，有时能够将测试结果导出到测试报告也很有用。

Exporting test results is no different to exporting binaries, as shown in the previous section of this guide:
导出测试结果与导出二进制文件没有什么不同，如本指南的上一部分所示：

1. Save the test results to a file.
   将测试结果保存到文件中。
2. Create a new stage in your Dockerfile using the `scratch` base image.
   使用 `scratch` 基础映像在 Dockerfile 中创建一个新阶段。
3. Export that stage using the `local` exporter.
   使用 `local` 导出器导出该阶段。

The exact steps on how to do this is left as a reader's exercise :-)
有关如何执行此操作的确切步骤留为读者的练习：-）

## [Summary 总结](https://docs.docker.com/build/guide/test/#summary)

This section has shown an example on how you can use Docker builds to run tests (or as shown in this section, linters).
本部分展示了一个示例，说明如何使用 Docker 构建来运行测试（或如本节中所示的 linters）。

## [Next steps 后续步骤](https://docs.docker.com/build/guide/test/#next-steps)

The next topic in this guide is multi-platform builds, using emulation and cross-compilation.
本指南的下一个主题是使用仿真和交叉编译的多平台构建。

[Multi-platform 多平台](https://docs.docker.com/build/guide/multi-platform/)

# Multi-platform 多平台

Up until this point in the guide, you've built Linux binaries. This section describes how you can support other operating systems, and architectures, using multi-platform builds via emulation and cross-compilation.
到本指南的这一点为止，您已经构建了 Linux 二进制文件。本部分介绍如何通过仿真和交叉编译使用多平台构建来支持其他操作系统和体系结构。

The easiest way to get started with building for multiple platforms is using emulation. With emulation, you can build your app to multiple architectures without having to make any changes to your Dockerfile. All you need to do is to pass the `--platform` flag to the build command, specifying the OS and architecture you want to build for.
开始为多个平台构建的最简单方法是使用仿真。通过仿真，您可以根据多种架构构建应用程序，而无需对 Dockerfile 进行任何更改。您需要做的就是将 `--platform` 标志传递给构建命令，并指定要构建的操作系统和体系结构。

The following command builds the server image for the `linux/arm/v7` platform:
以下命令为 `linux/arm/v7` 平台构建服务器映像：

```console
 docker build --target=server --platform=linux/arm/v7 .
```

You can also use emulation to produce outputs for multiple platforms at once. However, the default image store in Docker Engine doesn't support building and loading multi-platform images. You need to enable the containerd image store which supports concurrent multi-platform builds.
您还可以使用仿真一次为多个平台生成输出。但是，Docker Engine 中的默认镜像存储不支持构建和加载多平台镜像。您需要启用支持并发多平台构建的 containerd 镜像存储。

## [Enable the containerd image store 启用 containerd 镜像存储](https://docs.docker.com/build/guide/multi-platform/#enable-the-containerd-image-store)

------

To enable the containerd image store in Docker Desktop, go to **Settings** and select **Use containerd for pulling and storing images** in the **General** tab.
要在 Docker Desktop 中启用 containerd 镜像存储，请转到“设置”，然后在“常规”选项卡中选择“使用 containerd 拉取和存储镜像”。

Note that changing the image store means you'll temporarily lose access to images and containers in the classic image store. Those resources still exist, but to view them, you'll need to disable the containerd image store.
请注意，更改映像存储意味着您将暂时失去对经典映像存储中映像和容器的访问权限。这些资源仍然存在，但要查看它们，您需要禁用 containerd 映像存储。

------

If you're not using Docker Desktop, enable the containerd image store by adding the following feature configuration to your `/etc/docker/daemon.json` configuration file.
如果不使用 Docker Desktop，请通过将以下功能配置添加到 `/etc/docker/daemon.json` 配置文件来启用 containerd 映像存储。

```json
{
  "features": {
    "containerd-snapshotter": true
  }
}
```

Restart the daemon after updating the configuration file.
更新配置文件后重新启动守护程序。

```console
 systemctl restart docker
```

## [Build using emulation 使用仿真进行构建](https://docs.docker.com/build/guide/multi-platform/#build-using-emulation)

To run multi-platform builds, invoke the `docker build` command, and pass it the same arguments as you did before. Only this time, also add a `--platform` flag specifying multiple architectures.
要运行多平台构建，请调用该 `docker build` 命令，并像以前一样向其传递相同的参数。只是这一次，还添加了一个 `--platform` 指定多个架构的标志。

```console
 docker build \
    --target=binaries \
    --output=bin \
    --platform=linux/amd64,linux/arm64,linux/arm/v7 .
```

This command uses emulation to run the same build three times, once for each platform. The build results are exported to a `bin` directory.
此命令使用仿真运行同一生成三次，每个平台一次。生成结果将导出到目录中 `bin` 。



```text
bin
├── linux_amd64
│   ├── client
│   └── server
├── linux_arm64
│   ├── client
│   └── server
└── linux_arm_v7
    ├── client
    └── server
```

When you build for multiple platforms concurrently, BuildKit runs all of the build steps under emulation for each platform that you specify. Effectively forking the build into multiple concurrent processes.
当您同时为多个平台构建时，BuildKit 会在仿真下为您指定的每个平台运行所有构建步骤。有效地将构建分叉为多个并发进程。

![Build pipelines using emulation](https://docs.docker.com/build/guide/images/emulation.png)

There are, however, a few downsides to running multi-platform builds using emulation:
但是，使用仿真运行多平台构建有一些缺点：

- If you tried running the command above, you may have noticed that it took a long time to finish. Emulation can be much slower than native execution for CPU-intensive tasks.
  如果您尝试运行上述命令，您可能已经注意到它花了很长时间才完成。对于 CPU 密集型任务，仿真可能比本机执行慢得多。
- Emulation only works when the architecture is supported by the base image you’re using. The example in this guide uses the Alpine Linux version of the `golang` image, which means you can only build Linux images this way, for a limited set of CPU architectures, without having to change the base image.
  仅当所使用的基础映像支持体系结构时，仿真才起作用。本指南中的示例使用 `golang` 镜像的 Alpine Linux 版本，这意味着您只能以这种方式为一组有限的 CPU 架构构建 Linux 镜像，而无需更改基础镜像。

As an alternative to emulation, the next step explores cross-compilation. Cross-compiling makes multi-platform builds much faster and versatile.
作为仿真的替代方法，下一步将探索交叉编译。交叉编译使多平台构建更快、更通用。

## [Build using cross-compilation 使用交叉编译进行构建](https://docs.docker.com/build/guide/multi-platform/#build-using-cross-compilation)

Using cross-compilation means leveraging the capabilities of a compiler to build for multiple platforms, without the need for emulation.
使用交叉编译意味着利用编译器的功能为多个平台构建，而无需仿真。

The first thing you'll need to do is pinning the builder to use the node’s native architecture as the build platform. This is to prevent emulation. Then, from the node's native architecture, the builder cross-compiles the application to a number of other target platforms.
您需要做的第一件事是固定构建器，以使用节点的原生架构作为构建平台。这是为了防止仿真。然后，从节点的本机架构中，构建器将应用程序交叉编译到许多其他目标平台。

### [Platform build arguments 平台构建参数](https://docs.docker.com/build/guide/multi-platform/#platform-build-arguments)

This approach involves using a few pre-defined build arguments that you have access to in your Docker builds: `BUILDPLATFORM` and `TARGETPLATFORM` (and derivatives, like `TARGETOS`). These build arguments reflect the values you pass to the `--platform` flag.
此方法涉及使用一些预定义的构建参数，您可以在 Docker 构建中访问这些参数： `BUILDPLATFORM` 和 `TARGETPLATFORM` （以及衍生物，如 `TARGETOS` ）。这些生成参数反映了传递给标志的值 `--platform` 。

For example, if you invoke a build with `--platform=linux/amd64`, then the build arguments resolve to:
例如，如果使用 `--platform=linux/amd64` 调用生成，则生成参数解析为：

- `TARGETPLATFORM=linux/amd64`
- `TARGETOS=linux`
- `TARGETARCH=amd64`

When you pass more than one value to the platform flag, build stages that use the pre-defined platform arguments are forked automatically for each platform. This is in contrast to builds running under emulation, where the entire build pipeline runs per platform.
当您将多个值传递给平台标志时，使用预定义平台参数的构建阶段将自动为每个平台分叉。这与在仿真下运行的生成形成鲜明对比，在仿真下，整个生成管道按平台运行。

![Build pipelines using cross-compilation](https://docs.docker.com/build/guide/images/cross-compilation.png)

### [Update the Dockerfile 更新 Dockerfile](https://docs.docker.com/build/guide/multi-platform/#update-the-dockerfile)

To build the app using the cross-compilation technique, update the Dockerfile as follows:
若要使用交叉编译技术生成应用，请按如下方式更新 Dockerfile：

- Add `--platform=$BUILDPLATFORM` to the `FROM` instruction for the initial `base` stage, pinning the platform of the `golang` image to match the architecture of the host machine.
  添加到 `--platform=$BUILDPLATFORM` 初始阶段的 `FROM` 指令中，固定 `golang` 映像的平台以匹配 `base` 主机的体系结构。
- Add `ARG` instructions for the Go compilation stages, making the `TARGETOS` and `TARGETARCH` build arguments available to the commands in this stage.
  添加 `ARG` Go 编译阶段的指令，使 `TARGETOS` and `TARGETARCH` build 参数可用于此阶段的命令。
- Set the `GOOS` and `GOARCH` environment variables to the values of `TARGETOS` and `TARGETARCH`. The Go compiler uses these variables to do cross-compilation.
  将 `GOOS` and `GOARCH` 环境变量设置为 `TARGETOS` 和 `TARGETARCH` 的值。Go 编译器使用这些变量进行交叉编译。

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
  ARG GOLANGCI_LINT_VERSION=v1.59
- FROM golang:${GO_VERSION}-alpine AS base
+ FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod \
      --mount=type=bind,source=go.mod,target=go.mod \
      --mount=type=bind,source=go.sum,target=go.sum \
      go mod download -x

  FROM base AS build-client
+ ARG TARGETOS
+ ARG TARGETARCH
  RUN --mount=type=cache,target=/go/pkg/mod \
      --mount=type=bind,target=. \
-     go build -o /bin/client ./cmd/client
+     GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o /bin/client ./cmd/client

  FROM base AS build-server
+ ARG TARGETOS
+ ARG TARGETARCH
  RUN --mount=type=cache,target=/go/pkg/mod \
      --mount=type=bind,target=. \
-     go build -o /bin/server ./cmd/server
+     GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]

  FROM scratch AS binaries
  COPY --from=build-client /bin/client /
  COPY --from=build-server /bin/server /

  FROM golangci/golangci-lint:${GOLANGCI_LINT_VERSION} as lint
  WORKDIR /test
  RUN --mount=type=bind,target=. \
      golangci-lint run
```

The only thing left to do now is to run the actual build. To run a multi-platform build, set the `--platform` option, and specify a CSV string of the OS and architectures that you want to build for. The following command illustrates how to build, and export, binaries for Mac (ARM64), Windows, and Linux:
现在唯一要做的就是运行实际的构建。要运行多平台构建，请设置选项 `--platform` ，并指定要为其构建的操作系统和体系结构的 CSV 字符串。以下命令演示如何生成和导出适用于 Mac （ARM64）、Windows 和 Linux 的二进制文件：

```console
 docker build \
  --target=binaries \
  --output=bin \
  --platform=darwin/arm64,windows/amd64,linux/amd64 .
```

When the build finishes, you’ll find client and server binaries for all of the selected platforms in the `bin` directory:
构建完成后，您将在 `bin` 目录中找到所有选定平台的客户端和服务器二进制文件：

```diff
bin
├── darwin_arm64
│   ├── client
│   └── server
├── linux_amd64
│   ├── client
│   └── server
└── windows_amd64
    ├── client
    └── server
```

## [Summary 总结](https://docs.docker.com/build/guide/multi-platform/#summary)

This section has demonstrated how you can get started with multi-platform builds using emulation and cross-compilation.
本部分演示了如何使用仿真和交叉编译开始进行多平台构建。

Related information: 相关信息：

- [Multi-platfom images 多平台图像](https://docs.docker.com/build/building/multi-platform/)
- [containerd image store (Docker Desktop)
  containerd 镜像存储（Docker Desktop）](https://docs.docker.com/desktop/containerd/)
- [containerd image store (Docker Engine)
  containerd 镜像存储（Docker Engine）](https://docs.docker.com/storage/containerd/)

You may also want to consider checking out [xx - Dockerfile cross-compilation helpers](https://github.com/tonistiigi/xx)

. `xx` is a Docker image containing utility scripts that make cross-compiling with Docker builds easier.
您可能还需要考虑查看 xx - Dockerfile 交叉编译助手。 `xx` 是一个 Docker 镜像，其中包含实用程序脚本，使与 Docker 构建的交叉编译变得更加容易。

## [Next steps 后续步骤](https://docs.docker.com/build/guide/multi-platform/#next-steps)

This section is the final part of the Build with Docker guide. The following page contains some pointers for where to go next.
本部分是“使用 Docker 构建”指南的最后一部分。以下页面包含一些指向下一步操作的指示。

# Next steps 后续步骤

This guide has demonstrated some of the build features and capabilities that Docker provides.
本指南演示了 Docker 提供的一些构建特性和功能。

If you would like to continue learning about Docker build, consider exploring the following resources:
如果您想继续学习有关 Docker 构建的信息，请考虑浏览以下资源：

- [BuildKit](https://docs.docker.com/build/buildkit/): deep-dive into the open source build engine that powers your Docker builds
  BuildKit：深入了解为 Docker 构建提供支持的开源构建引擎
- [Drivers](https://docs.docker.com/build/drivers/): configure for how and where your Docker builds run
  驱动程序：配置 Docker 构建的运行方式和位置
- [Exporters](https://docs.docker.com/build/exporters/): save your build results to different output formats
  导出器：将构建结果保存为不同的输出格式
- [Bake](https://docs.docker.com/build/bake/): orchestrate your build workflows
  烘焙：编排生成工作流
- [Attestations](https://docs.docker.com/build/attestations/): annotate your build artifacts with metadata
  证明：使用元数据注释您的构建工件
- [Continuous integration](https://docs.docker.com/build/ci/): run Docker builds in CI
  持续集成：在 CI 中运行 Docker 构建