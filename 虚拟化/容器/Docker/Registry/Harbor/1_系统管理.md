This section describes how to configure and maintain Harbor after  deployment. These operations are performed by the Harbor system  administrator. The Harbor system administrator performs global  configuration operations that apply to the whole Harbor instance.
本节介绍如何在部署后配置和维护 Harbor。这些操作由 Harbor 系统管理员执行。Harbor 系统管理员执行适用于整个 Harbor 实例的全局配置操作。

The operations that are performed by the Harbor system administrator are the following.
Harbor 系统管理员需要执行的操作如下。

- Select database, LDAP/Active Directory, or OIDC based authentication. For information, see  [Configuring Authentication](https://goharbor.io/docs/2.11.0/administration/configure-authentication/).
  选择数据库、LDAP/Active Directory 或基于 OIDC 的身份验证。有关信息，请参阅配置身份验证。
- Add users in database authentication mode and assign the system administrator role to other users. For information, see  [Managing Users](https://goharbor.io/docs/2.11.0/administration/managing-users/).
  以数据库认证方式添加用户，并为其他用户分配系统管理员角色。有关信息，请参阅管理用户。
- Configure global settings, such as setting the registry to read-only mode, and  restriction who can create projects. For information, see  [Configure Global Settings](https://goharbor.io/docs/2.11.0/administration/general-settings/).
  配置全局设置，例如将注册表设置为只读模式，并限制可以创建项目的人员。有关信息，请参阅配置全局设置。
- Apply resource quotas to projects. For information, see  [Configure Project Quotas](https://goharbor.io/docs/2.11.0/administration/configure-project-quotas/).
  将资源配额应用于项目。有关信息，请参阅配置项目配额。
- Set up replication of images between Harbor and another Harbor instance or a 3rd party replication target. For information, see  [Configuring Replication](https://goharbor.io/docs/2.11.0/administration/configuring-replication/).
  设置 Harbor 与另一个 Harbor 实例或第三方复制目标之间的镜像复制。有关信息，请参阅配置复制。
- Set up vulnerability scanners to check the images in the registry for CVE vulnerabilities. For information, see  [Vulnerability Scanning](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/).
  设置漏洞扫描程序以检查注册表中的图像是否存在 CVE 漏洞。有关信息，请参阅漏洞扫描。
- Perform garbage collection, to remove unnecessary data from Harbor. For information, see  [Garbage Collection](https://goharbor.io/docs/2.11.0/administration/garbage-collection/).
  执行垃圾回收，以从 Harbor 中删除不必要的数据。有关信息，请参阅垃圾回收。
- Manage audit logs by configuring an audit log retention window and setting a  syslog endpoint to forward audit logs.For information, see  [Log Rotation](https://goharbor.io/docs/2.11.0/administration/log-rotation/).
  通过配置审核日志保留时段并设置 syslog 端点以转发审核日志来管理审核日志。有关信息，请参阅日志轮换。
- Upgrade Harbor when a new version becomes available. For information, see  [Upgrading Harbor](https://goharbor.io/docs/2.11.0/administration/upgrade/).
  当新版本可用时升级 Harbor。有关信息，请参阅升级 Harbor。
- Set up P2P preheat provider instances to preheat the specified images into the P2P network. For information, see  [P2P preheat](https://goharbor.io/docs/2.11.0/administration/p2p-preheat/).
  设置 P2P 预热提供商实例，将指定图像预热到 P2P 网络中。有关信息，请参阅 P2P 预热。
- Details of defining a user-defined OCI artifact so that Harbor can manage it. For information, see  [user-defined OCI artifact](https://goharbor.io/docs/2.11.0/administration/user-defined-oci-artifact/).
  定义用户定义的 OCI 工件以便 Harbor 可以对其进行管理的详细信息。有关信息，请参阅用户定义的 OCI 项目。

##      配置身份验证

Harbor supports different modes for authenticating users and managing user  accounts. You should select an authentication mode as soon as you deploy Harbor.
Harbor 支持多种模式对用户进行身份认证和管理用户账号。您应该在部署 Harbor 后立即选择身份验证模式。

​                        

​                 If you create user accounts in the Harbor database, Harbor is  locked in database mode. You cannot change to a different authentication mode after creating local users.      
如果您在 Harbor 数据库中创建用户账户，Harbor 将以数据库模式锁定。创建本地用户后，无法更改为其他身份验证模式。

- [Database Authentication](https://goharbor.io/docs/2.11.0/administration/configure-authentication/db-auth/): You create and manage user accounts directly in Harbor. The user accounts are stored in the Harbor database.
  数据库身份验证：您可以直接在 Harbor 中创建和管理用户帐户。用户帐户存储在 Harbor 数据库中。
- [LDAP/Active Directory Authentication](https://goharbor.io/docs/2.11.0/administration/configure-authentication/ldap-auth/): You connect Harbor to an external LDAP/Active Directory server. The  user accounts are created and managed by your LDAP/AD provider.
  LDAP/Active Directory 身份验证：将 Harbor 连接到外部 LDAP/Active Directory 服务器。用户帐户由 LDAP/AD 提供商创建和管理。
- [OIDC Provider Authentication](https://goharbor.io/docs/2.11.0/administration/configure-authentication/oidc-auth/): You connect Harbor to an external OIDC provider. The user accounts are created and managed by your OIDC provider.
  OIDC 提供商身份验证：您将 Harbor 连接到外部 OIDC 提供商。用户帐户由 OIDC 提供商创建和管理。

The Harbor interface offers an option to configure UAA authentication. This authentication mode is not recommended and is not documented in this  guide.
Harbor 接口提供了一个配置 UAA 身份验证的选项。不建议使用此身份验证模式，本指南中未对此进行介绍。

### 配置数据库身份验证

In database authentication mode, user accounts are stored in the local  database. By default, only the Harbor system administrator can create  user accounts to add users to Harbor. You can optionally configure  Harbor to allow self-registration.
在数据库认证模式下，用户帐户存储在本地数据库中。默认情况下，只有 Harbor 系统管理员才能创建用户账号以将用户添加到 Harbor 中。您可以选择将 Harbor 配置为允许自行注册。

​                        

​                 If you create users in the database, Harbor is locked in  database mode. You cannot change to a different authentication mode  after you have created local users.      
如果在数据库中创建用户，Harbor 会以数据库模式锁定。创建本地用户后，无法更改为其他身份验证模式。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Under **Administration**, go to **Configuration** and select the **Authentication** tab.
   在“管理”下，转到“配置”，然后选择“身份验证”选项卡。

3. Leave **Auth Mode** set to the default **Database** option.
   将“身份验证模式”设置为默认的“数据库”选项。

   

   ​    ![Database authentication](https://goharbor.io/docs/2.11.0/img/db-auth.png)  

   

4. Optionally select the **Allow Self-Registration** check box.
   （可选）选中“允许自行注册”复选框。

   

   ​    ![Enable self-registration](https://goharbor.io/docs/2.11.0/img/new-self-reg.png)  

   

   If you enable the self registration option, users can register themselves  in Harbor. Self-registration is deactivated by default. If you enable  self-registration, unregistered users can sign up for a Harbor account  by clicking **Sign up for an account** in the Harbor log in page.
   如果您启用自助注册选项，用户可以在 Harbor 中自行注册。默认情况下，自助注册处于停用状态。如果您开启了自助注册功能，则未注册用户可以通过在 Harbor 登录页面单击“注册帐户”来注册 Harbor 帐户。

   

   ​    ![Enable self-registration](https://goharbor.io/docs/2.11.0/img/self-registration-login.png)  

### 配置 LDAP/Active Directory 身份验证

If you select LDAP/AD authentication, users whose credentials are stored  in an external LDAP or AD server can log in to Harbor directly. In this  case, you do not create user accounts in Harbor.
如果选择LDAP/AD认证，则凭证存储在外部LDAP或AD服务器中的用户可以直接登录Harbor。在这种情况下，您不会在 Harbor 中创建用户帐户。

​                        

​                 You can change the authentication mode from database to LDAP  only if no local users have been added to the database. If there is at  least one user other than `admin` in the Harbor database, you cannot change the authentication mode.      
仅当数据库中未添加任何本地用户时，才能将身份验证模式从数据库更改为 LDAP。如果 Harbor 数据库中至少 `admin` 有一个用户，则无法更改身份验证模式。

Because the users are managed by LDAP or AD, self-registration, creating users, deleting users, changing passwords, and resetting passwords are not  supported in LDAP/AD authentication mode.
由于用户是通过LDAP或AD进行管理的，因此在LDAP/AD认证模式下，不支持自行注册、创建用户、删除用户、修改密码和重置密码。

If you want to manage user authentication by using LDAP groups, you must enable the `memberof` feature on the LDAP/AD server. With the `memberof` feature, the LDAP/AD user entity’s `memberof` attribute is updated when the group entity’s `member` attribute is updated, for example by adding or removing an LDAP/AD user from the LDAP/AD group. This feature is enabled by default in Active  Directory. For information about how to enable and verify `memberof` overlay in OpenLDAP, see  [this technical note](https://technicalnotes.wordpress.com/2014/04/19/openldap-setup-with-memberof-overlay).
如果要使用 LDAP 组管理用户身份验证，则必须在 LDAP/AD 服务器上启用该 `memberof` 功能。使用此功能 `memberof` 时，LDAP/AD 用户实体的 `memberof` 属性将在更新组实体的 `member` 属性时进行更新，例如，通过在 LDAP/AD 组中添加或删除 LDAP/AD 用户。默认情况下，此功能在 Active Directory 中处于启用状态。有关如何在 OpenLDAP 中启用和验证 `memberof` 覆盖的信息，请参阅此技术说明。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Under **Administration**, go to **Configuration** and select the **Authentication** tab.
   在“管理”下，转到“配置”，然后选择“身份验证”选项卡。

3. Use the **Auth Mode** drop-down menu to select **LDAP**.
   使用 Auth Mode 下拉菜单选择 LDAP。

   

   ​    ![LDAP authentication](https://goharbor.io/docs/2.11.0/img/select-ldap-auth.png)  

   

4. Enter the address of your LDAP server, for example `ldaps://10.162.16.194`.
   输入 LDAP 服务器的地址，例如 `ldaps://10.162.16.194` 。

5. Enter information about your LDAP server.
   输入有关 LDAP 服务器的信息。

   - **LDAP Search DN** and **LDAP Search Password**: When a user logs in to Harbor with their LDAP username and password,  Harbor uses these values to bind to the LDAP/AD server. For example, `cn=admin,dc=example.com`.
     LDAP 搜索 DN 和 LDAP 搜索密码：当用户使用其 LDAP 用户名和密码登录 Harbor 时，Harbor 会使用这些值绑定到 LDAP/AD 服务器。例如， `cn=admin,dc=example.com` .

   - **LDAP Base DN**: Harbor looks up the user under the LDAP Base DN entry, including the subtree. For example, `dc=example.com`.
     LDAP 基本 DN：Harbor 在 LDAP 基本 DN 条目下查找用户，包括子树。例如， `dc=example.com` .

   - **LDAP Filter**: The filter to search for LDAP/AD users. For example, `objectclass=user`.
     LDAP 过滤器：用于搜索 LDAP/AD 用户的过滤器。例如， `objectclass=user` .

   - **LDAP UID**: An attribute, for example `uid`, or `cn`, that is used to match a user with the username. If a match is found,  the user’s password is verified by a bind request to the LDAP/AD server.
     LDAP UID：一个属性，例如 `uid` 或 `cn` ，用于将用户与用户名匹配。如果找到匹配项，则通过向 LDAP/AD 服务器发出绑定请求来验证用户的密码。

   - **LDAP Scope**: The scope to search for LDAP/AD users. Select from **Subtree**, **Base**, and **OneLevel**.
     LDAP 作用域：用于搜索 LDAP/AD 用户的作用域。从“子树”（Subtree）、“基”（Base） 和“OneLevel”（OneLevel） 中进行选择。

     

     ​    ![Basic LDAP configuration](https://goharbor.io/docs/2.11.0/img/ldap-auth.png)  

     

6. If you want to manage user authentication with LDAP groups, configure the group settings.
   如果要使用 LDAP 组管理用户身份验证，请配置组设置。

   - **LDAP Group Base DN**: The base DN from which to lookup a group in LDAP/AD. For example, `ou=groups,dc=example,dc=com`. This field cannot be empty when LDAP group feature is enabled.
     LDAP 组基本 DN：在 LDAP/AD 中查找组的基本 DN。例如， `ou=groups,dc=example,dc=com` .启用LDAP组功能时，此字段不能为空。

   - **LDAP Group Filter**: The filter to search for LDAP/AD groups. for OpenLDAP: `objectclass=groupOfNames`. for Active Directory: `objectclass=group`. This field cannot be empty when LDAP group feature is enabled.
     LDAP 组过滤器：用于搜索 LDAP/AD 组的过滤器。对于 OpenLDAP： `objectclass=groupOfNames` 。对于 Active Directory： `objectclass=group` 。启用LDAP组功能时，此字段不能为空。

   - **LDAP Group GID**: The attribute used to name an LDAP/AD group. For example, `cn`. This field cannot be empty when LDAP group feature is enabled.
     LDAP 组 GID：用于命名 LDAP/AD 组的属性。例如， `cn` .启用LDAP组功能时，此字段不能为空。

   - **LDAP Group Admin DN**: All LDAP/AD users in this group DN have Harbor system administrator privileges.
     LDAP 组管理员 DN：此组 DN 中的所有 LDAP/AD 用户都具有 Harbor 系统管理员权限。

   - **LDAP Group Membership**: The user attribute usd to identify a user as a member of a group. By default this is `memberof`.
     LDAP 组成员身份：用户属性 usd，用于将用户标识为组成员。默认情况下，这是 `memberof` 。

   - **LDAP Scope**: The scope to search for LDAP/AD groups. Select from **Subtree**, **Base**, and **OneLevel**.
     LDAP 作用域：搜索 LDAP/AD 组的作用域。从“子树”（Subtree）、“基”（Base） 和“OneLevel”（OneLevel） 中进行选择。

     

     ​    ![LDAP group configuration](https://goharbor.io/docs/2.11.0/img/ldap-groups.png)  

     

7. Uncheck **LDAP Verify Cert** if the LDAP/AD server uses a self-signed or untrusted certificate.
   如果 LDAP/AD 服务器使用自签名证书或不受信任的证书，请取消选中 LDAP 验证证书。

   

   ​    ![LDAP certificate verification](https://goharbor.io/docs/2.11.0/img/ldap-cert-test.png)  

   

8. Click **Test LDAP Server** to make sure that your configuration is correct.
   单击“测试 LDAP 服务器”以确保您的配置正确无误。

9. Click **Save** to complete the configuration.
   单击“保存”以完成配置。

### Configure OIDC Provider Authentication      
配置 OIDC 提供商身份验证

If you select OpenID Connect (OIDC) authentication, users log in to the  Harbor interface via an OIDC single sign-on (SSO) provider, such as  Okta, KeyCloak, or dex. In this case, you do not create user accounts in Harbor.
如果选择 OpenID Connect （OIDC） 身份验证，用户将通过 OIDC 单点登录 （SSO） 提供商（如 Okta、KeyCloak 或 dex）登录 Harbor 接口。在这种情况下，您不会在 Harbor 中创建用户帐户。

​                        

​                 You can change the authentication mode from database to OIDC  only if no local users have been added to the database. If there is at  least one user other than `admin` in the Harbor database, you cannot change the authentication mode.      
只有当数据库中未添加任何本地用户时，您才能将身份验证模式从数据库更改为 OIDC。如果 Harbor 数据库中至少 `admin` 有一个用户，则无法更改身份验证模式。

Because the users are managed by the OIDC provider, self-registration, creating users, deleting users, changing passwords, and resetting passwords are  not supported in OIDC authentication mode.
由于用户由 OIDC 提供商管理，因此 OIDC 认证模式不支持自行注册、创建用户、删除用户、更改密码和重置密码。

### Configure Your OIDC Provider 配置 OIDC 提供商

You must configure your OIDC provider so that you can use it with Harbor.  For precise information about how to perform these configurations, see  the documentation for your OIDC provider.
您必须配置 OIDC 提供商，以便可以将其与 Harbor 一起使用。有关如何执行这些配置的准确信息，请参阅 OIDC 提供商的文档。

- Set up the users and groups that will use the OIDC provider to log in to  Harbor. You do not need to assign any specific OIDC roles to users or  groups as these do not get mapped to Harbor roles.
  设置将使用 OIDC 提供商登录 Harbor 的用户和组。您无需为用户或组分配任何特定的 OIDC 角色，因为这些角色不会映射到 Harbor 角色。
- The URL of the OIDC provider endpoint, known as the Authorization Server in OAuth terminology, must service the well-known URI for its  configuration document. For more information about the configuration  document, see the  [OpenID documentation](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest).
  OIDC 提供商端点的 URL（在 OAuth 术语中称为授权服务器）必须为其配置文档的已知 URI 提供服务。有关配置文档的更多信息，请参阅 OpenID 文档。
- To manage users by using OIDC groups, create a custom group claim that  contains all of the user groups that you want to register in Harbor. The group claim must be mapped in the ID token that is sent to Harbor when  users log in. You can enable the `memberof` feature on the OIDC provider. With the `memberof` feature, the OIDC user entity’s `memberof` attribute is updated when the group entity’s `member` attribute is updated, for example by adding or removing an OIDC user from the OIDC group.
  要使用 OIDC 组管理用户，请创建一个自定义组声明，其中包含您要在 Harbor 中注册的所有用户组。组声明必须映射到用户登录时发送到 Harbor 的 ID 令牌中。您可以在 OIDC 提供商上启用该 `memberof` 功能。借助此功能 `memberof` ，当组实体的 `member` 属性更新时，OIDC 用户实体的 `memberof` 属性也会更新，例如，通过在 OIDC 组中添加或删除 OIDC 用户。
- Register Harbor as a client application with the OIDC provider. Associate Harbor’s callback URI to the client application as a `redirectURI`. This is the address to which the OIDC provider sends ID tokens.
  将 Harbor 注册为向 OIDC 提供商提供的客户端应用程序。将 Harbor 的回调 URI 作为 `redirectURI` .这是 OIDC 提供商向其发送 ID 令牌的地址。

### Configure an OIDC Provider in Harbor 在 Harbor 中配置 OIDC 提供商

Before configuring an OIDC provider in Harbor, make sure that your provider is configured correctly according to the preceding section.
在 Harbor 中配置 OIDC 提供商之前，请确保已根据上一部分正确配置了提供商。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Under **Administration**, go to **Configuration** and select the **Authentication** tab.
   在“管理”下，转到“配置”，然后选择“身份验证”选项卡。

3. Use the **Auth Mode** drop-down menu to select **OIDC**.
   使用 Auth Mode 下拉菜单选择 OIDC。

   

   ​    ![LDAP authentication](https://goharbor.io/docs/2.11.0/img/select-oidc-auth.png)  

   

4. Enter information about your OIDC provider.
   输入有关您的 OIDC 提供商的信息。

   - **Primary Auth Mode**: Whether to use the OIDC mode as the primary auth mode. 
     主认证模式：是否使用OIDC模式作为主认证模式。

     ​                        

     ​                 To override and login via DB is possible when visiting the URL ‘/account/sign-in’ explicitly      
     在显式访问 URL“/account/sign-in”时，可以通过 DB 进行覆盖和登录

     

   - **OIDC Provider Name**: The name of the OIDC provider.
     OIDC 提供商名称：OIDC 提供商的名称。

   - **OIDC Provider Endpoint**: The URL of the endpoint of the OIDC provider.
     OIDC 提供商端点：OIDC 提供商的端点的 URL。

   - **OIDC Client ID**: The client ID with which Harbor is registered as  client application with the OIDC provider.
     OIDC 客户端 ID：Harbor 用于在 OIDC 提供商处注册为客户端应用程序的客户端 ID。

   - **OIDC Client Secret**: The secret for the Harbor client application.
     OIDC 客户端密钥：Harbor 客户端应用程序的密钥。

   - **OIDC Group Filter**: The  [regular expression](https://pkg.go.dev/regexp/syntax) to select matching groups from the `Group Claim Name` list . Matching groups are added to Harbor. This filter does not limit the users’ capability to log in into Harbor.
     OIDC Group Filter：用于从列表中选择匹配组的 `Group Claim Name` 正则表达式。匹配的组将添加到 Harbor 中。此过滤器不会限制用户登录 Harbor 的能力。

   - **Group Claim Name**: The name of a custom group claim that you have configured in your OIDC provider, that includes the groups to add to Harbor.
     组声明名称：您在 OIDC 提供商中配置的自定义组声明的名称，其中包括要添加到 Harbor 的组。

   - **OIDC Admin Group**: The name of the admin group, if the ID token of the user shows that he is a member of this group, the user will have admin privilege in Harbor. **Note**: You can only set one Admin Group.  Please also make sure the value in this field matches the value of group item in ID token.
     OIDC Admin Group：管理员组的名称，如果用户的 ID 令牌显示他是该组的成员，则该用户将在 Harbor 中拥有管理员权限。注意：您只能设置一个管理员组。此外，请确保此字段中的值与 ID 令牌中组项的值匹配。

   - **OIDC Scope**: A comma-separated string listing the scopes to be used during authentication.
     OIDC 范围：一个以逗号分隔的字符串，列出了身份验证期间要使用的范围。

     The OIDC scope must contain `openid` and usually also contains `profile` and `email`. To obtain refresh tokens it should also contain `offline_access`. If you are using OIDC groups, a scope must identify the group claim.  Check with your OIDC provider administrator for precise details of how  to identify the group claim scope, as this differs from vendor to  vendor.
     OIDC 作用域必须包含 `openid` 并且通常还包含 `profile` 和 `email` 。要获取刷新令牌，它还应包含 `offline_access` .如果您使用的是 OIDC 组，则范围必须标识组声明。请与您的 OIDC 提供商管理员联系，了解如何识别组索赔范围的确切详细信息，因为这因供应商而异。

     

     ​    ![OIDC settings](https://goharbor.io/docs/2.11.0/img/oidc-auth-setting.png)  

     

5. Uncheck **Verify Certificate** if the OIDC Provider uses a self-signed or untrusted certificate.
   如果 OIDC 提供商使用自签名证书或不受信任的证书，请取消选中验证证书。

6. Check the **Automatic onboarding** if you don’t want user to set his username in Harbor during his first login.  When this option is checked, the attribute **Username Claim** must be set, Harbor will read the value of this claim from ID token and use it as the username for onboarding the user.  Therefore, you must  make sure the value you set in **Username Claim** is included in the ID token returned by the OIDC provider you set,  otherwise there will be a system error when Harbor tries to onboard the  user.
   如果您不希望用户在首次登录时在 Harbor 中设置其用户名，请检查自动载入。勾选此选项后，必须设置 Username Claim 属性，Harbor 将从 ID  令牌中读取此声明的值，并将其用作用户引导的用户名。因此，您必须确保在 Username Claim 中设置的值包含在您设置的 OIDC  提供商返回的 ID 令牌中，否则当 Harbor 尝试加入用户时，将出现系统错误。

7. Verify that the Redirect URI that you configured in your OIDC provider is the  same as the one displayed at the bottom of the page.  
   验证您在 OIDC 提供商中配置的重定向 URI 是否与页面底部显示的 URI 相同。

   ​    ![OIDC_auto_onboarding](https://goharbor.io/docs/2.11.0/img/oidc-cert-verifi-auto-onboard.png)  

   

8. Click **Test OIDC Server** to make sure that your configuration is correct.
   单击“测试 OIDC 服务器”以确保您的配置正确无误。

9. Click **Save** to complete the configuration.
   单击“保存”以完成配置。

### Log In to Harbor via an OIDC Provider 通过 OIDC 提供商登录 Harbor

When the Harbor system administrator has configured Harbor to authenticate via OIDC a **LOGIN WITH ${your_oidc_provider_name}** button appears on the Harbor login page.
当 Harbor 系统管理员将 Harbor 配置为通过 OIDC 进行身份验证时，Harbor 登录页面上会出现一个 LOGIN WITH ${your_oidc_provider_name} 按钮。



​    ![oidc_login](https://goharbor.io/docs/2.11.0/img/oidc-login.png)  



**NOTE:** When Harbor is configured authentication via OIDC, the **LOGIN VIA LOCAL DB** button is for the local Harbor system administrator to log in.
注意：当 Harbor 配置通过 OIDC 进行身份验证时，LOGIN VIA LOCAL DB 按钮供本地 Harbor 系统管理员登录。

1. As a Harbor user, click the **LOGIN WITH ${your_oidc_provider_name}** button.
   作为 Harbor 用户，点击 LOGIN WITH ${your_oidc_provider_name} 按钮。

   This redirects you to the OIDC Provider for authentication, after the OIDC  provider has authenticated you, you are redirected back to Harbor.
   这会将您重定向到 OIDC 提供商进行身份验证，在 OIDC 提供商对您进行身份验证后，您将被重定向回 Harbor。

2. If this is the first time you are logging in to Harbor with OIDC, you will be onboarded to Harbor so that you have a user record in Harbor’s  database, which is used when adding you to projects, assigning roles,  and so on.  The flow of this process depends on the configuration:
   如果这是您首次使用 OIDC 登录 Harbor，您将被引导至 Harbor，以便在 Harbor 的数据库中拥有用户记录，该记录在将您添加到项目、分配角色等时使用。此过程的流程取决于配置：

   1. If the option 

      Automatic onboarding

       is not checked, a dialog will be displayed for specifying a user name for Harbor to associate with your OIDC username.

      
      如果未选中“自动载入”选项，则会显示一个对话框，用于指定 Harbor 的用户名以与您的 OIDC 用户名关联。

      ​    ![Specify Harbor username for OIDC](https://goharbor.io/docs/2.11.0/img/oidc-onboard-dlg.png)  

      If the username is already taken, you are prompted to choose another one.

      
      如果用户名已被占用，系统会提示您选择另一个用户名。

   2. If the option **Automatic onboarding** is checked, you will not be prompted to set the user name, instead,  Harbor will try to extract the user name from ID token via the claim set in **Username Claim** and automatically onboard the user using this username.
      如果勾选了“自动载入”选项，系统将不会提示您设置用户名，相反，Harbor 将尝试通过“用户名声明”中设置的声明从 ID 令牌中提取用户名，并自动使用此用户名加入用户。

### Using OIDC from the Docker or Helm CLI 从 Docker 或 Helm CLI 使用 OIDC

After you have authenticated via OIDC and logged into the Harbor interface  for the first time, you can use the Docker or Helm CLI to access Harbor.
通过 OIDC 进行身份验证并首次登录 Harbor 界面后，您可以使用 Docker 或 Helm CLI 访问 Harbor。

The Docker and Helm CLIs cannot handle redirection for OIDC, so Harbor  provides a CLI secret for use when logging in from Docker or Helm. This  is only available when Harbor uses OIDC authentication.
Docker 和 Helm CLI 无法处理 OIDC 的重定向，因此 Harbor 提供了一个 CLI 密钥，以便在从 Docker 或 Helm 登录时使用。仅当 Harbor 使用 OIDC 身份验证时，此功能才可用。

1. Log in to Harbor with an OIDC user account.
   使用 OIDC 用户帐户登录 Harbor。

2. Click your username at the top of the screen and select **User Profile**.
   单击屏幕顶部的用户名，然后选择“用户个人资料”。

   

   ​    ![Access user profile](https://goharbor.io/docs/2.11.0/img/user-profile.png)  

   

3. Click the clipboard icon to copy the CLI secret associated with your account.
   单击剪贴板图标以复制与您的帐户关联的 CLI 密钥。

   

   ​    ![Copy CLI secret](https://goharbor.io/docs/2.11.0/img/profile-dlg.png)  

   

4. Optionally click the **…** icon in your user profile to display buttons for automatically generating or manually creating a new CLI secret.
   （可选）单击 ...图标以显示用于自动生成或手动创建新 CLI 密钥的按钮。

   

   ​    ![Copy CLI secret](https://goharbor.io/docs/2.11.0/img/generate-create-new-secret.png)  

   

   A user can only have one CLI secret, so when a new secret is generated or create, the old one becomes invalid.
   一个用户只能有一个 CLI 密钥，因此当生成或创建新密钥时，旧密钥将失效。

5. If you generated a new CLI secret, click the clipboard icon to copy it.
   如果您生成了新的 CLI 密钥，请单击剪贴板图标以复制它。

You can now use your CLI secret as the password when logging in to Harbor from the Docker or Helm CLI.
现在，从 Docker 或 Helm CLI 登录 Harbor 时，您可以使用 CLI 密钥作为密码。

```
docker login -u testuser -p cli_secret jt-dev.local.goharbor.io
```

​                        

​                 The CLI secret is associated with the OIDC ID token. Harbor will try to refresh the token, so the CLI secret will be valid after the ID  token expires. However, if the OIDC Provider does not provide a refresh  token or the refresh fails, the CLI secret becomes invalid. In this  case, log out and log back in to Harbor via your OIDC provider so that  Harbor can get a new ID token. The CLI secret will then work again.      
CLI 密钥与 OIDC ID 令牌关联。Harbor 将尝试刷新令牌，因此 CLI 密钥将在 ID 令牌过期后生效。但是，如果 OIDC  提供商未提供刷新令牌或刷新失败，则 CLI 密钥将失效。在这种情况下，请通过您的 OIDC 提供商注销并重新登录 Harbor，以便  Harbor 可以获取新的 ID 令牌。然后，CLI 密钥将再次工作。

##         管理用户

Harbor manages images through projects. You provide access to these images to  users by including the users in projects and assigning one of the  following roles to them.
Harbor 通过项目管理图像。您可以通过将用户包含在项目中并为他们分配以下角色之一来向用户提供对这些图像的访问权限。



​    ![RBAC](https://goharbor.io/docs/2.11.0/img/rbac.png)  



- **Limited Guest**: A Limited Guest does not have full read privileges for a project. They  can pull images but cannot push, and they cannot see logs or the other  members of a project. For example, you can create limited guests for  users from different organizations who share access to a project.
  受限访客：受限访客不具有项目的完全读取权限。他们可以拉取图像，但不能推送，并且无法查看日志或项目的其他成员。例如，您可以为共享项目访问权限的不同组织的用户创建受限来宾。
- **Guest**: Guest has read-only privilege for a specified project. They can pull and retag images, but cannot push.
  Guest：Guest 对指定项目具有只读权限。他们可以拉取和重新标记图像，但不能推送。
- **Developer**: Developer has read and write privileges for a project.
  开发人员：开发人员具有项目的读写权限。
- **Maintainer**: Maintainer has elevated permissions beyond those of ‘Developer’  including the ability to scan images, view replications jobs, and delete images and helm charts.
  维护者：维护者拥有超越“开发人员”的权限，包括扫描图像、查看复制作业以及删除图像和 helm 图表的能力。
- **ProjectAdmin**: When creating a new project, you will be assigned the “ProjectAdmin”  role to the project. Besides read-write privileges, the “ProjectAdmin”  also has some management privileges, such as adding and removing  members, starting a vulnerability scan.
  ProjectAdmin：创建新项目时，您将被分配到该项目的“ProjectAdmin”角色。除了读写权限外，“ProjectAdmin”还具有一些管理权限，例如添加和删除成员、启动漏洞扫描等。

Besides the above roles, there are two system-level roles:
除了上述角色外，还有两个系统级角色：

- **Harbor system administrator**: “Harbor system administrator” has the most privileges. In addition to  the privileges mentioned above, “Harbor system administrator” can also  list all projects, set an ordinary user as administrator, delete users  and set vulnerability scan policy for all images. The public project  “library” is also owned by the administrator.
  Harbor 系统管理员：“Harbor 系统管理员”拥有最多的权限。除上述权限外，“Harbor 系统管理员”还可以列出所有项目、设置普通用户为管理员、删除用户以及为所有镜像设置漏洞扫描策略。公共项目“库”也归管理员所有。
- **Anonymous**: When a user is not logged in, the user is considered as an “Anonymous”  user. An anonymous user has no access to private projects and has  read-only access to public projects.
  匿名：当用户未登录时，该用户将被视为“匿名”用户。匿名用户无权访问私有项目，而对公共项目具有只读访问权限。

For full details of the permissions of the different roles, see  [User Permissions By Role](https://goharbor.io/docs/2.11.0/administration/managing-users/user-permissions-by-role/).
有关不同角色的权限的完整详细信息，请参阅按角色划分的用户权限。

If you run Harbor in database authentication mode, you create user  accounts directly in the Harbor interface. For information about how to  create local user accounts, see  [Create User Accounts in Database Mode](https://goharbor.io/docs/2.11.0/administration/managing-users/create-users-db/).
如果在数据库认证模式下运行 Harbor，可以直接在 Harbor 界面中创建用户账户。有关如何创建本地用户帐户的信息，请参阅在数据库模式下创建用户帐户。

If you run Harbor in LDAP/AD or OIDC authentication mode, you create and  manage user accounts in your LDAP/AD or OIDC provider. Harbor obtains  the users from the LDAP/AD or OIDC server and displays them in the **Users** tab of the Harbor interface.
如果您在 LDAP/AD 或 OIDC 身份验证模式下运行 Harbor，则可以在 LDAP/AD 或 OIDC  提供商中创建和管理用户帐户。Harbor 从 LDAP/AD 或 OIDC 服务器获取用户，并在 Harbor 界面的 用户  选项卡中展示这些用户。

## Assigning the Harbor System Administrator Role 分配 Harbor 系统管理员角色

Harbor system administrators can assign the Harbor system administrator role to other users by selecting usernames and clicking **Set as Administrator** in the **Users** tab.
Harbor 系统管理员可以通过选择用户名并单击“用户”选项卡中的“设为管理员”来为其他用户分配 Harbor 系统管理员角色。



​    ![browse project](https://goharbor.io/docs/2.11.0/img/new-set-admin-remove-user.png)  



To delete users, select a user and click `DELETE`. When deleting the user, its privilege will be removed. for LDAP/AD or  OIDC authentication mode, it just delete the user data in Harbor, not in the LDAP/AD or OIDC.
要删除用户，请选择一个用户，然后单击 `DELETE` 。删除用户时，其权限将被取消。对于 LDAP/AD 或 OIDC 认证模式，它只是删除 Harbor 中的用户数据，而不是 LDAP/AD 或 OIDC 中的用户数据。

### 按角色划分的用户权限

Users have different abilities depending on the role they have in a project.
用户具有不同的能力，具体取决于他们在项目中扮演的角色。

On public projects all users will be able to see the list of repositories, images, image vulnerabilities, helm charts and helm chart versions,  pull images, retag images (need push permission for destination image),  download helm charts, download helm chart versions.
在公共项目上，所有用户将能够看到仓库列表、镜像、镜像漏洞、helm chart 和 helm chart 版本、拉取镜像、重新标记镜像（目标镜像需要推送权限）、下载 helm chart、下载 helm chart 版本。

System admin have all permissions for the project.
系统管理员拥有项目的所有权限。

## Project members permissions 项目成员权限

The following table depicts the various user permission levels in a project.
下表描述了项目中的各种用户权限级别。

| Action 行动                                                  | Limited Guest 限定宾客人 | Guest 客人 | Developer 开发 人员 | Maintainer 保持 | Project Admin 项目管理员 |
| ------------------------------------------------------------ | ------------------------ | ---------- | ------------------- | --------------- | ------------------------ |
| See the project configurations 查看项目配置                  | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Edit the project configurations 编辑项目配置                 |                          |            |                     |                 | ✓                        |
| See a list of project members 查看项目成员列表               |                          | ✓          | ✓                   | ✓               | ✓                        |
| Create/edit/delete project members 创建/编辑/删除项目成员    |                          |            |                     |                 | ✓                        |
| See a list of project logs 查看项目日志列表                  |                          | ✓          | ✓                   | ✓               | ✓                        |
| See a list of project replications 查看项目复制列表          |                          |            |                     | ✓               | ✓                        |
| See a list of project replication jobs 查看项目复制作业列表  |                          |            |                     |                 | ✓                        |
| See a list of project labels 查看项目标签列表                |                          |            |                     | ✓               | ✓                        |
| Create/edit/delete project labels 创建/编辑/删除项目标签     |                          |            |                     | ✓               | ✓                        |
| See a list of repositories 查看仓库列表                      | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Create repositories 创建仓库                                 |                          |            | ✓                   | ✓               | ✓                        |
| Edit/delete repositories 编辑/删除仓库                       |                          |            |                     | ✓               | ✓                        |
| See a list of images 查看图片列表                            | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Retag image 重新标记图像                                     |                          | ✓          | ✓                   | ✓               | ✓                        |
| Pull image 拉取镜像                                          | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Push image 推送图片                                          |                          |            | ✓                   | ✓               | ✓                        |
| Scan/delete image 扫描/删除图像                              |                          |            |                     | ✓               | ✓                        |
| Add scanners to Harbor  * 向 Harbor 添加扫描仪 *             |                          |            |                     |                 |                          |
| Edit scanners in projects 在项目中编辑扫描仪                 |                          |            |                     |                 | ✓                        |
| See a list of image vulnerabilities 查看图像漏洞列表         | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Create list of project vulnerabilities 创建项目漏洞列表      |                          |            | ✓                   | ✓               | ✓                        |
| Read list of project vulnerabilities 读取项目漏洞列表        |                          |            | ✓                   | ✓               | ✓                        |
| Export list of project vulnerabilities 导出项目漏洞列表      |                          |            | ✓                   | ✓               | ✓                        |
| See image build history 查看镜像构建历史记录                 | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Add/Remove labels of image 添加/删除图像标签                 |                          |            | ✓                   | ✓               | ✓                        |
| See a list of helm charts 查看 helm 图表列表                 | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Download helm charts 下载 helm charts                        | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Upload helm charts 上传 helm 图表                            |                          |            | ✓                   | ✓               | ✓                        |
| Delete helm charts 删除 helm 图表                            |                          |            |                     | ✓               | ✓                        |
| See a list of helm chart versions 查看 helm chart 版本列表   | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Download helm chart versions 下载 helm chart 版本            | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Upload helm chart versions 上传 helm chart 版本              |                          |            | ✓                   | ✓               | ✓                        |
| Delete helm chart versions 删除 helm chart 版本              |                          |            |                     | ✓               | ✓                        |
| Add/Remove labels of helm chart version 添加/删除 helm chart 版本的标签 |                          |            | ✓                   | ✓               | ✓                        |
| See a list of project robots 查看项目机器人列表              |                          |            |                     | ✓               | ✓                        |
| Create/edit/delete project robots 创建/编辑/删除项目机器人   |                          |            |                     |                 | ✓                        |
| See configured CVE allowlist 查看配置的 CVE 允许列表         | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Create/edit/remove CVE allowlist 创建/编辑/删除 CVE 允许列表 |                          |            |                     |                 | ✓                        |
| View webhook events 查看 Webhook 事件                        |                          |            |                     | ✓               | ✓                        |
| Add new webhook events 添加新的 Webhook 事件                 |                          |            |                     |                 | ✓                        |
| Enable/deactivate webhooks 启用/停用 Webhook                 |                          |            |                     |                 | ✓                        |
| Create/delete tag retention rules 创建/删除代码保留规则      |                          |            | ✓                   | ✓               | ✓                        |
| Enable/deactivate tag retention rules 启用/停用代码保留规则  |                          |            | ✓                   | ✓               | ✓                        |
| Create/delete tag immutability rules 创建/删除标签不可变性规则 |                          |            |                     | ✓               | ✓                        |
| Enable/deactivate tag immutability rules 启用/停用标记不可变性规则 |                          |            |                     | ✓               | ✓                        |
| See project quotas 查看项目配额                              | ✓                        | ✓          | ✓                   | ✓               | ✓                        |
| Edit project quotas  * 编辑项目配额 *                        |                          |            |                     |                 |                          |
| Delete Project 删除项目                                      |                          |            |                     |                 | ✓                        |

\* Only the Harbor system administrator can edit project quotas and add new scanners.
\* 只有 Harbor 系统管理员才能编辑项目配额并添加新的扫描仪。

### 在数据库模式下创建用户帐户

In database authentication mode, the Harbor system administrator creates user accounts manually.
在数据库认证模式下，Harbor 系统管理员需要手动创建用户账号。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Under **Administration**, go to **Users**.
   在“管理”下，转到“用户”。

   

   ​    ![Create user account](https://goharbor.io/docs/2.11.0/img/create-user.png)  

   

3. Click **New User**. 单击“新建用户”。

4. Enter information about the new user.
   输入有关新用户的信息。

   

   ​    ![Provide user information](https://goharbor.io/docs/2.11.0/img/new-user.png)  

   

   - The username must be unique in the Harbor system
     用户名在 Harbor 系统中必须是唯一的
   - The email address must be unique in the Harbor system
     电子邮件地址在 Harbor 系统中必须是唯一的
   - The password must contain at least 8 characters with 1 lowercase letter, 1 uppercase letter and 1 numeric character
     密码必须至少包含 8 个字符，包括 1 个小写字母、1 个大写字母和 1 个数字字符

If users forget their password, they need to ask the administrator to  [reset their password](https://goharbor.io/docs/2.11.0/administration/managing-users/reset-user-password/)
如果用户忘记了密码，他们需要要求管理员重置密码

### 在数据库模式下重置用户密码

In database authentication mode, the Harbor system administrator can reset passwords for the specified users.
在数据库认证模式下，Harbor 系统管理员可以为指定用户重置密码。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Under **Administration**, go to **Users**.
   在“管理”下，转到“用户”。

   

   ​    ![User_list](https://goharbor.io/docs/2.11.0/img/create-user.png)  

   

3. Select an user then click the **Reset Password** button under the **Actions** dropdown.
   选择一个用户，然后单击“操作”下拉列表下的“重置密码”按钮。

   

   ​    ![Reset_user_password](https://goharbor.io/docs/2.11.0/img/reset-user-password.png)  

   

4. Enter a new password for the selected user.
   为所选用户输入新密码。

   

   ​    ![Enter_new_password](https://goharbor.io/docs/2.11.0/img/enter-new-password.png)  

   

- You are not allowed to reset your own password
  您不能重置自己的密码
- The new password must contain at least 8 characters with 1 lowercase letter, 1 uppercase letter and 1 numeric character
  新密码必须至少包含 8 个字符，包括 1 个小写字母、1 个大写字母和 1 个数字字符



## 配置全局设置

You can configure Harbor to set the registry in read-only mode, and  configure Harbor so that only system administrators can create projects.
您可以配置 Harbor 将注册表设置为只读模式，并将 Harbor 配置为只有系统管理员才能创建项目。

## Make the Registry Read Only 将注册表设为只读

You can set Harbor to read-only mode. In read-only mode, Harbor allows `docker pull` but prevents `docker push` and the deletion of repositories and tags.
您可以将 Harbor 设置为只读模式。在只读模式下，Harbor 允许 `docker pull` 但阻止 `docker push` 和删除仓库和标签。



​    ![Read-only mode](https://goharbor.io/docs/2.11.0/img/read-only.png)  



If it set to true, deleting repositories, tags and pushing images are not permitted.
如果设置为true，则不允许删除仓库、标签和推送镜像。



​    ![browse project](https://goharbor.io/docs/2.11.0/img/read-only-enable.png)  



```sh
docker push 10.117.169.182/demo/ubuntu:14.04
The push refers to a repository [10.117.169.182/demo/ubuntu]
0271b8eebde3: Preparing 
denied: The system is in read only mode. Any modification is prohibited.
```

## Set Who Can Create Projects 设置谁可以创建项目

Use the **Project Creation** drop-down menu to set which users can create projects. Select **Everyone** to allow all users to create projects. Select **Admin Only** to allow only users with the Harbor system administrator role to create projects.
使用项目创建下拉菜单设置哪些用户可以创建项目。选择“所有人”以允许所有用户创建项目。选择“仅管理员”，仅允许具有 Harbor 系统管理员角色的用户创建项目。



​    ![browse project](https://goharbor.io/docs/2.11.0/img/new-proj-create.png)  



## Retain image last pull time on scanning 在扫描时保留图像的最后拉取时间

By default, a vulnerability scanner(e.g. Trivy) will update the image’s last `pull time` when the image is scanned. This affects the **Tag Retention Rules** based on pull time. If you want to eliminate this effect, you can  enable this option to avoid updating the pull time on scanning.
默认情况下，漏洞扫描器（例如Trivy）将在扫描图像时更新图像的最后一次 `pull time` 更新。这会影响基于拉取时间的标签保留规则。如果要消除此影响，可以启用此选项以避免在扫描时更新拉取时间。



​    ![browse project](https://goharbor.io/docs/2.11.0/img/skip-pull-time.png)  



## Set a banner message on the Harbor UI 在 Harbor UI 上设置横幅消息

Set a custom banner message that will be displayed on the top of the Harbor UI， then every user including anonymous users can see the banner  message.
设置一个自定义横幅消息，该消息将显示在 Harbor UI 的顶部，然后每个用户（包括匿名用户）都可以看到横幅消息。

- **Message Content**: Enter your message content in the text area. This filed is required.
  消息内容：在文本区域中输入您的消息内容。此文件是必需的。
- **Message Type**: Select a message type, each message type has its corresponding style.
  消息类型：选择一种消息类型，每种消息类型都有其对应的样式。
- **Closable**: Decide whether the banner message can be closed temporarily.
  可关闭：决定是否可以暂时关闭横幅消息。
- **Duration**: Set the display time period of the banner message, which is from 0:00  of the start date to 0:00 of the end date. This filed is required.
  持续时间：设置横幅消息的显示时间段，即从开始日期的0：00到结束日期的0：00。此文件是必需的。



​    ![Banner Message](https://goharbor.io/docs/2.11.0/img/banner-message.png)  





## 配置项目配额

To exercise control over resource use, as a Harbor system administrator  you can set  quotas on projects. You can limit the amount of storage  capacity that a project can consume. You can set default quotas that  apply to all projects globally.
要对资源使用进行控制，作为 Harbor 系统管理员，您可以为项目设置配额。您可以限制项目可以使用的存储容量。您可以设置适用于全局所有项目的默认配额。

​                        

​                 Default quotas apply to projects that are created after you set  or change the default quota. The default quota is not applied to  projects that already existed before you set it.      
默认配额适用于在设置或更改默认配额后创建的项目。默认配额不适用于在设置默认配额之前已存在的项目。

You can also set quotas on individual projects. If you set a global default quota and you set different quotas on individual projects, the  per-project quotas are applied.
您还可以为单个项目设置配额。如果设置了全局默认配额，并且对单个项目设置了不同的配额，则将应用每个项目的配额。

By default, all projects have unlimited quotas for storage use.
默认情况下，所有项目都有无限的存储使用配额。

1. Select the **Project Quotas** view.
   选择“项目配额”视图。

   

   ​    ![Project quotas](https://goharbor.io/docs/2.11.0/img/project-quota1.png)  

   

2. To set global default quotas on all projects, click **Edit**.
   要为所有项目设置全局默认配额，请单击“编辑”。

   

   ​    ![Project quotas](https://goharbor.io/docs/2.11.0/img/project-quota2.png)  

   

   1. For **Default storage consumption**, enter the maximum quantity of storage that any project can consume, selecting `MiB`, `GiB`, or `TiB` from the drop-down menu, or enter `-1` to set the default to unlimited.
      对于“默认存储消耗”，输入任何项目可以消耗的最大存储量，从下拉菜单中选择 `MiB` 、 `GiB` 或 `TiB` Enter `-1` ，将默认值设置为无限制。

      ​    ![Project quotas](https://goharbor.io/docs/2.11.0/img/project-quota3.png)  

      

   2. Click **OK**. 单击“确定”。

3. To set quotas on an individual project, select the project and then click **Edit**.  
   若要在单个项目上设置配额，请选择该项目，然后单击“编辑”。

   ​    ![Project quotas](https://goharbor.io/docs/2.11.0/img/project-quota4.png)  

   

   1. For **Default storage consumption**, enter the maximum quantity of storage that this individual project can consume, selecting `MiB`, `GiB`, or `TiB` from the drop-down menu.
      对于默认存储消耗，输入此单个项目可以消耗的最大存储量，从下拉菜单中选择 `MiB` 、 `GiB` 或 `TiB` 。

After you set quotas, you can see how much of their quotas each project has consumed.
设置配额后，您可以查看每个项目消耗了多少配额。



​    ![Project quotas](https://goharbor.io/docs/2.11.0/img/project-quota5.png)  



### How Harbor Calculates Resource Usage Harbor 如何计算资源使用情况

When setting project quotas, it is useful to know how Harbor calculates  storage use, especially in relation to image pushing, retagging, and  garbage collection.
在设置项目配额时，了解 Harbor 如何计算存储使用量非常有用，尤其是在与图像推送、重新标记和垃圾回收相关的内容中。

- Harbor computes image size when blobs and manifests are pushed from the Docker client.
  Harbor 在从 Docker 客户端推送 blob 和清单时计算图像大小。

  ​                        

  ​                 When users push an image, the manifest is pushed last, after all of the associated blobs have been pushed successfully to the registry.  If several images are pushed concurrently and if there is an  insufficient number of tags left in the quota for all of them, images  are accepted in the order that their manifests arrive. Consequently, an  attempt to push an image might not be immediately rejected for exceeding the quota. This is because there was availability in the tag quota when the push was initiated, but by the time the manifest arrived the quota  had been exhausted.      
  当用户推送图像时，在所有关联的 blob  都已成功推送到注册表之后，最后推送清单。如果同时推送多个图像，并且所有图像的配额中剩余的标签数量不足，则将按照其清单到达的顺序接受图像。因此，推送图像的尝试可能不会因超过配额而立即被拒绝。这是因为在启动推送时，标签配额中存在可用性，但当清单到达时，配额已用尽。

- Shared blobs are only computed once per project. In Docker, blob sharing is  defined globally. In Harbor, blob sharing is defined at the project  level. As a consequence, overall storage usage can be greater than the  actual disk capacity.
  每个项目仅计算一次共享 blob。在 Docker 中，blob 共享是全局定义的。在 Harbor 中，blob 共享是在项目级别定义的。因此，总体存储使用量可能大于实际磁盘容量。

- Retagging images reserves and releases resources:
  重新标记图像、保留和释放资源：

  - If you retag an image within a project,  the storage usage does not change because there are no new blobs or manifests.
    如果在项目中重新标记图像，则存储使用情况不会更改，因为没有新的 blob 或清单。
  - If you retag an image from one project to another, the storage usage will increase.
    如果将图像从一个项目重新标记到另一个项目，则存储使用量将会增加。

- During garbage collection, Harbor frees the storage used by untagged blobs in the project.
  在垃圾回收期间，Harbor 会释放项目中未标记的 blob 使用的存储。

- Helm chart size is not calculated.
  不计算 Helm 图表大小。

   

## User-defined OCI artifact 用户定义的 OCI 工件

Harbor now can expands support for Machine Learning on K8s datamodels such as  Kubeflow datamodels. Actually, they are still OCI artifacts. These artifacts follow Harbor-specific configuration so that harbor can  show their rich metadata in a way and their icons. They are called  user-defined OCI artifact.
Harbor 现在可以在 K8s 数据模型（如 Kubeflow 数据模型）上扩展对机器学习的支持。实际上，它们仍然是 OCI 工件。这些项目遵循特定于  Harbor 的配置，以便 Harbor 可以以某种方式显示其丰富的元数据及其图标。它们称为用户定义的 OCI 工件。

## Harbor-specific Configuration 特定于 Harbor 的配置

The Harbor-specific configuration defines annotations keys in the manifest of an OCI artifact.
特定于 Harbor 的配置在 OCI 工件的清单中定义注释键。

- **`io.goharbor.artifact.v1alpha1.skip-list`** string `io.goharbor.artifact.v1alpha1.skip-list` 字符串
   It is in `manifest.config.annotations`.
  它位于 `manifest.config.annotations` .
   OPTIONAL property. The list of skip keys. Harbor will ignore these keys  in configuration JSON layer. The value for this key should be type  string separated by comma.
  OPTIONAL 属性。跳过键的列表。Harbor 将忽略配置 JSON 层中的这些键。此键的值应为字符串类型，以逗号分隔。
- **`io.goharbor.artifact.v1alpha1.icon`** empty string `io.goharbor.artifact.v1alpha1.icon` 空字符串
   It is in `manifest.layers[].annotations`.
  它位于 `manifest.layers[].annotations` .
   The identifier of artifact icon. The value for this key should be empty  string. Only key will be processed, the value will not be used. If an icon is used by artifacts, the icon must be a layer of artifacts  when building artifacts. Note: The mediaType of icons support “image/gif, image/png, image/jpeg”.
  项目图标的标识符。此键的值应为空字符串。仅处理键，不会使用该值。如果图标被工件使用，则在构建工件时，该图标必须是工件层。注意：图标的 mediaType 支持“image/gif、image/png、image/jpeg”。

## Example OCI Manifest 示例 OCI 清单

Example showing a user-defined OCI artifact:
显示用户定义的 OCI 工件的示例：

```fallback
{
    "schemaVersion": 2,
    "config": {
        "mediaType": "application/vnd.caicloud.model.config.v1alpha1+json",
        "digest": "sha256:be948daf0e22f264ea70b713ea0db35050ae659c185706aa2fad74834455fe8c",
        "size": 187,
        "annotations": {
            "io.goharbor.artifact.v1alpha1.skip-list": "metrics,git"
        }
    },
    "layers": [
        {
            "mediaType": "image/png",
            "digest": "sha256:d923b93eadde0af5c639a972710a4d919066aba5d0dfbf4b9385099f70272da0",
            "size": 166015,
            "annotations": {
                "io.goharbor.artifact.v1alpha1.icon": ""
            }
        },
        {
            "mediaType": "application/tar+gzip",
            "digest": "sha256:d923b93eadde0af5c639a972710a4d919066aba5d0dfbf4b9385099f70272da0",
            "size": 166015
        }
    ]
}
```

## User-defined OCI Artifact Example 用户定义的 OCI 工件示例

If you are interested in user-defined OCI artifact,  [ORMB](https://github.com/kleveross/ormb) is a great example.
如果您对用户定义的 OCI 工件感兴趣，ORMB 就是一个很好的示例。

## 配置复制

Replication allows users to replicate resources, namely images and charts, between  Harbor and non-Harbor registries, in both pull or push mode.
复制允许用户在 Harbor 和非 Harbor 注册表之间以拉取或推送模式复制资源，即图像和图表。

When the Harbor system administrator has set a replication rule, all  resources, and any associated Cosign signatures, that match the defined  filter patterns are replicated to the destination registry when the  triggering condition is met. Each resource that is replicated starts a  replication task. If the namespace does not exist in the destination  registry, a new namespace is created automatically. If it already exists and the user account that is configured in the replication policy does  not have write privileges in it, the process fails. Member information  is not replicated.
当 Harbor 系统管理员设置了复制规则时，当满足触发条件时，与定义的过滤器模式匹配的所有资源和任何关联的 Cosign  签名都将复制到目标注册表。复制的每个资源都会启动一个复制任务。如果命名空间在目标注册表中不存在，则会自动创建新的命名空间。如果该帐户已存在，并且复制策略中配置的用户帐户中没有写入权限，则该过程将失败。会员信息不会被复制。

There might be some delay during replication based on the condition of the  network. If a replication task fails, it is re-scheduled for a few  minutes later and retried several times.
根据网络状况，复制过程中可能会有一些延迟。如果复制任务失败，则会在几分钟后重新安排该任务，并重试几次。

​                        

​                 Due to API changes, replication between different versions of Harbor is not supported.      
由于 API 变更，不支持 Harbor 不同版本之间的复制。

------

##             Pages in this section           此部分中的页面

- ​              [                 Creating Replication Endpoints               
  创建复制端点](https://goharbor.io/docs/2.11.0/administration/configuring-replication/create-replication-endpoints/)            
- ​              [                 Creating a Replication Rule               
  创建复制规则](https://goharbor.io/docs/2.11.0/administration/configuring-replication/create-replication-rules/)            
- ​              [                 Running Replication Manually               
  手动运行复制](https://goharbor.io/docs/2.11.0/administration/configuring-replication/manage-replications/)            

创建复制端点

To replicate image repositories from one instance of Harbor to another  Harbor or non-Harbor registry, you first create replication endpoints.
要将镜像仓库从一个 Harbor 实例复制到另一个 Harbor 或非 Harbor 注册表，您首先需要创建复制端点。

​                        

​                 You can also use an endpoint in a proxy cache project. Read more about how to [Configure Proxy Cache](https://goharbor.io/docs/2.11.0/administration/configure-proxy-cache/).      
您还可以在代理缓存项目中使用端点。阅读有关如何配置代理缓存的更多信息。

1. Go to **Registries** and click the **+ New Endpoint** button.
   转到 Registries，然后单击 + New Endpoint 按钮。

   

   ​    ![New replication endpoint](https://goharbor.io/docs/2.11.0/img/replication-endpoint1.png)  

   

2. For **Provider**, use the drop-down menu to select the type of registry to set up as a replication endpoint.
   对于 Provider （提供程序），使用下拉菜单选择要设置为复制终结点的注册表类型。

   The endpoint can be another Harbor instance, or a non-Harbor registry.  Currently, the following non-Harbor registries are supported:
   端点可以是另一个 Harbor 实例，也可以是非 Harbor 注册表。目前，支持以下非 Harbor 注册表：

   - Docker Hub Docker Hub（Docker 中心）
   - Docker registry Docker 注册表
   - AWS Elastic Container Registry
     AWS 弹性容器注册表
   - Azure Container Registry
     Azure 容器注册表
   - Ali Cloud Container Registry
     阿里云容器镜像服务
   - Google Container Registry (and Google Cloud Artifact Registry)
     Google Container Registry（和 Google Cloud Artifact Registry）
   - Huawei SWR 华为SWR
   - Gitlab Gitlab的
   - Quay 码头
   - Jfrog Artifactory Jfrog 文物

   ​                        

   ​                 If you plan to use this endpoint in a proxy cache project, note  that they only support Harbor, Docker Hub, AWS Elastic Container  Registry, Azure Container Registry, Google Container Registry/Google  Cloud Artifact Registry, and Quay registries. Read more about how to [Configure Proxy Cache](https://goharbor.io/docs/2.11.0/administration/configure-proxy-cache/).      
   如果您计划在代理缓存项目中使用此端点，请注意，它们仅支持 Harbor、Docker Hub、AWS Elastic Container Registry、Azure Container  Registry、Google Container Registry/Google Cloud Artifact Registry 和 Quay 注册表。阅读有关如何配置代理缓存的更多信息。

   

   ​    ![Replication providers](https://goharbor.io/docs/2.11.0/img/replication-endpoint2.png)  

   

3. Enter a suitable name and description for the new replication endpoint.
   为新的复制终结点输入合适的名称和描述。

4. Enter the full URL of the registry to set up as a replication endpoint.
   输入注册表的完整 URL，以设置为复制终结点。

   For example, to replicate to another Harbor instance, enter  https://harbor_instance_address:443. The registry must exist and be  running before you create the endpoint.
   例如，要复制到另一个 Harbor 实例，请输入 https：//harbor_instance_address：443。在创建终结点之前，注册表必须存在并正在运行。

5. Enter the Access ID and Access Secret for the endpoint registry instance.
   输入端点注册表实例的 Access ID 和 Access Secret。

   Use an account that has the appropriate privileges on that registry, or an  account that has write permission on the corresponding project in a  Harbor registry. See more information about  [Access ID and Secret Configuration](https://goharbor.io/docs/2.11.0/administration/configuring-replication/create-replication-endpoints/#access-id-and-secret-configuration).
   使用对该注册表具有适当权限的帐户，或者使用对 Harbor 注册表中的相应项目具有写入权限的帐户。请参阅有关访问 ID 和密钥配置的更多信息。

   ​                        

   ​                 If you plan to use this endpoint with a proxy cache project, the access accounts you provide here enables the proxy cache project to  pull every image from the target registry that the access account has  permission to pull.      
   如果您计划将此端点与代理缓存项目一起使用，则您在此处提供的访问帐户使代理缓存项目能够从访问帐户有权拉取的目标注册表中拉取每个图像。

6. Optionally, select the **Verify Remote Cert** check box.
   （可选）选中“验证远程证书”复选框。

   Deselect the check box if the remote registry uses a self-signed or untrusted certificate.
   如果远程注册表使用自签名证书或不受信任的证书，请取消选中该复选框。

7. Click **Test Connection**. 单击“测试连接”。

8. When you have successfully tested the connection, click **OK**.
   成功测试连接后，单击“确定”。

## Access ID and Secret Configuration 访问 ID 和密钥配置

- AWS ECR adapters should use access keys, not a username and password.The  access key should have sufficient permissions, such as  storagepermission.
  AWS ECR 适配器应使用访问密钥，而不是用户名和密码。访问密钥应具有足够的权限，例如 storagepermission。

- Google GCR adapters should use the entire JSON key generated in the service  account. The namespace should start with the project ID.
  Google GCR 适配器应使用服务帐号中生成的整个 JSON 密钥。命名空间应以项目 ID 开头。

- Quay Registry 码头登记处

  - Supported scope

     支持的范围

    - [Quay.io](https://quay.io) (cloud version) does not allow to create namespaces (organizations) automaticaly, due to Recaptcha enabled on the Quay.io side.
      Quay.io（云版）不允许自动创建命名空间（组织），因为在 Quay.io 端启用了 Recaptcha。
    - [RedHat Quay](https://www.openshift.com/products/quay) (enterprise on-premises version) is fully supported (tested on v3.2.0)
      完全支持 RedHat Quay（企业本地版本）（在 v3.2.0 上测试）
    - [Project Quay](https://github.com/quay/quay) (open sourced version) is also supported theoretically, but has not been tested yet.
      Project Quay（开源版本）在理论上也是受支持的，但还没有经过测试。

  - Authorization

     授权

    - If you are connecting to a registry without authorization, keep Access ID and Access Secret empty.
      如果在未经授权的情况下连接到注册表，请将 Access ID 和 Access Secret 留空。
    - If you are connecting to a registry with authorization, you don’t need to  input an Access ID. Harbor uses json_file as the default Access ID.  Input your Access Secret in json format, example:
      如果您通过授权连接到注册表，则无需输入访问 ID。 Harbor 使用 json_file 作为默认的访问 ID。 以 json 格式输入您的访问密钥，示例：

    ```fallback
    {
    "oauth2_token": "YmQZ1QZENVmOD6v9kENzmfptNVhgBuy5oVl85eGV", // optional
    "account_name": "jack",
    "docker_cli_password": "q6NVazikNqIf4coiQ+JvV4iqiCpkNjE0DLX8ZMQuFRbkHk5iMv6/hd4WdV3W3nyX"
    }
    ```

    - `oauth2_token` is required only if you want to create an organization automatically.
       `oauth2_token` 仅当要自动创建组织时才需要。
    - `account_name` is your login name. Its not recommended to use a robot account because a robot account can not access different organization’s repositories.
       `account_name` 是您的登录名。不建议使用机器人帐户，因为机器人帐户无法访问不同组织的存储库。
    - `docker_cli_password` is your cli password. You can generate this on the Quay ui page.
       `docker_cli_password` 是您的 CLI 密码。您可以在 Quay ui 页面上生成此内容。

  ​                        

  ​                 Harbor does not support Docker registry manifest schema1 in Quay registries.      
  Harbor 不支持 Quay 注册表中的 Docker 注册表清单 schema1。

## Managing Registries 管理注册表

You can list, add, edit and delete registries under **Administration** -> **Registries**. Only registries which are not referenced by any rules can be deleted.
您可以在“管理”->“注册表”下列出、添加、编辑和删除注册表。只有未被任何规则引用的注册表才能被删除。



​    ![browse project](https://goharbor.io/docs/2.11.0/img/manage-registry.png)  



创建复制规则

A replication endpoint must exist before you create a replication rule. To create an endpoint, follow the instructions in  [Creating Replication Endpoints](https://goharbor.io/docs/2.11.0/administration/configuring-replication/create-replication-endpoints/).
在创建复制规则之前，必须存在复制终结点。要创建终端节点，请按照创建复制终端节点中的说明进行操作。

​                        

​                 Because of major API changes in the v2.0 release to support [OCI](https://github.com/opencontainers/distribution-spec). You **can not** replicate from Harbor v1.x to v2.0 and later, and you **can not** replicate artifacts with **manifest list** from v2.0 and later to v1.x.      
由于 v2.0 版本中为 OCI 进行了重大 API 更改。您无法从 Harbor v1.x 复制到 v2.0 及更高版本，也无法将带有清单列表的工件从 v2.0 及更高版本复制到 v1.x。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Replications**.
   展开“管理”，然后选择“复制”。

   

   ​    ![Add a replication rule](https://goharbor.io/docs/2.11.0/img/replication-rule1.png)  

   

3. Click **New Replication Rule**.
   单击“新建复制规则”。

4. Provide a name and description for the replication rule.
   提供复制规则的名称和描述。

5. Select **Push-based** or **Pull-based** replication, depending on whether you want to replicate artifacts to or from the remote registry.
   选择“基于推送的复制”或“基于拉取的复制”，具体取决于是要将项目复制到远程注册表还是从远程注册表复制项目。

   

   ​    ![Replication mode](https://goharbor.io/docs/2.11.0/img/replication-rule2.png)  

   

6. If you are creating a Pull-based rule, use the **Soure Registry** drop-down menu to select from the configured replication endpoints.
   如果要创建基于拉取的规则，请使用 Soure Registry 下拉菜单从配置的复制端点中进行选择。

7. For **Source resource filter**, identify the artifacts to replicate.
   对于 Source resource filter （源资源筛选器），确定要复制的项目。

   

   ​    ![Replication filters](https://goharbor.io/docs/2.11.0/img/replication-rule3.png)  

   

   - **Name**: Replicate resources with a given name by entering an artifact name or fragment.
     名称：通过输入项目名称或片段来复制具有给定名称的资源。
   - **Tag**: Replicate resources with a given tag by entering a tag name or  fragment. You can also specify matching/excluding for this filter.
     标签：通过输入标签名称或片段来复制具有给定标签的资源。您还可以为此过滤器指定匹配/排除。
   - **Label**: Replicate resources with a given label by using the drop-down menu to  select from the available labels. You can also specify  matching/excluding for this filter.
     标签：使用下拉菜单从可用标签中进行选择，复制具有给定标签的资源。您还可以为此过滤器指定匹配/排除。
   - **Resource**: Replicate images, artifacts or all. Artifacts contain images and other OCI compatible resources.
     资源：复制图像、工件或所有。项目包含映像和其他 OCI 兼容资源。

   The name filter and tag filters support the following patterns:
   名称筛选器和标记筛选器支持以下模式：

   - *****: Matches any sequence of non-separator characters `/`.
     *：匹配任何非分隔符 `/` 序列。
   - ***\***: Matches any sequence of characters, including path separators `/`. Note that the doublestar must appear as a path component by itself. A  pattern such as /path** is invalid and will be treated the same as  /path*, but /path*/** should achieve the desired result.
     **：匹配任何字符序列，包括路径分隔符 `/` 。请注意，双星号必须单独显示为路径组件。像 /path** 这样的模式是无效的，将被视为与 /path* 相同，但 /path*/** 应该达到预期的结果。
   - **?**: Matches any single non-separator character `/`.
     ？：匹配任何单个非分隔符 `/` 。
   - **{alt1,…}**: Matches a sequence of characters if one of the comma-separated alternatives matches.
     {alt1,...}：如果其中一个逗号分隔的备选项匹配，则匹配字符序列。

   **NOTE:** You must add `library` if you want to replicate the official artifacts of Docker Hub. For example, `library/hello-world` matches the official hello-world artifacts.
   注意：如果要复制Docker Hub的官方工件，则必须添加 `library` 。例如， `library/hello-world` 匹配官方你好世界工件。

   | Pattern 模式            | String(Match or not) 字符串（匹配与否）                      |
   | ----------------------- | ------------------------------------------------------------ |
   | `library/*`             | `library/hello-world`(Y) `library/hello-world` （Y）  `library/my/hello-world`(N) `library/my/hello-world` （北） |
   | `library/**`            | `library/hello-world`(Y) `library/hello-world` （Y）  `library/my/hello-world`(Y) `library/my/hello-world` （Y） |
   | `{library,goharbor}/**` | `library/hello-world`(Y) `library/hello-world` （Y）  `goharbor/harbor-core`(Y) `goharbor/harbor-core` （Y）  `google/hello-world`(N) `google/hello-world` （北） |
   | `1.?`                   | `1.0`(Y) `1.0` （Y）  `1.01`(N) `1.01` （北）                |

8. If you are creating a Push-based replication rule, use the **Destination Registry** drop-down menu to select from the configured replication endpoints.
   如果要创建基于推送的复制规则，请使用 Destination Registry 下拉菜单从配置的复制端点中进行选择。

9. For **Destination Namespace**, enter the name of the namespace in which to replicate resources in the  text box. If you do not enter a namespace, resources are placed in the  same namespace as in the source registry.
   对于 Destination Namespace，请在文本框中输入要在其中复制资源的命名空间的名称。如果不输入命名空间，则资源将放置在与源注册表相同的命名空间中。

10. Use the Destination Flattening drop-down to select how you want Harbor  treat to image hierarchy when replicating images. Depending on what you  select, Harbor will remove the same number of levels from the image’s  hierarchy, starting from the left, when replicating an image into your  chosen destination namespace.
    使用“目标展平”下拉列表选择在复制图像时希望 Harbor 处理图像层次结构的方式。根据您选择的内容，在将图像复制到您选择的目标命名空间时，Harbor 将从图像的层次结构中删除相同数量的级别（从左侧开始）。

    - **Flatten All Levels**: Remove all hierarchy from the replicated image. For example, `a/b/c/d/img` replicates to `namespace/img`. This is the default behavior of replication in v2.2 and before. All  replication rules created before upgrading to v2.3.0 will default to  using this flattening option after upgrade.
      展平所有级别：从复制的映像中删除所有层次结构。例如， `a/b/c/d/img` 复制到 `namespace/img` .这是 v2.2 及更早版本中复制的默认行为。在升级到 v2.3.0 之前创建的所有复制规则在升级后将默认使用此平展选项。
    - **No Flattening**: Use the same hierarchy when replicating an image. For example, `a/b/c/d/img` replicates to `namespace/a/b/c/d/img`.
      无拼合：复制图像时使用相同的层次结构。例如， `a/b/c/d/img` 复制到 `namespace/a/b/c/d/img` .
    - **Flattening 1 level**: Remove one level from the image hierarchy. For example, `a/b/c/d/img` replicates to `namespace/b/c/d/img`. This is the default selection.
      拼合 1 个级别：从图像层次结构中删除一个级别。例如， `a/b/c/d/img` 复制到 `namespace/b/c/d/img` .这是默认选择。
    - **Flattening 2 levels**: Remove two levels from the image hierarchy. For example, `a/b/c/d/img` replicates to `namespace/c/d/img`
      拼合 2 个级别：从图像层次结构中删除两个级别。例如， `a/b/c/d/img` 复制到 `namespace/c/d/img` 
    - **Flattening 3 levels**: Remove three levels from the image hierarchy. For example, `a/b/c/d/img` replicates to `namespace/d/img`
      拼合 3 个级别：从图像层次结构中删除三个级别。例如， `a/b/c/d/img` 复制到 `namespace/d/img` 

11. Use the Trigger Mode drop-down menu to select how and when to run the rule.
    使用触发器模式下拉菜单选择规则的运行方式和时间。

    - **Manual**: Replicate the resources manually when needed. **Note**: Deletion operations are not replicated.
      手动：在需要时手动复制资源。注意：删除操作不会被复制。
    - **Scheduled**: Replicate the resources periodically by defining a cron job. **Note**: Deletion operations are not replicated.
      已计划：通过定义 cron 作业定期复制资源。注意：删除操作不会被复制。
    - **Event Based**: When a new resource is pushed to the project, or an artifact is  retagged, it is replicated to the remote registry immediately. If you  select the **Delete remote resources when locally deleted**, if you delete an artifact, it is automatically deleted from the replication target.
      基于事件：当新资源被推送到项目，或者工件被重新标记时，它会立即复制到远程注册表。如果选择“本地删除远程资源时删除远程资源”，则在删除项目时，它将自动从复制目标中删除。

    ​                        

    ​                 You can filter artifacts for replication based on the labels  that are applied to the artifacts. However, changing a label on an  artifact does not trigger replication. Event-based replication is  limited to pushing, retagging, and deleting artifacts.      
    您可以根据应用于项目的标签筛选要复制的项目。但是，更改工件上的标签不会触发复制。基于事件的复制仅限于推送、重新标记和删除项目。

    

    ​    ![Trigger mode](https://goharbor.io/docs/2.11.0/img/replication-rule5.png)  

    

12. Optionally set the maximum network bandwidth for each replication task, please pay attention to the number of concurrent executions, the default value is  10 for each job-service pod. The unit is kilo bytes per second, and -1  stands for unlimited bandwith.
    可选择为每个复制任务设置最大网络带宽，请注意并发执行的次数，每个作业服务 Pod 的默认值为 10。该单位是千字节/秒，-1 代表无限带宽。

    

    ​    ![Bandwidth](https://goharbor.io/docs/2.11.0/img/replication-rule7.png)  

    

    ​                        

    ​                 There’s a known issue [15708](https://github.com/goharbor/harbor/issues/15708), that if you limit the bandwidth too slow, and stop the replication job, it may take quite a long time to really release the job worker to run a new job.      
    存在一个已知问题 15708，即如果将带宽限制得太慢，并停止复制作业，则可能需要相当长的时间才能真正释放作业辅助角色来运行新作业。

13. Optionally select the Override checkbox to force replicated resources to replace  resources at the destination with the same name.
    （可选）选中“覆盖”（Override） 复选框，以强制复制的资源替换目标中具有相同名称的资源。

    

    ​    ![Override](https://goharbor.io/docs/2.11.0/img/replication-rule8.png)  

    

14. Optionally select the Copy by chunk checkbox to enable the artifact blobs copied  by chunks, currently only supported for source and destination registry  are both harbor, but you can enable this by calling harbor API manually  for other type registries.  
    （可选）选中 Copy by chunk 复选框以启用按块复制的工件 blob，目前只有源注册表和目标注册表都支持 harbor，但您可以通过手动调用 harbor API 来为其他类型注册表启用此功能。

    ​    ![Copy by chunk](https://goharbor.io/docs/2.11.0/img/replication-rule9.png)  

    

    ​                        

    ​                 Copy by chunk has not been verified officially between harbor  and other type registries. The default chunk size is 10MB, you can  override it by setting env `REPLICATION_CHUNK_SIZE` in the jobservice, the value should be united as bytes, for example `10MB=1024*1024*10` then you should set `REPLICATION_CHUNK_SIZE=10485760`.      
    按块复制尚未在 Harbor 和其他类型注册表之间正式验证。默认的块大小是 10MB，你可以通过在 jobservice 中设置 env `REPLICATION_CHUNK_SIZE` 来覆盖它，值应该统一为字节，例如 `10MB=1024*1024*10` 你应该设置 `REPLICATION_CHUNK_SIZE=10485760` .

15. Click **Save** to create the replication rule.
    单击“保存”以创建复制规则。

手动运行复制

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Replications**.
   展开“管理”，然后选择“复制”。

3. Select a replication rule and click **Replicate**.
   选择复制规则，然后单击复制。

   

   ​    ![Add a replication rule](https://goharbor.io/docs/2.11.0/img/replication-rule6.png)  

   

   The resources to which the rule is applied start to replicate from the source registry to the destination immediately.
   应用规则的资源将立即开始从源注册表复制到目标。

4. Click the rule to see its execution status.
   单击规则可查看其执行状态。

5. Click the **ID** of the execution to see the details of the replication  and the task list. The count of `IN PROGRESS` status in the summary includes both `Pending` and `In Progress` tasks.
   单击执行的 ID 可查看复制的详细信息和任务列表。摘要中的 `IN PROGRESS` 状态计数包括 `Pending` 和 `In Progress` 任务。

6. Optionally click **STOP** to stop the replication.
   （可选）单击“停止”以停止复制。

7. Click the log icon to see detailed information about the replication task.
   单击日志图标可查看有关复制任务的详细信息。

   

   ​    ![View replication task](https://goharbor.io/docs/2.11.0/img/list-tasks.png)  

   

To edit or delete a replication rule, select the replication rule in the **Replications** view and click **Edit** or **Delete**. Only rules which have no executions in progress can be edited deleted.
要编辑或删除复制规则，请在“复制”视图中选择复制规则，然后单击“编辑”或“删除”。只有没有正在执行的规则才能被编辑、删除。



​    ![Delete or edit rule](https://goharbor.io/docs/2.11.0/img/replication-rule6.png)  

## P2P Preheat                P2P预热

P2P preheating integrates key P2P distribution capabilities of CNCF projects like  [Dragonfly](https://github.com/dragonflyoss/Dragonfly) (v1.0.5+) and Uber  [Kraken](https://github.com/uber/kraken) (v0.1.3+) into Harbor and allow users to define policies around this action.
P2P预热将蜻蜓（v1.0.5+）和优步海妖（v0.1.3+）等CNCF项目的关键P2P分发能力集成到Harbor中，并允许用户围绕此动作定义策略。

Before preheating images from Harbor, you must first install a P2P engine in your environment. Refer to your P2P distribution engine’s installation guide for specific configuration steps.
在从 Harbor 预热图像之前，您必须先在您的环境中安装 P2P 引擎。请参阅 P2P 分发引擎的安装指南，了解具体的配置步骤。

​                        

​                 Due to the limitations of the Kraken preheat API, there are extra configurations steps needed. Follow the Kraken [configuration guide](https://github.com/uber/kraken/blob/master/docs/INTEGRATEWITHHARBOR.md) for more information on integrating Kraken and Harbor.      
由于 Kraken 预热 API 的限制，需要额外的配置步骤。按照 Kraken 配置指南了解有关集成 Kraken 和 Harbor 的更多信息。

The system admin can create P2P preheat provider instances by providing preheat API endpoint of the selected vendor (Dragonfly or Kraken) and related credential if necessary. The created preheat provider instances can be used across all the projects.
如有必要，系统管理员可以通过提供所选供应商（Dragonfly 或 Kraken）的预热 API 端点和相关凭证来创建 P2P 预热提供商实例。创建的预热提供程序实例可以跨所有项目使用。

The project admin can create multiple preheat policies under the specified  project by setting the resource filters and preheat criteria (including: content trust and vulnerability situation)  and choosing the P2P preheat provider instance added by the system administrator. The preheating policy can be  triggered to start by manual, on a scheduled basis, or event-based ways. When the preheating policy is executing, all the images that match the  criteria defined in the policy will be distributed to and cached in the target P2P engine for future pulling requests.
项目管理员可以通过设置资源过滤器和预热条件（包括：内容信任和漏洞情况）并选择系统管理员添加的P2P预热提供商实例，在指定项目下创建多个预热策略。预热策略可以通过手动、定时或基于事件的方式触发启动。当预热策略正在执行时，所有符合策略中定义的条件的图片都会被分发到目标 P2P 引擎并缓存在目标 P2P 引擎中，以便将来进行拉取请求。

Harbor records each time a preheating policy is executed. You can check the details of preheating executions and the related logs from the Project’s page.
Harbor 记录每次执行预热策略的时间。您可以从项目页面查看预热执行的详细信息和相关日志。

### Manage Preheat Provider Instances      
管理预热提供商实例            

### Create Preheat Provider Instance 创建预热提供程序实例

To preheat images, you need to create preheat provider instances first.
要预热图像，您需要先创建预热提供者实例。

1. Go to **Distributions** item under **Administration** and click **+NEW INSTANCE** to open the creation dialog.
   转到“管理”下的“分发”项，然后单击“+新建实例”以打开创建对话框。

   

   ​    ![creation dialog](https://goharbor.io/docs/2.11.0/img/p2p-preheat/creation-dialog.png)  

   

2. For the **Provider**, select **Dragonfly** or **Kraken** based on the target P2P environment.
   对于提供商，请根据目标 P2P 环境选择 Dragonfly 或 Kraken。

3. Enter a proper name and description (optional) for the new P2P provider instance.
   输入新的 P2P 提供商实例的正确名称和描述（可选）。

4. Input the preheating API endpoint of the target P2P provider. e.g.: http://my-provider.com or http://my-provider.com:8002
   输入目标 P2P 提供商的预热 API 端点。例如：http://my-provider.com 或 http://my-provider.com:8002

5. Select the proper **Auth Mode** based on the target P2P provider configuration and, if required, input the necessary access credentials. The following modes are supported: So far, the following modes are supported:
   根据目标 P2P 提供商配置选择正确的身份验证模式，如果需要，请输入必要的访问凭据。支持以下模式： 到目前为止，支持以下模式：

   - **NONE**: no authentication needed.
     NONE：无需身份验证。
   - **Basic**: HTTP basic authentication mode, **Username** and **Password** are required.
     基础：HTTP基本认证模式，用户名和密码是必需的。
   - **OAuth**: OAuth bearer token mode, bearer **Token** is required.
     OAuth：OAuth 持有者令牌模式，需要持有者令牌。

6. Check or uncheck the **Enable** checkbox to enable/deactivate the instance after creation.
   选中或取消选中 Enable （启用） 复选框以在创建实例后启用/停用实例。

7. Optionally, select the **Skip certificate verification** check box.
   （可选）选中“跳过证书验证”复选框。

   Select the check box if the preheat provider instance uses a self-signed or untrusted certificate.
   如果预热提供程序实例使用自签名证书或不受信任的证书，请选中该复选框。

8. Click **TEST CONNECTION** button to test the connectivity of the creating instance.
   单击 TEST CONNECTION 按钮以测试创建实例的连通性。

9. If the connectivity testing is successful, click **OK** button to save the creating instance.
   如果连通性测试成功，请单击“确定”按钮以保存创建实例。

### Manage Preheat Provider Instances 管理预热提供商实例

The existing configured preheat provider instances are listed in the datagrid view.
现有配置的预热提供程序实例列在数据网格视图中。

​                        

​                 The healthy status of the managed provider instances are also shown in the view. If the connectivity of the provider instance is ok, the status column will be marked with **Healthy** in a green box.      
受管提供商实例的运行状况也会显示在视图中。如果提供程序实例的连接正常，则状态列将在绿色框中标记为“正常”。



​    ![provider instances](https://goharbor.io/docs/2.11.0/img/p2p-preheat/provider-instances.png)  



Select the provider instance by checking the checkbox at front of the row, click **ACTIONS** to open the drop down menu.
通过选中行前面的复选框来选择提供程序实例，然后单击“操作”以打开下拉菜单。



​    ![actions](https://goharbor.io/docs/2.11.0/img/p2p-preheat/actions.png)  



1. Click **Edit** to open the edit dialog to do modifications to the selected provider instance.
   单击“编辑”以打开编辑对话框，以对选定的提供程序实例进行修改。
2. Click **Enable**/**Deactivate** to enable/deactivate the selected provider instance if it is disabled/deactivated.
   单击“启用/停用”以启用/停用选定的提供程序实例（如果该实例已禁用/停用）。
3. Click **Delete** to delete the selected provider instance.
   单击“删除”以删除选定的提供程序实例。

​                        

​                 Only P2P provider instances which are not referenced by any preheat policies can be deleted. Delete all the related preheat policies and then try deleting again.      
只能删除未被任何预热策略引用的 P2P 提供商实例。删除所有相关的预热策略，然后再次尝试删除。

## 配置代理缓存

Proxy cache allows you to use Harbor to proxy and cache images from a target  public or private registry. As of Harbor v2.1.1, the proxy cache feature was updated to align with  [Docker Hub’s rate limit policy](https://www.docker.com/blog/scaling-docker-to-serve-millions-more-developers-network-egress/). If you plan to use proxy cache with your Harbor instance, it is  strongly recommended that you use v2.1.1 or later to avoid being rate  limited.
代理缓存允许您使用 Harbor 来代理和缓存来自目标公共或私有注册表的图像。从 Harbor v2.1.1 开始，代理缓存功能已更新，以符合 Docker  Hub 的速率限制策略。如果您计划在 Harbor 实例上使用代理缓存，强烈建议您使用 v2.1.1 或更高版本，以避免受到速率限制。

You can use a proxy cache to pull images from a target Harbor or non-Harbor registry in an environment with limited or no access to the internet.  You can also use a proxy cache to limit the amount of requests made to a public registry, avoiding consuming too much bandwidth or being  throttled by the registry server.
您可以使用代理缓存从目标 Harbor 或非 Harbor 注册表中提取图像，这些环境下的 Internet 访问受限或无法访问 Internet。您还可以使用代理缓存来限制向公共注册表发出的请求量，从而避免消耗过多带宽或受到注册表服务器的限制。

​                        

Harbor supports proxy caching for the following registries:
Harbor 支持以下注册表的代理缓存：

- Harbor 港
- Docker Hub Docker Hub（Docker 中心）
- Docker registry Docker 注册表
- AWS Elastic Container Registry
  AWS 弹性容器注册表
- Azure Container Registry
  Azure 容器注册表
- Google Container Registry
  Google 容器注册表
- Quay 码头
- Github Container Registry
  Github 容器注册表
- JFrog Artifactory Registry
  JFrog Artifactory 注册表

A Harbor system administrator configures a proxy cache by creating a  proxy cache project, which connects to a target registry using a  registry endpoint you have configured. A proxy cache project works  similarly to a normal Harbor project, except that you are not able to  push images to a proxy cache project.
Harbor 系统管理员通过创建代理缓存项目来配置代理缓存，该项目使用您配置的注册表端点连接到目标注册表。代理缓存项目的工作方式与普通的 Harbor 项目类似，不同之处在于您无法将图像推送到代理缓存项目。

To use a Harbor proxy cache, configure your docker pull commands and pod  manifests to pull images from the proxy cache project instead of the  target registry.
要使用 Harbor 代理缓存，请配置 docker pull 命令和 pod 清单，以从代理缓存项目而不是目标注册表中提取图像。

## How Harbor proxy cache works Harbor 代理缓存的工作原理

When a pull request comes to a proxy cache project, if the image is not  cached, Harbor pulls the image from the target registry and serves the  pull command as if it is a local image from the proxy cache project. The proxy cache project then caches the image for a future request.
当拉取请求来到代理缓存项目时，如果镜像没有被缓存，Harbor 会从目标注册表中拉取镜像，并像从代理缓存项目中的本地镜像一样提供拉取命令。然后，代理缓存项目会缓存图像以供将来的请求使用。

The next time a user requests that image, Harbor checks the image’s latest  manifest in the target registry and serves the image based on the  following scenarios:
下次用户请求该镜像时，Harbor 会在目标注册表中检查镜像的最新清单，并根据以下情况提供该镜像：

- If the image has not been updated in the target registry, the cached image is served from the proxy cache project.
  如果尚未在目标注册表中更新映像，则从代理缓存项目提供缓存的图像。
- If the image has been updated in the target registry, the new image is  pulled from the target registry, then served and cached in the proxy  cache project.
  如果映像已在目标注册表中更新，则会从目标注册表中提取新映像，然后在代理缓存项目中提供和缓存。
- If the target registry is not reachable, the proxy cache project serves the cached image.
  如果无法访问目标注册表，则代理缓存项目将提供缓存的图像。
- If the image is no longer in the target registry, no image is served.
  如果映像不再位于目标注册表中，则不会提供任何映像。

As of Harbor v2.1.1, Harbor proxy cache fires a HEAD request to determine  whether any layer of a cached image has been updated in the Docker Hub  registry. Using this method to check the target registry will not  trigger the  [Docker Hub rate limiter](https://www.docker.com/blog/scaling-docker-to-serve-millions-more-developers-network-egress/). If any image layer was updated, the proxy cache will pull the new image, which will count towards the Docker Hub rate limiter.
从 Harbor v2.1.1 开始，Harbor 代理缓存会触发 HEAD 请求，以确定 Docker Hub  注册表中是否更新了缓存图像的任何层。使用此方法检查目标注册表不会触发 Docker Hub  速率限制器。如果更新了任何图像层，代理缓存将拉取新图像，该图像将计入 Docker Hub 速率限制器。

## Create Proxy Cache Project 创建代理缓存项目

To set up a proxy cache, a Harbor system administrators can create a proxy cache project that connects to a target registry using a registry  endpoint.
要设置代理缓存，Harbor 系统管理员可以创建一个代理缓存项目，该项目使用注册表端点连接到目标注册表。

A proxy cache project is able to use the same features available to a  normal Harbor project, except that you are not able to push images to a  proxy cache project. For more information on projects, see the  [Working with Projects](https://goharbor.io/docs/2.11.0/working-with-projects/) documentation.
代理缓存项目能够使用与普通 Harbor 项目相同的功能，只是您无法将图像推送到代理缓存项目。有关项目的更多信息，请参阅“使用项目”文档。

1. Before creating a proxy cache project, create a registry endpoint for the proxy cache project to use. See how to  [create a registry endpoint](https://goharbor.io/docs/2.11.0/administration/configuring-replication/create-replication-endpoints/).
   在创建代理缓存项目之前，请为要使用的代理缓存项目创建注册表终结点。了解如何创建注册表终结点。

   ​                        

   ​                 Proxy cache projects can pull every image from the target  registry that the access account you configure in the registry endpoint  has access to. This means that Harbor users with access to the proxy  cache project are able to pull any image available to the access account in the target repository.      
   代理缓存项目可以从目标注册表中提取您在注册表终结点中配置的访问帐户有权访问的每个图像。这意味着，有权访问代理缓存项目的 Harbor 用户能够在目标仓库中拉取访问账户可用的任何镜像。

2. On the Projects page, click **New Project** and configure the new project information. See the  [Create Projects](https://goharbor.io/docs/2.11.0/working-with-projects/create-projects/) documentation for more details.
   在“项目”页面上，单击“新建项目”，配置新的项目信息。有关更多详细信息，请参阅创建项目文档。

3. Click the **Proxy Cache** slider and then select your registry endpoint from the drop-down that appears.
   单击“代理缓存”滑块，然后从显示的下拉列表中选择注册表终结点。

   

   ​    ![add proxy cache project](https://goharbor.io/docs/2.11.0/img/add-proxy-cache-project.png)  

   

4. Click **OK**. 单击“确定”。

You can view all available proxy cache projects from the Projects page.
您可以从“项目”页面查看所有可用的代理缓存项目。

By default, Harbor creates a 7 day retention policy for each new proxy cache project. See more about  [Tag Retention Policies](https://goharbor.io/docs/2.11.0/working-with-projects/working-with-images/create-tag-retention-rules/).
默认情况下，Harbor 会为每个新的代理缓存项目创建 7 天的保留策略。请参阅有关标签保留策略的更多信息。

To start using the proxy cache, configure your docker pull commands or pod manifests to reference the proxy cache project by adding `<harbor_servername>/<proxy_project_name>/` as a prefix to the image tag. For example:
要开始使用代理缓存，请配置 docker pull 命令或 pod 清单，通过向图像标记添加 `<harbor_servername>/<proxy_project_name>/` 作为前缀来引用代理缓存项目。例如：

```bash
> docker pull <harbor_server_name>/<proxy_project_name>/goharbor/harbor
```

## 漏洞扫描

Harbor provides static analysis of vulnerabilities in images through the open source projects  [Trivy](https://github.com/aquasecurity/trivy). To be able to use Trivy you must have enabled Trivy when you installed  your Harbor instance (by appending installation options `--with-trivy`). For information about installing Harbor with Trivy, see the  [Run the Installer Script](https://goharbor.io/docs/2.11.0/install-config/run-installer-script/).
Harbor 通过开源项目 Trivy 提供图像中漏洞的静态分析。为了能够使用 Trivy，您必须在安装 Harbor 实例时启用 Trivy（通过附加安装选项 `--with-trivy` ）。有关使用 Trivy 安装 Harbor 的信息，请参阅运行安装程序脚本。

If the upgrading path is from the version that is >=V1.10 to current  version (V2.0) and there was an existing system default scanner “ABC” is set in the previous version, that scanner “ABC” will be kept as system  default scanner;
如果升级路径是从 >=V1.10 的版本升级到当前版本 （V2.0），并且在上一版本中设置了现有的系统默认扫描程序“ABC”，则该扫描程序“ABC”将保留为系统默认扫描程序;

You can also connect Harbor to your own instance of Trivy or to other  [additional vulnerability scanners](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/pluggable-scanners/) through Harbor’s embedded interrogation service. These scanners can be  configured in the Harbor UI at any time after installation.
您还可以通过 Harbor 的嵌入式查询服务将 Harbor 连接到您自己的 Trivy 实例或其他额外的漏洞扫描器。安装后，可以随时在 Harbor UI 中配置这些扫描仪。

It might be necessary to connect Harbor to other scanners for corporate  compliance reasons, or because your organization already uses a  particular scanner. Different scanners also use different vulnerability  databases, capture different CVE sets, and apply different severity  thresholds. By connecting Harbor to more than one vulnerability scanner, you broaden the scope of your protection against vulnerabilities. For  the list of additional scanners that are currently supported, see the  [Harbor Compatibility List](https://goharbor.io/docs/2.11.0/install-config/harbor-compatibility-list/#scanner-adapters).
出于公司合规性原因，或者您的组织已在使用特定扫描程序，可能需要将 Harbor 连接到其他扫描器。不同的扫描程序还使用不同的漏洞数据库，捕获不同的 CVE 集，并应用不同的严重性阈值。通过将 Harbor  连接到多个漏洞扫描器，您可以扩大对漏洞的保护范围。有关当前支持的其他扫描程序的列表，请参阅 Harbor 兼容性列表。

​                        

​                 Clair has been removed as a default scanner in v2.2. You are  still able to use Clair for vulnerability scanning by adding it as an  external scanner.      
Clair 在 v2.2 中已被删除为默认扫描器。您仍然可以通过将 Clair 添加为外部扫描程序来使用它进行漏洞扫描。

You can manually initiate scanning on a particular image, or on all images  in Harbor. Additionally, you can also set a policy to automatically scan all of the images at specific intervals. Vulnerability scans of  [Cosign signatures](https://goharbor.io/docs/2.11.0/working-with-projects/working-with-images/sign-images/#use-cosign-to-sign-artifacts) are not supported.
您可以手动启动对特定图像的扫描，也可以对 Harbor 中的所有图像进行扫描。此外，您还可以设置策略以按特定时间间隔自动扫描所有图像。不支持对 Cosign 签名进行漏洞扫描。

You can also export scans for an image using the Harbor API endpoint `/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities`. See more information about using this endpoint in the  [Harbor Swagger file](https://github.com/goharbor/harbor/blob/main/api/v2.0/swagger.yaml).
您还可以使用 Harbor API 端点导出图像的扫描 `/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities` 。在 Harbor Swagger 文件中查看有关使用此终结点的更多信息。

### 将 Harbor 连接到其他漏洞扫描程序

To connect Harbor to additional vulnerability scanners, you must install  and configure an instance of the additional scanner according to the  scanner vendor’s requirements. The scanner must expose an API endpoint  to allow Harbor to trigger the scan process or get reports. You can  deploy multiple different scanners, and multiple instances of the same  type of scanner.
要将 Harbor 连接到其他漏洞扫描器，您必须根据扫描器供应商的要求安装并配置其他扫描器的实例。扫描程序必须公开 API 端点，以允许 Harbor 触发扫描过程或获取报告。您可以部署多个不同的扫描程序，以及同一类型扫描程序的多个实例。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Interrogation Services**.  
   展开“管理”，然后选择“询问服务”。

   ​    ![Interrogation Services](https://goharbor.io/docs/2.11.0/img/interrogation-services.png)  

   

3. Click the **New Scanner** button.
   单击“新建扫描仪”按钮。

4. Enter the information to identify the scanner.
   输入信息以识别扫描仪。

   - A unique name for this scanner instance, to display in the Harbor interface.
     此扫描程序实例的唯一名称，显示在 Harbor 界面中。

   - An optional description of this scanner instance.
     此扫描程序实例的可选说明。

   - The address of the API endpoint that the scanner exposes to Harbor.

     
     扫描器向 Harbor 公开的 API 端点的地址。

     ​    ![Add scanner](https://goharbor.io/docs/2.11.0/img/add-scanner.png)  

5. Select how to connect to the scanner from the **Authorization** drop-down menu.  
   从授权下拉菜单中选择如何连接到扫描仪。

   ​    ![Select scanner authentication method](https://goharbor.io/docs/2.11.0/img/scanner-auth.png)  

   

   - **None**: The scanner allows all connections without any security.
     无：扫描程序允许所有连接，而无需任何安全性。
   - **Basic**: Enter a username and password for an account that can connect to the scanner.
     基本：输入可以连接到扫描仪的帐户的用户名和密码。
   - **Bearer**: Paste the contents of a bearer token in the **Token** text box.
     持有者：将持有者令牌的内容粘贴到令牌文本框中。
   - **APIKey**: Paste the contents of an API key for the scanner in the **APIKey** text box.
     APIKey：将扫描程序的 API 密钥内容粘贴到 APIKey 文本框中。

6. Optionally select **Skip certificate verification** if the scanner uses a self-signed or untrusted certificate.
   （可选）如果扫描程序使用自签名证书或不受信任的证书，请选择跳过证书验证。

7. Optionally select **Use internal registry address** if the scanner should connect to Harbor using an internal network address rather than its external URL.
   如果扫描程序应使用内部网络地址而不是其外部 URL 连接到 Harbor，则可以选择“使用内部注册表地址”。

   **NOTE**: To use this option, the scanner must be deployed in a network that  allows the scanner to reach Harbor via Harbor’s internal network.
   注意：要使用此选项，扫描仪必须部署在允许扫描仪通过 Harbor 的内部网络访问 Harbor 的网络中。

8. Click **Test Connection** to make sure that Harbor can connect successfully to the scanner.  
   单击“测试连接”，确保 Harbor 可以成功连接到扫描仪。

   ​    ![Test scanner connection](https://goharbor.io/docs/2.11.0/img/test-scanner-connection.png)  

   

9. Click **Add** to connect Harbor to the scanner.
   单击“添加”以将 Harbor 连接到扫描仪。

10. Optionally repeat the procedure to add more scanners.
    （可选）重复该过程以添加更多扫描仪。

11. If you configure multiple scanners, select one and click **Set as Default** to designate it as the default scanner.
    如果配置了多个扫描仪，请选择一个扫描仪，然后单击“设为默认值”以将其指定为默认扫描仪。

### Vulnerability Metadata 漏洞元数据

Vulnerability scanners depend on the vulnerability metadata to complete the analysis  process. After the first initial installation, the vulnerability scanner automatically starts to update the metadata database from different  vulnerability repositories. The database update might take a while,  based on the data size and network connection.
漏洞扫描程序依赖于漏洞元数据来完成分析过程。首次初始安装后，漏洞扫描程序会自动开始更新来自不同漏洞存储库的元数据数据库。数据库更新可能需要一段时间，具体取决于数据大小和网络连接。

Depending on the scanner that you use, once the database is ready, the timestamp of the last update is shown in the **Interrogation Services** > **Vulnerability** tab. Currently, only Clair and Anchore provide timestamp information.  
根据您使用的扫描程序，一旦数据库准备就绪，上次更新的时间戳将显示在“查询服务>漏洞”选项卡中。目前，只有 Clair 和 Anchore 提供时间戳信息。

​    ![browse project](https://goharbor.io/docs/2.11.0/img/clair-ready.png)  



Until the database has been fully populated, the timestamp is replaced by a  warning symbol. When the database is ready, you can scan images  individually or scan all images across all projects.
在数据库完全填充之前，时间戳将替换为警告符号。当数据库准备就绪时，您可以单独扫描图像或扫描所有项目中的所有图像。

If your Harbor instance is not connected to the external internet, you  must manually update the vulnerability metadata. For information about  how to update Clair manually, see  [Import Vulnerability Data to an Offline Harbor instance](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/import-vulnerability-data/).
如果您的 Harbor 实例未连接到外部互联网，您必须手动更新漏洞元数据。有关如何手动更新 Clair 的信息，请参阅将漏洞数据导入离线 Harbor 实例。

### scan Individual Artifacts      
扫描单个工件

1. Log in to the Harbor interface with an account that has at least project administrator privileges.
   使用至少具有项目管理员权限的帐户登录 Harbor 界面。

2. Go to **Projects** and select a project.
   转到“项目”，然后选择一个项目。

3. Select the **Scanner** tab. 选择“扫描仪”选项卡。

   The **Scanner** tab shows the details of the scanner that is currently set as the scanner to use for this project.
   “扫描仪”选项卡显示当前设置为要用于此项目的扫描仪的扫描仪的详细信息。

   

   ​    ![Project scanner tab](https://goharbor.io/docs/2.11.0/img/project-scanners.png)  

   

4. Click **Edit** to select a different scanner from the list of scanners that are connected to this Harbor instance, and click **OK**.
   单击“编辑”，从连接到此 Harbor 实例的扫描程序列表中选择不同的扫描程序，然后单击“确定”。

   

   ​    ![Project scanner tab](https://goharbor.io/docs/2.11.0/img/select-scanner.png)  

   

   ​                        

   ​                 If you have selected the **Prevent vulnerable images from running** option in the project **Configuration** tab, the prevention of pulling vulnerable artifacts is determined by  the scanner that is set in the project, or by the global default scanner if no scanner is configured specifically for the project. Different  scanners might apply different levels of severity to artifact  vulnerabilities.      
   如果在项目的“配置”选项卡中选择了“阻止易受攻击的图像运行”选项，则拉取易受攻击工件的阻止由项目中设置的扫描程序确定，如果没有专门为项目配置扫描程序，则由全局默认扫描程序确定。不同的扫描程序可能会对项目漏洞应用不同级别的严重性。

5. Select the **Repositories** tab and select a repository.
   选择“存储库”选项卡，然后选择一个存储库。

   For each artifact in the repository, the **Vulnerabilities** column displays the vulnerability scanning status and related information.
   对于存储库中的每个工件，“漏洞”列将显示漏洞扫描状态和相关信息。

   

   ​    ![Artifact vulnerability status](https://goharbor.io/docs/2.11.0/img/artifact-vulnerability-status.png)  

   

6. Select a artifact, or use the check box at the top to select all artifacts in the repository, and click the **Scan** button to run the vulnerability scan on this artifact.
   选择一个工件，或使用顶部的复选框选择存储库中的所有工件，然后单击“扫描”按钮以对此工件运行漏洞扫描。

   

   ​    ![Scan an artifact](https://goharbor.io/docs/2.11.0/img/scan-artifact.png)  

   

   **NOTE**: You can start a scan at any time, unless the status is **Queued** or **Scanning**. If the database has not been fully populated, you should not run a scan. The following statuses are displayed in the **Vulnerabilities** column:
   注意：您可以随时开始扫描，除非状态为“已排队”或“正在扫描”。如果数据库尚未完全填充，则不应运行扫描。“漏洞”列中显示以下状态：

   - **Not Scanned:** The artifact has never been scanned.
     未扫描：从未扫描过工件。
   - **Unsupported:** The artifact is not supported by the scanner.
     不受支持：扫描程序不支持该项目。
   - **Queued:** The scanning task is scheduled but has not run yet.
     已排队：扫描任务已计划，但尚未运行。
   - **Scanning:** The scanning task is in progress and a progress bar is displayed.
     扫描中：扫描任务正在进行中，并显示进度条。
   - **Scan stopped:** The scanning task has been cancelled by a stop scan request.
     扫描已停止：已通过停止扫描请求取消扫描任务。
   - **View log:** The scanning task failed to complete. Click **View Log** link to view the related logs.
     查看日志：扫描任务无法完成。单击“查看日志”链接，查看相关日志。
   - **Complete:** The scanning task completed successfully.
     完成：扫描任务已成功完成。

   If the process completes successfully, the result indicates the overall  severity level, with the total number of vulnerabilities found for each  severity level, and the number of fixable vulnerabilities.
   如果该过程成功完成，则结果将指示总体严重性级别，以及每个严重性级别发现的漏洞总数以及可修复的漏洞数。

   

   ​    ![Scan result](https://goharbor.io/docs/2.11.0/img/scan-result.png)  

   

   - **Red:** At least one critical vulnerability found
     红色：至少发现一个严重漏洞
   - **Orange:** At least one high level vulnerability found
     橙色：至少发现一个高级漏洞
   - **Yellow:** At least one medium level vulnerability found
     黄色：至少发现一个中等级别的漏洞
   - **Blue:** At least one low level vulnerability found
     蓝色：至少发现一个低级别漏洞
   - **Green:** No vulnerabilities found
     绿色：未发现漏洞
   - **Grey:** Unknown vulnerabilities
     灰色：未知漏洞

7. Hover over the number of fixable vulnerabilities to see a summary of the vulnerability report.
   将鼠标悬停在可修复漏洞的数量上可查看漏洞报告的摘要。

   

   ​    ![Vulnerability summary](https://goharbor.io/docs/2.11.0/img/vulnerability-summary.png)  

   

8. Click on the artifact digest to see a detailed vulnerability report.
   单击工件摘要可查看详细的漏洞报告。

   

   ​    ![Vulnerability report](https://goharbor.io/docs/2.11.0/img/artifact-detail.png)  

   

   In addition to information about the artifact, all of the vulnerabilities  found in the last scan are listed. You can order or filter the list by  the different columns. You can also click **Scan** in the report page to run a scan on this artifact.
   除了有关项目的信息外，还列出了在上次扫描中发现的所有漏洞。您可以按不同的列对列表进行排序或筛选。您也可以在报告页面中单击“扫描”以对此项目运行扫描。

## Vulnerability scanning for OCI image index OCI 镜像索引漏洞扫描

When scanning an OCI image index, Harbor will send scan requests for each of the referenced artifact which is supported by the scanner to the  scanner. If the image scanning status of any referenced image is **Scanning**, the status for the OCI image index as a whole will also be **Scanning**. The scan for the index is considered successful only if all referenced  images are successfully scanned. It is considered limited successful  when not all referenced images are successfully scanned but at least one of referenced image is successfully scanned, otherwise it is considered failed.
扫描 OCI 镜像索引时，Harbor 会向扫描器发送扫描器支持的每个引用工件的扫描请求。如果任何引用图像的图像扫描状态为“正在扫描”，则整个  OCI  图像索引的状态也将为“正在扫描”。仅当成功扫描了所有引用的图像时，才认为索引扫描成功。如果未成功扫描所有引用的图像，但至少成功扫描了一个引用的图像，则认为有限成功，否则将被视为失败。



​    ![Limited successful](https://goharbor.io/docs/2.11.0/img/limited-successful-status.png)  



When an OCI image index is successfully scanned, the summary of the  vulnerability report for the OCI image index is aggregated from the  individual scan results of the the artifacts referenced by the index.  The vulnerability report will show both sets of statistics.
成功扫描 OCI 映像索引后，将从索引引用的工件的单个扫描结果中聚合 OCI 映像索引的漏洞报告摘要。漏洞报告将显示两组统计信息。

## Export Vulnerability Scans 导出漏洞扫描

As a project administrator, maintainer, or developer you are able to  export vulnerability scan results from your projects as a CVS and  download it from your Harbor instance. Note that you can only export  vulnerability data from one project at a time.
作为项目管理员、维护者或开发人员，您可以将项目的漏洞扫描结果导出为 CVS，并从 Harbor 实例中下载。请注意，您一次只能从一个项目中导出漏洞数据。

1. Log in to the Harbor interface.
   登录 Harbor 界面。
2. Go to **Projects** and select a project.
   转到“项目”，然后选择一个项目。
3. Select **Action** and then **Export CVE(s)**.
   选择“操作”，然后选择“导出 CVE”。



​    ![Export CVE](https://goharbor.io/docs/2.11.0/img/export-vulnerabilities.png)  



1. In the Export CVE window you can apply any filters you want to the data included in the CVS.
   在 Export CVE 窗口中，您可以对 CVS 中包含的数据应用所需的任何过滤器。

- **Repositories:** Filters by repository name. Enter multiple repository names in a comma separated list, repositories match a name `repo*`,or ** for all repositories in the projects.
  存储库：按存储库名称进行筛选。在逗号分隔的列表中输入多个仓库名称，仓库匹配一个名称 `repo*` ，或者**表示项目中的所有仓库。

- **Tags:** Filters by tags. Enter multiple tags in a comma separated list, tags match a name `tag*`,or ** for all tags in the projects.
  标签：按标签筛选。在逗号分隔的列表中输入多个标签，标签与名称 `tag*` 匹配，或者**表示项目中的所有标签。

- **Labels:** Filters by labels. Select multiple labels from the drop down.
  标签：按标签筛选。从下拉列表中选择多个标签。

- **CVE IDs:** Filters by CVE number. Enter comma separated list of CVE IDs.
  CVE ID：按 CVE 编号筛选。输入以逗号分隔的 CVE ID 列表。

  

  ​    ![Export CVE filter options](https://goharbor.io/docs/2.11.0/img/filter-export-vulnerabilities.png)  

  

1. Click **Export**. Harbor will begin creating the CVS file with your exported CVE details. The generated CVE file will be named `csv_file_` and the current date and time formatted as yyyyMMddHHmmss. For example, `csv_file_20220804123037.csv` was created on 08/04/2022 at 12:30:37.
   单击导出。Harbor 将开始使用您导出的 CVE 详细信息创建 CVS 文件。生成的 CVE 文件将被命名 `csv_file_` ，当前日期和时间的格式为 yyyyMMddHHmmss。例如， `csv_file_20220804123037.csv` 在 08/04/2022 （12：30：37） 上创建。
2. Download the CVE file from the Event Log window. Expand the Event Log window by clicking on **Event Log** from the Harbor interface.
   从“事件日志”窗口下载 CVE 文件。通过单击 Harbor 界面中的 Event Log 来展开 Event Log 窗口。
3. Click the download icon next to the CSV file you want to download. Once you download the file, Harbor will delete it.
   单击要下载的 CSV 文件旁边的下载图标。下载文件后，Harbor 会将其删除。



​    ![Download CSV file of vulnerability data](https://goharbor.io/docs/2.11.0/img/download-export-vulnerabilities.png)  

### 停止扫描和停止扫描全部

Scanning images can be a useful feature to detect potential vulnerabilities for  artifact management purpose, but the scanning process could also be resource-consuming, depending on the scale of objects being scanned,  making Harbor barely be able to perform other functionalities.  Therefore, it’s worthwhile to introduce a stop scan feature for users to terminate a  running scan job, and to add a stop scan all functionality to cancel a  list of running scan jobs created by scan all.
扫描图像可以是一个有用的功能，可以检测潜在的漏洞以进行工件管理，但扫描过程也可能消耗资源，具体取决于被扫描对象的规模，使 Harbor  几乎无法执行其他功能。因此，值得为用户引入停止扫描功能以终止正在运行的扫描作业，并添加停止扫描所有功能以取消由“全部扫描”创建的正在运行的扫描作业列表。

Starting from Harbor 2.4.0, the feature of stop scan individual artifacts and  stop scan all artifacts is available for Harbor customers to use. They can explore it through Harbor web portal.
从 Harbor 2.4.0 开始，Harbor 客户可以使用停止扫描单个工件和停止扫描所有工件的功能。他们可以通过 Harbor 门户网站进行探索。

## Stop Scan Individual Artifacts 停止扫描单个工件

There is a `STOP SCAN` button sitting next to `SCAN` button which you click to trigger a scan job of a given artifact, [scan individual artifact](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/scan-individual-artifact/). When you click `SCAN`, the value in **Vulnerabilities** field changes to **Queued**, and then **Scanning**. And at this point, if you click `STOP SCAN`, a stop scan request will be sent to Harbor backend, and the value of **Vulnerabilities** field will be soon changed to **Scan stopped**.
按钮旁边 `SCAN` 有一个 `STOP SCAN` 按钮，单击该按钮可触发给定工件的扫描作业，扫描单个工件。单击 `SCAN` 时，“漏洞”字段中的值将变为“已排队”，然后变为“正在扫描”。而此时，如果点击 `STOP SCAN` ，将向 Harbor 后端发送停止扫描请求，并且 Vulnerabilities 字段的值将很快更改为 Scan stopped。

Users can also create a webhook for **Scanning stopped** event.
用户还可以为扫描停止事件创建 Webhook。

1. Login to Harbor web portal. And navigate into a preferred project.
   登录到 Harbor 门户网站。并导航到首选项目。
2. Click the **Webhooks** tab, and click **NEW WEBHOOK** button to add a new webhook.
   单击“Webhooks”选项卡，然后单击“新建 WEBHOOK”按钮以添加新的 Webhook。
3. Please fulfill the form and make sure you select **Scanning stopped** checkbox, before clicking the **ADD** button to submit.
   请填写表格并确保选中“扫描已停止”复选框，然后单击“添加”按钮进行提交。

If you create a webhook of a given project for **Scanning stopped** event, then try stop scan feature again (stop scan an artifact of this given project). And you should be able to receive a webhook payload this time.
如果为扫描停止事件创建给定项目的 webhook，则再次尝试停止扫描功能（停止扫描此给定项目的工件）。这次你应该能够接收到 webhook 有效负载。

## Stop Scan All 停止全部扫描

In the case of stop scan all, there is no additional `STOP SCAN` button, but the text of `SCAN NOW` button will be changed to `STOP SCAN` after users click `SCAN NOW` to create a  [scan all request](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/scan-all-artifacts/). And once the text is changed to `STOP SCAN`, you can then click it to send a stop scan all request. And the value of **Vulnerabilities** field of all stopped jobs will be changed to **Scan stopped**, and webhooks, if any, will also be sent out.
在停止全部扫描的情况下，没有额外的 `STOP SCAN` 按钮，但按钮的 `SCAN NOW` 文本将更改为在用户单击 `SCAN NOW` 以创建全部扫描请求 `STOP SCAN` 后。一旦文本更改为 `STOP SCAN` ，您就可以单击它以发送停止扫描所有请求。并且所有已停止作业的 Vulnerabilities 字段的值将更改为 Scan stopped，并且 Webhooks（如果有）也将被发送出去。

### 部署安全性

Starting in version 2.0, Harbor has added capabilities to check for supported  artifact types in the pluggable scanners. It will use the **consumes_mime_types** metadata of the scanner to decide whether a requested artifact is  supported by this scanner. For example, helm charts cannot be scanned  for vulnerabilities by the supported scanner, Aqua Trivy.
从版本 2.0 开始，Harbor  增加了在可插拔扫描器中检查支持的工件类型的功能。它将使用扫描程序的consumes_mime_types元数据来确定此扫描程序是否支持请求的项目。例如，受支持的扫描程序 Aqua Trivy 无法扫描 helm 图表以查找漏洞。

Harbor v2.0 now supports OCI image index, which is a higher-level manifest  which points to specific image manifests, ideal for one or more  platform. Scanning for OCI image index is also supported, with the scan  result of the index being an aggregation of the scan results of the  artifacts referenced within.
Harbor v2.0 现在支持 OCI 镜像索引，这是一种更高级别的清单，指向特定的镜像清单，非常适合一个或多个平台。还支持扫描 OCI 图像索引，索引的扫描结果是其中引用的工件的扫描结果的聚合。

Harbor has ‘deployment security’ which can prevent artifacts from being pulled if vulnerabilities are discovered. For pulling indexes, ‘deployment  security’ will skip this policy checking for the index artifact itself  and will only apply policy checking on the referenced artifacts and at  the individual artifact level and not on the index as a whole. This  means when pulling Redis for ARM for example, it only checks to see if  whether Redis for ARM has vulnerabilities and not impacted by whether  amd64 has CVEs. This applies to CNABs as well.
Harbor  具有“部署安全性”，可以防止在发现漏洞时拉取工件。对于拉取索引，“部署安全性”将跳过此策略检查，以检查索引工件本身，并且仅对引用的工件和单个工件级别应用策略检查，而不对整个索引应用策略检查。这意味着，例如，在拉取 Redis for ARM 时，它只检查 Redis for ARM 是否存在漏洞，而不受 amd64 是否有 CVE 的影响。这也适用于  CNAB。

### Scan All Artifacts       扫描所有工件

In addition to scanning individual artifacts in projects, you can run  global scans on all of the artifacts in a Harbor instance, across all  projects.
除了扫描项目中的单个工件外，您还可以对 Harbor 实例中的所有工件跨所有项目运行全局扫描。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Interrogation Services**.
   展开“管理”，然后选择“询问服务”。

3. Select the **Vulnerability** tab and click **Scan Now** to scan all of the artifacts in all projects.
   选择“漏洞”选项卡，然后单击“立即扫描”以扫描所有项目中的所有工件。

   

   ​    ![Scan all artifacts](https://goharbor.io/docs/2.11.0/img/scan-all.png)  

   

Scanning requires intensive resource consumption. If scanning is in progress, the **Scan Now** button is unavailable.
扫描需要大量资源消耗。如果扫描正在进行中，则“立即扫描”按钮不可用。

### 计划扫描

You can set policies to control when vulnerability scanning should run.
您可以设置策略来控制何时运行漏洞扫描。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Interrogation Services**.
   展开“管理”，然后选择“询问服务”。

3. Select the **Vulnerability** tab and click the **Edit** button next to **Schedule to scan all**.
   选择“漏洞”选项卡，然后单击“计划”旁边的“编辑”按钮以扫描所有内容。

4. Use the drop down-menu to select how often to run scans.
   使用下拉菜单选择运行扫描的频率。

   

   ​    ![browse project](https://goharbor.io/docs/2.11.0/img/scan-policy.png)  

   

   - **None**: No scans are scheduled.
     无：不安排任何扫描。
   - **Hourly**: Run a scan at the beginning of every hour.
     每小时：每小时开始时运行一次扫描。
   - **Daily**: Run a scan at midnight every day.
     每天：每天午夜运行一次扫描。
   - **Weekly**: Run a scan at midnight every Saturday.
     每周：每周六午夜运行一次扫描。
   - **Custom**: Run a scan according to a `cron` job.
     自定义：根据 `cron` 作业运行扫描。

5. Click **Save**. 点击保存。

### 将漏洞数据导入离线 Harbor 实例

​                        

​                 Clair has been removed as the default vulnerability scanner in  Harbor v2.2. It’s highly recommended that you configure Trivy as your  default scanner instead. If you want to continue using Clair in v2.2 and later, you must configure it as an [external scanner](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/pluggable-scanners/).      
Clair 已作为 Harbor v2.2 中的默认漏洞扫描器被移除。强烈建议您将 Trivy 配置为默认扫描程序。如果您想在 v2.2 及更高版本中继续使用 Clair，您必须将其配置为外部扫描器。

If Harbor is installed in an environment without an internet connection,  Clair cannot fetch data from the public vulnerability database. In this  case, the Harbor administrator must update the Clair database manually.
如果 Harbor 安装在没有互联网连接的环境中，Clair 无法从公共漏洞数据库中获取数据。在这种情况下，Harbor 管理员必须手动更新 Clair 数据库。

## Preparation 制备

- You have an instance of Clair that has an internet connection. If you have  another instance of Harbor that has internet access, this also works.
  您有一个具有 Internet 连接的 Clair 实例。如果您有另一个可以访问 Internet 的 Harbor 实例，这也有效。

- Check whether your Clair instance has already updated its vulnerability database to the latest version.
  检查您的 Clair 实例是否已经将其漏洞数据库更新到最新版本。

  1. Use `docker ps` to find out the container ID of the Clair service.
     用于 `docker ps` 查找 Clair 服务的容器 ID。
  2. Run `docker logs <container_id>` to check the log of the Clair container. If you are using Harbor you can find the latest Clair logs under `/var/log/harbor/2017-xx-xx/clair.log`.
     运行以 `docker logs <container_id>` 检查 Clair 容器的日志。如果您使用的是 Harbor，则可以在以下位置 `/var/log/harbor/2017-xx-xx/clair.log` 找到最新的 Clair 日志。
  3. Look for logs that look like the following:
     查找如下所示的日志：

  ```fallback
  Jul 3 20:40:45 172.18.0.1 clair[3516]: {"Event":"finished fetching","Level":"info","Location":"updater.go:227","Time":"2017-07-04 03:40:45.890364","updater name":"rhel"}
  Jul 3 20:40:46 172.18.0.1 clair[3516]: {"Event":"finished fetching","Level":"info","Location":"updater.go:227","Time":"2017-07-04 03:40:46.768924","updater name":"alpine"}
  Jul 3 20:40:47 172.18.0.1 clair[3516]: {"Event":"finished fetching","Level":"info","Location":"updater.go:227","Time":"2017-07-04 03:40:47.190982","updater name":"oracle"}
  Jul 3 20:41:07 172.18.0.1 clair[3516]: {"Event":"Debian buster is not mapped to any version number (eg. Jessie-\u003e8). Please update me.","Level":"warning","Location":"debian.go:128","Time":"2017-07-04 03:41:07.833720"}
  Jul 3 20:41:07 172.18.0.1 clair[3516]: {"Event":"finished fetching","Level":"info","Location":"updater.go:227","Time":"2017-07-04 03:41:07.833975","updater name":"debian"}
  Jul 4 00:26:17 172.18.0.1 clair[3516]: {"Event":"finished fetching","Level":"info","Location":"updater.go:227","Time":"2017-07-04 07:26:17.596986","updater name":"ubuntu"}
  Jul 4 00:26:18 172.18.0.1 clair[3516]: {"Event":"adding metadata to vulnerabilities","Level":"info","Location":"updater.go:253","Time":"2017-07-04 07:26:18.060810"}
  Jul 4 00:38:05 172.18.0.1 clair[3516]: {"Event":"update finished","Level":"info","Location":"updater.go:198","Time":"2017-07-04 07:38:05.251580"}
  ```

The phrase `finished fetching` indicates that Clair has finished a round of vulnerability updates from an endpoint. Make sure all of the `rhel`, `alpine`, `oracle`, `debian`, and `ubuntu` endpoints are updated correctly. If they have not, wait for Clair to get the data.
该短语 `finished fetching` 表示 Clair 已从端点完成了一轮漏洞更新。确保所有 `rhel` 、 `alpine` 、 `oracle` 和 `debian` `ubuntu` 端点都已正确更新。如果没有，请等待 Clair 获取数据。

## Dump Vulnerability Data Dump 漏洞数据

1. Log in to the host, that is connected to Internet, on which the Postgres Clair database is running.
   登录到连接到 Internet 的主机，该主机正在运行 Postgres Clair 数据库。

2. Dump Clair’s vulnerability database by running the following commands.
   通过运行以下命令转储 Clair 的漏洞数据库。

   ​                        

   ​                 The container name `clair-db` is a placeholder for the database container used by the internet-connected instance of Clair.      
   容器名称 `clair-db` 是连接到 Internet 的 Clair 实例使用的数据库容器的占位符。

   ```shell
   $ docker exec clair-db /bin/sh -c  "pg_dump -U postgres -a -t feature -t keyvalue -t namespace -t schema_migrations -t vulnerability -t vulnerability_fixedin_feature" > vulnerability.sql  
   $ docker exec clair-db /bin/sh -c "pg_dump -U postgres -c -s" > clear.sql
   ```

The files `vulnerability.sql` and `clear.sql` are generated.
文件 `vulnerability.sql` 和 `clear.sql` 生成。

## Back Up the Harbor Clair Database 备份 Harbor Clair 数据库

Before importing the data, it is strongly recommended to back up the Clair database in Harbor.
在导入数据之前，强烈建议先备份 Harbor 中的 Clair 数据库。

```shell
docker exec harbor-db /bin/sh -c  "pg_dump -U postgres -c" > all.sql
```

## Update the Harbor Clair Database 更新 Harbor Clair 数据库

1. Copy the `vulnerability.sql` and `clear.sql` files to the host on which Harbor is running.
   将 `vulnerability.sql` and `clear.sql` 文件复制到运行 Harbor 的主机上。

2. Run the following commands to import the data to the Harbor Clair database:
   运行以下命令以将数据导入到 Harbor Clair 数据库：

   ```shell
   docker exec -i harbor-db psql -U postgres < clear.sql  
   docker exec -i harbor-db psql -U postgres < vulnerability.sql
   ```

## Rescan the Images 重新扫描图像

After importing the data, trigger the scanning process in the Harbor interface. For information about running a scan, see  [Scan All Artifacts](https://goharbor.io/docs/2.11.0/administration/vulnerability-scanning/scan-all-artifacts/).
导入数据后，在 Harbor 界面触发扫描过程。有关运行扫描的信息，请参阅扫描所有项目。

### 配置系统范围的 CVE 允许列表

When you run vulnerability scans, images that are subject to Common  Vulnerabilities and Exposures (CVE) are identified. According to the  severity of the CVE and your security settings, these images might not  be permitted to run. As a Harbor system administrator, you can create  allowlists of CVEs to ignore during vulnerability scanning.
运行漏洞扫描时，将识别受常见漏洞和暴露 （CVE） 影响的图像。根据 CVE 的严重性和您的安全设置，可能不允许运行这些映像。作为 Harbor 系统管理员，您可以创建 CVE 白名单，以便在漏洞扫描过程中忽略。

You can set a system-wide CVE allowlist or you can set CVE allowlists on a  per-project basis. For information about per-project CVE allowlists, see  [Configure a Per-Project CVE Allowlist](https://goharbor.io/docs/2.11.0/working-with-projects/project-configuration/configure-project-allowlist/).
您可以设置系统范围的 CVE 允许列表，也可以根据每个项目设置 CVE 允许列表。有关每个项目的 CVE 允许列表的信息，请参阅配置每个项目的 CVE 允许列表。

System-wide CVE allowlists apply to all of the projects in a Harbor instance.
系统范围的CVE白名单适用于Harbor实例中的所有项目。

1. Go to **Configuration** > **Security**.
   转到“配置”>“安全性”。

2. Under **Deployment security**, click **Add**.
   在“部署安全性”下，单击“添加”。

3. Enter the list of CVE IDs to ignore during vulnerability scanning.  
   输入在漏洞扫描期间要忽略的 CVE ID 列表。

   ​    ![Add system CVE allowlist](https://goharbor.io/docs/2.11.0/img/cve-allowlist2.png)  

   

   Either use a comma-separated list or newlines to add multiple CVE IDs to the list.
   使用逗号分隔的列表或换行符将多个 CVE ID 添加到列表中。

4. Click **Add** at the bottom of the window to add the list.
   单击窗口底部的“添加”以添加列表。

5. Optionally uncheck the **Never expires** checkbox and use the calendar selector to set an expiry date for the allowlist.  
   （可选）取消选中永不过期复选框，并使用日历选择器为许可名单设置到期日期。

   ​    ![Add system CVEs](https://goharbor.io/docs/2.11.0/img/cve-allowlist3.png)  

   

6. Click **Save** at the bottom of the page to save your settings.
   单击页面底部的“保存”以保存您的设置。

After you have created a system allowlist, you can remove CVE IDs from the  list by clicking the delete button next to it in the list. You can click **Add** to add more CVE IDs to the system allowlist.
创建系统允许列表后，您可以通过在列表中单击 CVE ID 旁边的删除按钮从列表中删除 CVE ID。您可以单击“添加”，将更多CVE ID添加到系统白名单中。



​    ![Add and remove system CVEs](https://goharbor.io/docs/2.11.0/img/cve-allowlist4.png)  

  

### Configure custom Certification Authorities for trivy      
为 trivy 配置自定义证书颁发机构

In some cases it might be usefull to provide custom certificate auhtority  (CA) bundles to trivy. This is often the case if you are in an  enterprise environment where a webproxy is used. Because trivy must  connect to the internet to get the CVE data, it must pass the proxy.  Trivy reads certificates from a bind-mount, thus it is possible to place certificates in this folder and trivy will validate against them, if  new connections are created.
在某些情况下，向 trivy 提供自定义证书托管 （CA） 捆绑包可能很有用。如果您处于使用 webproxy 的企业环境中，则通常会出现这种情况。因为  trivy 必须连接到互联网才能获取 CVE 数据，所以它必须通过代理。Trivy  从绑定挂载中读取证书，因此可以将证书放在此文件夹中，如果创建了新连接，Trivy 将针对它们进行验证。

## Preparation 制备

- You have a ca-bundle, or single public certificates of your CA, which is used by the webproxy.
  您有一个 CA 包，或您的 CA 的单个公共证书，由 webproxy 使用。

## Implementation 实现

1. Change into your harbor configuration folder
   切换到 harbor 配置文件夹
2. Take a look at the docker-compose.yml and the configuration of trivy-adapter. It looks something like this:
   看看trivy-adapter docker-compose.yml和配置。它看起来像这样：

```yaml
  trivy-adapter:
    container_name: trivy-adapter
    image: goharbor/trivy-adapter-photon:dev
    restart: always
    cap_drop:
      - ALL
    dns_search: .
    depends_on:
      - log
      - redis
    networks:
      - harbor
    volumes:
      - type: bind
        source: /data/trivy-adapter/trivy
        target: /home/scanner/.cache/trivy
      - type: bind
        source: /data/trivy-adapter/reports
        target: /home/scanner/.cache/reports
      - type: bind
        source: ./common/config/shared/trust-certificates
        target: /harbor_cust_cert
```

1. note the binding which mounts to `/harbor_cust_cert` and add your ca-bundle or the single public-certificates into the mount-location, by copying them.
   请注意绑定，该绑定将挂载到 `/harbor_cust_cert` 您的 CA 捆绑包或单个公共证书，通过复制它们将其添加到挂载位置。
2. (opt) if the host-path doesn’t fit for your case, you can also configure  another path in the docker-compose file. be aware, that you might have  to manually change this, if there are changes on new releases of  trivy/harbor.
   （opt） 如果 host-path 不适合您的情况，您也可以在 docker-compose 文件中配置另一个路径。请注意，如果 Trivy/Harbor 的新版本有更改，您可能需要手动更改此设置。
3. restart your containers (at least trivy-adapter) by using `docker restart trivy-adapter` or `docker-compose restart`. If you changed the bind path, it is necessary to start the services by using `docker-compose up -d`
   使用 `docker restart trivy-adapter` 或 `docker-compose restart` 重新启动容器（至少是 trivy-adapter）。如果更改了绑定路径，则必须使用 `docker-compose up -d` 

## Upgrades 升级

Depending on if you changed the path or not an update might overwrite the folder  or mount from a different location. The following process makes sure,  you don’t run into anything unexpected
根据您是否更改了路径，更新可能会覆盖文件夹或从其他位置装载。以下过程可确保您不会遇到任何意外情况

1. backup your certificates to a folder, which is unrelated to harbor-configuration
   将您的证书备份到与 harbor-configuration 无关的文件夹中
2. upgrade harbor as always
   一如既往地升级 Harbor
3. check if the `/harbor_cust_cert` mount is the same as the folder where your certificates reside (normally `./common/config/shared/trust-certificates`)
   检查挂 `/harbor_cust_cert` 载是否与证书所在的文件夹相同（通常 `./common/config/shared/trust-certificates` ）
4. check if the folder still holds your certificates, otherwise copy your backuped certificates to the location
   检查该文件夹是否仍包含您的证书，否则请将备份的证书复制到该位置
5. check if trivy is able to get CVE data
   检查 trivy 是否能够获取 CVE 数据

## Access Metrics                访问指标

Harbor exposes some key metrics needed for operators and administrators to  monitor how your Harbor instance is running in real time. Observability  is a key feature for operating a service in production and using this  data you can identify abnormal statuses and make informed decisions to  fix issues when an error occurs. Harbor exposes metrics using the   [Prometheus data model](https://prometheus.io/docs/concepts/data_model/) so you can easily start scraping your Harbor instance’s metrics using Prometheus.
Harbor 公开了操作员和管理员实时监控 Harbor  实例运行方式所需的一些关键指标。可观察性是在生产环境中运行服务的关键特性，使用此数据，您可以识别异常状态，并在发生错误时做出明智的决策来解决问题。Harbor 使用 Prometheus 数据模型公开指标，因此您可以轻松地开始使用 Prometheus 抓取 Harbor 实例的指标。

In Harbor v2.2 and later you are able to enable metrics in your Harbor  [configuration file](https://goharbor.io/docs/2.11.0/install-config/configure-yml-file/). Harbor metrics are available at `<harbor_instance>:<metrics_port>/<metrics_path>` based on your configured values.
在 Harbor v2.2 及更高版本中，您可以在 Harbor 配置文件中启用指标。Harbor 指标位于 `<harbor_instance>:<metrics_port>/<metrics_path>` 基于您配置的值。

Harbor metrics show data related to
Harbor 指标显示与以下内容相关的数据

- Runtime information from the  [GO library](https://github.com/prometheus/client_golang)
  GO 库中的运行时信息
- Performance metrics about all API requests in core
  有关核心中所有 API 请求的性能指标
- Number of requests in flight in core
  核心中正在进行的请求数
- Metrics provided by the  [Distribution/Distribution](https://github.com/distribution/distribution/blob/main/notifications/metrics.go) itself
  由分发/分发本身提供的指标
- Some data related to business logic which already exist in the Harbor database
  Harbor 数据库中已经存在的一些与业务逻辑相关的数据

Metrics are exposed by several Harbor components: `exporter`, `core`, `jobservice`, and `registry`. In addition to runtime and performance data, these components also  expose Harbor specific metrics. The following sections list the  available Harbor metrics.
指标由多个 Harbor 组件公开： `exporter` 、 `core` 、 `jobservice` 和 `registry` 。除了运行时和性能数据外，这些组件还公开了 Harbor 特定的指标。以下部分列出了可用的 Harbor 指标。

## Harbor Exporter Metrics Harbor Exporter 指标

The `exporter` component metrics relate to your Harbor instance configuration and  collects some data from the Harbor database. Metrics are available at `<harbor_instance>:<metrics_port>/<metrics_path>`.
 `exporter` 组件指标与您的 Harbor 实例配置相关，并从 Harbor 数据库中收集一些数据。有关指标，请访问 `<harbor_instance>:<metrics_port>/<metrics_path>` 。

| Name 名字                         | Description 描述                                             | Labels (Values) 标签（值）                                   | Metric type 指标类型 |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- |
| `harbor_project_total`            | Total number of public and private projects 公共和私人项目总数 | public (`true`,`false`) 公共 （ `true` ， `false` ）         | gauge 轨距           |
| `harbor_project_repo_total`       | Total number of repositories in a project 项目中的仓库总数   | public (`true`,`false`),  project_name 公共 （ `true` ， `false` ）， project_name | gauge 轨距           |
| `harbor_project_member_total`     | Total number of members in a project 项目中的成员总数        | project_name                                                 | gauge 轨距           |
| `harbor_project_quota_usage_byte` | Total used resources of a project 项目的总已用资源           | project_name                                                 | gauge 轨距           |
| `harbor_project_quota_byte`       | Quota set in a project 在项目中设置的配额                    | project_name                                                 | gauge 轨距           |
| `harbor_artifact_pulled`          | Number of images pulled in a project 项目中拉取的图像数量    | project_name                                                 | gauge 轨距           |
| `harbor_project_artifact_total`   | Total number of artifacts type in a project 项目中的项目类型总数 | artifact_type , project_name, public (`true`,`false`) artifact_type ， project_name， 公共 （ `true` ， `false` ） | gauge 轨距           |
| `harbor_health`                   | Current status of Harbor 港口的现状                          |                                                              | gauge 轨距           |
| `harbor_system_info`              | Information about your Harbor instance 有关 Harbor 实例的信息 | auth_mode (`db_auth`, `ldap_auth`, `uaa_auth`, `http_auth`, `oidc_auth`), harbor_version, self_registration(`true`,`false`) auth_mode （ `db_auth` ， `ldap_auth` ， `uaa_auth` ， ， `http_auth` ）， `oidc_auth` harbor_version， self_registration（ `true` ， `false` ） | gauge 轨距           |
| `harbor_up`                       | Running status of Harbor components Harbor 组件的运行状态    | component (`chartmuseum`, `core`, `database`, `jobservice`, `portal`, `redis`, `registry`, `registryctl`, `trivy`) 分量 （ `chartmuseum` ， `core` ， `database` ， `jobservice` ， `portal` ， `redis` ， `registry` `registryctl` `trivy` ， ， ） | gauge 轨距           |
| `harbor_task_queue_size`          | The total number of tasks per type in the queue 队列中每种类型的任务总数 | instance, job, type 实例、作业、类型                         | gauge 轨距           |
| `harbor_task_queue_latency`       | How long ago the next job to be processed was enqueued per type 每个类型在多长时间前，要处理的下一个作业已排队 | instance, job, type 实例、作业、类型                         | gauge 轨距           |
| `harbor_task_scheduled_total`     | Number of scheduled tasks 计划任务数                         | instance, job 实例、作业                                     | gauge 轨距           |
| `harbor_task_concurrency`         | Total number of concurrent tasks per type on a pool 池中每种类型的并发任务总数 | instance, job, pool, type 实例、作业、池、类型               | gauge 轨距           |

## Harbor Core Metrics Harbor 核心指标

The following are metrics pulled from the Harbor core pod and are available at `<harbor_instance>:<metrics_port>/<metrics_path>?comp=core`.
以下是从 Harbor 核心 pod 中提取的指标，可在以下网址 `<harbor_instance>:<metrics_port>/<metrics_path>?comp=core` 找到。

| Name 名字                                   | Description 描述                                 | Labels (Values) 标签（值）                                   | Metric type 指标类型 |
| ------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | -------------------- |
| `harbor_core_http_inflight_requests`        | The total number of requests 请求总数            | operation (values from `operationId` in  [Harbor API](https://github.com/goharbor/harbor/blob/main/api/v2.0/swagger.yaml). Some legacy endpoints do not have an `operationId`, so the label value is `unknown`) 操作（Harbor API `operationId` 中的值。一些旧版端点没有 `operationId` ，因此标签值为 `unknown` ） | gauge 轨距           |
| `harbor_core_http_request_duration_seconds` | The time duration of the requests 请求的持续时间 | method (`GET`, `POST`, `HEAD`, `PATCH`, `PUT`), operation (values from `operationId` in  [Harbor API](https://github.com/goharbor/harbor/blob/main/api/v2.0/swagger.yaml). Some legacy endpoints do not have an `operationId`, so the label value is `unknown`), quantile 方法 （ `GET` 、 `POST` 、 `HEAD` 、 `PATCH` 、 ） `PUT` 操作 （Harbor API `operationId` 中的值。一些旧版端点没有 `operationId` ，因此标签值为 `unknown` ），分位数 | summary 总结         |
| `harbor_core_http_request_total`            | The total number of requests 请求总数            | method (`GET`, `POST`, `HEAD`, `PATCH`, `PUT`), operation (values from `operationId` in  [Harbor API](https://github.com/goharbor/harbor/blob/main/api/v2.0/swagger.yaml). Some legacy endpoints do not have an `operationId`, so the label value is `unknown`) 方法 （ `GET` 、 `POST` 、 `HEAD` 、 `PATCH` 、 ） `PUT` 操作 （Harbor API `operationId` 中的值。一些旧版端点没有 `operationId` ，因此标签值为 `unknown` ） | counter 计数器       |

## Registry Metrics 注册表指标

The following are metrics pulled from the Distribution/Distribution and are available at `<harbor_instance>:<metrics_port>/<metrics_path>?comp=registry`.
以下是从 Distribution/Distribution 中提取的指标，可在 上 `<harbor_instance>:<metrics_port>/<metrics_path>?comp=registry` 找到。

| Name 名字                                                    | Description 描述                                             | Labels (Values) 标签（值）                                   | Metric type 指标类型 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- |
| `registry_http_in_flight_requests`                           | The in-flight HTTP requests 正在进行的 HTTP 请求             | handler 处理器                                               | gauge 轨距           |
| `registry_http_request_duration_seconds_bucket` `registry_http_request_duration_seconds_sum` `registry_http_request_duration_seconds_count` | The HTTP request latencies in seconds HTTP 请求延迟（以秒为单位） | handler, method (`GET`, `POST`, `HEAD`, `PATCH`, `PUT`), le 处理程序、方法 （ `GET` 、 `POST` 、 `HEAD` 、 `PATCH` 、 `PUT` ）、le | histogram 直方图     |
| `registry_http_request_size_bytes_bucket registry_http_request_size_bytes_sum registry_http_request_size_bytes_count` | The HTTP request sizes in bytes HTTP 请求大小（以字节为单位） | handler, le 汉德勒，LE                                       | histogram 直方图     |
| `registry_http_requests_total`                               | Total number of HTTP requests made 发出的 HTTP 请求总数      | code,handler,method,le 代码，处理程序，方法，LE              | counter 计数器       |
| `registry_http_response_size_bytes_bucket` `registry_http_response_size_bytes_sum` `registry_http_response_size_bytes_count` | The HTTP response sizes in bytes HTTP 响应大小（以字节为单位） | handler,le 处理者，LE                                        | histogram 直方图     |
| `registry_storage_action_seconds_bucket` `registry_storage_action_seconds_sum` `registry_storage_action_seconds_count` | The number of seconds that the storage action takes 存储操作所花费的秒数 | action,driver,le 动作，司机，LE                              | histogram 直方图     |
| `registry_storage_cache_total`                               | The number of cache request received 收到的缓存请求数        | type 类型                                                    | gauge 轨距           |

## Harbor Jobservice metrics Harbor Jobservice 指标

The following are metrics pulled from the Harbor Jobservice and are available at `<harbor_instance>:<metrics_port>/<metrics_path>?comp=jobservice`.
以下是从 Harbor Jobservice 中提取的指标，可在 `<harbor_instance>:<metrics_port>/<metrics_path>?comp=jobservice` 上找到。

| Name 名字                                     | Description 描述                                             | Labels (Values) 标签（值）                                   | Metric type 指标类型 |
| --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- |
| `harbor_jobservice_info`                      | The information of Jobservice Jobservice的信息               | instance, job, node, pool, workers 实例、作业、节点、池、辅助角色 | gauge 轨距           |
| `harbor_jobservice_task_total`                | The number of processed tasks per job type 每种作业类型的已处理任务数 | instance, job, status, type 实例、作业、状态、类型           | counter 计数器       |
| `harbor_jobservice_task_process_time_seconds` | The duration of the task processing time 任务处理时间的持续时间 | instance, job, quantile, status, type 实例、作业、分位数、状态、类型 | summary 总结         |

## Scraping Metrics with Prometheus 使用 Prometheus 抓取指标

To begin accessing your Harbor instance’s metrics with Prometheus,
要开始使用 Prometheus 访问 Harbor 实例的指标，请执行以下操作：

1. Enable exposing metrics in your `harbor.yml`  [configuration file](https://goharbor.io/docs/2.11.0/install-config/configure-yml-file/) and set the port and path for metrics to be exposed on. Also see more about  [reconfiguring your Harbor instance](https://goharbor.io/docs/2.11.0/install-config/reconfigure-manage-lifecycle/).
   在 `harbor.yml` 配置文件中启用公开指标，并设置要公开指标的端口和路径。另请参阅有关重新配置 Harbor 实例的更多信息。

2. Set up a Prometheus server, see the  [Prometheus documentation](https://prometheus.io/docs/prometheus/latest/installation/) for more information on installing.
   设置 Prometheus 服务器，请参阅 Prometheus 文档以获取有关安装的更多信息。

3. Configure your Prometheus config file to scrape Harbor metrics exposed at your  configured port and path. Below is an example scrape config, see the  Prometheus documentation for all available  [scrape configuration options](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config).
   配置 Prometheus 配置文件以抓取在配置的端口和路径上公开的 Harbor 指标。下面是一个 scrape 配置示例，请参阅 Prometheus 文档了解所有可用的 scrape 配置选项。

   ```fallback
     scrape_configs:
   
       - job_name: 'harbor-exporter'
         scrape_interval: 20s
         static_configs:
           # Scrape metrics from the Harbor exporter component
           - targets: ['<harbor_instance>:<metrics_port>']
   
       - job_name: 'harbor-core'
         scrape_interval: 20s
         params:
           # Scrape metrics from the Harbor core component
           comp: ['core']
         static_configs:
           - targets: ['<harbor_instance>:<metrics_port>']
   
       - job_name: 'harbor-registry'
         scrape_interval: 20s
         params:
           # Scrape metrics from the Harbor registry component
           comp: ['registry']
         static_configs:
           - targets: ['<harbor_instance>:<metrics_port>']
   
       - job_name: 'harbor-jobservice'
         scrape_interval: 20s
         params:
           # Scrape metrics from the Harbor jobservice component
           comp: ['jobservice']
         static_configs:
           - targets: ['<harbor_instance>:<metrics_port>']
   ```

4. Once you have configured your Prometheus server to collect your Harbor metrics, you can use  [Grafana](https://grafana.com/docs/) to visualize your data. An  [example Grafana dashboard](https://github.com/goharbor/harbor/blob/main/contrib/grafana-dashboard/metrics-example.json) is available in the Harbor repo to help you get started visualizing Harbor metrics.
   配置 Prometheus 服务器以收集 Harbor 指标后，您可以使用 Grafana 来可视化数据。Harbor 存储库中提供了一个示例 Grafana 仪表板，可帮助你开始可视化 Harbor 指标。

### From a Kubernetes cluster 从 Kubernetes 集群

You can also use Prometheus to collect metrics from a Harbor instance  deployed in your Kubernetes cluster. You should already have  [installed  Prometheus](https://github.com/prometheus-community/helm-charts) and set up to pull metrics from your cluster.
您还可以使用 Prometheus 从 Kubernetes 集群中部署的 Harbor 实例中收集指标。您应该已经安装了 Prometheus 并设置了从集群中提取指标。

1. Create a ServiceMonitor in Prometheus for Harbor.
   在 Prometheus for Harbor 中创建 ServiceMonitor。

   ```fallback
   apiVersion: monitoring.coreos.com/v1
   kind: ServiceMonitor
   metadata:
     name: harbor
     labels:
       app: harbor
   spec:
     selector:
       matchLabels:
         app: harbor
     endpoints:
     - port: metrics
   ```

2. Enable Harbor to expose metrics by updating your harbor-helm `values.yaml` file and set `metrics.enabled` to `true`. You can also edit the port and path the metrics are exposed on by updating the available harbor-helm chart  [configuration options for metrics](https://github.com/goharbor/harbor-helm#configuration).
   通过更新 harbor-helm `values.yaml` 文件并设置为 `metrics.enabled` `true` .您还可以通过更新指标的可用 harbor-helm 图表配置选项来编辑指标在其上公开的端口和路径。

Prometheus should now show your Harbor instance’s metrics.
Prometheus 现在应该显示您的 Harbor 实例的指标。

## Distributed Tracing                分布式跟踪

Observability is a key feature for operating a service in production and using this  data you can identify abnormal statuses and make informed decisions to  fix issues when an error occurs. The distributed tracing is key element  of observability in modern application. Harbor can provide distributed  tracing data for operators and administrator to know the current running status and to help  troubleshooting.  Harbor expose tracing data using  the  [OpenTelemetry](https://opentelemetry.io/) sdk, you can eazily export traces via Otel protocol which can comsumed by  [OpenTelemetry Collector](https://opentelemetry.io/docs/collector/) then expose to almost the on-prem or cloud trace backend. Because of the popularity  [Jaeger](https://www.jaegertracing.io), Harbor also can expose tracing data to Jaeger backend directly.
可观察性是在生产环境中运行服务的关键特性，使用此数据，您可以识别异常状态，并在发生错误时做出明智的决策来解决问题。分布式追踪是现代应用中可观测性的关键要素。Harbor 可以为操作员和管理员提供分布式跟踪数据，以了解当前的运行状态并帮助排除故障。Harbor 使用 OpenTelemetry sdk  公开跟踪数据，您可以通过 Otel 协议轻松导出跟踪，OpenTelemetry Collector  可以使用这些跟踪数据，然后几乎暴露到本地或云跟踪后端。由于 Jaeger 的受欢迎程度，Harbor 还可以直接将追踪数据暴露给 Jaeger  后端。

In harbor v2.4 and later you are able to enable distributed tracing in you Harbor  [configuration file](https://goharbor.io/docs/2.11.0/install-config/configure-yml-file/). But we only support one exporter at a time( you can not set bosh or  none of them if you enabled tracing). You can set otel as exporter and  leveraging OpenTelemetry Collector to retransmit to multiple backend if  you want to send data to multiple exporter. And similarly, Jaeger  exporter  support agent mode and endpoint mode, but only one mode can  enabled at a time.
在 Harbor v2.4 及更高版本中，您可以在 Harbor  配置文件中启用分布式跟踪。但是我们一次只支持一个导出器（如果您启用了跟踪，则无法设置 bosh  或不设置任何导出器）。如果您想将数据发送到多个导出器，您可以将 otel 设置为导出器，并利用 OpenTelemetry Collector  重新传输到多个后端。同样，Jaeger 导出器也支持代理模式和端点模式，但一次只能启用一种模式。

# Exposed data 暴露的数据

Tracing data are exposed by serveral Harbor components: `core`, `jobservice`, `registry`. The following sections list the available Harbor trace data.
追踪数据由服务器 Harbor 组件公开： `core` 、 `jobservice` 、 `registry` 。以下各节列出了可用的 Harbor 跟踪数据。

| Data 数据                                       | Component 元件      | Example 例                                                   |
| ----------------------------------------------- | ------------------- | ------------------------------------------------------------ |
| Received HTTP Request 已收到 HTTP 请求          | Core 核心           | Every HTTP request (like operation on harbor UI, push image, etc. ) 每个HTTP请求（如在harbor UI上的操作，推送图片等） |
| Client Sent HTTP Request 客户端发送的 HTTP 请求 | Core 核心           | core access other services via HTTP(like health check, proxy to chartmuseum, call job service API, etc.) 通过HTTP核心访问其他服务（如健康检查、代理chartmuseum、调用作业服务API等） |
| Request ID 请求 ID                              | Core 核心           | Every http tracing will added a `X-Request-ID` , which will help to find the log 每个 http 跟踪都会添加一个 `X-Request-ID` ，这将有助于查找日志 |
| Database Transaction 数据库事务                 | Core 核心           | Every Operation that triggered DB transaction(like create project, push image to harbor, etc) 触发数据库事务的每个操作（如创建项目、推送镜像到港等） |
| Received HTTP Request 已收到 HTTP 请求          | Jobservice 工作服务 | Every HTTP request(like health check, call from core, etc.) 每个HTTP请求（如健康检查、核心调用等） |
| Client Sent HTTP Request 客户端发送的 HTTP 请求 | Jobservice 工作服务 | jobservice access other services via HTTP(like replication job calling core API to push image, GC job calling registryctl API, etc.) jobservice通过HTTP访问其他服务（如复制作业调用核心API推送镜像，GC作业调用registryctl API等） |
| backend jobs 后端作业                           | Jobservice 工作服务 | Any job ran by jobservice jobservice 运行的任何作业          |
| Received HTTP Request 已收到 HTTP 请求          | Registryctl 注册表  | Every HTTP request(like health check from core, call from jobservice, etc.) 每个HTTP请求（如来自核心的健康检查，来自jobservice的调用等） |

## Create System Robot Accounts               
创建系统机器人帐户

Harbor incorporates the concept of system-wide robot accounts. An  administrator can create a system-wide robot account covering multiple  projects. System robot accounts are used to create non-user-scoped credentials to  perform operations and API calls across multiple projects.
Harbor 采用了系统级机器人账户的概念。管理员可以创建涵盖多个项目的系统级机器人帐户。系统机器人帐户用于创建非用户范围的凭据，以在多个项目中执行操作和 API 调用。

Each system robot account can have multiple system permissions and multiple project level permissions across multiple projects.
每个系统机器人账号可以有多个系统权限，也可以跨多个项目拥有多个项目级权限。

The  [**Permission References**](https://goharbor.io/docs/2.11.0/administration/robot-accounts/#permission-references) contains a list of permission and their operations. These permissions can be combined and assigned to a system robot  account, allowing it to execute the desired tasks via an OCI client or  the Harbor API. Robot Accounts cannot be used to log into the user  interface.
权限引用包含权限及其操作的列表。这些权限可以组合并分配给系统机器人帐户，从而允许其通过 OCI 客户端或 Harbor API 执行所需的任务。机器人帐户不能用于登录用户界面。

You can also create project-scoped robot accounts that have access limited to a single project. Read more about  [project robot accounts](https://goharbor.io/docs/2.11.0/working-with-projects/project-configuration/create-robot-accounts/).
您还可以创建项目范围的机器人帐户，这些帐户的访问权限仅限于单个项目。阅读有关项目机器人帐户的更多信息。

## View System Robot Accounts 查看系统机器人帐户

1. Log into your Harbor instance as an administrator.
   以管理员身份登录 Harbor 实例。
2. In the sidebar select **Robot Accounts** in the **Administration section**.
   在侧边栏中，选择“管理”部分的“机器人帐户”。



​    ![System robot account page](https://goharbor.io/docs/2.11.0/img/robot-account/system-robot-account-page.png)  



This page contains the lists of all existing system robot accounts in your  Harbor instance. The table contains the following information for each  system robot account:
此页面包含 Harbor 实例中所有现有系统机器人帐户的列表。该表包含每个系统机器人帐户的以下信息：

- The name of a system account. This is derived from robot account prefix  configured for your Harbor instance and the name assigned to the account when it was created. A robot account name follows the format `<prefix><account_name>`. If you use the search function on this page, you only need to search for the account name without the prefix.
  系统帐户的名称。这是从为您的 Harbor 实例配置的机器人账户前缀以及创建账户时分配给账户的名称派生而来的。机器人帐户名称遵循以下格式 `<prefix><account_name>` 。如果您在此页面上使用搜索功能，则只需搜索不带前缀的账户名称即可。

- Enabled status indicates whether an account is active or deactivated.
  “已启用”状态指示帐户是处于活动状态还是已停用状态。

- The count of system permissions an account is assigned to. To see a full set of the assigned system permissions, click on the **PERMISSIONS** link.
  帐户分配到的系统权限计数。要查看已分配的系统权限的完整集，请单击“权限”链接。

  

  ​    ![View all the system permissions](https://goharbor.io/docs/2.11.0/img/robot-account/view-system-permissions.png)  

  

- The number of projects an account is associated with. Click on the **PROJECT(S)** link to see a full list of projects associated with an account.
  帐户关联的项目数。单击“项目”链接可查看与帐户关联的项目的完整列表。

  

  ​    ![View list of all projects associated with a system robot account](https://goharbor.io/docs/2.11.0/img/list-robot-account-projects.png)  

  

- The created time shows when the robot account was created.
  创建时间显示机器人帐户的创建时间。

- The account expiration time. Calculated based on the created time and the expiration time set when creating the robot account.
  帐户过期时间。根据创建机器人账户时设置的创建时间和到期时间计算。

- The manually added description for the system robot account.
  手动添加的系统机器人帐户的描述。

## Add a System Robot Account 添加 System Robot 帐户

1. Log in to the Harbor interface, with system administrator privileges.
   使用系统管理员权限登录 Harbor 界面。

2. Go to **Administration**, select a project, and select **Robot Accounts**.
   转到“管理”，选择一个项目，然后选择“机器人帐户”。

3. Click **New Robot Account**. 单击“新建机器人帐户”。

   

   ​    ![Create system robot account window](https://goharbor.io/docs/2.11.0/img/robot-account/create-system-robot-account-step1.png)  

   

4. Enter a name and an optional description for this robot account.
   输入此机器人帐户的名称和可选描述。

5. Set Expiration time for this robot account. By default the system configured expiration time is used. You can also select **Never Expired** from the dropdown if you want to create a never expiring robot account.
   设置此机器人帐户的过期时间。默认情况下，使用系统配置的过期时间。如果您想创建一个永不过期的机器人帐户，您也可以从下拉列表中选择永不过期。

6. Select the system permissions for this robot account.
   选择此机器人帐户的系统权限。

7. Select **Cover all projects** if you want to use this system robot account across all projects. Using this option means that this system robot account will be able to access all existing and future projects in your Harbor instance. You can  select which permission to grant to the robot account.
   如果要在所有项目中使用此系统机器人帐户，请选择“覆盖所有项目”。使用此选项意味着此系统机器人帐户将能够访问您的 Harbor 实例中的所有现有和未来项目。您可以选择向机器人帐户授予哪个权限。

   ​    ![Cover all projects and select permissions](https://goharbor.io/docs/2.11.0/img/robot-account/cover-all-project-and-select-permissions.png)  

   

8. If you want this robot account to only cover certain projects or be  granted certain permissions, use the project table to select the  projects and permissions you want to assign to the system robot account. This table shows the each project name, the project creation time, and a dropdown list of permissions to assign the system robot account for  that project.
   如果您希望此机器人帐户仅涵盖特定项目或被授予特定权限，请使用项目表选择要分配给系统机器人帐户的项目和权限。此表显示每个项目名称、项目创建时间以及用于为该项目分配系统机器人帐户的权限下拉列表。

   

   ​    ![Project table for assigning robot accounts](https://goharbor.io/docs/2.11.0/img/robot-account/project-table-robot-account.png)  

   

   Click the checkbox next to the project name to associate this robot account.
   单击项目名称旁边的复选框以关联此机器人帐户。

   By default the table shows all projects in your Harbor instance. You are able to filter for projects using the **filter icon** to the right of Project Name header. Note that the project table may be broken into pages and only display a subset of projects at one time  depending on how many projects you have in your Harbor instance and how  many projects match your filter criteria.
   默认情况下，该表会显示 Harbor 实例中的所有项目。您可以使用“项目名称”标题右侧的过滤器图标来过滤项目。请注意，项目表可能会分成多个页面，并且一次只显示项目的子集，具体取决于 Harbor 实例中有多少个项目以及有多少项目符合您的筛选条件。

   

   ​    ![Filter project names](https://goharbor.io/docs/2.11.0/img/robot-account-filter-project-name.png)  

   

   Use the **Permissions** dropdown to choose which permissions to assign to a particular project. You are able to control which permissions to assign to an individual  robot account by project, allowing you fine grained control over each  robot account. You can select **Select All** or **Unselect All** to quickly add or remove all permissions from a robot account.
   使用“权限”下拉列表选择要分配给特定项目的权限。您可以控制按项目为单个机器人账户分配哪些权限，从而对每个机器人账户进行细粒度控制。您可以选择“全选”或“取消全选”以快速添加或删除机器人帐户中的所有权限。

   ​                        

   ​                 The **Push Repository** permission must be assigned with the **Pull Repository** permission. You are not able to assign the Push Repository permission by itself.      
   Push Repository 权限必须与 Pull Repository 权限一起分配。您无法自行分配 Push Repository 权限。

   

   ​    ![Set project permission](https://goharbor.io/docs/2.11.0/img/robot-account/set-project-permissions.png)  

   

   Click the **Reset All Project Permissions** dropdown to control which permissions are available for each project.  Selecting or unselecting a permission will add or remove the permission  for every project. Using this option will adjust permissions for all  projects, not just the projects shown if you have filtered for a  specific project name.
   单击“重置所有项目权限”下拉列表以控制每个项目可用的权限。选择或取消选择权限将为每个项目添加或删除权限。使用此选项将调整所有项目的权限，而不仅仅是已筛选特定项目名称后显示的项目的权限。

   

   ​    ![Reset robot account permissions](https://goharbor.io/docs/2.11.0/img/robot-account/reset-robot-permissions.png)  

   

   Click **Select All Projects** to associate the system robot account with all of the projects shown in the table. If you are filtering by project name, this option will only  select the filtered projects.
   单击“选择所有项目”，将系统机器人帐户与表中显示的所有项目关联。如果按项目名称进行筛选，则此选项将仅选择已筛选的项目。

9. Click **FINISH**. 单击 FINISH。

10. In the confirmation window, click **Export to File** to download the secret as a JSON file, or click the clipboard icon to copy its contents to the clipboard.
    在确认窗口中，单击“导出到文件”以将密钥下载为 JSON 文件，或单击剪贴板图标将其内容复制到剪贴板。

    

    ​    ![Copy system robot account token](https://goharbor.io/docs/2.11.0/img/copy-system-robot-account-token.png)  

    

    ​                        

    ​                 Harbor does not store robot account secrets, so you must either  download the secret or copy and paste its contents into a text file.  There is no way to get the secret from Harbor after you have created the robot account.      
    Harbor 不存储机器人帐户密钥，因此您必须下载密钥或将其内容复制并粘贴到文本文件中。创建机器人帐户后，无法从 Harbor 获取秘密。

    The new robot account appears as `<prefix>account_name` in the list of robot accounts. Read more about  [robot account prefixes](https://goharbor.io/docs/2.11.0/administration/robot-accounts/#configure-robot-account-prefix).
    新的机器人帐户将显示在 `<prefix>account_name` 机器人帐户列表中。阅读有关机器人帐户前缀的更多信息。

## Administration System Robot Account 管理系统机器人账户

You are able to edit, deactivate, or delete a system robot account.
您可以编辑、停用或删除系统机器人帐户。

1. From the administrator **Robot Account** page, select the checkbox next to the robot account you are updating.
   在管理员机器人帐户页面中，选中要更新的机器人帐户旁边的复选框。
2. Select **Action** and then **Edit**, **Deactivate**, or **Delete**.
   选择“操作”，然后选择“编辑”、“停用”或“删除”。



​    ![deactivate or delete a robot account](https://goharbor.io/docs/2.11.0/img/disable-delete-system-robot-account.png)  



## Refresh System Robot Account Secret 刷新系统机器人帐户密钥

You can refresh a robot account’s secret after its created in the event that you need a new one.
如果您需要一个新帐户，您可以在创建机器人帐户后刷新其密钥。

1. From the administrator **Robot Account** page, select the checkbox next to the robot account you are updating.
   在管理员机器人帐户页面中，选中要更新的机器人帐户旁边的复选框。

2. Select **Action** and then **Refresh Secret**.
   选择“操作”，然后选择“刷新机密”。

3. By default Harbor will generate a new secret randomly, or you can choose  to enable manually reseting the secret and entering the **New Secret** then **Confirm Secret**. Optionally, you can view the secret by clicking the eye icon.
   默认情况下，Harbor 会随机生成一个新密钥，或者您可以选择启用手动重置密钥并输入新密钥，然后再确认密钥。或者，您可以通过单击眼睛图标来查看密钥。

   

   ​    ![Refresh system robot account secret](https://goharbor.io/docs/2.11.0/img/refresh-robot-account-token.png)  

   

4. Click **Refresh**. If you created a secret randomly, download the secret JSON file or copy and paste its contents.
   单击“刷新”。如果您随机创建了密钥，请下载密钥 JSON 文件或复制并粘贴其内容。

## Configure the Expiry Period of Robot Accounts 配置机器人账号的有效期

By default, robot accounts expire after 30 days. You can set a longer or  shorter lifespan for robot accounts by modifying the expiry period for  robot account tokens. The expiry period applies to all robot accounts in all projects.
默认情况下，机器人帐户将在 30 天后过期。您可以通过修改机器人账户令牌的有效期来为机器人账户设置更长或更短的生命周期。有效期适用于所有项目中的所有机器人账户。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Go to **Configuration** and select **System Settings**.
   转到“配置”，然后选择“系统设置”。

3. In the **Robot Token Expiration (Days)** row, modify the number of days after which robot account tokens expire.
   在 Robot Token Expiration （Days） 行中，修改机器人帐户令牌过期的天数。

   

   ​    ![Set robot account token expiry](https://goharbor.io/docs/2.11.0/img/set-robot-account-token-duration.png)  

   

## Configure Robot Account Prefix 配置机器人帐户前缀

By default, robot account names use a prefix of `robot$`. Harbor uses this prefix to distinguish a robot account from a user  account. The full name of a system robot account is the prefix and the  name you provide when creating the robot account. For example if you  create a new robot system account with the name `test`, the full name is  `robot$test`.
默认情况下，机器人帐户名称使用前 `robot$` 缀 。Harbor 使用此前缀来区分机器人账户和用户账户。系统机器人帐户的全名是您在创建机器人帐户时提供的前缀和名称。例如，如果创建一个名为 `test` 的新机器人系统帐户，则全名为 `robot$test` 。

The same prefix is used for all robot accounts, including both system and  project robot accounts. When you update this value, it will apply to all existing and future system and project robot accounts, except robot  accounts created in Harbor v2.1 and earlier which will continue to use  the prefix `robot$`.
所有机器人帐户（包括系统和项目机器人帐户）都使用相同的前缀。当您更新此值时，它将应用于所有现有和未来的系统和项目机器人账户，但在 Harbor v2.1 及更早版本中创建的机器人账户除外，这些账户将继续使用前缀 `robot$` 。

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Go to **Configuration** and select **System Settings**.
   转到“配置”，然后选择“系统设置”。

3. In the **Robot Name Prefix** row, modify the prefix.
   在“机器人名称前缀”行中，修改前缀。

   

   ​    ![Set robot account prefix](https://goharbor.io/docs/2.11.0/img/set-robot-prefix.png)  

   

## Authenticate with a System Robot Account 使用 System Robot 帐户进行身份验证

To use a robot account in an automated process, for example a script, use `docker login` and provide the credentials of the robot account.
要在自动化流程（例如脚本）中使用机器人帐户，请使用 `docker login` 并提供机器人帐户的凭据。

```fallback
docker login <harbor_address<>
Username: <prefix><account_name>
Password: <secret>
```

## Permission References  权限引用

The below tables explain what a robot account can do with a specified permission.
下表说明了机器人帐户可以使用指定权限执行哪些操作。

#### System permissions 系统权限

| Permission (an action + a resource) 权限（操作 + 资源）      | Abilities 能力                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| List Audit log (audit-log) 列出审核日志 （audit-log）        | 1. GET  [/audit-logs](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1611) 1. 获取 /audit-logs |
| Read Catalog (catalog) 读取目录（catalog）                   | 1. GET /v2/_catalog 1. 获取 /v2/_catalog                     |
| Read Garbage Collection (garbage-collection) 读取垃圾回收 （garbage-collection） | 1. GET  [/system/gc/{gc_id}/log](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4216) 1. 获取 /system/gc/{gc_id}/log 2. GET  [/system/gc/schedule](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4244) 2. 获取 /system/gc/schedule |
| List Garbage Collection (garbage-collection) 列出垃圾回收 （garbage-collection） | 1. GET  [/system/gc](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4141) 1. 获取 /system/gc |
| Create Garbage Collection (garbage-collection) 创建垃圾回收 （garbage-collection） | 1. POST  [/system/gc/schedule](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4263) 1. 开机自检 /system/gc/schedule |
| Stop Garbage Collection (garbage-collection) 停止垃圾回收 （garbage-collection） | 1. PUT  [/system/gc/{gc_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4196) 1. 把 /system/gc/{gc_id} |
| Update Garbage Collection (garbage-collection) 更新垃圾回收 （garbage-collection） | 1. PUT  [/system/gc/schedule](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4291) 1. 放置 /system/gc/schedule |
| List Job Service Monitor (jobservice-monitor) 列出作业服务监视器 （jobservice-monitor） | 1. GET  [/jobservice/pools](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4641) 1. 获取 /jobservice/pools 2. GET  [/jobservice/pools/{pool_id}/workers](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L466) 2. 获取 /jobservice/pools/{pool_id}/workers 3. GET  [/jobservice/jobs/{job_id}/log](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4717) 3. 获取 /jobservice/jobs/{job_id}/log  4. GET  [/jobservice/queues](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4750) 4. 获取 /jobservice/queues |
| Stop Job Service Monitor (jobservice-monitor) 停止作业服务监视器 （jobservice-monitor） | 1. PUT  [/jobservice/jobs/{job_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4692) 1. 放置 /jobservice/jobs/{job_id}  2. PUT  [/jobservice/queues/{job_type}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4774) 2. 放置 /jobservice/queues/{job_type} |
| Read Label (label) 读取标签（label）                         | 1. GET  [/labels/{global_label_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L5869) 1. 获取 /labels/{global_label_id} |
| Create Label (label) 创建标签（label）                       | 1. POST  [/labels?scope=g](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L5836) 1. POST /labels？scope=g |
| Update Label (label) 更新标签（label）                       | 1. PUT  [/labels/{global_label_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L5890) 1. 放置 /labels/{global_label_id} |
| Delete Label (label) 删除标签（label）                       | 1. DELETE  [/labels/{global_label_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L5919) 1. 删除 /labels/{global_label_id} |
| Read Preheat Instance (preheat-instance) 读取预热实例 （preheat-instance） | 1. POST  [/preheat/instances/ping](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1706) 1. 开机自检/预热/实例/ping 2. GET  [/p2p/preheat/instances/{preheat_instance_name}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1799) 2. 获取 /p2p/preheat/instances/{preheat_instance_name} |
| List Preheat Instance (preheat-instance) 列出预热实例 （preheat-instance） | 1. GET  [/p2p/preheat/providers](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1680) 1. 获取 /p2p/preheat/providers  2. GET  [/p2p/preheat/instances](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1733) 2. 获取 /p2p/preheat/instances |
| Create Preheat Instance (preheat-instance) 创建预热实例（preheat-instance） | 1. POST  [/p2p/preheat/instances](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1769) 1. 开机自检/p2p/preheat/instances |
| Update Preheat Instance (preheat-instance) 更新预热实例 （preheat-instance） | 1. PUT  [/p2p/preheat/instances/{preheat_instance_name}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1843) 1. 放置 /p2p/preheat/instances/{preheat_instance_name} |
| Delete Preheat Instance (preheat-instance) 删除预热实例 （preheat-instance） | 1. DELETE  [/p2p/preheat/instances/{preheat_instance_name}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L1823) 1. 删除 /p2p/preheat/instances/{preheat_instance_name} |
| List Project (project) 列出项目（project）                   | 1. GET  [/projects](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L272) 1. 获取/项目 |
| Create Project (project) 创建项目 （project）                | 1. POST  [/projects](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L343) 1. 发布/项目 |
| Read Purge Audit (purge-audit) 阅读清除审计 （purge-audit）  | 1. GET  [/system/purgeaudit/{purge_id}/log](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4394) 1. 获取 /system/purgeaudit/{purge_id}/log 2. GET  [/system/purgeaudit/schedule](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4421) 2. 获取 /system/purgeaudit/schedule 3. GET  [/system/purgeaudit/{purge_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4351) 3. 获取 /system/purgeaudit/{purge_id} |
| List Purge Audit (purge-audit) 列表清除审计（purge-audit）   | 1. GET  [/system/purgeaudit](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4318) 1. 获取 /system/purgeaudit |
| Create Purge Audit (purge-audit) 创建清除审计（清除-审计）   | 1. POST  [/system/purgeaudit/schedule](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4440) 1. 发布/系统/清除审计/计划 |
| Stop Purge Audit (purge-audit) 停止清除审计（清除-审计）     | 1. PUT  [/system/purgeaudit/{purge_id}](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4373) 1. 放置 /system/purgeaudit/{purge_id} |
| Update Purge Audit (purge-audit) 更新清除审计 （purge-audit） | 1. PUT  [system/purgeaudit/schedule](https://github.com/goharbor/harbor/blob/323e11fefba181fd982b9773dacefa44b2ef0ca0/api/v2.0/swagger.yaml#L4470) 1. PUT系统/清除审计/计划 |
| Read Registry (registry) 读取注册表 （registry）             | 1. POST  [/registries/ping](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3855) 1. 发布 /registries/ping  2. GET  [/registries/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3883) 2. 获取 /registries/{id}  3. GET   [/registries/{id}/info](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3971) 3. 获取 /registries/{id}/info |
| List Registry (registry) 列表注册表（注册表）                | 1. GET  [/registries](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3817) 1. GET /注册表 |
| Create Registry (registry) 创建注册表（registry）            | 1. POST  [/registries](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3790) 1. 开机自检/注册管理机构 |
| Update Registry (registry) 更新注册表 （registry）           | 1. PUT  [/registries/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3937) 1. 放置 /registries/{id} |
| Delete Registry (registry) 删除注册表 （registry）           | 1. DELETE  [/registries/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3910) 1. 删除 /registries/{id} |
| Read Replication (replication) 读取复制 （replication）      | 1. GET   [/replication/executions/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3605) 1. 获取 /replication/executions/{id}   2. GET  [/replication/executions/{id}/tasks/{task_id}/log](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3706) |
| List Replication (replication) 列表复制 （replication）      | 1. GET  [/replication/executions](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3533) 1. 获取 /复制/执行  2. GET   [/replication/executions/{id}/tasks](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3658) 2. GET /复制/执行/{id}/任务 |
| Create Replication (replication) 创建复制（复制）            | 1. POST  [/replication/executions](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3579) 1. POST /复制/执行 2. PUT   [/replication/executions/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3632) 2. PUT /复制/执行/{id} |
| List Replication Adapter (replication-adapter) 列出复制适配器 （replication-adapter） | 1. GET   [/replication/adapters](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3746) 1. GET /复制/适配器 2. GET  [/replication/adapterinfos](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3768) 2. 获取 /replication/adapterinfos |
| Read Replication Policy (replication-policy) 读取复制策略 （replication-policy） | 1. GET  [/replication/policies/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3447) 1. 获取 /replication/policies/{id} |
| List Replication Policy (replication-policy) 列表复制策略 （replication-policy） | 1. GET   [/replication/policies](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3382) 1. 获取 /复制/策略 |
| Create Replication Policy (replication-policy) 创建复制策略 （replication-policy） | 1. POST  [/replication/policies](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3419) 1. 发布/复制/策略 |
| Update Replication Policy (replication-policy) 更新复制策略 （replication-policy） | 1. PUT    [/replication/policies/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3499) 1. 放置 /replication/policies/{id} |
| Delete Replication Policy (replication-policy) 删除复制策略 （replication-policy） | 1. DELETE  [/replication/policies/{id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3472) 1. 删除 /replication/policies/{id} |
| Read Scan All (scan-all) 读取全部扫描 （scan-all）           | 1. GET  [/scans/all/metrics](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L3999) 1. 获取 /scans/all/metrics  2. GET  [/scans/schedule/metrics](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L4021) 2. 获取 /scans/schedule/metrics |
| Create Scan All (scan-all) 创建“全部扫描”（scan-all）        | 1. POST  [/system/scanAll/schedule](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L4591) 1. 开机自检 /system/scanAll/schedule |
| Stop Scan All (scan-all) 停止全部扫描 （scan-all）           | 1. POST  [/system/scanAll/stop](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L4621) 1. 开机自检/system/scanAll/stop |
| Update Scan All (scan-all) 更新全部扫描 （scan-all）         | 1. PUT  [/system/scanAll/schedule](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L4564) |
| Read Scanner (scanner) 读取扫描器（扫描器）                  | 1. POST  [/scanners/ping](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5295) 1. 开机自检 /scanners/ping  2. GET  [/scanners/{registration_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5322) 2. 获取 /scanners/{registration_id}  3. GET  [/scanners/{registration_id}/metadata](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5436) 3. 获取 /scanners/{registration_id}/metadata |
| List Scanner (scanner) 列表扫描器（扫描器）                  | 1. GET  [/scanners](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5229) 1. GET /扫描仪 |
| Create Scanner (scanner) 创建扫描仪 （scanner）              | 1. POST  [/scanners](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5264) 1. 开机自检/扫描仪 |
| Update Scanner (scanner) 更新扫描程序 （scanner）            | 1. PUT   [/scanners/{registration_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5349) 1. 放置 /scanners/{registration_id} |
| Delete Scanner (scanner) 删除扫描程序 （scanner）            | 1. DELETE   [/scanners/{registration_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5380) 1. 删除 /scanners/{registration_id} |
| Read Security Hub (security-hub) 读取安全中心 （security-hub） | 1. GET  [/security/summary](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L6056) |
| List Security Hub (security-hub) 列出安全中心 （security-hub） | 1. GET  [/security/vul](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L6091) 1. 获取 /security/vul |
| Read System Volumes (system-volumes) 读取系统卷 （system-volumes） | 1. GET  [/systeminfo/volumes](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L4061) 1. 获取 /systeminfo/volumes |

#### Project permissions 项目权限

| Permission (an action + a resource) 权限（操作 + 资源）      | Abilities 能力                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| List Accessory (accessory) 列表配件（配件）                  | 1. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1348) 1. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories |
| Read Artifact (artifact) 读取工件 （artifact）               | 1. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1067) 1. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference} |
| List Artifact (artifact) 列出工件 （artifact）               | 1. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L961) 1. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts |
| Create Artifact (artifact) 创建工件 （artifact）             | 1. POST  [/projects/{project_name}/repositories/{repository_name}/artifacts](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1036) 1. 发布 /projects/{project_name}/repositories/{repository_name}/artifacts |
| Delete Artifact (artifact) 删除工件 （artifact）             | 1. DELETE  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1133) 1. 删除 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference} |
| Read Artifact Addition (artifact-addition) 读取工件添加 （artifact-addition） | 1. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1388) 1. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities  2. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1420) 2. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition} |
| Create Artifact Label (artifact-label) 创建工件标签 （artifact-label） | 1. POST  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1457) 1. 发布 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels |
| Delete Artifact Label (artifact-label) 删除工件标签 （artifact-label） | 1. DELETE  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L1490) 1. 删除 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id} |
| List Immutable Tag (immutable-tag) 列出不可变标签 （immutable-tag） | 1. GET  [/projects/{project_name_or_id}/immutabletagrules](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L2396) 1. 获取 /projects/{project_name_or_id}/immutabletagrules |
| Create Immutable Tag (immutable-tag) 创建不可变标签 （immutable-tag） | 1. POST  [/projects/{project_name_or_id}/immutabletagrules](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L2433) 1. 发布 /projects/{project_name_or_id}/immutabletagrules |
| Update Immutable Tag (immutable-tag) 更新不可变标签 （immutable-tag） | 1. PUT  [/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L2463) 1. 放置 /projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id} |
| Delete Immutable Tag (immutable-tag) 删除不可变标签 （immutable-tag） | 1. DELETE  [/projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L2489) 1. 删除 /projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id} |
| Read Label (label) 读取标签（label）                         | 1. GET  [/labels/{project_label_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5869) 1. 获取 /labels/{project_label_id} |
| List Label (label) 列表标签（label）                         | 1. GET  [/labels?scope=p&project_id={project_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5787) 1. GET /labels？scope=p&project_id={project_id} |
| Create Label (label) 创建标签（label）                       | 1. POST  [/labels?scope=p&project_id={project_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5836) 1. POST /labels？scope=p&project_id={project_id} |
| Update Label (label) 更新标签（label）                       | 1. PUT  [/labels/{project_label_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5890) 1. 放置 /labels/{project_label_id} |
| Delete Label (label) 删除标签（label）                       | 1. DELETE  [/labels/{project_label_id}](https://github.com/goharbor/harbor/blob/f99a619bc676ba614048c5a84cf0598adc79519f/api/v2.0/swagger.yaml#L5919) 1. 删除 /labels/{project_label_id} |
| List Log (log) 列表日志 （log）                              | 1. GET  [/projects/{project_name}/logs](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1646) 1. 获取 /projects/{project_name}/logs |
| Read Project Metadata (metadata) 读取项目元数据（metadata）  | 1. GET  [/projects/{project_name_or_id}/metadatas/{meta_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L715) 1. 获取 /projects/{project_name_or_id}/metadatas/{meta_name} |
| List Project Metadata (metadata) 列出项目元数据（metadata）  | 1. GET  [/projects/{project_name_or_id}/metadatas](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L656) 1. 获取 /projects/{project_name_or_id}/metadatas |
| Create Project Metadata (metadata) 创建项目元数据（metadata） | 1. POST  [/projects/{project_name_or_id}/metadatas](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L683) 1. 发布 /projects/{project_name_or_id}/metadatas |
| Update Project Metadata (metadata) 更新项目元数据（元数据）  | 1. PUT  [/projects/{project_name_or_id}/metadatas/{meta_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L747) 1. 放置 /projects/{project_name_or_id}/metadatas/{meta_name} |
| Delete Project Metadata (metadata) 删除项目元数据（metadata） | 1. DELETE  [/projects/{project_name_or_id}/metadatas/{meta_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L783) 1. 删除 /projects/{project_name_or_id}/metadatas/{meta_name} |
| Read Notification Policy (notification-policy) 读取通知策略 （notification-policy） | 1. GET  [/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2584) 1. 获取 /projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}  2. GET  [/projects/{project_name_or_id}/webhook/lasttrigger](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2787) 2. 获取 /projects/{project_name_or_id}/webhook/lasttrigger  3. GET  [/projects/{project_name_or_id}/webhook/events](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2867) 3. 获取 /projects/{project_name_or_id}/webhook/events   4. GET  [/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}/executions](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2668) 4. 获取 /projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}/executions  5. GET  [/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}/executions/{execution_id}/tasks](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2709) 5. 获取 /projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}/executions/{execution_id}/tasks  6. GET  [/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}/executions/{execution_id}/tasks/{task_id}/log](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2750) |
| List Notification Policy (notification-policy) 列表通知策略 （notification-policy） | 1. GET  [/projects/{project_name_or_id}/webhook/policies](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2511) 1. 获取 /projects/{project_name_or_id}/webhook/policies  2. GET  [/projects/{project_name_or_id}/webhook/jobs](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2815) 2. 获取 /projects/{project_name_or_id}/webhook/jobs |
| Create Notification Policy (notification-policy) 创建通知策略 （notification-policy） | 1. POST  [/projects/{project_name_or_id}/webhook/policies](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2548) 1. 发布 /projects/{project_name_or_id}/webhook/policies |
| Update Notification Policy (notification-policy) 更新通知策略 （notification-policy） | 1. PUT  [/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2611) |
| Delete Notification Policy (notification-policy) 删除通知策略 （notification-policy） | 1. DELETE  [/projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2642) 1. 删除 /projects/{project_name_or_id}/webhook/policies/{webhook_policy_id} |
| Read Preheat Policy (preheat-policy) 阅读预热政策 （preheat-policy） | 1. GET  [/projects/{project_name}/preheat/policies/{preheat_policy_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1936) 1. 获取 /projects/{project_name}/preheat/policies/{preheat_policy_name}  2. POST  [/projects/{project_name}/preheat/policies/{preheat_policy_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1992) 2. 发布 /projects/{project_name}/preheat/policies/{preheat_policy_name}  3. GET  [/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2084) 3. 获取 /projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}  4. GET  [/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2181) |
| List Preheat Policy (preheat-policy) 列表预热策略 （preheat-policy） | 1. GET  [/projects/{project_name}/preheat/policies](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1900) 1. 获取 /projects/{project_name}/preheat/policies  2. GET  [/projects/{project_name}/preheat/providers](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2215) 2. 获取 /projects/{project_name}/preheat/providers |
| Create Preheat Policy (preheat-policy) 创建预热策略 （preheat-policy） | 1. POST  [/projects/{project_name}/preheat/policies](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1872) 1. 发布 /projects/{project_name}/preheat/policies |
| Update Preheat Policy (preheat-policy) 更新预热策略 （preheat-policy） | 1. PUT  [/projects/{project_name}/preheat/policies/{preheat_policy_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1961) 1. 放置 /projects/{project_name}/preheat/policies/{preheat_policy_name}  2. PATCH  [/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2110) 2. 修补 /projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id} |
| Delete Preheat Policy (preheat-policy) 删除预热策略 （preheat-policy） | 1. DELETE  [/projects/{project_name}/preheat/policies/{preheat_policy_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L2021) 1. 删除 /projects/{project_name}/preheat/policies/{preheat_policy_name} |
| Read Project (project) 读取项目 （project）                  | 1. GET  [/projects/{project_name_or_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L370) 1. 获取 /projects/{project_name_or_id} |
| Update Project (project) 更新项目（project）                 | 1. PUT  [/projects/{project_name_or_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L389) 1. 放置 /projects/{project_name_or_id} |
| Delete Project (project) 删除项目 （project）                | 1. DELETE  [/projects/{project_name_or_id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L418) 1. 删除 /projects/{project_name_or_id}  2. GET  [/projects/{project_name_or_id}/_deletable](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L442) 2. 获取 /projects/{project_name_or_id}/_deletable |
| Read Repository (repository) 读取仓库（repository）          | 1. GET  [/projects/{project_name}/repositories/{repository_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L883) 1. 获取 /projects/{project_name}/repositories/{repository_name} |
| List Repository (repository) 列表仓库（repository）          | 1. GET  [/projects/{project_name}/repositories](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L845) 1. 获取 /projects/{project_name}/repositoies |
| Update Repository (repository) 更新仓库（repository）        | 1. PUT  [/projects/{project_name}/repositories/{repository_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L908) 1. 放置 /projects/{project_name}/repositories/{repository_name} |
| Delete Repository (repository) 删除仓库（repository）        | 1. DELETE  [/projects/{project_name}/repositories/{repository_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L937) 1. 删除 /projects/{project_name}/repositories/{repository_name} |
| Pull Repository (repository) 拉取仓库（repository）          | 1. Pull artifacts from the project 1. 从项目中提取工件       |
| Push Repository (repository) Push Repository （仓库）        | 1. Push artifacts to the project 1. 将工件推送到项目中       |
| Read Scan (scan) 读取扫描 （scan）                           | 1. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1206) 1. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log |
| Create Scan (scan) 创建扫描 （scan）                         | 1. POST  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1156) 1. 发布 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan。 |
| Stop Scan (scan) 停止扫描 （scan）                           | 1. POST  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1181) 1. 发布 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop |
| Read Scanner (scanner) 读取扫描器（扫描器）                  | 1. GET  [/projects/{project_name_or_id}/scanner](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1521) 1. 获取 /projects/{project_name_or_id}/scanner |
| Create Scanner (scanner) 创建扫描仪 （scanner）              | 1. PUT  [/projects/{project_name_or_id}/scanner](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1546) 1. 放置 /projects/{project_name_or_id}/scanner  2. GET  [/projects/{project_name_or_id}/scanner/candidates](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1575) 2. 获取 /projects/{project_name_or_id}/scanner/candidates |
| List Tag (tag) 列表标签（tag）                               | 1. GET  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1272) 1. 获取 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags |
| Create Tag (tag) 创建标签（tag）                             | 1. POST  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1238) 1. 发布 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags |
| Delete Tag (tag) 删除标签（tag）                             | 1. DELETE  [/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L1324) 1. 删除 /projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name} |
| Read Tag Retention (tag-retention) 读取标签保留 （tag-retention） | 1. GET  [/retentions/{id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L4925) 1. 获取 /retentions/{id}  2. GET  [/retentions/{id}/executions/{eid}/tasks/{tid}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L5188) |
| List Tag Retention (tag-retention) 列表标签保留 （tag-retention） | 1. GET  [/retentions/{id}/executions](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L5044)  2. GET  [/retentions/{id}/executions/{eid}/tasks](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L5133) |
| Create Tag Retention (tag-retention) 创建标签保留 （tag-retention） | 1. POST  [/retentions](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L4895) 1. 职位/保留 |
| Update Tag Retention (tag-retention) 更新标签保留 （tag-retention） | 1. PUT  [/retentions/{id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L4950) 1. 放置 /retentions/{id}  2. POST  [/retentions/{id}/executions](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L5009)  3 PATCH  [/retentions/{id}/executions/{eid}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L5093) 3 补丁 /retentions/{id}/executions/{eid} |
| Delete Tag Retention (tag-retention) 删除标签保留 （tag-retention） | 1. DELETE  [/retentions/{id}](https://github.com/goharbor/harbor/blob/2984c2e04b3b3194cabb44470d0e37acc4b1d5c9/api/v2.0/swagger.yaml#L4981) 1. 删除 /retentions/{id} |

​                        

​                 Public APIs are not included in the tables above because they can be accessed by anyone.      
公共 API 未包含在上表中，因为任何人都可以访问它们

## Garbage Collection                垃圾回收

When you delete images from Harbor, space is not automatically freed up. You must run garbage collection to free up space by removing blobs that are no longer referenced by a manifest from the file system.
当您从 Harbor 中删除图像时，空间不会自动释放。必须运行垃圾回收，通过从文件系统中删除清单不再引用的 blob 来释放空间。

## Run Garbage Collection 运行垃圾回收

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Clean Up**.
   展开“管理”，然后选择“清理”。

3. Select the **‘Garbage Collection’** tab.
   选择“垃圾回收”选项卡。

   

   ​    ![Garbage collection](https://goharbor.io/docs/2.11.0/img/garbage-collection.png)  

   

4. For the **Workers** item, you are able to select the number of workers that can execute GC tasks in parallel.
   对于 Workers 项，您可以选择可以并行执行 GC 任务的工作线程数。

5. To **Allow garbage collection on untagged artifacts**, select the option. If you have this option turned on, the next time  Garbage collect runs on your Harbor instance, Harbor will delete  untagged artifacts and then perform garbage collection on them.
   若要允许对未标记的项目进行垃圾回收，请选择该选项。如果您启用了此选项，则下次在您的 Harbor 实例上运行垃圾回收时，Harbor 将删除未标记的项目，然后对它们执行垃圾回收。

6. To dry run garbage collection, click **DRY RUN**.
   要试运行垃圾回收，请单击 DRY RUN。

7. To run garbage collection immediately, click **GC Now**.
   要立即运行垃圾回收，请单击“立即执行”。

**DRY RUN** prints the blobs eligible for deletion and a rough estimation of free up space without removing any data.
DRY RUN 打印符合删除条件的 blob，并在不删除任何数据的情况下粗略估计释放空间。

To avoid damaging the uploading artifact, the garbage collection  introduces a time windows(2 hours) to reserve the recent uploaded  layers. Garbage collection does not sweep the manifest & blob files  that have a timestamp in the time window. Harbor runs garbage collection without interrupting your ability to continue use Harbor, for example  you are able to push, pull, or delete artifacts while garbage collection is running.
为了避免损坏上传工件，垃圾回收引入了一个时间窗口（2 小时）来预留最近上传的层。垃圾回收不会扫描在时间窗口中具有时间戳的清单和 blob 文件。Harbor 在不中断您继续使用 Harbor  的能力的情况下运行垃圾回收，例如，您可以在垃圾回收运行时推送、拉取或删除工件。

To avoid triggering the garbage collection process too frequently, the availability of the **GC Now** button is restricted. Garbage collection can be only run once per minute.
为了避免过于频繁地触发垃圾回收过程，“GC Now”按钮的可用性受到限制。垃圾回收每分钟只能运行一次。

## Schedule Garbage Collection 计划垃圾回收

You are able to schedule garbage colleciton on your Harbor interface from the **‘Garbage Collection’** tab on the **Administration** > **Clean Up** page of the Harbor interface.
您可以从 Harbor 界面的 Administration > Clean Up 页面上的 “垃圾回收 ”选项卡中安排 Harbor 界面上的垃圾收集。

1. Use the drop down-menu to select how often to run garbage collection.
   使用下拉菜单选择运行垃圾回收的频率。

   

   ​    ![Schedule garbage collection](https://goharbor.io/docs/2.11.0/img/gc-policy.png)  

   

   - **None**: No garbage collection is scheduled.
     无：不计划垃圾回收。
   - **Hourly**: Run garbage collection at the beginning of every hour.
     每小时：每小时开始时运行垃圾回收。
   - **Daily**: Run garbage collection at midnight every day.
     每日：每天午夜运行垃圾回收。
   - **Weekly**: Run garbage collection at midnight every Saturday.
     每周：每周六午夜运行垃圾回收。
   - **Custom**: Run garbage collection according to a `cron` task.
     自定义：根据 `cron` 任务运行垃圾回收。

2. For the **Workers** item, you are able to select the number of workers that can execute GC tasks in parallel.
   对于 Workers 项，您可以选择可以并行执行 GC 任务的工作线程数。

3. To **Allow garbage collection on untagged artifacts**, select the option. If you have this option turned on, the next time  Garbage collect runs on your Harbor instance, Harbor will delete  untagged artifacts and then perform garbage collection on them.
   若要允许对未标记的项目进行垃圾回收，请选择该选项。如果您启用了此选项，则下次在您的 Harbor 实例上运行垃圾回收时，Harbor 将删除未标记的项目，然后对它们执行垃圾回收。

4. Click **Save**. 点击保存。

## View Garbage Collection History 查看垃圾回收历史记录

View garbage collection runs in the **Garbage Collection History** table on the **‘Garbage Collection’** tab on the **Administration** > **Clean Up** page of the Harbor interface.
在 Harbor 界面的 Administration > Clean Up 页面的 “Garbage Collection” 选项卡的 “Garbage Collection History” 表格中查看垃圾回收运行。

Each time you run garbage collection on your Harbor instance, Harbor will track some information about the run including:
每次在 Harbor 实例上运行垃圾回收时，Harbor 都会跟踪有关运行的一些信息，包括：

- **Task ID:** Unique numerical value assigned by Harbor when a run is initiated.
  任务 ID：启动运行时 Harbor 分配的唯一数值。
- **Trigger Type:** How the run was initiated, either Manual or by Schedule.
  触发器类型：运行的启动方式，手动或按计划启动。
- **Dry Run:** If the run was a dry run or not.
  试运行：如果运行是空运行，或者是否为空运行。
- **Status:** Current status of the run.
  状态：运行的当前状态。
- **Details:** Garbage collection details.
  详细信息：垃圾回收详细信息。
- **Creation Time:** Time the run started.
  创建时间：运行开始的时间。
- **Update time:** The last time the run was updated.
  更新时间：上次更新运行的时间。
- **Logs:** A link to the logs generated by the run. If you are performing a Dry  Run, this will include an estimate of the artifacts that will be garbage collected.
  日志：指向运行生成的日志的链接。如果您正在执行试运行，这将包括对将被垃圾回收的项目的估计值。



​    ![Garbage collection history](https://goharbor.io/docs/2.11.0/img/gc-history.png)  



## Stop in Progress Garbage Collection 停止进行中的垃圾回收

You are able to stop any running garbage collection task from the Garbage Collection History table.
您可以从“垃圾回收历史记录”（Garbage Collection History） 表格中停止任何正在运行的垃圾回收任务。

1. Navigate to **Administration** > **Clean Up** page and select the **‘Garbage Collection’** tab.
   导航到“管理”>“清理”页面，然后选择“垃圾回收”选项卡。

2. In the **Garbage Collection History** table, click on the checkbox next to the Task Id of the running garbage collection. You can stop one or more running garbage collection tasks  at one time.
   在“垃圾回收历史记录”表中，单击正在运行的垃圾回收的“任务 ID”旁边的复选框。您可以一次停止一个或多个正在运行的垃圾回收任务。

3. Click **Stop** and then **Confirm** that you want to stop the garbage collection in the modal.
   单击“停止”，然后单击“确认要停止模式中的垃圾回收”。

   

   ​    ![Select Garbage collection task from table](https://goharbor.io/docs/2.11.0/img/gc-stop-run.png)  

   

This will only stop the garbage collection task from processing more  artifacts. Harbor will not restore any artifact that has already been  garbage collected.
这只会阻止垃圾回收任务处理更多项目。Harbor 不会恢复任何已被垃圾回收的工件。

## Log Rotation                日志轮换

By default, Harbor tracks all image pull, push, and delete operations  performed and keeps a record of these actions in a database. Harbor  offers the ability to manage audit logs by configuring an audit log  retention window and setting a syslog endpoint to forward audit logs.
默认情况下，Harbor 会跟踪所有执行的镜像拉取、推送和删除操作，并将这些操作记录在数据库中。Harbor 通过配置审计日志保留窗口和设置 syslog 端点来转发审计日志，从而提供管理审计日志的功能。

## Schedule Log Purge 计划日志清除

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。

2. Expand **Administration**, and select **Clean Up**.
   展开“管理”，然后选择“清理”。

3. Select the **Log Rotation** tab.
   选择“日志轮换”选项卡。

   

   ​    ![Log rotation page in Harbor interface](https://goharbor.io/docs/2.11.0/img/log-rotation.png)  

   

4. Use the drop down-menu to select how often to run log rotation.
   使用下拉菜单选择运行日志轮换的频率。

   

   ​    ![Log rotation policy configuration](https://goharbor.io/docs/2.11.0/img/lr-policy.png)  

   

   - **None**: No log rotation is scheduled.
     无：不计划日志轮换。
   - **Hourly**: Run log rotation at the beginning of every hour.
     每小时：每小时开始时运行日志轮换。
   - **Daily**: Run log rotation at midnight every day.
     每天：每天午夜运行日志轮换。
   - **Weekly**: Run log rotation at midnight every Saturday.
     每周：每周六午夜运行日志轮换。
   - **Custom**: Run log rotation according to a `cron` task.
     自定义：根据 `cron` 任务运行日志轮换。

5. Use the **Keep records in** to configure how long audit logs should be kept. Use the drop down-menu to select **Hours** or **Days**. For example, if you set this to 7 days, Harbor will only purge audit logs that are 8 or more days old.
   使用“保留记录”来配置审核日志应保留多长时间。使用下拉菜单选择“小时”或“天”。例如，如果将此设置为 7 天，则 Harbor 将仅清除 8 天或更长时间的审计日志。

   

   ​    ![Log rotation policy configuration](https://goharbor.io/docs/2.11.0/img/lr-policy-settings.png)  

   

6. Select the **Included Operations** for the purge. When **Create**, **Delete**, or **Pull** is selected, Harbor will include audit logs for those operations in the purge.
   选择用于清除的“包含的操作”。选择“创建”、“删除”或“拉取”时，Harbor 将在清除中包含这些操作的审计日志。

7. Click **Save** to save your log rotation schedule.
   单击“保存”以保存日志轮换计划。

Use the **DRY RUN** option to test your purge settings. When you perform a dry run, Harbor  will create a log with the estimated amount of audit logs that will be  purged. You can view a dry run logs in the **Purge History** table.
使用 DRY RUN 选项测试您的吹扫设置。当您执行试运行时，Harbor 将创建一个日志，其中包含将要清除的估计审计日志量。您可以在“清除历史记录”（Purge History） 表格中查看试运行日志。

Use the **PURGE NOW** option to manually run a purge immediately, without waiting for the next scheduled purge.
使用“立即清除”选项可立即手动运行清除，而无需等待下一次计划的清除。

## View Log Rotation History 查看日志轮换历史记录

View the purge runs in the **Purge History** table. Harbor tracks information about each purge run, including:
在“清除历史记录”（Purge History） 表格中查看清除运行。Harbor 跟踪有关每次清除运行的信息，包括：

- **Task ID:** Unique numerical value assigned by Harbor when a run is initiated.
  任务 ID：启动运行时 Harbor 分配的唯一数值。
- **Trigger Type:** How the run was initiated, either Manual or by Schedule.
  触发器类型：运行的启动方式，手动或按计划启动。
- **Dry Run:** If the run was a dry run or not.
  试运行：如果运行是空运行，或者是否为空运行。
- **Status:** Current status of the run.
  状态：运行的当前状态。
- **Creation Time:** Time the run started.
  创建时间：运行开始的时间。
- **Update time:** The last time the run was updated.
  更新时间：上次更新运行的时间。
- **Logs:** A link to the logs generated by the run. If you are performing a Dry  Run, this will include an estimate of the artifacts that will be purged.
  日志：指向运行生成的日志的链接。如果您正在执行试运行，这将包括对将要清除的项目的估计。



​    ![Purge history table](https://goharbor.io/docs/2.11.0/img/purge-history.png)  



## Configure Audit Log Forward Endpoint 配置审核日志转发终结点

1. Log in to the Harbor interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的账号登录 Harbor 界面。
2. Go to **Configuration** and select **System Settings**.
   转到“配置”，然后选择“系统设置”。
3. In the **Audit Log Forward Syslog Endpoint** row, add your syslog endpoint. If the you installed Harbor with docker-compose, the local syslog endpoint is `harbor-log:10514`.
   在 Audit Log Forward Syslog Endpoint 行中，添加 Syslog 端点。如果您使用 docker-compose 安装了 Harbor，则本地 syslog 端点为 `harbor-log:10514` 。
4. If you have configured an endpoint to forward audit logs, you can select the checkbox to **Skip Audit Log Database**. When selected, Harbor will not keep any records of audit logs in its  database, but will forward all logs to your configured endpoint  immediately.
   如果您已配置端点来转发审计日志，则可以选中“跳过审计日志数据库”复选框。选择此选项后，Harbor 将不会在其数据库中保留任何审计日志记录，但会立即将所有日志转发到您配置的端点。



​    ![Audit log forward endpoint settings](https://goharbor.io/docs/2.11.0/img/audit-log-endpoint.png)  



Harbor will forward all purged records to the audit log forward syslog endpoint you specify.
Harbor 会将所有已清除的记录转发到您指定的审计日志转发 syslog 端点。

## Stop in Progress Log Rotation 停止进行日志旋转

You are able to stop any running log purge task from the Purge History table.
您可以从“清除历史记录”（Purge History） 表格中停止任何正在运行的日志清除任务。

1. Navigate to **Administration** > **Clean Up** page and select the **Log Rotation** tab.
   导航到“管理”>“清理”页面，然后选择“日志轮换”选项卡。

2. In the **Purge History** table, click on the checkbox next to the Task Id of the running log  purge task. You can stop one or more running log purge tasks at one  time.
   在“清除历史记录”（Purge History） 表格中，单击正在运行的日志清除任务的“任务 ID”（Task Id） 旁边的复选框。您可以一次停止一个或多个正在运行的日志清除任务。

3. Click **Stop** and then **Confirm** that you want to stop the garbage collection in the modal.
   单击“停止”，然后单击“确认要停止模式中的垃圾回收”。

   

   ​    ![Select Garbage collection task from table](https://goharbor.io/docs/2.11.0/img/lr-stop-run.png)  

   

This will only stop the log purge task from processing more logs. Harbor will not restore any logs that has already been purged.
这只会阻止日志清除任务处理更多日志。Harbor 不会恢复任何已被清除的日志。

## SBOM Generation Capabilities  SBOM 生成能力

Software Bill of Materials (SBOM) acts as an inventory list, documenting all  components used in a software project. It provides transparency by listing dependencies, their versions, and  associated licenses present it the software or container image. This visibility helps engineers as well as software systems track and  manage potential security issues effectively.
软件物料清单 （SBOM） 充当库存清单，记录软件项目中使用的所有组件。它通过列出依赖项、它们的版本和相关的许可证来提供透明度，并为其提供软件或容器映像。这种可见性有助于工程师和软件系统有效地跟踪和管理潜在的安全问题。

Since version 2.11 Harbor supports now automatic generation of SBOMs in combination with its default scanner - Trivy. Addition to that, users can also click the `GENERATE SBOM` button to manually generate an SBOM of a given artifact.
从版本 2.11 开始，Harbor 现在支持自动生成 SBOM 与其默认扫描器 - Trivy 结合使用。除此之外，用户还可以单击该 `GENERATE SBOM` 按钮以手动生成给定工件的 SBOM。

## Automatic Generation of SBOMs during Image Push 镜像推送时自动生成SBOM

To automatically generate an SBOM for images pushed to Harbor, users need to navigate to the `Configuration` tab of the project where an image was pushed. Then select the checkbox of `SBOM generation` and click `SAVE` button afterward.
要为推送到 Harbor 的图像自动生成 SBOM，用户需要导航到推送图像的项目 `Configuration` 选项卡。然后选择复选框， `SBOM generation` 然后单击 `SAVE` 按钮。



​    ![Enable SBOM auto generation configuration](https://goharbor.io/docs/2.11.0/img/sbom-integration/1_enable_auto_generate_sbom.png)  



After the configuration change, newly pushed artifacts `docker push ...` to this project will automatically trigger the SBOM generation process using the assigned scanner defined in the Scanner section.
配置更改后，新推送 `docker push ...` 到此项目的工件将自动触发 SBOM 生成过程，该过程将使用 Scanner 部分中定义的已分配扫描程序。



​    ![SBOM automatically generated](https://goharbor.io/docs/2.11.0/img/sbom-integration/2_sbom_accessory.png)  



In the project artifact page, users can see the SBOM details link as shown in the above image. By clicking on the “SBOM Details” (Inside the yellow rectangle), users will be redirected to the SBOM details page.
在项目工件页面中，用户可以看到 SBOM 详细信息链接，如上图所示。通过单击“SBOM 详细信息”（黄色矩形内），用户将被重定向到 SBOM 详细信息页面。

A table with package name, its current version, and package license will become visible, including a download link `DOWNLOAD SBOM` to download the file containing full SBOM details in SPDX format.
一个包含包名称、其当前版本和包许可证的表格将变为可见，其中包括一个下载链接 `DOWNLOAD SBOM` ，用于下载包含 SPDX 格式的完整 SBOM 详细信息的文件。



​    ![SBOM details](https://goharbor.io/docs/2.11.0/img/sbom-integration/3_sbom_details.png)  



## Manual SBOM Generation for Container Images With Harbor 手动生成带有 Harbor 的容器镜像的 SBOM

In case the automatic SBOM generation is not enabled or desired, Users can selectively generate SBOMs for container images. Navigate to the artifact page and select the images for which the SBOM should be generated. After one or more images are selected, the Button `GENERATE SBOM` will become available. It is also possible to abort the SBOM generation inside the `ACTIONS` drop-down menu.
如果未启用或不希望自动生成 SBOM，用户可以有选择地为容器镜像生成 SBOM。导航到项目页面，然后选择应为其生成 SBOM 的图像。选择一张或多张图片后，按钮 `GENERATE SBOM` 将变为可用。也可以在 `ACTIONS` 下拉菜单中中止 SBOM 生成。



​    ![SBOM manual generation and stopping](https://goharbor.io/docs/2.11.0/img/sbom-integration/4_stop_manual_generate_sbom.png)  



## How to delete an SBOM 如何删除 SBOM

An SBOM accessory can be deleted individually as shown below by clicking on the three vertical dot icon next to the SBOM accessory you want to delete and then click the `Delete` option.
通过单击要删除的 SBOM 附件旁边的三个垂直点图标，然后单击该 `Delete` 选项，可以单独删除 SBOM 附件，如下所示。



​    ![SBOM deletion individually](https://goharbor.io/docs/2.11.0/img/sbom-integration/5_delete_sbom_individually.png)  



After the deletion, the SBOM accessory will be removed from the artifact and hence not visible in the UI anymore.
删除后，SBOM 附件将从工件中删除，因此在 UI 中不再可见。



​    ![No SBOM accessory](https://goharbor.io/docs/2.11.0/img/sbom-integration/7_no_sbom_after_delete.png)  



The final and physical deletion of the SBOM will be performed during the garbage collection process.
SBOM 的最终和物理删除将在垃圾回收过程中执行。

An SBOM can also be deleted along with its subject artifact, as shown below.
也可以删除 SBOM 及其主题工件，如下所示。



​    ![SBOM deletion together with subject artifact](https://goharbor.io/docs/2.11.0/img/sbom-integration/9_delete_sbom_with_subject_artifact.png)  



## SBOM Replication SBOM 复制

Users can create a pull-based or pushed-based replication rule to replicate a set of artifacts together with their corresponding SBOM  from a source Harbor registry to a destination Harbor registry.
用户可以创建基于拉取或基于推送的复制规则，以将一组工件及其对应的 SBOM 从源 Harbor 注册表复制到目标 Harbor 注册表。

## Security Hub                安全中心

The Security Hub provides administrators with a comprehensive and  centralized overview of the present security status of artifacts stored  within the Harbor registry. Unlike the artifact-centric vulnerability  view, the Security Hub provides a holistic view of all vulnerabilities  across the registry and across all artifacts.
Security Hub 为管理员提供了存储在 Harbor 注册表中的工件当前安全状态的全面而集中的概览。与以工件为中心的漏洞视图不同，Security Hub 提供了注册表和所有工件中所有漏洞的整体视图。

You can access the Security Hub via the Harbor UI Navigation or direct URL:
您可以通过 Harbor UI 导航或直接 URL 访问 Security Hub：

1. Method 1: Accessing the Security Hub via UI Navigation
   方式一：通过UI导航访问Security Hub

   - Login to Harbor as a user with admin permissions, locate and click on the “Administration” option in the Harbor UI.
     以具有管理员权限的用户身份登录 Harbor，在 Harbor UI 中找到并单击“管理”选项。
   - Within the Administration section, find and click on the “Interrogation Service” section.
     在“管理”部分，找到并单击“询问服务”部分。
   - The Security Hub tab can be found on the “Interrogation Service” settings page. Click on it.
     可以在“查询服务”设置页面上找到“Security Hub”选项卡。点击它。

2. Method 2: Accessing the Security Hub via Direct URL:
   方法二：通过直接URL访问Security Hub：

   - Open your web browser, and enter the following URL in the address bar: `https://<harbor-domain>/harbor/interrogation-services/security-hub`.
     打开 Web 浏览器，然后在地址栏中输入以下 URL： `https://<harbor-domain>/harbor/interrogation-services/security-hub` 。

   Note: Replace  with the appropriate domain or IP address of your Harbor instance
   注意：请替换为 Harbor 实例的相应域或 IP 地址

The page title displays the total count of artifacts and scanned artifacts.
页面标题显示工件和扫描工件的总数。

## Total Vulnerabilities 漏洞总数

The first card shows the total number of vulnerabilities found in the  scanned images. The total number is broken up into severity groups with  their respective occurrences.
第一张卡片显示在扫描图像中发现的漏洞总数。总数被分解为严重性组，并具有各自的出现次数。



​    ![Total Vulnerabilities](https://goharbor.io/docs/2.11.0/img/security-hub/total_vulnerabilities.png)  



## Top 5 Most Dangerous Artifacts 前 5 名最危险的文物

The second card shows the top 5 most dangerous artifacts found in scanned  artifacts. It ranks the severe artifacts according to the number of  vulnerabilities and their severity levels. Clicking on an artifact, the  vulnerability table will query all vulnerabilities found in the selected artifact.
第二张卡片显示在扫描的工件中发现的前 5 个最危险的工件。它根据漏洞的数量及其严重性级别对严重工件进行排名。单击工件，漏洞表将查询在所选工件中找到的所有漏洞。



​    ![Most Dangerous Artifacts](https://goharbor.io/docs/2.11.0/img/security-hub/dangerous_artifacts.png)  



## Top 5 Most Dangerous CVEs 前 5 个最危险的 CVE

The third card shows the top 5 most dangerous CVEs found in scanned  artifacts. it sorts the dangerous CVEs by the number of artifacts and  their severity levels found in the artifacts. When click the CVE, the  search vulnerabilities table displays all vulnerabilities found in  artifacts.
第三张卡片显示在扫描的工件中发现的前 5 个最危险的 CVE。它根据在工件中找到的工件数量及其严重性级别对危险的 CVE 进行排序。单击 CVE 时，搜索漏洞表将显示在工件中找到的所有漏洞。



​    ![Most Dangerous CVEs](https://goharbor.io/docs/2.11.0/img/security-hub/dangerous_cves.png)  



## Search Vulnerabilities 搜索漏洞

The search vulnerabilities panel allows you to search the vulnerabilities  by the CVE ID, severity, project, repository, digest or tag etc. the  search result will be shown in the table below.
搜索漏洞面板允许您按 CVE ID、严重性、项目、存储库、摘要或标签等搜索漏洞，搜索结果将显示在下表中。



​    ![Search Vulnerabilities](https://goharbor.io/docs/2.11.0/img/security-hub/search_vulnerabilities.png)  



Supported search fields:
支持的搜索字段：

| Query condition 查询条件   | Description 描述                                             |
| -------------------------- | ------------------------------------------------------------ |
| CVE ID CVE 编号            | Search vulnerability information by CVE ID, for performance consideration,  cve_id condition is required to query the vulnerability info, support  exact match 按CVE ID搜索漏洞信息，出于性能考虑，需要cve_id条件查询漏洞信息，支持完全匹配 |
| Severity 严厉              | Search vulnerability information by severity level, support exact match 按严重性级别搜索漏洞信息，支持精确匹配 |
| CVSS3                      | Search vulnerability information by cvss v3 score range 按 cvss v3 分数范围搜索漏洞信息 |
| Project Name 项目名称      | Search vulnerability information by project name, support exact match 按项目名称搜索漏洞信息，支持精确匹配 |
| Digest 消化                | Search vulnerability information by artifact digest, support exact match 通过工件摘要搜索漏洞信息，支持精确匹配 |
| Repository Name 存储库名称 | Search vulnerability information by repository name, support exact match 按仓库名称搜索漏洞信息，支持精确匹配 |
| Package 包                 | Search vulnerability information by package name, support exact match 按包名搜索漏洞信息，支持精确匹配 |
| Tag 标记                   | Search vulnerability information by tag name, support exact match 按标签名称搜索漏洞信息，支持精确匹配 |

## Job Service Dashboard Job Service 仪表板

The job service dashboard is a web-based interface that allows you to view  and manage jobs that are running in the Harbor job service. It is  available at `https://<harbor_url>/harbor/job-service-dashboard/`. You can use the dashboard to view the status of job queues, the  schedule of jobs, and the status of the job service pools and workers.  you can also use it to stop pending or running jobs, or pause or resume  the job service queue.
作业服务仪表板是一个基于 Web 的界面，允许您查看和管理在 Harbor 作业服务中运行的作业。它位于 `https://<harbor_url>/harbor/job-service-dashboard/` 。您可以使用仪表板查看作业队列的状态、作业的计划以及作业服务池和工作线程的状态。您还可以使用它来停止挂起或正在运行的作业，或者暂停或恢复作业服务队列。

## View Job Service Queue Status 查看作业服务队列状态

1. Log in to the Harbor Web interface with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的帐户登录 Harbor Web 界面。
2. Expand **Administration**, and select **Job Service Dashboard**.
   展开“管理”，然后选择“作业服务仪表板”。

In the job service dashboard, you can view the status of the job service  queue, the job service pools, and the job service workers.
在作业服务仪表板中，您可以查看作业服务队列、作业服务池和作业服务工作线程的状态。



​    ![Job service dashboard](https://goharbor.io/docs/2.11.0/img/jobservice-dashboard/jobservice-dashboard.png)  



The following table describes the information that is displayed in the dashboard.
下表描述了仪表板中显示的信息。

| Field 田                                      | Description 描述                                             | Actions 行动                                                 |
| --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Pending Jobs In Queues 队列中的待处理作业** | The job service queue is a FIFO queue that stores jobs to be executed.  Total displays the count of queue type, and the top 2 queues 作业服务队列是一个 FIFO 队列，用于存储要执行的作业。“总计”显示队列类型的计数，以及前 2 个队列 | **Stop All**: stop all jobs in all queues 全部停止：停止所有队列中的所有作业 |
| **Schedules 附表**                            | The job service pool is a pool of workers that execute jobs, display the total count of schedules and show its status 作业服务池是执行作业、显示计划总数并显示其状态的工作人员池 | **Pause All**: Pause all running job schedule, **Resume All**: Resume all paused job schedule 暂停全部：暂停所有正在运行的作业计划，“全部恢复”：恢复所有暂停的作业计划 |
| **Workers 工人**                              | The job service worker is a goroutine that executes jobs, it displays the free/total workers Job Service Worker 是一个执行作业的 goroutine，它显示空闲/总 workers | **Free All**: stop the execution of running jobs to free all workers 释放所有：停止执行正在运行的作业以释放所有工作线程 |

## View Job Queue Details 查看作业队列详细信息

In the job service dashboard, click the **Job Queues** tab.
在作业服务仪表板中，单击“作业队列”选项卡。



​    ![Job queues](https://goharbor.io/docs/2.11.0/img/jobservice-dashboard/jobqueues.png)  



The **Job Queues** tab displays the detail of job queues. The following table describes the information that is displayed in the **Job Queues** tab.
〖作业队列〗选项卡显示作业队列的详细信息。下表描述了“作业队列”选项卡中显示的信息。

| Field 田                     | Description 描述                                             |
| ---------------------------- | ------------------------------------------------------------ |
| **Job Type 工作类型**        | The name of the job queue. 作业队列的名称。                  |
| **Pending Count 待处理计数** | The number of jobs that are waiting to be executed in the queue. 队列中等待执行的作业数。 |
| **Latency 延迟**             | The waiting time of the current queue, it indicate how long tasks in the queue have already waited. 当前队列的等待时间，它表示队列中的任务已经等待了多长时间。 |
| **Paused 暂停**              | The paused status of job queue. 作业队列的暂停状态。         |

Actions for each job queue:
每个作业队列的操作：

- Click the **Stop** button to stop all jobs in the queue. it will remove all jobs from the queue and mark their status as “Stopped”.
  单击“停止”按钮以停止队列中的所有作业。它将从队列中删除所有作业，并将其状态标记为“已停止”。
- Click the **Pause** button to pause the job queue.
  单击“暂停”按钮以暂停作业队列。
- Click the **Resume** button to resume the job queue.
  单击“恢复”按钮以恢复作业队列。

Job Types 工作类型

| Type Name 类型名称        | Description 描述                                             |
| ------------------------- | ------------------------------------------------------------ |
| `GARBAGE_COLLECTION`      | Job queue for garbage collection. 垃圾回收的作业队列。       |
| `IMAGE_SCAN`              | Job queue for image scan. 图像扫描的作业队列。               |
| `P2P_PREHEAT`             | Job queue for p2p preheat related task. p2p预热相关任务的作业队列。 |
| `PURGE_AUDIT`             | Job queue for purge audit log. 清除审核日志的作业队列。      |
| `REPLICATION`             | Job queue for image replication. 用于图像复制的作业队列。    |
| `RETENTION`               | Job queue for tag retention. 用于标记保留的作业队列。        |
| `SCAN_DATA_EXPORT`        | Job queue for export CVE data. 用于导出 CVE 数据的作业队列。 |
| `SCHEDULER`               | Job queue for all periodical tasks, if it is paused, all periodical schedule will not be triggered. 所有周期性任务的作业队列，如果已暂停，则不会触发所有周期性计划。 |
| `SLACK`                   | Job queue for sending slack message. 用于发送松弛消息的作业队列。 |
| `SYSTEM_ARTIFACT_CLEANUP` | Job queue for cleanup system artifact, used by export CVE feature. 用于清理系统工件的作业队列，由导出 CVE 功能使用。 |
| `WEBHOOK`                 | Job queue for web hook task. Web Hook 任务的作业队列。       |

**NOTE** The **Pause** and **Resume** operation just stop the worker from consuming jobs in the job queue, it does not stop the job task submission, neither change job status in the job queue.
注意 “暂停”和“恢复”操作只是停止工作人员在作业队列中使用作业，它不会停止作业任务提交，也不会更改作业队列中的作业状态。

## View Schedule Details 查看计划详细信息

In the job service dashboard, click the **Schedules** tab.
在作业服务仪表板中，单击“计划”选项卡。



​    ![Schedules](https://goharbor.io/docs/2.11.0/img/jobservice-dashboard/schedules.png)  



The **Schedules** tab displays the details of the job schedules. The following table  describes the information that is displayed in the Schedules tab.
“计划”选项卡显示作业计划的详细信息。下表描述了“计划”选项卡中显示的信息。

| Field 田                   | Description 描述                                             |
| -------------------------- | ------------------------------------------------------------ |
| **ID**                     | The ID of the job schedule. 作业计划的 ID。                  |
| **Vendor Type 供应商类型** | The vendor type of the job service schedule. 作业服务计划的供应商类型。 |
| **Vendor ID 供应商 ID**    | The vendor id of the job schedule. empty if there is no vendor id. 作业计划的供应商 ID。如果没有供应商 ID，则为空。 |
| **Cron 克龙**              | The cron expression of the schedule. 计划的 cron 表达式。    |
| **Create Time 创建时间**   | The created time of the job schedule. 作业计划的创建时间。   |

## View Worker Details 查看工作人员详细信息

In the job service dashboard, click the **Workers** tab.
在作业服务仪表板中，单击“工作人员”选项卡。



​    ![Workers](https://goharbor.io/docs/2.11.0/img/jobservice-dashboard/workers.png)  



The worker pools table displays the details of the worker pools. The  following table describes the information that is displayed in the  Workers tab. When you click a worker pool in the table, workes of this  pool is displayed in the worker’s table.
工作线程池表显示工作线程池的详细信息。下表描述了“工作人员”选项卡中显示的信息。当您单击表中的工作池时，此池的工作将在工作线程的表中显示。

| Field 田                         | Description 描述                                             |
| -------------------------------- | ------------------------------------------------------------ |
| **Worker Pool ID 工作线程池 ID** | The ID of the worker pool. 工作线程池的 ID。                 |
| **PID**                          | The process the worker pool. 进程：工作线程池。              |
| **Start At 起始价**              | The start time of the worker pool. 工作线程池的开始时间。    |
| **Heartbeat At 心跳时间**        | The heartbeat time of the worker pool. 工作线程池的检测信号时间。 |
| **Concurrency 并发**             | The concurrency of worker pool. 工作线程池的并发性。         |

The worker’s table displays the details of the workers. The following table describes the information that is displayed in the Workers tab.
工作人员的表格显示工作人员的详细信息。下表描述了“工作人员”选项卡中显示的信息。

| Field 田                                   | Description 描述                                             |
| ------------------------------------------ | ------------------------------------------------------------ |
| **Worker ID 工作人员 ID**                  | The ID of the worker. 工作人员的 ID。                        |
| **Job Name 职位名称**                      | The job name of the current job that the worker is executing. 工作人员正在执行的当前作业的作业名称。 |
| **Job ID 作业 ID**                         | The ID of the current job that the worker is executing. 工作人员正在执行的当前作业的 ID。 |
| **Started At 起始于**                      | The start time of the current job that the worker is executing. 工作人员正在执行的当前作业的开始时间。 |
| **Checked In At 办理登机手续办理登机手续** | The check in time of the current job that the worker is executing. 工作人员正在执行的当前作业的签入时间。 |
| **Logs 原木**                              | The log of the current job that the worker is executing. 工作人员正在执行的当前作业的日志。 |

Actions for workers: 工人的行动：

– Click the **Free** button to stop the execution of the current job that the worker is  executing to free the worker. The stop operation takes several minutes  to complete, it depends on the job type. – Click the link in the **Logs** column to view the log of the current job that the worker is executing.
– 单击“释放”按钮以停止执行工作人员正在执行的当前作业，以释放工作人员。停止操作需要几分钟才能完成，具体取决于作业类型。– 单击“日志”列中的链接可查看工作人员正在执行的当前作业的日志。

## Steps to Withdraw an Execution 撤销执行的步骤

Because an execution might contains one or many tasks, some of then might be in pending state, some of them might be in running state. Stop running  tasks might not stop whole the execution. You can use the following  steps to stop the overall execution.
由于执行可能包含一个或多个任务，因此其中一些任务可能处于挂起状态，而另一些任务可能处于运行状态。停止运行任务可能不会停止整个执行。您可以使用以下步骤来停止整体执行。

1. Go to the Harbor job service dashboard with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的帐户转到 Harbor 作业服务仪表板。
2. Click the **Job Queues** tab, and click the **Stop** button to stop all jobs in the queue.
   单击“作业队列”选项卡，然后单击“停止”按钮以停止队列中的所有作业。
3. Click the **Workers** tab, and click the **Free** button to stop the execution of the current job which the worker is working on to free the worker.
   单击〖工作人员〗选项卡，然后单击〜释放”按钮以停止执行工作人员正在处理的当前作业，以释放工作人员。
4. Wait and check the execution status to become **Stopped**.
   等待并检查执行状态以变为已停止。

Sometimes, you don’t want to remove this scheduled task from job queue. To let  workers to work on other types of jobs, you can pause/resume the job  queue.
有时，您不希望从作业队列中删除此计划任务。要让工作人员从事其他类型的工作，您可以暂停/恢复工作队列。

1. Go to the Harbor job service dashboard with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的帐户转到 Harbor 作业服务仪表板。
2. Click the **Job Queues** tab, and click the **Pause** button to pause all jobs in the queue.
   单击“作业队列”选项卡，然后单击“暂停”按钮以暂停队列中的所有作业。
3. Wait the job service workers to work on other type of jobs.
   等待工作服务工作人员从事其他类型的工作。
4. Click the **Resume** button to resume the job queue.
   单击“恢复”按钮以恢复作业队列。

## Upgrade Harbor and Migrate Data               
升级 Harbor 并迁移数据

This guide covers upgrade and migration to v2.11.0. This guide only covers  migration from v2.9.0 and later to the current version. If you are  upgrading from an earlier version, refer to the migration guide for an  earlier Harbor version.
本指南介绍如何升级到 v2.11.0。本指南仅介绍从 v2.9.0 及以上版本迁移到当前版本。如果您要从早期版本升级，请参阅早期 Harbor 版本的迁移指南。

- [Upgrade to Harbor v2.9.0
  升级到 Harbor v2.9.0](https://goharbor.io/docs/2.9.0/administration/upgrade/)
- [Upgrade to Harbor v2.8.0
  升级到 Harbor v2.8.0](https://goharbor.io/docs/2.8.0/administration/upgrade/)
- [Upgrade to Harbor v2.7.0
  升级到 Harbor v2.7.0](https://goharbor.io/docs/2.7.0/administration/upgrade/)
- [Upgrade to Harbor v2.6.0
  升级到 Harbor v2.6.0](https://goharbor.io/docs/2.6.0/administration/upgrade/)
- [Upgrade to Harbor v2.5.0
  升级到 Harbor v2.5.0](https://goharbor.io/docs/2.5.0/administration/upgrade/)
- [Upgrade to Harbor v2.4.0
  升级到 Harbor v2.4.0](https://goharbor.io/docs/2.4.0/administration/upgrade/)
- [Upgrade to Harbor v2.3.0
  升级到 Harbor v2.3.0](https://goharbor.io/docs/2.3.0/administration/upgrade/)

If you are upgrading a Harbor instance that you deployed with Helm, see  [Upgrading Harbor Deployed with Helm](https://goharbor.io/docs/2.11.0/administration/upgrade/helm-upgrade/).
如果您正在升级使用 Helm 部署的 Harbor 实例，请参阅升级使用 Helm 部署的 Harbor。

When upgrading an existing Harbor instance to a newer version, you might need to migrate the settings in `harbor.yml`. Since the migration might alter the database schema and the settings of `harbor.yml`, you should **always** back up your data before any migration.
将现有 Harbor 实例升级到较新版本时，您可能需要迁移 `harbor.yml` 中的设置。由于迁移可能会更改数据库架构和 `harbor.yml` 的设置，因此应始终在进行任何迁移之前备份数据。

## Important Upgrade Notes 重要升级注意事项

- Again, you MUST backup your data before any data migration.
  同样，您必须在进行任何数据迁移之前备份数据。
- In Harbor v2.9, if you are using an external database, make sure the version of PostgreSQL >= 12.
  在 Harbor v2.9 中，如果您使用的是外部数据库，请确保 PostgreSQL 的版本>= 12。

## Upgrading Harbor and Migrating Data 升级 Harbor 并迁移数据

1. Log in to the Harbor host and, if it is still running, stop and remove the existing Harbor instance.
   登录到 Harbor 主机，如果它仍在运行，请停止并删除现有的 Harbor 实例。

   ```sh
   cd harbor
   docker-compose down
   ```

2. Back up Harbor’s current files so that you can roll back to the current version if necessary.
   备份 Harbor 的当前文件，以便在必要时可以回滚到当前版本。

   ```sh
   mv harbor /my_backup_dir/harbor
   ```

3. Back up the database, which by default is in the directory `/data/database`.
   备份数据库，该数据库默认位于目录 `/data/database` 中。

   ```sh
   cp -r /data/database /my_backup_dir/
   ```

4. Get the latest Harbor release package from  https://github.com/goharbor/harbor/releases and extract it.
   从 https://github.com/goharbor/harbor/releases 获取最新的 Harbor 发布包并解压缩。

   For more information see  [Download the Harbor Installer](https://goharbor.io/docs/2.11.0/install-config/download-installer/).
   有关详细信息，请参阅下载 Harbor 安装程序。

5. Before upgrading Harbor, perform migration.
   在升级 Harbor 之前，请先进行迁移。

   The migration tool is in harbor-prepare tools delivered as a docker image.  You can pull the image from docker hub. in the following command:
   迁移工具位于 harbor-prepare 工具中，以 docker 镜像的形式提供。您可以从 docker hub 拉取镜像。在以下命令中：

   ```sh
   docker pull goharbor/prepare:[tag]
   ```

   Alternatively, if you are using an offline installer package, you can load it from the image tarball that is included in the offline installer package.  Replace [tag] with the new Harbor version, for example v1.10.0, in the  following command:
   或者，如果您使用的是脱机安装程序包，则可以从脱机安装程序包中包含的映像压缩包中加载它。在以下命令中将 [tag] 替换为新的 Harbor 版本，例如 v1.10.0：

   ```sh
   tar zxf <offline package>
   docker image load -i harbor/harbor.[version].tar.gz
   ```

6. Copy the `/path/to/old/harbor.yml` to `harbor.yml` and upgrade it.
   复制并 `/path/to/old/harbor.yml`  `harbor.yml` 升级它。

   ```sh
   docker run -it --rm -v /:/hostfs goharbor/prepare:[tag] migrate -i ${path to harbor.yml}
   ```

   **NOTE:** The schema upgrade and data migration of the database is performed by  core when Harbor starts. If the migration fails, check the core log to  debug.
   注意：数据库的架构升级和数据迁移是在 Harbor 启动时由 core 执行的。如果迁移失败，请检查核心日志进行调试。

7. In the `./harbor` directory, run the `./install.sh` script to install the new Harbor instance.
   在目录中 `./harbor` ，运行脚本 `./install.sh` 以安装新的 Harbor 实例。

   To install Harbor with Trivy, see  [Run the Installer Script](https://goharbor.io/docs/2.11.0/install-config/run-installer-script/) for more information.
   要使用 Trivy 安装 Harbor，请参阅运行安装程序脚本以获取更多信息。

If you need to roll back to the previous version of Harbor, see  [Roll Back from an Upgrade](https://goharbor.io/docs/2.11.0/administration/upgrade/roll-back-upgrade/).
如果需要回滚到上一版本的 Harbor，请参阅从升级回滚。

### 升级使用 Helm 部署的 Harbor

This guide is used to upgrade Harbor deployed by chart since version 0.3.0.
本指南用于升级 chart 自 0.3.0 版本起部署的 Harbor。

## Notes 笔记

- As the database schema may change between different versions of Harbor,  there is a progress to migrate the schema during the upgrade and the  downtime cannot be avoid
  由于不同版本的 Harbor 之间的数据库架构可能会发生变化，因此在升级过程中会进行架构迁移，因此无法避免停机
- The database schema cannot be downgraded automatically, so the `helm rollback` is not supported
  数据库架构无法自动降级，因此 `helm rollback` 不支持

## Upgrade 升级

### 1. Backup database 1. 备份数据库

Backup the database used by Harbor in case the upgrade process fails.
备份 Harbor 使用的数据库，以防升级过程失败。

### 2. Download new chart 2. 下载新图表

Download the latest version of Harbor chart.
下载最新版本的 Harbor chart。

### 3. Configure new chart 3. 配置新图表

Configure the new chart to make sure that the configuration items have the same values with the old one.
配置新图表，确保配置项的值与旧图表的值相同。

> Note: if TLS is enabled and the certificate is generated by chart  automatically, a new certificate will be generated and overwrite the old one during the upgrade, this may cause some issues if you have  distributed the certificate. You can follow the below steps to configure the new chart to use the old certificate:
> 注意：如果启用了 TLS 并且证书是通过 chart 自动生成的，则在升级过程中将生成新证书并覆盖旧证书，如果您分发了证书，这可能会导致一些问题。您可以按照以下步骤配置新图表以使用旧证书：

1. Get the secret name which certificate is stored in:
   获取存储证书的机密名称：

   ```bash
   kubectl get secret
   ```

   Find the secret whose name ends with `-harbor-ingress` (expose service via `Ingress`) or `-harbor-nginx`(expose service via `ClusterIP` or `NodePort`)
   查找名称以 `-harbor-ingress` （expose service via `Ingress` ） 或 `-harbor-nginx` （expose service via `ClusterIP` or `NodePort` ） 结尾的密钥

2. Export the secret as yaml file:
   将密钥导出为 yaml 文件：

   ```bash
   kubectl get secret <secret-name-from-step-1> -o yaml > secret.yaml
   ```

3. Rename the secret by setting `metadata.name` in `secret.yaml`
   通过设置 `metadata.name` `secret.yaml` 

4. Create a new secret:
   创建新密钥：

   ```bash
   kubectl create -f secret.yaml
   ```

5. Configure the chart to use the new secret by setting `expose.tls.secretName` as the value you set in step **3**
   通过将设置 `expose.tls.secretName` 设置为在步骤 3 中设置的值，将图表配置为使用新密钥

### 4. Upgrade 4. 升级

Run upgrade command: 运行升级命令：

```bash
helm upgrade release-name --force .
```

​                        

​                 The `--force` is necessary if upgrade from version 0.3.0 due to issue [#30](https://github.com/goharbor/harbor-helm/issues/30).      
如果由于问题 #30 而从版本 0.3.0 升级， `--force` 则这是必需的。

## Known issues 已知问题

- The job logs will be lost if you upgrade from version 0.3.0 as the logs are store in a `emptyDir` in 0.3.0.
  如果从版本 0.3.0 升级，作业日志将丢失，因为日志存储在 0.3.0 `emptyDir` 中。

### 从升级中回滚

If, for any reason, you need to roll back to the previous version of Harbor, perform the following steps.
如果出于任何原因需要回滚到以前版本的 Harbor，请执行以下步骤。

​                        

​                 To roll back from an upgrade, you must have backed up the  previous version of Harbor. For information about backing up Harbor  before an upgrade, see [Upgrade Harbor and Migrate Data](https://goharbor.io/docs/2.11.0/administration/upgrade/roll-back-upgrade/_index.md).      
要从升级中回滚，您必须已备份以前版本的 Harbor。有关在升级前备份 Harbor 的信息，请参阅升级 Harbor 和迁移数据。

​                        

​                 Harbor 2.2 is compiled by Golang 1.15 which deprecated self  signed certificate without SAN. If you enabled internal TLS and cert  files are generated by Harbor prepare script, you must generate the  internal certificates again, using command like this `docker run -v /:/hostfs goharbor/prepare:v2.2.0 gencert -p /path/to/internal/tls/cert` The certs generated by the old version prepare script didn’t include  the SAN extension. If you manage the certs file, make the SAN is  included, if not please check [Configure Internal TLS communication between Harbor Component](https://goharbor.io/docs/2.11.0/administration/install-config/configure-internal-tls.md). For more information about Go’s break please refer [release note of Go 1.5](https://golang.org/doc/go1.15#commonname) and [this issue](https://github.com/golang/go/issues/24151).      
Harbor 2.2 由 Golang 1.15 编译，Golang 1.15 弃用了没有 SAN 的自签名证书。如果您启用了内部 TLS 并且证书文件是由 Harbor 准备脚本生成的，则必须使用如下 `docker run -v /:/hostfs goharbor/prepare:v2.2.0 gencert -p /path/to/internal/tls/cert` 命令重新生成内部证书 旧版本准备脚本生成的证书不包括 SAN 扩展。如果您管理证书文件，请将 SAN 包含在内，如果没有，请检查配置 Harbor 组件之间的内部 TLS 通信。关于 Go 的突破，请参考 Go 1.5 的发布说明和本期。

1. Stop and remove the current Harbor service if it is still running.
   如果当前 Harbor 服务仍在运行，请停止并删除该服务。

   ```sh
   cd harbor
   docker-compose down
   ```

2. Remove current Harbor instance.
   删除当前 Harbor 实例。

   ```sh
   rm -rf harbor
   ```

3. Restore the older version of Harbor.
   恢复旧版本的 Harbor。

   ```sh
   mv /my_backup_dir/harbor harbor
   ```

4. To restore the database, copy the data files from the backup directory to your data volume, which by default is `/data/database`.
   要还原数据库，请将备份目录中的数据文件复制到数据卷，默认情况下为 `/data/database` 。

5. Restart the Harbor service using the previous configuration.
   使用之前的配置重新启动 Harbor 服务。

   If the previous version of Harbor was installed by a release build:
   如果 Harbor 的先前版本是由发布版本安装的：

   ```sh
   cd harbor
   ./install.sh
   ```

​                        

​                 While you can roll back an upgrade to the state before you started the upgrade, Harbor does not support downgrades.      
虽然您可以在开始升级之前将升级回滚到状态，但 Harbor 不支持降级。

### If, for any reason, you need to roll back to the previous version of Harbor, perform the following steps.
如果出于任何原因需要回滚到以前版本的 Harbor，请执行以下步骤。

​                        

​                 To roll back from an upgrade, you must have backed up the  previous version of Harbor. For information about backing up Harbor  before an upgrade, see [Upgrade Harbor and Migrate Data](https://goharbor.io/docs/2.11.0/administration/upgrade/roll-back-upgrade/_index.md).      
要从升级中回滚，您必须已备份以前版本的 Harbor。有关在升级前备份 Harbor 的信息，请参阅升级 Harbor 和迁移数据。

​                        

​                 Harbor 2.2 is compiled by Golang 1.15 which deprecated self  signed certificate without SAN. If you enabled internal TLS and cert  files are generated by Harbor prepare script, you must generate the  internal certificates again, using command like this `docker run -v /:/hostfs goharbor/prepare:v2.2.0 gencert -p /path/to/internal/tls/cert` The certs generated by the old version prepare script didn’t include  the SAN extension. If you manage the certs file, make the SAN is  included, if not please check [Configure Internal TLS communication between Harbor Component](https://goharbor.io/docs/2.11.0/administration/install-config/configure-internal-tls.md). For more information about Go’s break please refer [release note of Go 1.5](https://golang.org/doc/go1.15#commonname) and [this issue](https://github.com/golang/go/issues/24151).      
Harbor 2.2 由 Golang 1.15 编译，Golang 1.15 弃用了没有 SAN 的自签名证书。如果您启用了内部 TLS 并且证书文件是由 Harbor 准备脚本生成的，则必须使用如下 `docker run -v /:/hostfs goharbor/prepare:v2.2.0 gencert -p /path/to/internal/tls/cert` 命令重新生成内部证书 旧版本准备脚本生成的证书不包括 SAN 扩展。如果您管理证书文件，请将 SAN 包含在内，如果没有，请检查配置 Harbor 组件之间的内部 TLS 通信。关于 Go 的突破，请参考 Go 1.5 的发布说明和本期。

1. Stop and remove the current Harbor service if it is still running.
   如果当前 Harbor 服务仍在运行，请停止并删除该服务。

   ```sh
   cd harbor
   docker-compose down
   ```

2. Remove current Harbor instance.
   删除当前 Harbor 实例。

   ```sh
   rm -rf harbor
   ```

3. Restore the older version of Harbor.
   恢复旧版本的 Harbor。

   ```sh
   mv /my_backup_dir/harbor harbor
   ```

4. To restore the database, copy the data files from the backup directory to your data volume, which by default is `/data/database`.
   要还原数据库，请将备份目录中的数据文件复制到数据卷，默认情况下为 `/data/database` 。

5. Restart the Harbor service using the previous configuration.
   使用之前的配置重新启动 Harbor 服务。

   If the previous version of Harbor was installed by a release build:
   如果 Harbor 的先前版本是由发布版本安装的：

   ```sh
   cd harbor
   ./install.sh
   ```

​                        

​                 While you can roll back an upgrade to the state before you started the upgrade, Harbor does not support downgrades.      
虽然您可以在开始升级之前将升级回滚到状态，但 Harbor 不支持降级。

### Test Harbor 升级

## Prepare data 准备数据

1. Add user usera userb userc userd usere, set usera userb as system admin.
   添加用户 usera userb userc userd usere，将 usera userb 设置为系统管理员。
2. Create project projecta projectc as private, create projectb as public.
   将项目 projecta projectc 创建为 private，将 projectb 创建为 public。
3. Add usera as projecta’s admin, userc as developer, and userd as guest. Do the same to projectb and projectc.
   将 usera 添加为 projecta 的管理员，将 userc 添加为开发人员，将 userd 添加为 guest。对 projectb 和 projectc 执行相同的操作。
4. Login harbor as usera, push an unsigned image into projecta, then push a signed image to projecta.
   以 usera 身份登录 harbor，将未签名的镜像推送到 projecta，然后再将已签名的镜像推送到 projecta。
5. Login harbor as userc, push an unsigned image into projecta, then push a signed image to projeca.
   以 userc 身份登录 harbor，将未签名的镜像推送到 projecta，然后将已签名的镜像推送到 projeca。
6. Login harbor as userd, push each image one time.
   以用户身份登录港，推送每张图片一次。
7. Repeat 4 5 6 to projectb and projectc.
   对 projectb 和 projectc 重复 4 5 6。
8. Add one endpoint to harbor.
   向 Harbor 添加一个端点。
9. Add an immediate replication rule to projeca, a schedule rule to projectb, a manual rule to projectc, trigger each rule one time.
   向 projeca 添加立即复制规则，向 projectb 添加计划规则，向 projectc 添加手动规则，每个规则触发一次。
10. Add 5 system label syslabel1 to syslabel5 and tag syslabel1 and syslabel2 to all unsigned image.
    将 5 个系统标签 syslabel1 添加到 syslabel5，并将标记 syslabel1 和 syslabel2 添加到所有未签名的图像中。
11. In each project add 5 project label projlabela to projlabele, add projlabela projlabelb and projlabelc to signed image.
    在每个项目中，将 5 个项目标签 projlabela 添加到 projlabele，将 projlabela、projlabelb 和 projlabelc 添加到签名图像中。
12. Trigger one scan all job to scan all images.(For Trivy enabled instance)
    触发一次“扫描所有”作业以扫描所有图像。（对于启用了 Trivy 的实例）
13. Update project publicly, content trust, severity and scanning settings.
    公开更新项目、内容信任度、严重性和扫描设置。
14. Update Harbor email, token expire read only and scan settings.
    更新 Harbor 电子邮件、令牌过期、只读和扫描设置。
15. Update repository info. 更新仓库信息。
     **NOTE**: Create user step is not needed if auth mode is LDAP.
    注意：如果身份验证模式为 LDAP，则不需要创建用户步骤。

# Upgrade 升级

## Follow the upgrade guide 按照升级指南进行操作

1. Run db migrator image to backup database.
   运行 db migrator image 以备份数据库。
2. Run db migrator image to migrate database.
   运行 db migrator image 进行数据库迁移。
3. Install new version harbor.
   安装新版本 harbor。

# After upgrade 升级后

1. Confirm users are exist and available(No need for VIC and LDAP Mode).
   确认用户存在且可用（无需 VIC 和 LDAP 模式）。
2. Confirm users have the correct role.
   确认用户具有正确的角色。
3. Confirm labels are existing and labeled correct.(No need for VIC)
   确认标签已存在且标记正确。（无需 VIC）
4. Confirm endpoint exist. 确认端点存在。
5. Confirm replication rule exist and works well.
   确认复制规则存在且运行良好。
6. Confirm project level settings(publicly, content trust, scan) same as before.
   确认项目级别设置（公开、内容信任、扫描）与以前相同。
7. Confirm system level settings(email token expire scan) same as before.
   确认系统级别设置（电子邮件令牌过期扫描）与以前相同。
8. Confirm scan result the same as before upgrade.
   确认扫描结果与升级前相同。
9. Confirm access log the same as before upgrade.
   确认访问日志与升级前相同。
10. Confirm repository info the same as before.
    确认存储库信息与之前相同。
11. Confirm other image metadata(e.g. author, size) the same as before.
    确认其他图像元数据（例如作者、大小）与以前相同。

## Backup And Restore Harbor With Velero               
使用 Velero 备份和恢复 Harbor

Backup and restore is important for disaster recovery and data migration scenarios. With a tool like  [Velero](https://velero.io/), you can backup and restore your Harbor instances and avoid disruptions  in service in the event of a disaster. Velero is is an open source tool  you can use to safely backup and restore, perform disaster recovery, and migrate Kubernetes cluster resources and persistent volumes.
备份和还原对于灾难恢复和数据迁移方案非常重要。使用 Velero 等工具，您可以备份和恢复 Harbor 实例，并避免在发生灾难时服务中断。Velero  是一个开源工具，您可以使用它来安全地备份和恢复、执行灾难恢复以及迁移 Kubernetes 集群资源和持久卷。

The following tutorial shows how to use Velero to backup and restore a  Harbor instance that has been deployed in a Kubernetes cluster using the Harbor helm chart. See more details about  [How Velero Works](https://velero.io/docs/v1.9/how-velero-works/).
以下教程展示了如何使用 Velero 通过 Harbor helm chart 备份和恢复已部署在 Kubernetes 集群中的 Harbor 实例。查看有关 Velero 工作原理的更多详细信息。

​                        

This tutorial only backs up a subset of Harbor’s resources and data,  including all Harbor related Kubernetes resources (Deployments,  StatefulSets, Services, ConfigMaps, etc.) and data in the  PersistentVolumes of Harbor’s internal database, registry, chartmuseum,  jobservice and Trivy.
本教程仅备份了 Harbor 资源和数据的一个子集，包括所有与 Harbor 相关的 Kubernetes  资源（Deployments、StatefulSets、Services、ConfigMap 等）以及 Harbor  内部数据库、registry、chartmuseum、jobservice 和 Trivy 的 PersistentVolumes 中的数据。

Harbor’s Redis data is not backed up, see the [Limitations](https://goharbor.io/docs/2.11.0/administration/backup-restore/#limitations) section for more details of the potential impact to your Harbor instance.
Harbor 的 Redis 数据未备份，请参阅限制部分，了解对 Harbor 实例的潜在影响的更多详细信息。

The backup taken in this tutorial is crash consistent, not application  consistent. This means that some data will be lost after restore, see  the [Limitations](https://goharbor.io/docs/2.11.0/administration/backup-restore/#limitations) part for more information.
本教程中执行的备份是崩溃一致性的，而不是应用程序一致性的。这意味着某些数据在还原后会丢失，有关详细信息，请参阅限制部分。

## Install Velero 安装 Velero

Install the Velero CLI and server according to the  [official Velero documentation](https://velero.io/docs/latest/basic-install/).
根据官方 Velero 文档安装 Velero CLI 和服务器。

​                        

​                 Depending on the size of your data, you may need to increase the CPU or memory resources available to Velero, especially if you are  using Restic. Refer to the [doc](https://velero.io/docs/latest/customize-installation/#customize-resource-requests-and-limits) for more information.      
根据数据的大小，您可能需要增加可用于 Velero 的 CPU 或内存资源，尤其是在使用 Restic 时。有关详细信息，请参阅文档。

## Backup Harbor Instance 备份 Harbor 实例

### Set Harbor to ReadOnly 将 Harbor 设置为 ReadOnly

1. Log in to the Harbor portal with an account that has Harbor system administrator privileges.
   使用具有 Harbor 系统管理员权限的帐户登录 Harbor 门户。

2. Expand **Administration**, and select **Configuration**.
   展开“管理”，然后选择“配置”。

3. Select the **System Settings** tab.
   选择“系统设置”选项卡。

   

   ​    ![Set read only](https://goharbor.io/docs/2.11.0/img/set-read-only.png)  

   

4. Select the check box **Repository Read Only** and click the **Save** button to save the configurations.
   选中“存储库只读”复选框，然后单击“保存”按钮以保存配置。

### Backup Harbor Instance 备份 Harbor 实例

According to the capability of the platform where Harbor is deployed, you can  choose back up the PersistentVolumes with Snapshot or Restic:
根据 Harbor 部署的平台的能力，您可以选择使用 Snapshot 或 Restic 备份 PersistentVolumes：

- Snapshot 快照
   If you want to use snapshots to backup the PersistentVolumes, make sure there is a  [corresponding Velero plugin](https://velero.io/docs/v1.9/supported-providers/) for your Kubernetes provider.
  如果您想使用快照来备份 PersistentVolumes，请确保您的 Kubernetes 提供商有相应的 Velero 插件。

  1. In order to exclude the volume of Redis in backup, we need to label the Redis pod, PVC and PV with specific label:

     
     为了排除备份中的Redis卷，我们需要给Redis pod、PVC和PV贴上特定的标签：

     ```shell
      # label the Pod of Redis, replace the namespace and Pod name with yours
      kubectl -n harbor label pod/harbor-redis-0 velero.io/exclude-from-backup=true
      # label the PVC of Redis, replace the namespace and PVC name with yours
      kubectl -n harbor label pvc/data-harbor-redis-0 velero.io/exclude-from-backup=true
      # get the name of Redis PV, replace the namespace and PVC name with yours
      kubectl -n harbor get pvc data-harbor-redis-0 --template={{.spec.volumeName}}
      # label the PV of Redis, replace the pv-name with the one get from last command
      kubectl label pv/pv-name velero.io/exclude-from-backup=true
     ```

  2. Back up Harbor

      备份港

     ```shell
     # replace the namespace and backup name with yours
     velero backup create harbor-backup --include-namespaces harbor --snapshot-volumes --wait
     ```

- Restic 雷斯蒂克
   If you want to take volume snapshots but didn’t find a plugin for your  provider, Velero has support for snapshotting using restic. Before using restic, you should review the Velero  [restic integration](https://velero.io/docs/latest/restic/) page, and especially understand  [restic limitations](https://velero.io/docs/latest/restic/#limitations).
  如果您想拍摄卷快照，但没有找到适合您的提供商的插件，Velero 支持使用 restic 进行快照。在使用 restic 之前，您应该查看 Velero restic 集成页面，并特别了解 restic 的限制。

  1. Exclude the volume of Redis in backup

     
     在备份中排除 Redis 的卷

     ```shell
     # replace the namespace and pod name with yours
     kubectl -n harbor annotate pod/harbor-redis-0 backup.velero.io/backup-volumes-excludes=data
     ```

  2. Back up Harbor

      备份港

     ```shell
     # replace the namespace and backup name with yours
     velero backup create harbor-backup --include-namespaces harbor --default-volumes-to-restic --wait
     ```

### Unset ReadOnly 取消设置 ReadOnly

Follow the same steps in  [Set Harbor to ReadOnly](https://goharbor.io/docs/2.11.0/administration/backup-restore/#set-harbor-to-readonly), uncheck the **Repository Read Only** check box and click the **Save** button to save the configurations.
按照 将 Harbor 设置为 ReadOnly 中的相同步骤，取消选中 Repository Read Only 复选框，然后单击 Save 按钮以保存配置。

## Restore Harbor Instance 恢复 Harbor 实例

### Restore from the Backup 从备份还原

```shell
# replace the backup and restore names with yours
velero restore create harbor-restore --from-backup harbor-backup --wait
```

### Unset ReadOnly 取消设置 ReadOnly

As we set Harbor to ReadOnly when doing the backup, the instance is still in ReadOnly mode after the restoring, follow  [Unset ReadOnly](https://goharbor.io/docs/2.11.0/administration/backup-restore/#unset-readonly) to unset ReadOnly.
由于我们在备份时将 Harbor 设置为 ReadOnly，因此实例在恢复后仍处于 ReadOnly 模式，因此请按照 Unset ReadOnly 来取消设置 ReadOnly。

## Troubleshooting 故障 排除

If you have any issue while backing up or restoring, please refer to Velero’s  [troubleshooting](https://velero.io/docs/latest/troubleshooting/) documentation.
如果您在备份或恢复时遇到任何问题，请参阅 Velero 的故障排除文档。

## Limitations 局限性

- **The upload purging process may cause backup failure
  上传清除过程可能会导致备份失败**
   A purging process starts in the `registry` pod by default, it removes the unused files under the upload directory  periodically and cannot be deactivated without restarting. This may  impact the backup when using Restic and cause failures.
  默认情况下， `registry` 清除过程会在 pod 中启动，它会定期删除上传目录下未使用的文件，如果不重新启动就无法停用。这可能会在使用 Restic 时影响备份并导致失败。
   It’s better to increase the  [interval](https://github.com/goharbor/harbor-helm/blob/v1.9.2/values.yaml#L581) of the purging operation(the default value is 168h) and do the backup  in the middle of two rounds of purging to avoid files being removed.
  最好增加清除操作的间隔（默认值为 168h），并在两轮清除的中间进行备份，以避免文件被删除。
- **The data in memory is lost during the backup
  在备份过程中，内存中的数据会丢失**
   Harbor stores repository pull and artifact pull times in memory and  syncs them periodically into Harbor’s database. This means that any data that isn’t synced into the database when you take a backup is lost.  This data loss should be low impact to your restored Harbor instance.
  Harbor 将存储库拉取和工件拉取时间存储在内存中，并定期将它们同步到 Harbor 的数据库中。这意味着，在进行备份时，未同步到数据库的任何数据都将丢失。此数据丢失对还原的 Harbor 实例的影响应该很小。
- **Tasks may hang in the in-progress status after restore
  还原后，任务可能会在进行中状态挂起**
   Harbor tasks, such as replication, garbage collection, or security scans may hang in the in-progress status after restore. You can manually stop them on the portal.
  Harbor 任务（如复制、垃圾回收或安全扫描）在还原后可能会挂起，处于进行中状态。您可以在门户上手动停止它们。
- **Sessions of logged users will lose after restore
  恢复后，已登录用户的会话将丢失**
   As we don’t back up the persistent volume of Redis, the sessions of logged used will is lost after restore.
  由于我们不备份 Redis 的持久卷，因此记录的已用会话在恢复后会丢失。
- **Backups of external databases are not supported
  不支持备份外部数据库**
   Only backups of the Harbor internal database is supported.
  仅支持 Harbor 内部数据库的备份。