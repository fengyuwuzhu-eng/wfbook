# 使用 Docker 构建



# Build, tag, and publish an image 构建、标记和发布映像

<iframe id="youtube-player-chiiGLlYRlY" data-video-id="chiiGLlYRlY" class="youtube-video aspect-video w-full" frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Docker concepts - Build, tag, and publish an image" width="100%" height="100%" src="https://www.youtube.com/embed/chiiGLlYRlY?rel=0&amp;iv_load_policy=3&amp;enablejsapi=1&amp;origin=https%3A%2F%2Fdocs.docker.com&amp;widgetid=1" data-gtm-yt-inspected-15="true"></iframe>

## [Explanation 解释](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#explanation)

In this guide, you will learn the following:
在本指南中，您将学习以下内容：

- Building images - the process of building an image based on a `Dockerfile`
  构建镜像 - 基于 `Dockerfile` 
- Tagging images - the process of giving an image a name, which also determines where the image can be distributed
  标记图像 - 为图像命名的过程，这也决定了图像可以分布在哪里
- Publishing images - the process to distribute or share the newly created image using a container registry
  发布映像 - 使用容器注册表分发或共享新创建的映像的过程

### [Building images 构建镜像](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#building-images)

Most often, images are built using a Dockerfile. The most basic `docker build` command might look like the following:
大多数情况下，映像是使用 Dockerfile 构建的。最基本 `docker build` 的命令可能如下所示：

```bash
docker build .
```

The final `.` in the command provides the path or URL to the [build context](https://docs.docker.com/build/building/context/#what-is-a-build-context)

. At this location, the builder will find the `Dockerfile` and other referenced files.
命令中的最后一个 `.` 提供生成上下文的路径或 URL。在此位置，构建器将找到 `Dockerfile` 和其他引用的文件。

When you run a build, the builder pulls the base image, if needed, and then runs the instructions specified in the Dockerfile.
运行生成时，生成器会根据需要拉取基础映像，然后运行 Dockerfile 中指定的说明。

With the previous command, the image will have no name, but the output will  provide the ID of the image. As an example, the previous command might  produce the following output:
使用上一个命令时，图像将没有名称，但输出将提供图像的 ID。例如，上一个命令可能会生成以下输出：

```console
 docker build .
[+] Building 3.5s (11/11) FINISHED                                              docker:desktop-linux
 => [internal] load build definition from Dockerfile                                            0.0s
 => => transferring dockerfile: 308B                                                            0.0s
 => [internal] load metadata for docker.io/library/python:3.12                                  0.0s
 => [internal] load .dockerignore                                                               0.0s
 => => transferring context: 2B                                                                 0.0s
 => [1/6] FROM docker.io/library/python:3.12                                                    0.0s
 => [internal] load build context                                                               0.0s
 => => transferring context: 123B                                                               0.0s
 => [2/6] WORKDIR /usr/local/app                                                                0.0s
 => [3/6] RUN useradd app                                                                       0.1s
 => [4/6] COPY ./requirements.txt ./requirements.txt                                            0.0s
 => [5/6] RUN pip install --no-cache-dir --upgrade -r requirements.txt                          3.2s
 => [6/6] COPY ./app ./app                                                                      0.0s
 => exporting to image                                                                          0.1s
 => => exporting layers                                                                         0.1s
 => => writing image sha256:9924dfd9350407b3df01d1a0e1033b1e543523ce7d5d5e2c83a724480ebe8f00    0.0s
```

With the previous output, you could start a container by using the referenced image:
在前面的输出中，可以使用引用的映像启动容器：



```console
docker run sha256:9924dfd9350407b3df01d1a0e1033b1e543523ce7d5d5e2c83a724480ebe8f00
```

That name certainly isn't memorable, which is where tagging becomes useful.
这个名字当然不会令人难忘，这就是标记变得有用的地方。

### [Tagging images 标记图像](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#tagging-images)

Tagging images is the method to provide an image with a memorable name.  However, there is a structure to the name of an image. A full image name has the following structure:
标记图像是为图像提供具有令人难忘的名称的方法。但是，图像的名称有一个结构。完整的映像名称具有以下结构：



```text
[HOST[:PORT_NUMBER]/]PATH[:TAG]
```

- `HOST`: The optional registry hostname where the image is located. If no host is specified, Docker's public registry at `docker.io` is used by default.
  `HOST` ：映像所在的可选注册表主机名。如果未指定主机，则默认使用 Docker 的公共注册表 at `docker.io` 。
- `PORT_NUMBER`: The registry port number if a hostname is provided
  `PORT_NUMBER` ：如果提供了主机名，则为注册表端口号
- `PATH`: The path of the image, consisting of slash-separated components. For Docker Hub, the format follows `[NAMESPACE/]REPOSITORY`, where namespace is either a user's or organization's name. If no namespace is specified, `library` is used, which is the namespace for Docker Official Images.
  `PATH` ：图像的路径，由斜杠分隔的组件组成。对于 Docker Hub，格式如下 `[NAMESPACE/]REPOSITORY` ，其中 namespace 是用户或组织的名称。如果未指定命名空间， `library` 则使用命名空间，即 Docker 官方镜像的命名空间。
- `TAG`: A custom, human-readable identifier that's typically used to identify  different versions or variants of an image. If no tag is specified, `latest` is used by default.
  `TAG` ：一种自定义的、人类可读的标识符，通常用于识别图像的不同版本或变体。如果未指定标记， `latest` 则默认使用。

Some examples of image names include:
图像名称的一些示例包括：

- `nginx`, equivalent to `docker.io/library/nginx:latest`: this pulls an image from the `docker.io` registry, the `library` namespace, the `nginx` image repository, and the `latest` tag.
  `nginx` ，等同于 `docker.io/library/nginx:latest` ：这将从 `docker.io` 注册表、 `library` 命名空间、 `nginx` 图像存储库和 `latest` 标签中提取图像。
- `docker/welcome-to-docker`, equivalent to `docker.io/docker/welcome-to-docker:latest`: this pulls an image from the `docker.io` registry, the `docker` namespace, the `welcome-to-docker` image repository, and the `latest` tag
  `docker/welcome-to-docker` ，等效于 `docker.io/docker/welcome-to-docker:latest` ：这将从 `docker.io` 注册表、 `docker` 命名空间、 `welcome-to-docker` 图像仓库和 `latest` 标签中拉取图像
- `ghcr.io/dockersamples/example-voting-app-vote:pr-311`: this pulls an image from the GitHub Container Registry, the `dockersamples` namespace, the `example-voting-app-vote` image repository, and the `pr-311` tag
  `ghcr.io/dockersamples/example-voting-app-vote:pr-311` ：这将从 GitHub 容器注册表、 `dockersamples` 命名空间、 `example-voting-app-vote` 图像仓库和 `pr-311` 标签中提取图像

To tag an image during a build, add the `-t` or `--tag` flag:
要在构建过程中标记图像，请添加 `-t` or `--tag` 标志：

```console
docker build -t my-username/my-image .
```

If you've already built an image, you can add another tag to the image by using the [`docker image tag`](https://docs.docker.com/engine/reference/commandline/image_tag/)

 command:
如果您已构建一个映像，则可以使用以下 `docker image tag` 命令向映像添加另一个标记：



```console
docker image tag my-username/my-image another-username/another-image:v1
```

### [Publishing images 发布图像](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#publishing-images)

Once you have an image built and tagged, you're ready to push it to a registry. To do so, use the [`docker push`](https://docs.docker.com/engine/reference/commandline/image_push/)

 command:
一旦您构建并标记了映像，您就可以将其推送到注册表了。为此，请使用以下 `docker push` 命令：



```console
docker push my-username/my-image
```

Within a few seconds, all of the layers for your image will be pushed to the registry.
在几秒钟内，图像的所有层都将被推送到注册表。

> **Requiring authentication 要求身份验证**
>
> Before you're able to push an image to a repository, you will need to be authenticated. To do so, simply use the [docker login](https://docs.docker.com/engine/reference/commandline/login/)

>  command.
>  在将映像推送到存储库之前，您需要进行身份验证。为此，只需使用 docker login 命令即可。

## [Try it out 尝试一下](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#try-it-out)

In this hands-on guide, you will build a simple image using a provided Dockerfile and push it to Docker Hub.
在本实践指南中，您将使用提供的 Dockerfile 构建一个简单的映像，并将其推送到 Docker Hub。

### [Set up 建立](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#set-up)

1. Get the sample application.
   获取示例应用程序。

   If you have Git, you can clone the repository for the sample application.  Otherwise, you can download the sample application. Choose one of the  following options.
   如果您有 Git，则可以克隆示例应用程序的存储库。否则，您可以下载示例应用程序。选择以下选项之一。

------

Use the following command in a terminal to clone the sample application repository.
在终端中使用以下命令克隆样本应用程序存储库。

```console
 git clone https://github.com/docker/getting-started-todo-app
```

------

[Download and install](https://www.docker.com/products/docker-desktop/)

 Docker Desktop.
下载并安装 Docker Desktop。

If you don't have a Docker account yet, [create one now](https://hub.docker.com/)

1. . Once you've done that, sign in to Docker Desktop using that account.
   如果您还没有 Docker 帐户，请立即创建一个。完成此操作后，使用该帐户登录到 Docker Desktop。

### [Build an image 构建镜像](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#build-an-image)

Now that you have a repository on Docker Hub, it's time for you to build an image and push it to the repository.
现在，您在 Docker Hub 上已经有了一个存储库，是时候构建一个镜像并将其推送到存储库了。

1. Using a terminal in the root of the sample app repository, run the following command. Replace `YOUR_DOCKER_USERNAME` with your Docker Hub username:
   使用示例应用程序存储库根目录中的终端，运行以下命令。替换为 `YOUR_DOCKER_USERNAME` 您的 Docker Hub 用户名：

```console
 docker build -t YOUR_DOCKER_USERNAME/concepts-build-image-demo .
```

As an example, if your username is `mobywhale`, you would run the command:
例如，如果您的用户名是 `mobywhale` ，您将运行以下命令：

```console
 docker build -t mobywhale/concepts-build-image-demo .
```

Once the build has completed, you can view the image by using the following command:
生成完成后，可以使用以下命令查看映像：



```console
 docker image ls
```

The command will produce output similar to the following:
该命令将生成类似于以下内容的输出：

```plaintext
REPOSITORY                             TAG       IMAGE ID       CREATED          SIZE
mobywhale/concepts-build-image-demo    latest    746c7e06537f   24 seconds ago   354MB
```

You can actually view the history (or how the image was created) by using the [docker image history](https://docs.docker.com/reference/cli/docker/image/history/) command:
实际上，您可以使用 docker image history 命令查看历史记录（或映像的创建方式）：

```console
 docker image history mobywhale/concepts-build-image-demo
```

You'll then see output similar to the following:
然后，你将看到类似于以下内容的输出：

1. ```plaintext
   IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT
   f279389d5f01   8 seconds ago   CMD ["node" "./src/index.js"]                   0B        buildkit.dockerfile.v0
   <missing>      8 seconds ago   EXPOSE map[3000/tcp:{}]                         0B        buildkit.dockerfile.v0 
   <missing>      8 seconds ago   WORKDIR /app                                    8.19kB    buildkit.dockerfile.v0
   <missing>      4 days ago      /bin/sh -c #(nop)  CMD ["node"]                 0B
   <missing>      4 days ago      /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B
   <missing>      4 days ago      /bin/sh -c #(nop) COPY file:4d192565a7220e13…   20.5kB
   <missing>      4 days ago      /bin/sh -c apk add --no-cache --virtual .bui…   7.92MB
   <missing>      4 days ago      /bin/sh -c #(nop)  ENV YARN_VERSION=1.22.19     0B
   <missing>      4 days ago      /bin/sh -c addgroup -g 1000 node     && addu…   126MB
   <missing>      4 days ago      /bin/sh -c #(nop)  ENV NODE_VERSION=20.12.0     0B
   <missing>      2 months ago    /bin/sh -c #(nop)  CMD ["/bin/sh"]              0B
   <missing>      2 months ago    /bin/sh -c #(nop) ADD file:d0764a717d1e9d0af…   8.42MB
   ```

   This output shows the layers of the image, highlighting the layers you added and those that were inherited from your base image.
   此输出显示图像的图层，突出显示您添加的图层以及从基础图像继承的图层。

### [Push the image 推送镜像](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#push-the-image)

Now that you have an image built, it's time to push the image to a registry.
现在，您已经构建了一个映像，可以将该映像推送到注册表了。

1. Push the image using the [docker push](https://docs.docker.com/reference/cli/docker/image/push/) command:
   使用 docker push 命令推送镜像：

   

1. ```console
   docker push YOUR_DOCKER_USERNAME/concepts-build-image-demo
   ```

   If you receive a `requested access to the resource is denied`, make sure you are both logged in and that your Docker username is correct in the image tag.
   如果您收到 ， `requested access to the resource is denied` 请确保您都已登录，并且您的 Docker 用户名在图像标记中是正确的。

   After a moment, your image should be pushed to Docker Hub.
   片刻之后，您的镜像应该会被推送到 Docker Hub。

## [Additional resources 其他资源](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#additional-resources)

To learn more about building, tagging, and publishing images, visit the following resources:
要了解有关构建、标记和发布图像的更多信息，请访问以下资源：

- [What is a build context?
  什么是构建上下文？](https://docs.docker.com/build/building/context/#what-is-a-build-context)
- [docker build reference Docker 构建参考](https://docs.docker.com/engine/reference/commandline/image_build/)
- [docker image tag reference
  Docker 镜像标签参考](https://docs.docker.com/engine/reference/commandline/image_tag/)
- [docker push reference Docker 推送参考](https://docs.docker.com/engine/reference/commandline/image_push/)
- [What is a registry?
  什么是注册表？](https://docs.docker.com/guides/docker-concepts/the-basics/what-is-a-registry/)

## [Next steps 后续步骤](https://docs.docker.com/guides/docker-concepts/building-images/build-tag-and-publish-an-image/#next-steps)

Now that you have learned about building and publishing images, it's time  to learn how to speed up the build process using the Docker build cache.
现在，您已经了解了如何构建和发布镜像，是时候学习如何使用 Docker 构建缓存来加快构建过程了。

[Using the build cache

](https://docs.docker.com/guides/docker-concepts/building-images/using-the-build-cache/)

# Using the build cache 使用构建缓存

<iframe id="youtube-player-Ri6jMknjprY" data-video-id="Ri6jMknjprY" class="youtube-video aspect-video w-full" frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Docker concepts - Using the build cache" width="100%" height="100%" src="https://www.youtube.com/embed/Ri6jMknjprY?rel=0&amp;iv_load_policy=3&amp;enablejsapi=1&amp;origin=https%3A%2F%2Fdocs.docker.com&amp;widgetid=1" data-gtm-yt-inspected-27="true"></iframe>

## [Explanation 解释](https://docs.docker.com/guides/docker-concepts/building-images/using-the-build-cache/#explanation)

Consider the following Dockerfile that you created for the [getting-started](https://docs.docker.com/guides/docker-concepts/building-images/writing-a-dockerfile/) app.
请考虑为入门应用创建的以下 Dockerfile。

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "./src/index.js"]
```

When you run the `docker build` command to create a new image, Docker executes each instruction in your Dockerfile, creating a layer for each command and in the order  specified. For each instruction, Docker checks whether it can reuse the  instruction from a previous build. If it finds that you've already  executed a similar instruction before, Docker doesn't need to redo it.  Instead, it’ll use the cached result. This way, your build process  becomes faster and more efficient, saving you valuable time and  resources.
当您运行命令 `docker build` 以创建新映像时，Docker 会执行 Dockerfile 中的每条指令，并按照指定的顺序为每个命令创建一个层。对于每条指令，Docker  都会检查它是否可以重用先前构建的指令。如果它发现你之前已经执行过类似的指令，Docker  不需要重做它。相反，它将使用缓存的结果。这样，您的构建过程就会变得更快、更高效，从而为您节省宝贵的时间和资源。

Using the build cache effectively lets you achieve faster builds by reusing  results from previous builds and skipping unnecessary work. In order to maximize cache usage and avoid resource-intensive and  time-consuming rebuilds, it's important to understand how cache  invalidation works. Here are a few examples of situations that can cause cache to be  invalidated:
有效地使用生成缓存，可以重复使用先前生成的结果并跳过不必要的工作，从而更快地生成。为了最大限度地提高缓存使用率并避免资源密集型和耗时的重建，了解缓存失效的工作原理非常重要。以下是可能导致缓存失效的一些情况示例：

- Any changes to the command of a `RUN` instruction invalidates that layer. Docker detects the change and invalidates the build cache if there's any modification to a `RUN` command in your Dockerfile.
  对 `RUN` 指令命令的任何更改都会使该层失效。Docker 会检测到更改，如果 Dockerfile 中 `RUN` 的命令有任何修改，则会使构建缓存失效。
- Any changes to files copied into the image with the `COPY` or `ADD` instructions. Docker keeps an eye on any alterations to files within  your project directory. Whether it's a change in content or properties  like permissions, Docker considers these modifications as triggers to  invalidate the cache.
  对复制到图像中的文件进行的任何更改， `COPY` 以及 or `ADD` 说明。Docker 会密切关注项目目录中文件的任何更改。无论是内容更改还是权限等属性的更改，Docker 都会将这些修改视为使缓存失效的触发器。
- Once one layer is invalidated, all following layers are also invalidated. If any previous layer, including the base image or intermediary layers,  has been invalidated due to changes, Docker ensures that subsequent  layers relying on it are also invalidated. This keeps the build process  synchronized and prevents inconsistencies.
  一旦一个图层失效，所有后续图层也将失效。如果任何先前的层（包括基础镜像或中间层）由于更改而失效，Docker 将确保依赖于它的后续层也失效。这样可以使构建过程保持同步，并防止不一致。

When you're writing or editing a Dockerfile, keep an eye out for unnecessary cache misses to ensure that builds run as fast and efficiently as  possible.
在编写或编辑 Dockerfile 时，请留意不必要的缓存未命中，以确保生成尽可能快速有效地运行。

## [Try it out 尝试一下](https://docs.docker.com/guides/docker-concepts/building-images/using-the-build-cache/#try-it-out)

In this hands-on guide, you will learn how to use the Docker build cache effectively for a Node.js application.
在本实践指南中，您将学习如何有效地将 Docker 构建缓存用于 Node.js 应用程序。

### [Build the application 构建应用程序](https://docs.docker.com/guides/docker-concepts/building-images/using-the-build-cache/#build-the-application)

1. [Download and install](https://www.docker.com/products/docker-desktop/)

 Docker Desktop.
下载并安装 Docker Desktop。

Open a terminal and [clone this sample application](https://github.com/dockersamples/todo-list-app)

.
打开一个终端并克隆此示例应用程序。

```console
 git clone https://github.com/dockersamples/todo-list-app
```

Navigate into the `todo-list-app` directory:
导航到 `todo-list-app` 目录：



```console
 cd todo-list-app
```

Inside this directory, you'll find a file named `Dockerfile` with the following content:
在此目录中，您将找到一个名为以下内容的文件 `Dockerfile` ：

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
EXPOSE 3000
CMD ["node", "./src/index.js"]
```

Execute the following command to build the Docker image:
执行以下命令以构建Docker镜像：

```console
 docker build .
```

Here’s the result of the build process:
以下是生成过程的结果：



```console
[+] Building 20.0s (10/10) FINISHED
```

The first line indicates that the entire build process took *20.0 seconds*. The first build may take some time as it installs dependencies.
第一行表示整个生成过程花费了 20.0 秒。第一次构建可能需要一些时间，因为它会安装依赖项。

Rebuild without making changes.
在不进行更改的情况下进行重建。

Now, re-run the `docker build` command without making any change in the source code or Dockerfile as shown:
现在，重新运行该 `docker build` 命令，而不对源代码或 Dockerfile 进行任何更改，如下所示：

```console
 docker build .
```

Subsequent builds after the initial are faster due to the caching mechanism, as  long as the commands and context remain unchanged. Docker caches the  intermediate layers generated during the build process. When you rebuild the image without making any changes to the Dockerfile or the source  code, Docker can reuse the cached layers, significantly speeding up the  build process.
由于缓存机制，只要命令和上下文保持不变，初始之后的后续构建会更快。Docker 会缓存在构建过程中生成的中间层。当您在不对 Dockerfile 或源代码进行任何更改的情况下重新生成映像时，Docker 可以重用缓存的层，从而显著加快构建过程。

```console
[+] Building 1.0s (9/9) FINISHED                                                                            docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                        0.0s
 => => transferring dockerfile: 187B                                                                                        0.0s
 ...
 => [internal] load build context                                                                                           0.0s
 => => transferring context: 8.16kB                                                                                         0.0s
 => CACHED [2/4] WORKDIR /app                                                                                               0.0s
 => CACHED [3/4] COPY . .                                                                                                   0.0s
 => CACHED [4/4] RUN yarn install --production                                                                              0.0s
 => exporting to image                                                                                                      0.0s
 => => exporting layers                                                                                                     0.0s
 => => exporting manifest
```

The subsequent build was completed in just 1.0 second by leveraging the  cached layers. No need to repeat time-consuming steps like installing  dependencies.
通过利用缓存层，随后的构建仅需 1.0 秒即可完成。无需重复耗时的步骤，例如安装依赖项。

| Steps 步骤 | Description 描述                                             | Time Taken(1st Run) 所用时间（第 1 次运行） | Time Taken (2nd Run) 所用时间（第 2 次运行） |
| ---------- | ------------------------------------------------------------ | ------------------------------------------- | -------------------------------------------- |
| 1          | Load build definition from Dockerfile 从 Dockerfile 加载构建定义 | 0.0 seconds 0.0 秒                          | 0.0 seconds 0.0 秒                           |
| 2          | Load metadata for docker.io/library/node:20-alpine 加载 docker.io/library/node:20-alpine 的元数据 | 2.7 seconds 2.7 秒                          | 0.9 seconds 0.9 秒                           |
| 3          | Load .dockerignore 加载 .dockerignore                        | 0.0 seconds 0.0 秒                          | 0.0 seconds 0.0 秒                           |
| 4          | Load build context 加载生成上下文(Context size: 4.60MB) （上下文大小：4.60MB） | 0.1 seconds 0.1 秒                          | 0.0 seconds 0.0 秒                           |
| 5          | Set the working directory (WORKDIR) 设置工作目录（WORKDIR）  | 0.1 seconds 0.1 秒                          | 0.0 seconds 0.0 秒                           |
| 6          | Copy the local code into the container 将本地代码复制到容器中 | 0.0 seconds 0.0 秒                          | 0.0 seconds 0.0 秒                           |
| 7          | Run yarn install --production 运行 yarn install --production | 10.0 seconds 10.0 秒                        | 0.0 seconds 0.0 秒                           |
| 8          | Exporting layers 导出图层                                    | 2.2 seconds 2.2 秒                          | 0.0 seconds 0.0 秒                           |
| 9          | Exporting the final image 导出最终图像                       | 3.0 seconds 3.0 秒                          | 0.0 seconds 0.0 秒                           |

Going back to the `docker image history` output, you see that each command in the Dockerfile becomes a new layer in the image. You might remember that when you made a change to the  image, the `yarn` dependencies had to be reinstalled. Is there a way to fix this? It  doesn't make much sense to reinstall the same dependencies every time  you build, right?
回到输出， `docker image history` 您会看到 Dockerfile 中的每个命令都成为映像中的新层。您可能还记得，当您对映像进行更改时，必须重新安装 `yarn` 依赖项。有没有办法解决这个问题？每次构建时重新安装相同的依赖项没有多大意义，对吧？

To fix this, restructure your Dockerfile so that the dependency cache  remains valid unless it really needs to be invalidated. For Node-based  applications, dependencies are defined in the `package.json` file. You'll want to reinstall the dependencies if that file changes,  but use cached dependencies if the file is unchanged. So, start by  copying only that file first, then install the dependencies, and finally copy everything else. Then, you only need to recreate the yarn  dependencies if there was a change to the `package.json` file.
要解决此问题，请重新构建 Dockerfile，以便依赖项缓存保持有效，除非它确实需要使其失效。对于基于 Node 的应用程序，依赖项在 `package.json` 文件中定义。如果该文件发生更改，则需要重新安装依赖项，但如果文件未更改，则使用缓存的依赖项。因此，首先仅复制该文件，然后安装依赖项，最后复制其他所有内容。然后，如果 `package.json` 文件发生更改，则只需重新创建 yarn 依赖项。

Update the Dockerfile to copy in the `package.json` file first, install dependencies, and then copy everything else in.
更新 Dockerfile 以首先复制该文件 `package.json` ，安装依赖项，然后复制其他所有内容。

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production 
COPY . . 
EXPOSE 3000
CMD ["node", "src/index.js"]
```

Create a file named `.dockerignore` in the same folder as the Dockerfile with the following contents.
在与 Dockerfile 相同的文件夹中创建一个名为的文件 `.dockerignore` ，其中包含以下内容。

```plaintext
node_modules
```

Build the new image:
构建新映像：

```console
 docker build .
```

You'll then see output similar to the following:
然后，你将看到类似于以下内容的输出：

```console
[+] Building 16.1s (10/10) FINISHED
=> [internal] load build definition from Dockerfile                                               0.0s
=> => transferring dockerfile: 175B                                                               0.0s
=> [internal] load .dockerignore                                                                  0.0s
=> => transferring context: 2B                                                                    0.0s
=> [internal] load metadata for docker.io/library/node:21-alpine                                  0.0s
=> [internal] load build context                                                                  0.8s
=> => transferring context: 53.37MB                                                               0.8s
=> [1/5] FROM docker.io/library/node:21-alpine                                                    0.0s
=> CACHED [2/5] WORKDIR /app                                                                      0.0s
=> [3/5] COPY package.json yarn.lock ./                                                           0.2s
=> [4/5] RUN yarn install --production                                                           14.0s
=> [5/5] COPY . .                                                                                 0.5s
=> exporting to image                                                                             0.6s
=> => exporting layers                                                                            0.6s
=> => writing image     
sha256:d6f819013566c54c50124ed94d5e66c452325327217f4f04399b45f94e37d25        0.0s
=> => naming to docker.io/library/node-app:2.0                                                 0.0s
```

You'll see that all layers were rebuilt. Perfectly fine since you changed the Dockerfile quite a bit.
您将看到所有图层都已重建。完全没问题，因为您对 Dockerfile 进行了相当多的更改。

Now, make a change to the `src/static/index.html` file (like change the title to say "The Awesome Todo App").
现在，对 `src/static/index.html` 文件进行更改（例如将标题更改为“The Awesome Todo App”）。

Build the Docker image. This time, your output should look a little different.
构建 Docker 镜像。这一次，您的输出应该看起来略有不同。

```console
 docker build -t node-app:3.0 .
```

You'll then see output similar to the following:
然后，你将看到类似于以下内容的输出：

1. ```console
   [+] Building 1.2s (10/10) FINISHED 
   => [internal] load build definition from Dockerfile                                               0.0s
   => => transferring dockerfile: 37B                                                                0.0s
   => [internal] load .dockerignore                                                                  0.0s
   => => transferring context: 2B                                                                    0.0s
   => [internal] load metadata for docker.io/library/node:21-alpine                                  0.0s 
   => [internal] load build context                                                                  0.2s
   => => transferring context: 450.43kB                                                              0.2s
   => [1/5] FROM docker.io/library/node:21-alpine                                                    0.0s
   => CACHED [2/5] WORKDIR /app                                                                      0.0s
   => CACHED [3/5] COPY package.json yarn.lock ./                                                    0.0s
   => CACHED [4/5] RUN yarn install --production                                                     0.0s
   => [5/5] COPY . .                                                                                 0.5s 
   => exporting to image                                                                             0.3s
   => => exporting layers                                                                            0.3s
   => => writing image     
   sha256:91790c87bcb096a83c2bd4eb512bc8b134c757cda0bdee4038187f98148e2eda       0.0s
   => => naming to docker.io/library/node-app:3.0                                                 0.0s
   ```

   First off, you should notice that the build was much faster. You'll see that  several steps are using previously cached layers. That's good news;  you're using the build cache. Pushing and pulling this image and updates to it will be much faster as well.
   首先，您应该注意到构建速度要快得多。您将看到有几个步骤正在使用以前缓存的图层。这是个好消息;您正在使用生成缓存。推送和拉取此映像及其更新也将快得多。

By following these optimization techniques, you can make your Docker  builds faster and more efficient, leading to quicker iteration cycles  and improved development productivity.
通过遵循这些优化技术，您可以使 Docker 构建更快、更高效，从而缩短迭代周期并提高开发效率。

## [Additional resources 其他资源](https://docs.docker.com/guides/docker-concepts/building-images/using-the-build-cache/#additional-resources)

- [Optimizing builds with cache management
  使用缓存管理优化构建](https://docs.docker.com/build/cache/)
- [Cache Storage Backend 缓存存储后端](https://docs.docker.com/build/cache/backends/)
- [Build cache invalidation
  构建缓存失效](https://docs.docker.com/build/cache/invalidation/)

## [Next steps 后续步骤](https://docs.docker.com/guides/docker-concepts/building-images/using-the-build-cache/#next-steps)

Now that you understand how to use the Docker build cache effectively, you're ready to learn about Multi-stage builds.
现在，您已经了解如何有效地使用 Docker 构建缓存，接下来可以了解多阶段构建了。

# Multi-stage builds 多阶段构建

<iframe id="youtube-player-vR185cjwxZ8" data-video-id="vR185cjwxZ8" class="youtube-video aspect-video w-full" frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Docker concepts - Multi-stage builds" width="100%" height="100%" src="https://www.youtube.com/embed/vR185cjwxZ8?rel=0&amp;iv_load_policy=3&amp;enablejsapi=1&amp;origin=https%3A%2F%2Fdocs.docker.com&amp;widgetid=1" data-gtm-yt-inspected-15="true"></iframe>

## [Explanation 解释](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#explanation)

In a traditional build, all build instructions are executed in sequence,  and in a single build container: downloading dependencies, compiling  code, and packaging the application. All those layers end up in your  final image. This approach works, but it leads to bulky images carrying  unnecessary weight and increasing your security risks. This is where  multi-stage builds come in.
在传统构建中，所有构建指令都按顺序执行，并在单个构建容器中执行：下载依赖项、编译代码和打包应用程序。所有这些图层最终都会出现在您的最终图像中。这种方法是可行的，但它会导致体积庞大的图像带来不必要的重量，并增加您的安全风险。这就是多阶段构建的用武之地。

Multi-stage builds introduce multiple stages in your Dockerfile, each with a  specific purpose. Think of it like the ability to run different parts of a build in multiple different environments, concurrently. By separating the build environment from the final runtime environment, you can  significantly reduce the image size and attack surface. This is  especially beneficial for applications with large build dependencies.
多阶段构建会在 Dockerfile 中引入多个阶段，每个阶段都有特定的用途。可以把它想象成在多个不同的环境中同时运行构建的不同部分的能力。通过将构建环境与最终运行时环境分开，可以显著减小图像大小和攻击面。这对于具有大型构建依赖项的应用程序尤其有益。

Multi-stage builds are recommended for all types of applications.
对于所有类型的应用程序，建议使用多阶段构建。

- For interpreted languages, like JavaScript or Ruby or Python, you can build and minify your code in one stage, and copy the production-ready files  to a smaller runtime image. This optimizes your image for deployment.
  对于解释型语言（如 JavaScript、Ruby 或 Python），您可以在一个阶段构建和缩小代码，并将生产就绪的文件复制到较小的运行时映像中。这样可以优化映像的部署。
- For compiled languages, like C or Go or Rust, multi-stage builds let you  compile in one stage and copy the compiled binaries into a final runtime image. No need to bundle the entire compiler in your final image.
  对于编译语言，如 C 或 Go 或 Rust，多阶段构建允许您在一个阶段进行编译，并将编译的二进制文件复制到最终的运行时映像中。无需将整个编译器捆绑在最终映像中。

Here's a simplified example of a multi-stage build structure using pseudo-code. Notice there are multiple `FROM` statements and a new `AS <stage-name>`. In addition, the `COPY` statement in the second stage is copying `--from` the previous stage.
下面是使用伪代码的多阶段构建结构的简化示例。请注意，有多个 `FROM` 语句和一个新的 `AS <stage-name>` .此外，第二阶段 `COPY` 的语句正在复制 `--from` 上一阶段。

```dockerfile
# Stage 1: Build Environment
FROM builder-image AS build-stage 
# Install build tools (e.g., Maven, Gradle)
# Copy source code
# Build commands (e.g., compile, package)

# Stage 2: Runtime environment
FROM runtime-image AS final-stage  
#  Copy application artifacts from the build stage (e.g., JAR file)
COPY --from=build-stage /path/in/build/stage /path/to/place/in/final/stage
# Define runtime configuration (e.g., CMD, ENTRYPOINT) 
```

This Dockerfile uses two stages:
此 Dockerfile 使用两个阶段：

- The build stage uses a base image containing build tools needed to compile  your application. It includes commands to install build tools, copy  source code, and execute build commands.
  生成阶段使用一个基础映像，其中包含编译应用程序所需的生成工具。它包括用于安装生成工具、复制源代码和执行生成命令的命令。
- The final stage uses a smaller base image suitable for running your  application. It copies the compiled artifacts (a JAR file, for example)  from the build stage. Finally, it defines the runtime configuration  (using `CMD` or `ENTRYPOINT`) for starting your application.
  最后阶段使用适合运行应用程序的较小基础映像。它从构建阶段复制已编译的工件（例如，JAR 文件）。最后，它定义了用于启动应用程序的运行时配置（使用 `CMD` or `ENTRYPOINT` ）。

## [Try it out 尝试一下](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#try-it-out)

In this hands-on guide, you'll unlock the power of multi-stage builds to  create lean and efficient Docker images for a sample Java application.  You'll use a simple “Hello World” Spring Boot-based application built  with Maven as your example.
在本实践指南中，您将解锁多阶段构建的强大功能，为示例 Java 应用程序创建精简高效的 Docker 映像。您将使用一个简单的基于 “Hello World” Spring Boot 的应用程序作为示例，该应用程序是使用 Maven 构建的。

1. [Download and install](https://www.docker.com/products/docker-desktop/)

 Docker Desktop.
下载并安装 Docker Desktop。

Open this [pre-initialized project](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.3.0-M3&packaging=jar&jvmVersion=21&groupId=com.example&artifactId=spring-boot-docker&name=spring-boot-docker&description=Demo project for Spring Boot&packageName=com.example.spring-boot-docker&dependencies=web)

 to generate a ZIP file. Here’s how that looks:
打开这个预先初始化的项目以生成一个 ZIP 文件。这是它的样子：

![A screenshot of Spring Initializr tool selected with Java 21, Spring Web and Spring Boot 3.3.0](https://docs.docker.com/guides/docker-concepts/building-images/images/spring-initializr.webp)

[Spring Initializr](https://start.spring.io/)

 is a quickstart generator for Spring projects. It provides an  extensible API to generate JVM-based projects with implementations for  several common concepts — like basic language generation for Java,  Kotlin, and Groovy.
Spring Initializr 是 Spring 项目的快速启动生成器。它提供了一个可扩展的 API，用于生成基于 JVM 的项目，其中包含几个常见概念的实现，例如 Java、Kotlin 和 Groovy 的基本语言生成。

Select **Generate** to create and download the zip file for this project.
选择“生成”以创建并下载此项目的 zip 文件。

For this demonstration, you’ve paired Maven build automation with Java, a Spring Web dependency, and Java 21 for your metadata.
在本演示中，您已将 Maven 构建自动化与 Java（Spring Web 依赖项）和元数据的 Java 21 配对。

Navigate the project directory. Once you unzip the file, you'll see the following project directory structure:
在项目目录中导航。解压缩文件后，您将看到以下项目目录结构：

```plaintext
spring-boot-docker
├── Dockerfile
├── Dockerfile.multi
├── HELP.md
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── example
    │   │           └── springbootdocker
    │   │               └── SpringBootDockerApplication.java
    │   └── resources
    │       ├── application.properties
    │       ├── static
    │       └── templates
    └── test
        └── java
            └── com
                └── example
                    └── springbootdocker
                        └── SpringBootDockerApplicationTests.java

15 directories, 9 files
```

The `src/main/java` directory contains your project's source code, the `src/test/java` directory
该 `src/main/java` 目录包含项目的源代码，即 `src/test/java` 该目录
contains the test source, and the `pom.xml` file is your project’s Project Object Model (POM).
包含测试源，文件 `pom.xml` 是项目的项目对象模型 （POM）。

The `pom.xml` file is the core of a Maven project's configuration. It's a single configuration file that
该文件 `pom.xml` 是 Maven 项目配置的核心。这是一个单一的配置文件，
contains most of the information needed to build a customized project. The POM is huge and can seem
包含生成自定义项目所需的大部分信息。POM 很大，看起来
daunting. Thankfully, you don't yet need to understand every intricacy to use it effectively.
艰巨。值得庆幸的是，您还不需要了解每一个复杂性即可有效地使用它。

Create a RESTful web service that displays "Hello World!".
创建一个显示“Hello World！”的 RESTful Web 服务。

Under the `src/main/java/com/example/springbootdocker/` directory, you can modify your
在目录下 `src/main/java/com/example/springbootdocker/` ，您可以修改您的
`SpringBootDockerApplication.java` file with the following content:
 `SpringBootDockerApplication.java` 包含以下内容的文件：

1. ```java
   package com.example.springbootdocker;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   
   @RestController
   @SpringBootApplication
   public class SpringBootDockerApplication {
   
       @RequestMapping("/")
           public String home() {
           return "Hello World";
       }
   
   	public static void main(String[] args) {
   		SpringApplication.run(SpringBootDockerApplication.class, args);
   	}
   
   }
   ```

   The `SpringbootDockerApplication.java` file starts by declaring your `com.example.springbootdocker` package and importing necessary Spring frameworks. This Java file  creates a simple Spring Boot web application that responds with "Hello  World" when a user visits its homepage.
   该文件 `SpringbootDockerApplication.java` 首先声明您的 `com.example.springbootdocker` 包并导入必要的 Spring 框架。此 Java 文件创建了一个简单的 Spring Boot Web 应用程序，当用户访问其主页时，该应用程序会以“Hello World”进行响应。

### [Create the Dockerfile 创建 Dockerfile](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#create-the-dockerfile)

Now that you have the project, you’re ready to create the `Dockerfile`.
现在，您已经有了项目，可以创建 `Dockerfile` .

1. Create a file named `Dockerfile` in the same folder that contains all the other folders and files (like src, pom.xml, etc.).
   在包含所有其他文件夹和文件（如 src、pom.xml 等）的同一文件夹中创建一个命名 `Dockerfile` 的文件。
2. In the `Dockerfile`, define your base image by adding the following line:
   在 中， `Dockerfile` 通过添加以下行来定义基础映像：

```dockerfile
FROM eclipse-temurin:21.0.2_13-jdk-jammy
```

Now, define the working directory by using the `WORKDIR` instruction. This will specify where future commands will run and the  directory files will be copied inside the container image.
现在，使用指令 `WORKDIR` 定义工作目录。这将指定将来命令的运行位置，并将目录文件复制到容器映像中。

```dockerfile
WORKDIR /app
```

Copy both the Maven wrapper script and your project's `pom.xml` file into the current working directory `/app` within the Docker container.
将 `pom.xml` Maven 包装脚本和项目文件复制到 Docker 容器内的当前工作目录中 `/app` 。

```dockerfile
COPY .mvn/ .mvn
COPY mvnw pom.xml ./
```

Execute a command within the container. It runs the `./mvnw dependency:go-offline` command, which uses the Maven wrapper (`./mvnw`) to download all dependencies for your project without building the final JAR file (useful for faster builds).
在容器内执行命令。它运行该 `./mvnw dependency:go-offline` 命令，该命令使用 Maven 包装器 （ `./mvnw` ） 下载项目的所有依赖项，而无需构建最终的 JAR 文件（对于更快的构建很有用）。



```dockerfile
RUN ./mvnw dependency:go-offline
```

Copy the `src` directory from your project on the host machine to the `/app` directory within the container.
将主机上的项目中的 `src` 目录复制到容器内的 `/app` 目录中。

```dockerfile
COPY src ./src
```

Set the default command to be executed when the container starts. This  command instructs the container to run the Maven wrapper (`./mvnw`) with the `spring-boot:run` goal, which will build and execute your Spring Boot application.
设置容器启动时要执行的默认命令。此命令指示容器运行 Maven 包装器 （ `./mvnw` ）， `spring-boot:run` 目标是构建并执行您的 Spring Boot 应用程序。

```dockerfile
CMD ["./mvnw", "spring-boot:run"]
```

And with that, you should have the following Dockerfile:
有了这个，你应该有以下的Dockerfile：

1. ```dockerfile
   FROM eclipse-temurin:21.0.2_13-jdk-jammy
   WORKDIR /app
   COPY .mvn/ .mvn
   COPY mvnw pom.xml ./
   RUN ./mvnw dependency:go-offline
   COPY src ./src
   CMD ["./mvnw", "spring-boot:run"]
   ```

### [Build the container image 构建容器镜像](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#build-the-container-image)

1. Execute the following command to build the Docker image:
   执行以下命令以构建Docker镜像：

   

```console
 docker build -t spring-helloworld .
```

Check the size of the Docker image by using the `docker images` command:
使用以下 `docker images` 命令检查 Docker 映像的大小：

```console
 docker images
```

Doing so will produce output like the following:
这样做将产生如下输出：

1. ```console
   REPOSITORY          TAG       IMAGE ID       CREATED          SIZE
   spring-helloworld   latest    ff708d5ee194   3 minutes ago    880MB
   ```

   This output shows that your image is 880MB in size. It contains the full  JDK, Maven toolchain, and more. In production, you don’t need that in  your final image.
   此输出显示您的图像大小为 880MB。它包含完整的 JDK、Maven 工具链等。在生产环境中，最终映像中不需要它。

### [Run the Spring Boot application 运行 Spring Boot 应用程序](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#run-the-spring-boot-application)

1. Now that you have an image built, it's time to run the container.
   现在，您已经构建了一个映像，可以运行容器了。

```console
 docker run -d -p 8080:8080 spring-helloworld
```

You'll then see output similar to the following in the container log:
然后，你将在容器日志中看到类似于以下内容的输出：You'll then see output similar to the following in the container log：

```plaintext
[INFO] --- spring-boot:3.3.0-M3:run (default-cli) @ spring-boot-docker ---
[INFO] Attaching agents: []
 .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
 ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
 '  |____| .__|_| |_|_| |_\__, | / / / /
  =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::             (v3.3.0-M3)

 2024-04-04T15:36:47.202Z  INFO 42 --- [spring-boot-docker] [           main]       
 c.e.s.SpringBootDockerApplication        : Starting SpringBootDockerApplication using Java    
 21.0.2 with PID 42 (/app/target/classes started by root in /app)
 ….
```

Access your “Hello World” page through your web browser at http://localhost:8080

, or via this curl command:
通过 http://localhost:8080 的 Web 浏览器或以下 curl 命令访问您的“Hello World”页面：



1. ```console
   curl localhost:8080
   Hello World
   ```

### [Use multi-stage builds 使用多阶段构建](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#use-multi-stage-builds)

1. Consider the following Dockerfile:
   请考虑以下 Dockerfile：

```dockerfile
FROM eclipse-temurin:21.0.2_13-jdk-jammy AS builder
WORKDIR /opt/app
COPY .mvn/ .mvn
COPY mvnw pom.xml ./
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean install

FROM eclipse-temurin:21.0.2_13-jre-jammy AS final
WORKDIR /opt/app
EXPOSE 8080
COPY --from=builder /opt/app/target/*.jar /opt/app/*.jar
ENTRYPOINT ["java", "-jar", "/opt/app/*.jar"]
```

Notice that this Dockerfile has been split into two stages.
请注意，此 Dockerfile 已分为两个阶段。

- The first stage remains the same as the previous Dockerfile, providing a  Java Development Kit (JDK) environment for building the application.  This stage is given the name of builder.
  第一阶段与之前的 Dockerfile 相同，提供用于构建应用程序的 Java 开发套件 （JDK） 环境。此阶段被命名为 builder。
- The second stage is a new stage named `final`. It uses a slimmer `eclipse-temurin:21.0.2_13-jre-jammy` image, containing just the Java Runtime Environment (JRE) needed to run the application. This image provides a Java Runtime Environment (JRE)  which is enough for running the compiled application (JAR file).
  第二阶段是一个名为 `final` 的新阶段。它使用更 `eclipse-temurin:21.0.2_13-jre-jammy` 纤细的映像，仅包含运行应用程序所需的 Java 运行时环境 （JRE）。此映像提供了一个 Java 运行时环境 （JRE），该环境足以运行已编译的应用程序（JAR 文件）。

> For production use, it's highly recommended that you produce a custom  JRE-like runtime using jlink. JRE images are available for all versions  of Eclipse Temurin, but `jlink` allows you to create a minimal runtime containing only the necessary  Java modules for your application. This can significantly reduce the  size and improve the security of your final image. [Refer to this page](https://hub.docker.com/_/eclipse-temurin)

1. >  for more information.
   >  对于生产用途，强烈建议您使用 jlink 生成类似 JRE 的自定义运行时。JRE 镜像可用于 Eclipse Temurin 的所有版本，但 `jlink` 允许您创建仅包含应用程序所需的 Java 模块的最小运行时。这可以显著减小最终图像的大小并提高其安全性。有关详细信息，请参阅此页面。

With multi-stage builds, a Docker build uses one base image for compilation, packaging, and unit tests and then a separate image for the application runtime. As a result, the final image is smaller in size since it  doesn’t contain any development or debugging tools. By separating the  build environment from the final runtime environment, you can  significantly reduce the image size and increase the security of your  final images.
在多阶段构建中，Docker 构建使用一个基础镜像进行编译、打包和单元测试，然后使用一个单独的镜像用于应用程序运行时。因此，最终图像的尺寸较小，因为它不包含任何开发或调试工具。通过将构建环境与最终运行时环境分开，可以显著减小图像大小并提高最终图像的安全性。

1. Now, rebuild your image and run your ready-to-use production build.
   现在，重新生成映像并运行现成的生产生成版本。

```console
 docker build -t spring-helloworld-builder .
```

This command builds a Docker image named `spring-helloworld-builder` using the final stage from your `Dockerfile` file located in the current directory.
此命令从位于当前目录中的文件构建使用最后阶段 `Dockerfile` 命名 `spring-helloworld-builder` 的 Docker 映像。

> **Note 注意**
>
> In your multi-stage Dockerfile, the final stage (final) is the default  target for building. This means that if you don't explicitly specify a  target stage using the `--target` flag in the `docker build` command, Docker will automatically build the last stage by default. You could use `docker build -t spring-helloworld-builder --target builder .` to build only the builder stage with the JDK environment.
> 在多阶段 Dockerfile 中，最后阶段 （final） 是构建的默认目标。这意味着，如果您没有在 `docker build` 命令中使用标志 `--target` 明确指定目标阶段，Docker 将默认自动构建最后一个阶段。您只能用于 `docker build -t spring-helloworld-builder --target builder .` 在 JDK 环境中构建构建器阶段。

Look at the image size difference by using the `docker images` command:
使用以下 `docker images` 命令查看图像大小差异：



```console
 docker images
```

You'll get output similar to the following:
你将获得类似于以下内容的输出：

1. ```console
   spring-helloworld-builder latest    c5c76cb815c0   24 minutes ago      428MB
   spring-helloworld         latest    ff708d5ee194   About an hour ago   880MB
   ```

   Your final image is just 428 MB, compared to the original build size of 880 MB.
   最终图像仅为 428 MB，而原始构建大小为 880 MB。

   By optimizing each stage and only including what's necessary, you were able to significantly reduce the
   通过优化每个阶段并仅包含必要的内容，您可以显着减少
   overall image size while still achieving the same functionality. This not only improves performance but
   整体图像大小，同时仍实现相同的功能。这不仅提高了性能，而且
   also makes your Docker images more lightweight, more secure, and easier to manage.
   还使您的 Docker 镜像更轻量级、更安全且更易于管理。

## [Additional resources 其他资源](https://docs.docker.com/guides/docker-concepts/building-images/multi-stage-builds/#additional-resources)

- [Multi-stage builds 多阶段构建](https://docs.docker.com/build/building/multi-stage/)
- [Dockerfile best practices
  Dockerfile 最佳实践](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [Base images 基础图像](https://docs.docker.com/build/building/base-images/)
- [Spring Boot Docker](https://spring.io/guides/topicals/spring-boot-docker)



Welcome! This guide is an introduction and deep-dive into building software with Docker.
欢迎！本指南是对使用 Docker 构建软件的介绍和深入探讨。

Whether you’re just getting started, or you’re already an advanced Docker user, this guide aims to provide useful pointers into the possibilities and best practices of Docker's build features.
无论您是刚入门，还是已经是 Docker 的高级用户，本指南都旨在提供有用的指针，了解 Docker 构建功能的可能性和最佳实践。

Topics covered in this guide include:
本指南涵盖的主题包括：

- Introduction to build concepts
  构建概念简介
- Image size optimization 图像尺寸优化
- Build speed performance improvements
  构建速度性能改进
- Building and exporting binaries
  构建和导出二进制文件
- Cache mounts and bind mounts
  缓存挂载和绑定挂载
- Software testing 软件测试
- Multi-platform builds 多平台构建

Throughout this guide, an example application written in Go is used to illustrate how the build features work. You don’t need to know the Go programming language to follow this guide.
在本指南中，我们将使用一个用 Go 编写的示例应用程序来说明构建功能的工作原理。您无需了解 Go 编程语言即可遵循本指南。

The guide starts off with a simple Dockerfile example, and builds from there. Some of the later sections in this guide describe advanced concepts and workflows. You don't need to complete this entire guide from start to finish. Follow the sections that seem relevant to you, and save the advanced sections at the end for later, when you need them.
本指南从一个简单的 Dockerfile 示例开始，然后从那里构建。本指南后面的一些部分介绍了高级概念和工作流。您无需从头到尾完成整个指南。按照看起来与您相关的部分进行操作，并在末尾保存高级部分，以备以后需要时使用。

[Get started 开始使用](https://docs.docker.com/build/guide/intro/)



[Edit this page 编辑本页](https://github.com/docker/docs/edit/main/content/build/guide/_index.md)

# Introduction 介绍

The starting resources for this guide include a simple Go project and a Dockerfile. From this starting point, the guide illustrates various ways that you can improve how you build the application with Docker.
本指南的起始资源包括一个简单的 Go 项目和 Dockerfile。从这个起点出发，本指南演示了各种方法，您可以改进使用 Docker 构建应用程序的方式。

## [Environment setup 环境设置](https://docs.docker.com/build/guide/intro/#environment-setup)

To follow this guide: 要遵循本指南，请执行以下操作：

1. Install [Docker Desktop or Docker Engine](https://docs.docker.com/get-docker/)
   安装 Docker Desktop 或 Docker Engine
2. Clone or create a new repository from the [application example on GitHub](https://github.com/dockersamples/buildme)

1. 
   从 GitHub 上的应用程序示例克隆或创建新存储库

## [The application 应用程序](https://docs.docker.com/build/guide/intro/#the-application)

The example project for this guide is a client-server application for translating messages to a fictional language.
本指南的示例项目是一个客户端-服务器应用程序，用于将消息翻译成虚构语言。

Here’s an overview of the files included in the project:
以下是项目中包含的文件的概述：

```text
.
├── Dockerfile
├── cmd
│   ├── client
│   │   ├── main.go
│   │   ├── request.go
│   │   └── ui.go
│   └── server
│       ├── main.go
│       └── translate.go
├── go.mod
└── go.sum
```

The `cmd/` directory contains the code for the two application components: client and server. The client is a user interface for writing, sending, and receiving messages. The server receives messages from clients, translates them, and sends them back to the client.
该 `cmd/` 目录包含两个应用程序组件的代码：客户端和服务器。客户端是用于编写、发送和接收消息的用户界面。服务器从客户端接收消息，翻译它们，然后将它们发送回客户端。

## [The Dockerfile](https://docs.docker.com/build/guide/intro/#the-dockerfile)

A Dockerfile is a text document in which you define the build steps for your application. You write the Dockerfile in a domain-specific language, called the Dockerfile syntax.
Dockerfile 是一个文本文档，您可以在其中定义应用程序的构建步骤。使用特定于域的语言编写 Dockerfile，称为 Dockerfile 语法。

Here's the Dockerfile used as the starting point for this guide:
下面是用作本指南起点的 Dockerfile：Here's the Dockerfile used as the starting point for this guide：

```dockerfile
# syntax=docker/dockerfile:1
FROM golang:1.21-alpine
WORKDIR /src
COPY . .
RUN go mod download
RUN go build -o /bin/client ./cmd/client
RUN go build -o /bin/server ./cmd/server
ENTRYPOINT [ "/bin/server" ]
```

Here’s what this Dockerfile does:
以下是此 Dockerfile 的作用：

1. `# syntax=docker/dockerfile:1`

   This comment is a [Dockerfile parser directive](https://docs.docker.com/reference/dockerfile/#parser-directives). It specifies which version of the Dockerfile syntax to use. This file uses the `dockerfile:1` syntax which is best practice: it ensures that you have access to the latest Docker build features.
   此注释是 Dockerfile 解析器指令。它指定要使用的 Dockerfile 语法版本。此文件使用最佳实践的 `dockerfile:1` 语法：它确保您有权访问最新的 Docker 构建功能。

2. `FROM golang:1.21-alpine`

   The `FROM` instruction uses version `1.21-alpine` of the `golang` official image.
   该 `FROM` 指令使用 `golang` 官方图像的版本 `1.21-alpine` 。

3. `WORKDIR /src`

   Creates the `/src` working directory inside the container.
   在容器内创建 `/src` 工作目录。

4. `COPY . .`

   Copies the files in the build context to the working directory in the container.
   将生成上下文中的文件复制到容器中的工作目录。

5. `RUN go mod download`

   Downloads the necessary Go modules to the container. Go modules is the dependency management tool for the Go programming language, similar to `npm install` for JavaScript, or `pip install` for Python.
   将必要的 Go 模块下载到容器中。Go modules 是 Go 编程语言的依赖项管理工具，类似于 `npm install` JavaScript 或 `pip install` Python。

6. `RUN go build -o /bin/client ./cmd/client`

   Builds the `client` binary, which is used to send messages to be translated, into the `/bin` directory.
   将 `client` 二进制文件（用于发送要翻译的消息）构建到 `/bin` 目录中。

7. `RUN go build -o /bin/server ./cmd/server`

   Builds the `server` binary, which listens for client translation requests, into the `/bin` directory.
   将侦听客户端翻译请求的 `server` 二进制文件构建到 `/bin` 目录中。

8. `ENTRYPOINT [ "/bin/server" ]`

   Specifies a command to run when the container starts. Starts the server process.
   指定容器启动时要运行的命令。启动服务器进程。

## [Build the image 构建映像](https://docs.docker.com/build/guide/intro/#build-the-image)

To build an image using a Dockerfile, you use the `docker` command-line tool. The command for building an image is `docker build`.
要使用 Dockerfile 构建映像，请使用 `docker` 命令行工具。用于构建映像的命令是 `docker build` 。

Run the following command to build the image.
运行以下命令以构建映像。



```console
 docker build --tag=buildme .
```

This creates an image with the tag `buildme`. An image tag is the name of the image.
这将创建一个带有标签 `buildme` 的图像。图像标签是图像的名称。

## [Run the container 运行容器](https://docs.docker.com/build/guide/intro/#run-the-container)

The image you just built contains two binaries, one for the server and one for the client. To see the translation service in action, run a container that hosts the server component, and then run another container that invokes the client.
您刚刚构建的映像包含两个二进制文件，一个用于服务器，另一个用于客户端。若要查看翻译服务的运行情况，请运行托管服务器组件的容器，然后运行另一个调用客户端的容器。

To run a container, you use the `docker run` command.
要运行容器，请使用以下 `docker run` 命令。

1. Run a container from the image in detached mode.
   在分离模式下从映像运行容器。

```console
 docker run --name=buildme --rm --detach buildme
```

This starts a container named `buildme`.
这将启动一个名为 `buildme` 的容器。

Run a new command in the `buildme` container that invokes the client binary.
在 `buildme` 容器中运行一个新命令，以调用客户端二进制文件。



1. ```console
    docker exec -it buildme /bin/client
   ```

The `docker exec` command opens a terminal user interface where you can submit messages for the backend (server) process to translate.
该 `docker exec` 命令将打开一个终端用户界面，您可以在其中提交消息以供后端（服务器）进程进行翻译。

When you're done testing, you can stop the container:
完成测试后，可以停止容器：



```console
 docker stop buildme
```

## [Summary 总结](https://docs.docker.com/build/guide/intro/#summary)

This section gave you an overview of the example application used in this guide, an introduction to Dockerfiles and building. You've successfully built a container image and created a container from it.
本部分概述了本指南中使用的示例应用程序，并介绍了 Dockerfiles 和构建。您已成功生成容器映像，并从中创建了容器。

Related information: 相关信息：

- [Dockerfile reference Dockerfile 参考](https://docs.docker.com/reference/dockerfile/)
- [`docker build` CLI reference `docker build` CLI 参考](https://docs.docker.com/reference/cli/docker/buildx/build/)
- [`docker run` CLI reference `docker run` CLI 参考](https://docs.docker.com/reference/cli/docker/container/run/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/intro/#next-steps)

The next section explores how you can use layer cache to improve build speed.
下一节将探讨如何使用图层缓存来提高构建速度。

[Layers 层](https://docs.docker.com/build/guide/layers/)

# Layers 层

The order of Dockerfile instructions matters. A Docker build consists of a series of ordered build instructions. Each instruction in a Dockerfile roughly translates to an image layer. The following diagram illustrates how a Dockerfile translates into a stack of layers in a container image.
Dockerfile 指令的顺序很重要。Docker 构建由一系列有序的构建指令组成。Dockerfile 中的每条指令大致转换为一个图像层。下图演示了 Dockerfile 如何转换为容器映像中的层堆栈。

![From Dockerfile to layers](https://docs.docker.com/build/guide/images/layers.png)

## [Cached layers 缓存图层](https://docs.docker.com/build/guide/layers/#cached-layers)

When you run a build, the builder attempts to reuse layers from earlier builds. If a layer of an image is unchanged, then the builder picks it up from the build cache. If a layer has changed since the last build, that layer, and all layers that follow, must be rebuilt.
当您运行构建时，构建器会尝试重用早期构建中的层。如果图像的图层未更改，则构建器将从构建缓存中选取它。如果某个层自上次构建以来发生更改，则必须重新构建该层以及随后的所有层。

The Dockerfile from the previous section copies all project files to the container (`COPY . .`) and then downloads application dependencies in the following step (`RUN go mod download`). If you were to change any of the project files, then that would invalidate the cache for the `COPY` layer. It also invalidates the cache for all of the layers that follow.
上一部分中的 Dockerfile 将所有项目文件复制到容器 （ `COPY . .` ），然后在下一步 （ ） 中下载应用程序依赖项 `RUN go mod download` 。如果要更改任何工程文件，则会使 `COPY` 图层的缓存失效。它还会使后续所有图层的缓存失效。

![Layer cache is bust](https://docs.docker.com/build/guide/images/cache-bust.png)

Because of the current order of the Dockerfile instructions, the builder must download the Go modules again, despite none of the packages having changed since the last time.
由于 Dockerfile 指令的当前顺序，构建器必须再次下载 Go 模块，尽管自上次以来没有任何包更改。

## [Update the instruction order 更新指示顺序](https://docs.docker.com/build/guide/layers/#update-the-instruction-order)

You can avoid this redundancy by reordering the instructions in the Dockerfile. Change the order of the instructions so that downloading and installing dependencies occur before the source code is copied over to the container. In that way, the builder can reuse the "dependencies" layer from the cache, even when you make changes to your source code.
您可以通过对 Dockerfile 中的指令重新排序来避免这种冗余。更改说明的顺序，以便在将源代码复制到容器之前下载和安装依赖项。这样，即使您对源代码进行了更改，构建器也可以重用缓存中的“依赖项”层。

Go uses two files, called `go.mod` and `go.sum`, to track dependencies for a project. These files are to Go, what `package.json` and `package-lock.json` are to JavaScript. For Go to know which dependencies to download, you need to copy the `go.mod` and `go.sum` files to the container. Add another `COPY` instruction before `RUN go mod download`, this time copying only the `go.mod` and `go.sum` files.
Go 使用两个名为 `go.mod` 和 `go.sum` 的文件来跟踪项目的依赖项。这些文件是 Go、what `package.json` 和 `package-lock.json` JavaScript。为了让 Go 知道要下载哪些依赖项，您需要将 `go.mod` and `go.sum` 文件复制到容器中。在 之前添加另一 `COPY` 条指令，这次只复制 `go.mod` 和 `go.sum` `RUN go mod download` 文件。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine
  WORKDIR /src
- COPY . .
+ COPY go.mod go.sum .
  RUN go mod download
+ COPY . .
  RUN go build -o /bin/client ./cmd/client
  RUN go build -o /bin/server ./cmd/server
  ENTRYPOINT [ "/bin/server" ]
```

Now if you edit your source code, building the image won't cause the builder to download the dependencies each time. The `COPY . .` instruction appears after the package management instructions, so the builder can reuse the `RUN go mod download` layer.
现在，如果您编辑源代码，构建图像不会导致构建器每次都下载依赖项。该 `COPY . .` 指令显示在包管理指令之后，因此构建器可以重用该 `RUN go mod download` 层。

![Reordered](https://docs.docker.com/build/guide/images/reordered-layers.png)

## [Summary 总结](https://docs.docker.com/build/guide/layers/#summary)

Ordering your Dockerfile instructions appropriately helps you avoid unnecessary work at build time.
适当地对 Dockerfile 指令进行排序有助于避免在生成时进行不必要的工作。

Related information: 相关信息：

- [Docker build cache Docker 构建缓存](https://docs.docker.com/build/cache/)
- [Dockerfile best practices
  Dockerfile 最佳实践](https://docs.docker.com/build/building/best-practices/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/layers/#next-steps)

The next section shows how you can make the build run faster, and make the resulting output smaller, using multi-stage builds.
下一部分将介绍如何使用多阶段生成来加快生成运行速度，并使生成的输出更小。

# Multi-stage 多级

This section explores multi-stage builds. There are two main reasons for why you’d want to use multi-stage builds:
本部分探讨多阶段生成。想要使用多阶段构建的原因有两个主要：There are two main reasons for why you'd want to use multi-stage builds：

- They allow you to run build steps in parallel, making your build pipeline faster and more efficient.
  它们允许您并行运行构建步骤，从而使您的构建管道更快、更高效。
- They allow you to create a final image with a smaller footprint, containing only what's needed to run your program.
  它们允许您创建占用空间更小的最终图像，仅包含运行程序所需的内容。

In a Dockerfile, a build stage is represented by a `FROM` instruction. The Dockerfile from the previous section doesn’t leverage multi-stage builds. It’s all one build stage. That means that the final image is bloated with resources used to compile the program.
在 Dockerfile 中，构建阶段由指令 `FROM` 表示。上一部分的 Dockerfile 不利用多阶段构建。这都是一个构建阶段。这意味着最终图像中充满了用于编译程序的资源。

```console
 docker build --tag=buildme .
 docker images buildme
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
buildme      latest    c021c8a7051f   5 seconds ago   150MB
```

The program compiles to executable binaries, so you don’t need Go language utilities to exist in the final image.
该程序编译为可执行二进制文件，因此您不需要在最终图像中存在 Go 语言实用程序。

## [Add stages 添加阶段](https://docs.docker.com/build/guide/multi-stage/#add-stages)

Using multi-stage builds, you can choose to use different base images for your build and runtime environments. You can copy build artifacts from the build stage over to the runtime stage.
使用多阶段构建，您可以选择为构建和运行时环境使用不同的基础映像。您可以将构建项目从构建阶段复制到运行时阶段。

Modify the Dockerfile as follows. This change creates another stage using a minimal `scratch` image as a base. In the final `scratch` stage, the binaries built in the previous stage are copied over to the filesystem of the new stage.
按如下方式修改 Dockerfile。此更改使用最小 `scratch` 图像作为基础创建另一个阶段。在最后 `scratch` 阶段，在上一阶段构建的二进制文件将被复制到新阶段的文件系统中。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine
  WORKDIR /src
  COPY go.mod go.sum .
  RUN go mod download
  COPY . .
  RUN go build -o /bin/client ./cmd/client
  RUN go build -o /bin/server ./cmd/server
+
+ FROM scratch
+ COPY --from=0 /bin/client /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Now if you build the image and inspect it, you should see a significantly smaller number:
现在，如果生成映像并进行检查，应会看到一个明显较小的数字：

```console
 docker build --tag=buildme .
 docker images buildme
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
buildme      latest    436032454dd8   7 seconds ago   8.45MB
```

The image went from 150MB to only just 8.45MB in size. That’s because the resulting image only contains the binaries, and nothing else.
图像的大小从 150MB 增加到只有 8.45MB。这是因为生成的图像仅包含二进制文件，而不包含其他任何内容。

## [Parallelism 排比](https://docs.docker.com/build/guide/multi-stage/#parallelism)

You've reduced the footprint of the image. The following step shows how you can improve build speed with multi-stage builds, using parallelism. The build currently produces the binaries one after the other. There is no reason why you need to build the client before building the server, or vice versa.
您已经减少了图像的占用空间。以下步骤演示如何使用并行性通过多阶段生成提高生成速度。该版本当前会一个接一个地生成二进制文件。没有理由需要在构建服务器之前构建客户端，反之亦然。

You can split the binary-building steps into separate stages. In the final `scratch` stage, copy the binaries from each corresponding build stage. By segmenting these builds into separate stages, Docker can run them in parallel.
您可以将二进制构建步骤拆分为多个单独的阶段。在最后 `scratch` 阶段，从每个相应的生成阶段复制二进制文件。通过将这些构建划分为单独的阶段，Docker 可以并行运行它们。

The stages for building each binary both require the Go compilation tools and application dependencies. Define these common steps as a reusable base stage. You can do that by assigning a name to the stage using the pattern `FROM image AS stage_name`. This allows you to reference the stage name in a `FROM` instruction of another stage (`FROM stage_name`).
构建每个二进制文件的阶段都需要 Go 编译工具和应用程序依赖项。将这些常见步骤定义为可重用的基础阶段。您可以通过使用 pattern `FROM image AS stage_name` 为舞台分配名称来执行此操作。这允许您在另一个阶段 （ `FROM stage_name` ） 的 `FROM` 指令中引用阶段名称。

You can also assign a name to the binary-building stages, and reference the stage name in the `COPY --from=stage_name` instruction when copying the binaries to the final `scratch` image.
您还可以为二进制文件构建阶段分配名称，并在将二进制文件复制到最终 `scratch` 映像时在指令中 `COPY --from=stage_name` 引用阶段名称。



```diff
  # syntax=docker/dockerfile:1
- FROM golang:1.21-alpine
+ FROM golang:1.21-alpine AS base
  WORKDIR /src
  COPY go.mod go.sum .
  RUN go mod download
  COPY . .
+
+ FROM base AS build-client
  RUN go build -o /bin/client ./cmd/client
+
+ FROM base AS build-server
  RUN go build -o /bin/server ./cmd/server

  FROM scratch
- COPY --from=0 /bin/client /bin/server /bin/
+ COPY --from=build-client /bin/client /bin/
+ COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Now, instead of first building the binaries one after the other, the `build-client` and `build-server` stages are executed simultaneously.
现在，不是先一个接一个地构建二进制文件，而是同时执行 `build-client` 和 `build-server` 阶段。

![Stages executing in parallel](https://docs.docker.com/build/guide/images/parallelism.gif)

## [Build targets 构建目标](https://docs.docker.com/build/guide/multi-stage/#build-targets)

The final image is now small, and you’re building it efficiently using parallelism. But this image is slightly strange, in that it contains both the client and the server binary in the same image. Shouldn’t these be two different images?
现在，最终的图像很小，您可以使用并行性有效地构建它。但是这个图像有点奇怪，因为它在同一图像中同时包含客户端和服务器二进制文件。这不应该是两个不同的图像吗？

It’s possible to create multiple different images using a single Dockerfile. You can specify a target stage of a build using the `--target` flag. Replace the unnamed `FROM scratch` stage with two separate stages named `client` and `server`.
可以使用单个 Dockerfile 创建多个不同的映像。您可以使用标志 `--target` 指定生成的目标阶段。将未命名 `FROM scratch` 的阶段替换为名为 `client` 和 `server` 的两个独立阶段。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
  COPY go.mod go.sum .
  RUN go mod download
  COPY . .

  FROM base AS build-client
  RUN go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN go build -o /bin/server ./cmd/server

- FROM scratch
- COPY --from=build-client /bin/client /bin/
- COPY --from=build-server /bin/server /bin/
- ENTRYPOINT [ "/bin/server" ]

+ FROM scratch AS client
+ COPY --from=build-client /bin/client /bin/
+ ENTRYPOINT [ "/bin/client" ]

+ FROM scratch AS server
+ COPY --from=build-server /bin/server /bin/
+ ENTRYPOINT [ "/bin/server" ]
```

And now you can build the client and server programs as separate Docker images (tags):
现在，您可以将客户端和服务器程序构建为单独的 Docker 镜像（标签）：

```console
 docker build --tag=buildme-client --target=client .
 docker build --tag=buildme-server --target=server .
 docker images "buildme*" 
REPOSITORY       TAG       IMAGE ID       CREATED          SIZE
buildme-client   latest    659105f8e6d7   20 seconds ago   4.25MB
buildme-server   latest    666d492d9f13   5 seconds ago    4.2MB
```

The images are now even smaller, about 4 MB each.
现在，这些图像甚至更小，每个图像约为 4 MB。

This change also avoids having to build both binaries each time. When selecting to build the `client` target, Docker only builds the stages leading up to that target. The `build-server` and `server` stages are skipped if they’re not needed. Likewise, building the `server` target skips the `build-client` and `client` stages.
此更改还避免了每次都必须构建两个二进制文件。在选择构建 `client` 目标时，Docker 仅构建导致该目标的阶段。如果不需要 `build-server` and `server` 阶段，则跳过它们。同样，构建 `server` 目标会跳过 `build-client` and `client` 阶段。

## [Summary 总结](https://docs.docker.com/build/guide/multi-stage/#summary)

Multi-stage builds are useful for creating images with less bloat and a smaller footprint, and also helps to make builds run faster.
多阶段生成对于创建体积较小且占用空间较小的映像非常有用，并且还有助于提高生成运行速度。

Related information: 相关信息：

- [Multi-stage builds 多阶段构建](https://docs.docker.com/build/building/multi-stage/)
- [Base images 基础图像](https://docs.docker.com/build/building/base-images/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/multi-stage/#next-steps)

The next section describes how you can use file mounts to further improve build speeds.
下一节将介绍如何使用文件挂载来进一步提高构建速度。

# Mounts 坐骑

This section describes how to use cache mounts and bind mounts with Docker builds.
本节介绍如何在 Docker 构建中使用缓存挂载和绑定挂载。

Cache mounts let you specify a persistent package cache to be used during builds. The persistent cache helps speed up build steps, especially steps that involve installing packages using a package manager. Having a persistent cache for packages means that even if you rebuild a layer, you only download new or changed packages.
通过缓存挂载，您可以指定在构建期间使用的持久性包缓存。持久性缓存有助于加快构建步骤，尤其是涉及使用包管理器安装包的步骤。拥有包的持久缓存意味着，即使您重建了层，也只需下载新的或更改的包。

Cache mounts are created using the `--mount` flag together with the `RUN` instruction in the Dockerfile. To use a cache mount, the format for the flag is `--mount=type=cache,target=<path>`, where `<path>` is the location of the cache directory that you wish to mount into the container.
缓存挂载是使用该 `--mount` 标志和 Dockerfile 中的 `RUN` 指令创建的。要使用缓存挂载，标志的格式为 `--mount=type=cache,target=<path>` ，其中 `<path>` 是您希望挂载到容器中的缓存目录的位置。

## [Add a cache mount 添加缓存挂载](https://docs.docker.com/build/guide/mounts/#add-a-cache-mount)

The target path to use for the cache mount depends on the package manager you’re using. The application example in this guide uses Go modules. That means that the target directory for the cache mount is the directory where the Go module cache gets written to. According to the [Go modules reference](https://go.dev/ref/mod#module-cache)

, the default location for the module cache is `$GOPATH/pkg/mod`, and the default value for `$GOPATH` is `/go`.
用于缓存装载的目标路径取决于您正在使用的包管理器。本指南中的应用程序示例使用 Go 模块。这意味着缓存挂载的目标目录是写入 Go 模块缓存的目录。根据 Go 模块参考，模块缓存的默认位置是 `$GOPATH/pkg/mod` ，而 的 `$GOPATH` 默认值是 `/go` 。

Update the build steps for downloading packages and compiling the program to mount the `/go/pkg/mod` directory as a cache mount:
更新下载包和编译程序的构建步骤，以将 `/go/pkg/mod` 目录挂载为缓存挂载：

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
  COPY go.mod go.sum .
- RUN go mod download
+ RUN --mount=type=cache,target=/go/pkg/mod/ \
+     go mod download -x
  COPY . .

  FROM base AS build-client
- RUN go build -o /bin/client ./cmd/client
+ RUN --mount=type=cache,target=/go/pkg/mod/ \
+     go build -o /bin/client ./cmd/client

  FROM base AS build-server
- RUN go build -o /bin/server ./cmd/server
+ RUN --mount=type=cache,target=/go/pkg/mod/ \
+     go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

The `-x` flag added to the `go mod download` command prints the download executions that take place. Adding this flag lets you see how the cache mount is being used in the next step.
添加到命令中 `-x`  `go mod download` 的标志将打印发生的下载执行。通过添加此标志，您可以查看下一步中如何使用缓存装载。

## [Rebuild the image 重建映像](https://docs.docker.com/build/guide/mounts/#rebuild-the-image)

Before you rebuild the image, clear your build cache. This ensures that you're starting from a clean slate, making it easier to see exactly what the build is doing.
在重新生成映像之前，请清除生成缓存。这可确保您从头开始，从而更容易准确地看到构建正在执行的操作。



```console
 docker builder prune -af
```

Now it’s time to rebuild the image. Invoke the build command, this time together with the `--progress=plain` flag, while also redirecting the output to a log file.
现在是时候重建映像了。调用 build 命令，这次与 `--progress=plain` 标志一起调用，同时将输出重定向到日志文件。

```console
 docker build --target=client --progress=plain . 2> log1.txt
```

When the build has finished, inspect the `log1.txt` file. The logs show how the Go modules were downloaded as part of the build.
生成完成后，检查 `log1.txt` 文件。日志显示了如何在构建过程中下载 Go 模块。

```console
 awk '/proxy.golang.org/' log1.txt
11 0.168 # get https://proxy.golang.org/github.com/charmbracelet/lipgloss/@v/v0.6.0.mod
11 0.168 # get https://proxy.golang.org/github.com/aymanbagabas/go-osc52/@v/v1.0.3.mod
11 0.168 # get https://proxy.golang.org/github.com/atotto/clipboard/@v/v0.1.4.mod
11 0.168 # get https://proxy.golang.org/github.com/charmbracelet/bubbletea/@v/v0.23.1.mod
11 0.169 # get https://proxy.golang.org/github.com/charmbracelet/bubbles/@v/v0.14.0.mod
11 0.218 # get https://proxy.golang.org/github.com/charmbracelet/bubbles/@v/v0.14.0.mod: 200 OK (0.049s)
11 0.218 # get https://proxy.golang.org/github.com/aymanbagabas/go-osc52/@v/v1.0.3.mod: 200 OK (0.049s)
11 0.218 # get https://proxy.golang.org/github.com/containerd/console/@v/v1.0.3.mod
11 0.218 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.0.mod
11 0.219 # get https://proxy.golang.org/github.com/charmbracelet/bubbletea/@v/v0.23.1.mod: 200 OK (0.050s)
11 0.219 # get https://proxy.golang.org/github.com/atotto/clipboard/@v/v0.1.4.mod: 200 OK (0.051s)
11 0.219 # get https://proxy.golang.org/github.com/charmbracelet/lipgloss/@v/v0.6.0.mod: 200 OK (0.051s)
...
```

Now, in order to see that the cache mount is being used, change the version of one of the Go modules that your program imports. By changing the module version, you're forcing Go to download the new version of the dependency the next time you build. If you weren’t using cache mounts, your system would re-download all modules. But because you've added a cache mount, Go can reuse most of the modules and only download the package versions that doesn't already exist in the `/go/pkg/mod` directory.
现在，为了查看正在使用缓存挂载，请更改程序导入的其中一个 Go 模块的版本。通过更改模块版本，您将强制 Go  在下次构建时下载依赖项的新版本。如果您没有使用缓存挂载，您的系统将重新下载所有模块。但是，由于您添加了缓存挂载，因此 Go  可以重用大部分模块，并且只下载目录中尚不存在的 `/go/pkg/mod` 包版本。

Update the version of the `chi` package that the server component of the application uses:
更新应用程序的服务器组件使用的 `chi` 包版本：



```console
 docker run -v $PWD:$PWD -w $PWD golang:1.21-alpine \
    go get github.com/go-chi/chi/v5@v5.0.8
```

Now, run another build, and again redirect the build logs to a log file:
现在，运行另一个生成，并再次将生成日志重定向到日志文件：



```console
 docker build --target=client --progress=plain . 2> log2.txt
```

Now if you inspect the `log2.txt` file, you’ll find that only the `chi` package that was changed has been downloaded:
现在，如果您检查该文件 `log2.txt` ，您会发现只有已更改的 `chi` 包已被下载：

```console
 awk '/proxy.golang.org/' log2.txt
10 0.143 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.mod
10 0.190 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.mod: 200 OK (0.047s)
10 0.190 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.info
10 0.199 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.info: 200 OK (0.008s)
10 0.201 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.zip
10 0.209 # get https://proxy.golang.org/github.com/go-chi/chi/v5/@v/v5.0.8.zip: 200 OK (0.008s)
```

## [Add bind mounts 添加绑定挂载](https://docs.docker.com/build/guide/mounts/#add-bind-mounts)

There are a few more small optimizations that you can implement to improve the Dockerfile. Currently, it's using the `COPY` instruction to pull in the `go.mod` and `go.sum` files before downloading modules. Instead of copying those files over to the container’s filesystem, you can use a bind mount. A bind mount makes the files available to the container directly from the host. This change removes the need for the additional `COPY` instruction (and layer) entirely.
您可以实施一些小的优化来改进 Dockerfile。目前，它正在使用指令 `COPY` 在下载模块之前拉入 `go.mod` and `go.sum` 文件。您可以使用绑定挂载，而不是将这些文件复制到容器的文件系统中。绑定挂载使文件可直接从主机提供给容器。此更改完全消除了对额外 `COPY` 指令（和层）的需求。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
- COPY go.mod go.sum .
  RUN --mount=type=cache,target=/go/pkg/mod/ \
+     --mount=type=bind,source=go.sum,target=go.sum \
+     --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x
  COPY . .

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Similarly, you can use the same technique to remove the need for the second `COPY` instruction as well. Specify bind mounts in the `build-client` and `build-server` stages for mounting the current working directory.
同样，您也可以使用相同的技术来消除对第二 `COPY` 条指令的需求。在 `build-client` 和 `build-server` 阶段中指定绑定挂载，以挂载当前工作目录。

```diff
  # syntax=docker/dockerfile:1
  FROM golang:1.21-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x
- COPY . .

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
+     --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN --mount=type=cache,target=/go/pkg/mod/ \
+     --mount=type=bind,target=. \
      go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

## [Summary 总结](https://docs.docker.com/build/guide/mounts/#summary)

This section has shown how you can improve your build speed using cache and bind mounts.
本部分介绍了如何使用缓存和绑定挂载来提高构建速度。

Related information: 相关信息：

- [Dockerfile reference Dockerfile 参考](https://docs.docker.com/reference/dockerfile/#run---mount)
- [Bind mounts 绑定挂载](https://docs.docker.com/storage/bind-mounts/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/mounts/#next-steps)

The next section of this guide is an introduction to making your builds configurable, using build arguments.
本指南的下一部分将介绍如何使用构建参数使构建可配置。

[Build arguments 构建参数](https://docs.docker.com/build/guide/build-args/)

# Build arguments 构建参数

Build arguments is a great way to add flexibility to your builds. You can pass build arguments at build-time, and you can set a default value that the builder uses as a fallback.
构建参数是增加构建灵活性的好方法。您可以在构建时传递构建参数，并且可以设置构建器用作回退的默认值。

## [Change runtime versions 更改运行时版本](https://docs.docker.com/build/guide/build-args/#change-runtime-versions)

A practical use case for build arguments is to specify runtime versions for build stages. Your image uses the `golang:1.21-alpine` image as a base image. But what if someone wanted to use a different version of Go for building the application? They could update the version number inside the Dockerfile, but that’s inconvenient, it makes switching between versions more tedious than it has to be. Build arguments make life easier:
构建参数的一个实际用例是指定构建阶段的运行时版本。您的映像使用该 `golang:1.21-alpine` 映像作为基础映像。但是，如果有人想使用不同版本的 Go 来构建应用程序怎么办？他们可以更新 Dockerfile 内的版本号，但这很不方便，它使得在版本之间切换比必须的更繁琐。构建参数让生活更轻松：

```diff
  # syntax=docker/dockerfile:1
- FROM golang:1.21-alpine AS base
+ ARG GO_VERSION=1.21
+ FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

The `ARG` keyword is interpolated in the image name in the `FROM` instruction. The default value of the `GO_VERSION` build argument is set to `1.21`. If the build doesn't receive a `GO_VERSION` build argument, the `FROM` instruction resolves to `golang:1.21-alpine`.
 `ARG` 关键字在 `FROM` 指令中的图像名称中插入。 `GO_VERSION` build 参数的默认值设置为 `1.21` 。如果构建未收到 `GO_VERSION` 构建参数，则指令 `FROM` 将解析为 `golang:1.21-alpine` 。

Try setting a different version of Go to use for building, using the `--build-arg` flag for the build command:
尝试设置一个不同版本的 Go 用于构建，使用 build 命令的标志 `--build-arg` ：

```console
 docker build --build-arg="GO_VERSION=1.19" .
```

Running this command results in a build using the `golang:1.19-alpine` image.
运行此命令将导致使用映像 `golang:1.19-alpine` 的生成。

## [Inject values 注入值](https://docs.docker.com/build/guide/build-args/#inject-values)

You can also make use of build arguments to modify values in the source code of your program, at build time. This is useful for dynamically injecting information, avoiding hard-coded values. With Go, consuming external values at build time is done using linker flags, or `-ldflags`.
您还可以在构建时使用构建参数来修改程序源代码中的值。这对于动态注入信息非常有用，可以避免硬编码的值。使用 Go 时，在构建时使用外部值是使用链接器标志或 `-ldflags` 来完成的。

The server part of the application contains a conditional statement to print the app version, if a version is specified:
如果指定了版本，则应用程序的服务器部分包含一个条件语句，用于打印应用程序版本：

```go
// cmd/server/main.go
var version string

func main() {
	if version != "" {
		log.Printf("Version: %s", version)
	}
```

You could declare the version string value directly in the code. But, updating the version to line up with the release version of the application would require updating the code ahead of every release. That would be both tedious and error-prone. A better solution is to pass the version string as a build argument, and inject the build argument into the code.
您可以直接在代码中声明版本字符串值。但是，更新版本以与应用程序的发布版本保持一致需要在每次发布之前更新代码。这将是既乏味又容易出错的。更好的解决方案是将版本字符串作为构建参数传递，并将构建参数注入到代码中。

The following example adds an `APP_VERSION` build argument to the `build-server` stage. The Go compiler uses the value of the build argument to set the value of a variable in the code.
以下示例将生成 `APP_VERSION` 参数添加到 `build-server` 舞台。Go 编译器使用 build 参数的值来设置代码中变量的值。

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
  FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
+ ARG APP_VERSION="v0.0.0+unknown"
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
-     go build -o /bin/server ./cmd/server
+     go build -ldflags "-X main.version=$APP_VERSION" -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
```

Now the version of the server is injected when building the binary, without having to update the source code. To verify this, you can build the `server` target and start a container with `docker run`. The server outputs `v0.0.1` as the version on startup.
现在，在构建二进制文件时会注入服务器的版本，而无需更新源代码。要验证这一点，您可以使用 构建目标 `server` 并启动容器 `docker run` 。服务器在启动时 `v0.0.1` 输出为版本。

```console
 docker build --target=server --build-arg="APP_VERSION=v0.0.1" --tag=buildme-server .
 docker run buildme-server
2023/04/06 08:54:27 Version: v0.0.1
2023/04/06 08:54:27 Starting server...
2023/04/06 08:54:27 Listening on HTTP port 3000
```

## [Summary 总结](https://docs.docker.com/build/guide/build-args/#summary)

This section showed how you can use build arguments to make builds more configurable, and inject values at build-time.
本部分展示了如何使用构建参数来使构建更具可配置性，并在构建时注入值。

Related information: 相关信息：

- [`ARG` Dockerfile reference
   `ARG` Dockerfile 参考](https://docs.docker.com/reference/dockerfile/#arg)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/build-args/#next-steps)

The next section of this guide shows how you can use Docker builds to create not only container images, but executable binaries as well.
本指南的下一部分将介绍如何使用 Docker 构建来创建容器映像，以及创建可执行二进制文件。

# Export binaries 导出二进制文件

Did you know that you can use Docker to build your application to standalone binaries? Sometimes, you don’t want to package and distribute your application as a Docker image. Use Docker to build your application, and use exporters to save the output to disk.
您知道可以使用 Docker 将应用程序构建为独立的二进制文件吗？有时，您不希望将应用程序打包并分发为 Docker 映像。使用 Docker 构建应用程序，并使用导出器将输出保存到磁盘。

The default output format for `docker build` is a container image. That image is automatically loaded to your local image store, where you can run a container from that image, or push it to a registry. Under the hood, this uses the default exporter, called the `docker` exporter.
的 `docker build` 默认输出格式是容器图像。该映像会自动加载到本地映像存储中，您可以在其中从该映像运行容器，或将其推送到注册表。在后台，它使用默认导出器，称为 `docker` 导出器。

To export your build results as files instead, you can use the `local` exporter. The `local` exporter saves the filesystem of the build container to the specified directory on the host machine.
要将生成结果导出为文件，可以使用 `local` 导出器。 `local` 导出器将构建容器的文件系统保存到主机上的指定目录中。

## [Export binaries 导出二进制文件](https://docs.docker.com/build/guide/export/#export-binaries)

To use the `local` exporter, pass the `--output` option to the `docker build` command. The `--output` flag takes one argument: the destination on the host machine where you want to save the files.
要使用导出器， `local` 请将选项 `--output` 传递给 `docker build` 命令。该 `--output` 标志接受一个参数：主机上要保存文件的目标。

The following commands exports the files from of the `server` target to the current working directory on the host filesystem:
以下命令将 `server` 目标中的文件导出到主机文件系统上的当前工作目录：

```console
 docker build --output=. --target=server .
```

Running this command creates a binary at `./bin/server`. It’s created under the `bin/` directory because that’s where the file was located inside the build container.
运行此命令会在 处 `./bin/server` 创建一个二进制文件。它是在目录 `bin/` 下创建的，因为这是文件位于构建容器内的位置。

```console
 ls -l ./bin
total 14576
-rwxr-xr-x  1 user  user  7459368 Apr  6 09:27 server
```

If you want to create a build that exports both binaries, you can create another build stage in the Dockerfile that copies both of the binaries from each build stage:
如果要创建导出两个二进制文件的生成，可以在 Dockerfile 中创建另一个生成阶段，从每个生成阶段复制两个二进制文件：

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
  FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base as build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base as build-server
  ARG APP_VERSION="0.0.0+unknown"
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -ldflags "-X main.version=$APP_VERSION" -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]
+
+ FROM scratch AS binaries
+ COPY --from=build-client /bin/client /
+ COPY --from=build-server /bin/server /
```

Now you can build the `binaries` target using the `--output` option to export both the client and server binaries.
现在，您可以使用导出客户端和服务器二进制文件的 `--output` 选项来构建 `binaries` 目标。

```console
 docker build --output=bin --target=binaries .
 ls -l ./bin
total 29392
-rwxr-xr-x  1 user  user  7581933 Apr  6 09:33 client
-rwxr-xr-x  1 user  user  7459368 Apr  6 09:33 server
```

## [Summary 总结](https://docs.docker.com/build/guide/export/#summary)

This section has demonstrated how you can use Docker to build and export standalone binaries. These binaries can be distributed freely, and don’t require a container runtime like the Docker daemon.
本部分演示了如何使用 Docker 来构建和导出独立二进制文件。这些二进制文件可以自由分发，并且不需要像 Docker 守护程序那样的容器运行时。

The binaries you've generated so far are Linux binaries. That's because the build environment is Linux. If your host OS is Linux, you can run these files. Building binaries that work on Mac or Windows machines requires cross-compilation. This is explored later on in this guide.
到目前为止，您生成的二进制文件是 Linux 二进制文件。那是因为构建环境是 Linux。如果您的主机操作系统是 Linux，则可以运行这些文件。构建在 Mac 或 Windows 计算机上运行的二进制文件需要交叉编译。本指南稍后将对此进行探讨。

Related information: 相关信息：

- [`docker build --output` CLI reference `docker build --output` CLI 参考](https://docs.docker.com/reference/cli/docker/buildx/build/#output)
- [Build exporters 建立导出器](https://docs.docker.com/build/exporters/)

## [Next steps 后续步骤](https://docs.docker.com/build/guide/export/#next-steps)

The next topic of this guide is testing: how you can use Docker to run application tests.
本指南的下一个主题是测试：如何使用 Docker 运行应用程序测试。

# Test 测试

This section focuses on testing. The example in this section focuses on linting, but the same principles apply for other kinds of tests as well, such as unit tests. Code linting is a static analysis of code that helps you detect errors, style violations, and anti-patterns.
本部分重点介绍测试。本节中的示例重点介绍 linting，但相同的原则也适用于其他类型的测试，例如单元测试。代码 linting 是对代码的静态分析，可帮助您检测错误、样式冲突和反模式。

The exact steps for how to test your code can vary a lot depending on the programming language or framework that you use. The example application used in this guide is written in Go. You will add a build step that uses `golangci-lint`, a popular linters runner for Go.
如何测试代码的确切步骤可能会有很大差异，具体取决于您使用的编程语言或框架。本指南中使用的示例应用程序是用 Go 编写的。您将添加一个使用 `golangci-lint` 的构建步骤，这是一个流行的 Go linters 运行器。

## [Run tests 运行测试](https://docs.docker.com/build/guide/test/#run-tests)

The `golangci-lint` tool is available as an image on Docker Hub. Before you add the lint step to the Dockerfile, you can try it out using a `docker run` command.
该 `golangci-lint` 工具在 Docker Hub 上以图像的形式提供。在将 lint 步骤添加到 Dockerfile 之前，可以使用 `docker run` 命令进行尝试。

```console
 docker run -v $PWD:/test -w /test \
  golangci/golangci-lint golangci-lint run
```

You will notice that `golangci-lint` works: it finds an issue in the code where there's a missing error check.
您会注意到它 `golangci-lint` 有效：它在代码中发现了一个问题，其中缺少错误检查。

```text
cmd/server/main.go:23:10: Error return value of `w.Write` is not checked (errcheck)
		w.Write([]byte(translated))
		      ^
```

Now you can add this as a step to the Dockerfile.
现在，您可以将此步骤作为一个步骤添加到 Dockerfile。

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
+ ARG GOLANGCI_LINT_VERSION=v1.59
  FROM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,source=go.sum,target=go.sum \
      --mount=type=bind,source=go.mod,target=go.mod \
      go mod download -x

  FROM base AS build-client
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -o /bin/client ./cmd/client

  FROM base AS build-server
  ARG APP_VERSION="0.0.0+unknown"
  RUN --mount=type=cache,target=/go/pkg/mod/ \
      --mount=type=bind,target=. \
      go build -ldflags "-X main.version=$APP_VERSION" -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]

  FROM scratch AS binaries
  COPY --from=build-client /bin/client /
  COPY --from=build-server /bin/server /
+
+ FROM golangci/golangci-lint:${GOLANGCI_LINT_VERSION} as lint
+ WORKDIR /test
+ RUN --mount=type=bind,target=. \
+     golangci-lint run
```

The added `lint` stage uses the `golangci/golangci-lint` image from Docker Hub to invoke the `golangci-lint run` command with a bind-mount for the build context.
添加 `lint` 的阶段使用 Docker Hub 中的 `golangci/golangci-lint` 映像通过 bind-mount 调用 `golangci-lint run` 构建上下文的命令。

The lint stage is independent of any of the other stages in the Dockerfile. Therefore, running a regular build won’t cause the lint step to run. To lint the code, you must specify the `lint` stage:
lint 阶段独立于 Dockerfile 中的任何其他阶段。因此，运行常规构建不会导致 lint 步骤运行。要对代码进行 lint 处理，必须指定 `lint` 阶段：



```console
 docker build --target=lint .
```

## [Export test results 导出测试结果](https://docs.docker.com/build/guide/test/#export-test-results)

In addition to running tests, it's sometimes useful to be able to export the results of a test to a test report.
除了运行测试之外，有时能够将测试结果导出到测试报告也很有用。

Exporting test results is no different to exporting binaries, as shown in the previous section of this guide:
导出测试结果与导出二进制文件没有什么不同，如本指南的上一部分所示：

1. Save the test results to a file.
   将测试结果保存到文件中。
2. Create a new stage in your Dockerfile using the `scratch` base image.
   使用 `scratch` 基础映像在 Dockerfile 中创建一个新阶段。
3. Export that stage using the `local` exporter.
   使用 `local` 导出器导出该阶段。

The exact steps on how to do this is left as a reader's exercise :-)
有关如何执行此操作的确切步骤留为读者的练习：-）

## [Summary 总结](https://docs.docker.com/build/guide/test/#summary)

This section has shown an example on how you can use Docker builds to run tests (or as shown in this section, linters).
本部分展示了一个示例，说明如何使用 Docker 构建来运行测试（或如本节中所示的 linters）。

## [Next steps 后续步骤](https://docs.docker.com/build/guide/test/#next-steps)

The next topic in this guide is multi-platform builds, using emulation and cross-compilation.
本指南的下一个主题是使用仿真和交叉编译的多平台构建。

[Multi-platform 多平台](https://docs.docker.com/build/guide/multi-platform/)

# Multi-platform 多平台

Up until this point in the guide, you've built Linux binaries. This section describes how you can support other operating systems, and architectures, using multi-platform builds via emulation and cross-compilation.
到本指南的这一点为止，您已经构建了 Linux 二进制文件。本部分介绍如何通过仿真和交叉编译使用多平台构建来支持其他操作系统和体系结构。

The easiest way to get started with building for multiple platforms is using emulation. With emulation, you can build your app to multiple architectures without having to make any changes to your Dockerfile. All you need to do is to pass the `--platform` flag to the build command, specifying the OS and architecture you want to build for.
开始为多个平台构建的最简单方法是使用仿真。通过仿真，您可以根据多种架构构建应用程序，而无需对 Dockerfile 进行任何更改。您需要做的就是将 `--platform` 标志传递给构建命令，并指定要构建的操作系统和体系结构。

The following command builds the server image for the `linux/arm/v7` platform:
以下命令为 `linux/arm/v7` 平台构建服务器映像：

```console
 docker build --target=server --platform=linux/arm/v7 .
```

You can also use emulation to produce outputs for multiple platforms at once. However, the default image store in Docker Engine doesn't support building and loading multi-platform images. You need to enable the containerd image store which supports concurrent multi-platform builds.
您还可以使用仿真一次为多个平台生成输出。但是，Docker Engine 中的默认镜像存储不支持构建和加载多平台镜像。您需要启用支持并发多平台构建的 containerd 镜像存储。

## [Enable the containerd image store 启用 containerd 镜像存储](https://docs.docker.com/build/guide/multi-platform/#enable-the-containerd-image-store)

------

To enable the containerd image store in Docker Desktop, go to **Settings** and select **Use containerd for pulling and storing images** in the **General** tab.
要在 Docker Desktop 中启用 containerd 镜像存储，请转到“设置”，然后在“常规”选项卡中选择“使用 containerd 拉取和存储镜像”。

Note that changing the image store means you'll temporarily lose access to images and containers in the classic image store. Those resources still exist, but to view them, you'll need to disable the containerd image store.
请注意，更改映像存储意味着您将暂时失去对经典映像存储中映像和容器的访问权限。这些资源仍然存在，但要查看它们，您需要禁用 containerd 映像存储。

------

If you're not using Docker Desktop, enable the containerd image store by adding the following feature configuration to your `/etc/docker/daemon.json` configuration file.
如果不使用 Docker Desktop，请通过将以下功能配置添加到 `/etc/docker/daemon.json` 配置文件来启用 containerd 映像存储。

```json
{
  "features": {
    "containerd-snapshotter": true
  }
}
```

Restart the daemon after updating the configuration file.
更新配置文件后重新启动守护程序。

```console
 systemctl restart docker
```

## [Build using emulation 使用仿真进行构建](https://docs.docker.com/build/guide/multi-platform/#build-using-emulation)

To run multi-platform builds, invoke the `docker build` command, and pass it the same arguments as you did before. Only this time, also add a `--platform` flag specifying multiple architectures.
要运行多平台构建，请调用该 `docker build` 命令，并像以前一样向其传递相同的参数。只是这一次，还添加了一个 `--platform` 指定多个架构的标志。

```console
 docker build \
    --target=binaries \
    --output=bin \
    --platform=linux/amd64,linux/arm64,linux/arm/v7 .
```

This command uses emulation to run the same build three times, once for each platform. The build results are exported to a `bin` directory.
此命令使用仿真运行同一生成三次，每个平台一次。生成结果将导出到目录中 `bin` 。



```text
bin
├── linux_amd64
│   ├── client
│   └── server
├── linux_arm64
│   ├── client
│   └── server
└── linux_arm_v7
    ├── client
    └── server
```

When you build for multiple platforms concurrently, BuildKit runs all of the build steps under emulation for each platform that you specify. Effectively forking the build into multiple concurrent processes.
当您同时为多个平台构建时，BuildKit 会在仿真下为您指定的每个平台运行所有构建步骤。有效地将构建分叉为多个并发进程。

![Build pipelines using emulation](https://docs.docker.com/build/guide/images/emulation.png)

There are, however, a few downsides to running multi-platform builds using emulation:
但是，使用仿真运行多平台构建有一些缺点：

- If you tried running the command above, you may have noticed that it took a long time to finish. Emulation can be much slower than native execution for CPU-intensive tasks.
  如果您尝试运行上述命令，您可能已经注意到它花了很长时间才完成。对于 CPU 密集型任务，仿真可能比本机执行慢得多。
- Emulation only works when the architecture is supported by the base image you’re using. The example in this guide uses the Alpine Linux version of the `golang` image, which means you can only build Linux images this way, for a limited set of CPU architectures, without having to change the base image.
  仅当所使用的基础映像支持体系结构时，仿真才起作用。本指南中的示例使用 `golang` 镜像的 Alpine Linux 版本，这意味着您只能以这种方式为一组有限的 CPU 架构构建 Linux 镜像，而无需更改基础镜像。

As an alternative to emulation, the next step explores cross-compilation. Cross-compiling makes multi-platform builds much faster and versatile.
作为仿真的替代方法，下一步将探索交叉编译。交叉编译使多平台构建更快、更通用。

## [Build using cross-compilation 使用交叉编译进行构建](https://docs.docker.com/build/guide/multi-platform/#build-using-cross-compilation)

Using cross-compilation means leveraging the capabilities of a compiler to build for multiple platforms, without the need for emulation.
使用交叉编译意味着利用编译器的功能为多个平台构建，而无需仿真。

The first thing you'll need to do is pinning the builder to use the node’s native architecture as the build platform. This is to prevent emulation. Then, from the node's native architecture, the builder cross-compiles the application to a number of other target platforms.
您需要做的第一件事是固定构建器，以使用节点的原生架构作为构建平台。这是为了防止仿真。然后，从节点的本机架构中，构建器将应用程序交叉编译到许多其他目标平台。

### [Platform build arguments 平台构建参数](https://docs.docker.com/build/guide/multi-platform/#platform-build-arguments)

This approach involves using a few pre-defined build arguments that you have access to in your Docker builds: `BUILDPLATFORM` and `TARGETPLATFORM` (and derivatives, like `TARGETOS`). These build arguments reflect the values you pass to the `--platform` flag.
此方法涉及使用一些预定义的构建参数，您可以在 Docker 构建中访问这些参数： `BUILDPLATFORM` 和 `TARGETPLATFORM` （以及衍生物，如 `TARGETOS` ）。这些生成参数反映了传递给标志的值 `--platform` 。

For example, if you invoke a build with `--platform=linux/amd64`, then the build arguments resolve to:
例如，如果使用 `--platform=linux/amd64` 调用生成，则生成参数解析为：

- `TARGETPLATFORM=linux/amd64`
- `TARGETOS=linux`
- `TARGETARCH=amd64`

When you pass more than one value to the platform flag, build stages that use the pre-defined platform arguments are forked automatically for each platform. This is in contrast to builds running under emulation, where the entire build pipeline runs per platform.
当您将多个值传递给平台标志时，使用预定义平台参数的构建阶段将自动为每个平台分叉。这与在仿真下运行的生成形成鲜明对比，在仿真下，整个生成管道按平台运行。

![Build pipelines using cross-compilation](https://docs.docker.com/build/guide/images/cross-compilation.png)

### [Update the Dockerfile 更新 Dockerfile](https://docs.docker.com/build/guide/multi-platform/#update-the-dockerfile)

To build the app using the cross-compilation technique, update the Dockerfile as follows:
若要使用交叉编译技术生成应用，请按如下方式更新 Dockerfile：

- Add `--platform=$BUILDPLATFORM` to the `FROM` instruction for the initial `base` stage, pinning the platform of the `golang` image to match the architecture of the host machine.
  添加到 `--platform=$BUILDPLATFORM` 初始阶段的 `FROM` 指令中，固定 `golang` 映像的平台以匹配 `base` 主机的体系结构。
- Add `ARG` instructions for the Go compilation stages, making the `TARGETOS` and `TARGETARCH` build arguments available to the commands in this stage.
  添加 `ARG` Go 编译阶段的指令，使 `TARGETOS` and `TARGETARCH` build 参数可用于此阶段的命令。
- Set the `GOOS` and `GOARCH` environment variables to the values of `TARGETOS` and `TARGETARCH`. The Go compiler uses these variables to do cross-compilation.
  将 `GOOS` and `GOARCH` 环境变量设置为 `TARGETOS` 和 `TARGETARCH` 的值。Go 编译器使用这些变量进行交叉编译。

```diff
  # syntax=docker/dockerfile:1
  ARG GO_VERSION=1.21
  ARG GOLANGCI_LINT_VERSION=v1.59
- FROM golang:${GO_VERSION}-alpine AS base
+ FROM --platform=$BUILDPLATFORM golang:${GO_VERSION}-alpine AS base
  WORKDIR /src
  RUN --mount=type=cache,target=/go/pkg/mod \
      --mount=type=bind,source=go.mod,target=go.mod \
      --mount=type=bind,source=go.sum,target=go.sum \
      go mod download -x

  FROM base AS build-client
+ ARG TARGETOS
+ ARG TARGETARCH
  RUN --mount=type=cache,target=/go/pkg/mod \
      --mount=type=bind,target=. \
-     go build -o /bin/client ./cmd/client
+     GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o /bin/client ./cmd/client

  FROM base AS build-server
+ ARG TARGETOS
+ ARG TARGETARCH
  RUN --mount=type=cache,target=/go/pkg/mod \
      --mount=type=bind,target=. \
-     go build -o /bin/server ./cmd/server
+     GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o /bin/server ./cmd/server

  FROM scratch AS client
  COPY --from=build-client /bin/client /bin/
  ENTRYPOINT [ "/bin/client" ]

  FROM scratch AS server
  COPY --from=build-server /bin/server /bin/
  ENTRYPOINT [ "/bin/server" ]

  FROM scratch AS binaries
  COPY --from=build-client /bin/client /
  COPY --from=build-server /bin/server /

  FROM golangci/golangci-lint:${GOLANGCI_LINT_VERSION} as lint
  WORKDIR /test
  RUN --mount=type=bind,target=. \
      golangci-lint run
```

The only thing left to do now is to run the actual build. To run a multi-platform build, set the `--platform` option, and specify a CSV string of the OS and architectures that you want to build for. The following command illustrates how to build, and export, binaries for Mac (ARM64), Windows, and Linux:
现在唯一要做的就是运行实际的构建。要运行多平台构建，请设置选项 `--platform` ，并指定要为其构建的操作系统和体系结构的 CSV 字符串。以下命令演示如何生成和导出适用于 Mac （ARM64）、Windows 和 Linux 的二进制文件：

```console
 docker build \
  --target=binaries \
  --output=bin \
  --platform=darwin/arm64,windows/amd64,linux/amd64 .
```

When the build finishes, you’ll find client and server binaries for all of the selected platforms in the `bin` directory:
构建完成后，您将在 `bin` 目录中找到所有选定平台的客户端和服务器二进制文件：

```diff
bin
├── darwin_arm64
│   ├── client
│   └── server
├── linux_amd64
│   ├── client
│   └── server
└── windows_amd64
    ├── client
    └── server
```

## [Summary 总结](https://docs.docker.com/build/guide/multi-platform/#summary)

This section has demonstrated how you can get started with multi-platform builds using emulation and cross-compilation.
本部分演示了如何使用仿真和交叉编译开始进行多平台构建。

Related information: 相关信息：

- [Multi-platfom images 多平台图像](https://docs.docker.com/build/building/multi-platform/)
- [containerd image store (Docker Desktop)
  containerd 镜像存储（Docker Desktop）](https://docs.docker.com/desktop/containerd/)
- [containerd image store (Docker Engine)
  containerd 镜像存储（Docker Engine）](https://docs.docker.com/storage/containerd/)

You may also want to consider checking out [xx - Dockerfile cross-compilation helpers](https://github.com/tonistiigi/xx)

. `xx` is a Docker image containing utility scripts that make cross-compiling with Docker builds easier.
您可能还需要考虑查看 xx - Dockerfile 交叉编译助手。 `xx` 是一个 Docker 镜像，其中包含实用程序脚本，使与 Docker 构建的交叉编译变得更加容易。

## [Next steps 后续步骤](https://docs.docker.com/build/guide/multi-platform/#next-steps)

This section is the final part of the Build with Docker guide. The following page contains some pointers for where to go next.
本部分是“使用 Docker 构建”指南的最后一部分。以下页面包含一些指向下一步操作的指示。

# Next steps 后续步骤

This guide has demonstrated some of the build features and capabilities that Docker provides.
本指南演示了 Docker 提供的一些构建特性和功能。

If you would like to continue learning about Docker build, consider exploring the following resources:
如果您想继续学习有关 Docker 构建的信息，请考虑浏览以下资源：

- [BuildKit](https://docs.docker.com/build/buildkit/): deep-dive into the open source build engine that powers your Docker builds
  BuildKit：深入了解为 Docker 构建提供支持的开源构建引擎
- [Drivers](https://docs.docker.com/build/drivers/): configure for how and where your Docker builds run
  驱动程序：配置 Docker 构建的运行方式和位置
- [Exporters](https://docs.docker.com/build/exporters/): save your build results to different output formats
  导出器：将构建结果保存为不同的输出格式
- [Bake](https://docs.docker.com/build/bake/): orchestrate your build workflows
  烘焙：编排生成工作流
- [Attestations](https://docs.docker.com/build/attestations/): annotate your build artifacts with metadata
  证明：使用元数据注释您的构建工件
- [Continuous integration](https://docs.docker.com/build/ci/): run Docker builds in CI
  持续集成：在 CI 中运行 Docker 构建