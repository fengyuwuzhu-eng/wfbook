# 数据类型

[TOC]

## 概述

数据类型用于声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。

按类别有以下几种数据类型：

| 序号 | 类型              | 描述                                                         |
| ---- | ----------------- | ------------------------------------------------------------ |
| 1    | 布尔型 bool       | 值只可以是常量 true 或者 false                               |
| 2    | 数字类型          | 整型 int 和浮点型 float32、float64。<br>Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 |
| 3    | 字符串类型 string | 一串固定长度的字符连接起来的字符序列。<br>Go 的字符串是由单个字节连接起来的。<br>Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 |
| 4    | 派生类型          | 指针类型（Pointer）<br/>数组类型 <br/>结构化类型(struct)<br/>Channel 类型 <br/>函数类型 <br/>切片类型<br/>接口类型（interface） <br/>Map 类型 <br/>字典类型 |

在 Printf 方法中，使用 **%T** 格式说明符（Format Specifier），可以打印出变量的类型。Go 的 [unsafe](https://golang.org/pkg/unsafe/) 包提供了一个 [Sizeof](https://golang.org/pkg/unsafe/#Sizeof) 函数，该函数接收变量并返回它的字节大小。*unsafe* 包应该小心使用，因为使用 unsafe 包可能会带来可移植性问题。

下面程序会输出变量 a 和 b 的类型和大小。格式说明符 `%T` 用于打印类型，而 `%d` 用于打印字节大小。

```go
package main

import (  
    "fmt"
    "unsafe"
)

func main() {  
    var a int = 89
    b := 95
    fmt.Println("value of a is", a, "and b is", b)
    fmt.Printf("type of a is %T, size of a is %d", a, unsafe.Sizeof(a)) // a 的类型和大小
    fmt.Printf("\ntype of b is %T, size of b is %d", b, unsafe.Sizeof(b)) // b 的类型和大小
}
```

以上程序会输出：

```go
value of a is 89 and b is 95
type of a is int, size of a is 4
type of b is int, size of b is 4
```

## 数字类型

### 整型

| 序号 | 类型   | 符号 | 类型宽度(bit) | 类型宽度(byte) | 描述                                      |
| ---- | ------ | ---- | ------------- | -------------- | ----------------------------------------- |
| 1    | uint   | 无   | 32 或 64      | 4 或 8         | 与计算机系统的位数有关                    |
| 2    | uint8  | 无   | 8             | 1              | 0～255                                    |
| 3    | uint16 | 无   | 16            | 2              | 0～65535                                  |
| 4    | uint32 | 无   | 32            | 4              | 0～4294967295                             |
| 5    | uint64 | 无   | 64            | 8              | 0～18446744073709551615                   |
| 6    | int    | 有   | 32 或 64      | 4 或 8         | 与计算机系统的位数有关                    |
| 7    | int8   | 有   | 8             | 1              | -128～127                                 |
| 8    | int16  | 有   | 16            | 2              | -32768～32767                             |
| 9    | int32  | 有   | 32            | 4              | -2147483648～2147483647                   |
| 10   | int64  | 有   | 64            | 8              | -9223372036854775808～9223372036854775807 |

#### 解释

以 `int8` 和 `uint8` 举例，8 代表 8个bit，能表示的数值个数有 2^8 = 256。

uint8 是无符号，能表示的都是正数，0-255，刚好256个数。

int8 是有符号，既可以正数，也可以负数，-128-127，也刚好 256个数。

int8 int16 int32 int64 这几个类型的最后都有一个数值，这表明了它们能表示的数值个数是固定的。

而 int 并没有指定它的位数，说明它的大小，是可以变化的。

- 当你在32位的系统下，int 和 uint 都占用 4个字节，也就是32位。
- 若你在64位的系统下，int 和 uint 都占用 8个字节，也就是64位。

出于这个原因，在某些场景下，应当避免使用 int 和 uint ，而使用更加精确的 int32 和 int64，比如在二进制传输、读写文件的结构描述（为了保持文件的结构不会受到不同编译目标平台字节长度的影响）。

#### 不同进制的表示方法

2进制：以`0b`或`0B`为前缀

8进制：以`0o`或者 `0O`为前缀

16进制：以`0x` 为前缀

### 浮点型

| 序号 | 类型       | 描述                  |
| ---- | ---------- | --------------------- |
| 1    | float32    | IEEE-754 32位浮点型数 |
| 2    | float64    | IEEE-754 64位浮点型数 |
| 3    | complex64  | 32 位实数和虚数       |
| 4    | complex128 | 64 位实数和虚数       |

整数部分和小数部分均由 10 进制表示法表示。还有另一种表示方法，在其中加入指数部分。指数部分由 “E” 或 “e” 以及一个带正负号的 10 进制数组成。

有时，浮点数类型值的表示可被简化。如，`30.0` 简化为 `30` 。`0.037` 简化为 `.037` 。

在 Go 语言里，浮点数的相关部分只能由 10 进制表示法表示，而不能由 8 进制表示法或 16 进制表示法表示。

#### float32 和 float64

**float32**，也即常说的单精度，存储占用 4个 字节，也即 4 * 8 = 32 位，其中 1 位用来符号，8 位用来指数，剩下的 23 位表示尾数。

 ![](../../Image/f/float32.jpg)

**float64**，也即我们熟悉的双精度，存储占用 8 个字节，也即 8 * 8 = 64 位，其中 1 位用来符号，11 位用来指数，剩下的 52 位表示尾数。

 ![](../../Image/f/float64.jpg)

**精度和有效位**

精度主要取决于尾数部分的位数。

对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2^-23，约等于1.19 * 10^-7，所以 float 小数部分只能精确到后面 6 位，加上小数点前的一位，即有效数字为 7 位。

同理 float64（单精度）的尾数部分为 52 位，最小为 2^-52，约为 2.22*10^-16，所以精确到小数点后 15 位，加上小数点前的一位，有效位数为 16 位。

- float32的精度只能提供大约 6 个十进制数（表示后科学计数法后，小数点后 6 位）的精度。
- float64的精度能提供大约 15 个十进制数（表示后科学计数法后，小数点后 15 位）的精度。

下面一个简单程序演示了整型和浮点型的运用。

```go
package main

import (  
    "fmt"
)

func main() {  
    a, b := 5.67, 8.97
    fmt.Printf("type of a %T b %T\n", a, b)
    sum := a + b
    diff := a - b
    fmt.Println("sum", sum, "diff", diff)

    no1, no2 := 56, 89
    fmt.Println("sum", no1+no2, "diff", no1-no2)
}
```

a 和 b 的类型根据赋值推断得出。在这里，a 和 b 的类型为 float64（float64 是浮点数的默认类型）。把 a 和 b 的和赋值给变量 sum，把 b 和 a 的差赋值给 diff，接下来打印 sum 和 diff。no1 和 no2  也进行了相同的计算。上述程序将会输出：

```go
type of a float64 b float64  
sum 14.64 diff -3.3000000000000007  
sum 145 diff -33
```

### 复数类型

* complex64

  实部和虚部都是 float32 类型的的复数。

* complex128

  实部和虚部都是 float64 类型的的复数。

内建函数 complex 用于创建一个包含实部和虚部的复数。complex 函数的定义如下：

```go
func complex(r, i FloatType) ComplexType
```

该函数的参数分别是实部和虚部，并返回一个复数类型。实部和虚部应该是相同类型，也就是 float32 或  float64。如果实部和虚部都是 float32 类型，则函数会返回一个 complex64 类型的复数。如果实部和虚部都是 float64  类型，则函数会返回一个 complex128 类型的复数。

还可以使用简短语法来创建复数：

```go
c := 6 + 7i
```

示例：

```go
package main

import (  
    "fmt"
)

func main() {  
    c1 := complex(5, 7)
    c2 := 8 + 27i
    cadd := c1 + c2
    fmt.Println("sum:", cadd)
    cmul := c1 * c2
    fmt.Println("product:", cmul)
}
```

在上面的程序里，c1 和 c2 是两个复数。c1 的实部为 5，虚部为 7。c2 的实部为 8，虚部为 27。c1 和 c2 的和赋值给 `cadd` ，而 c1 和 c2 的乘积赋值给 `cmul`。该程序将输出：

```go
sum: (13+34i)  
product: (-149+191i)
```

### 其他数字类型

以下列出了其他更多的数字类型：

| 序号 | 类型    | 描述                         |
| ---- | ------- | ---------------------------- |
| 1    | byte    | 类似 uint8                   |
| 2    | rune    | 类似 int32                   |
| 3    | uint    | 32 或 64 位                  |
| 4    | int     | 与 uint 一样大小             |
| 5    | uintptr | 无符号整型，用于存放一个指针 |

### byte 与 rune

都是字符类型。

* byte

  占用 1 个节字，就 8 个比特位（2^8 = 256，因此 byte 的表示范围 0 -> 255），所以它和 `uint8` 类型本质上没有区别，它表示的是 ACSII 表中的一个字符。是 uint8 的别名。

* rune

  占用 4 个字节，共 32 位比特位，所以它和 `uint32` 本质上也没有区别。它表示的是一个 Unicode字符（Unicode 是一个可以表示世界范围内的绝大部分字符的编码规范）。

在定义字符时，不管是 byte 还是 rune ，都是使用单引号，而没使用双引号。

在 Go 中单引号与 双引号并不是等价的。

单引号用来表示字符，使用双引号，定义一个字符串。

>  byte 和 uint8 没有区别，rune 和 uint32 没有区别，那为什么还要多出一个 byte 和 rune 类型呢？
>
> 理由很简单，因为uint8 和 uint32 ，直观上让人以为这是一个数值，但是实际上，它也可以表示一个字符，所以为了消除这种直观错觉，就诞生了 byte 和 rune 这两个别名类型。

## 字符串

字符串是字节的集合。

```go
package main

import (  
    "fmt"
)

func main() {  
    first := "Naveen"
    last := "Ramanathan"
    name := first +" "+ last
    fmt.Println("My name is",name)
}
```

上面程序中，first 赋值为字符串 "Naveen"，last 赋值为字符串 "Ramanathan"。+ 操作符可以用于拼接字符串。我们拼接了 first、空格和 last，并将其赋值给 name。上述程序将打印输出 `My name is Naveen Ramanathan`。

比如 `hello` ，对照 ascii 编码表，每个字母对应的编号是：104,101,108,108,111

```go
import (
    "fmt"
)

func main() {
    var mystr01 string = "hello"
    var mystr02 [5]byte = [5]byte{104, 101, 108, 108, 111}
    fmt.Printf("mystr01: %s\n", mystr01)
    fmt.Printf("mystr02: %s", mystr02)
}
```

输出如下，mystr01 和 mystr02 输出一样，说明了 string 的本质，其实是一个 byte数组。

```go
mystr01: hello
mystr02: hello
```

除了双引号之外 ，还可以使用反引号。大多情况下，二者并没有区别，但如果字符串中有转义字符 `\` ，这里就要注意了，它们是有区别的。使用反引号包裹的字符串，相当于 Python 中的 raw 字符串，会忽略里面的转义。

比如我想表示 `\r\n` 这个 字符串，使用双引号是这样写的，这种叫解释型表示法。

```go
var mystr01 string = "\\r\\n"
```

而使用反引号，就方便多了，所见即所得，这种叫原生型表示法。

```go
var mystr02 string = `\r\n`
```

打印结果 都是一样的：

```go
import (
    "fmt"
)

func main() {
    var mystr01 string = "\\r\\n"
    var mystr02 string = `\r\n`
    fmt.Println(mystr01)
    fmt.Println(mystr02)
}

// output
\r\n
\r\n
```

如果仍然想使用解释型的字符串，但是各种转义实在太麻烦了。你可以使用 fmt 的 `%q` 来还原一下。

```go
import (
    "fmt"
)

func main() {
    var mystr01 string = `\r\n`
    fmt.Print(`\r\n`)
    fmt.Printf("的解释型字符串是： %q", mystr01)
}
```

输出如下

```go
\r\n的解释型字符串是： "\\r\\n"
```

同时反引号可以不写换行符（因为没法写）来表示一个多行的字符串。

```go
import (
    "fmt"
)

func main() {
    var mystr01 string = `你好呀!
我的公众号是: Go编程时光，欢迎大家关注`

    fmt.Println(mystr01)
}
```

## 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。

声明数组，并给该数组里的每个元素赋值（索引值的最小有效值和其他大多数语言一样是 0，不是1）

```
// [3] 里的3 表示该数组的元素个数及容量
var arr [3]int
arr[0] = 1
arr[1] = 2
arr[2] = 3
```

声明并直接初始化数组

```
// 第一种方法
var arr [3]int = [3]int{1,2,3}

// 第二种方法
arr := [3]int{1,2,3}
```

上面的 3 表示数组的元素个数 ，万一你哪天想往该数组中增加元素，你得对应修改这个数字，为了避免这种硬编码，你可以这样写，使用 `...` 让Go语言自己根据实际情况来分配空间。

```
arr := [...]int{1,2,3}
```

`[3]int` 和 `[4]int` 虽然都是数组，但他们却是不同的类型，使用 fmt 的 `%T` 可以查得。

```
import (
    "fmt"
)

func main() {
    arr01 := [...]int{1, 2, 3}
    arr02 := [...]int{1, 2, 3, 4}
    fmt.Printf("%d 的类型是: %T\n", arr01, arr01)
    fmt.Printf("%d 的类型是: %T", arr02, arr02)
}
```

输出 如下

```
[1 2 3] 的类型是: [3]int
[1 2 3 4] 的类型是: [4]int
```

如果你觉得每次写 `[3]int` 有点麻烦，你可以为 `[3]int` 定义一个类型字面量，也就是别名类型。

使用 `type` 关键字可以定义一个类型字面量，后面只要你想定义一个容器大小为3，元素类型为int的数组 ，都可以使用这个别名类型。

```
import (
    "fmt"
)

func main() {
    type arr3 [3]int

    myarr := arr3{1,2,3}
    fmt.Printf("%d 的类型是: %T", myarr, myarr)
}
```

输出 如下

```
[1 2 3] 的类型是: main.arr3
```

其实定义数组还有一种偷懒的方法，比如下面这行代码

```
arr:=[4]int{2:3}
```

打印 arr，会是

```
[0 0 3 0]
```

可以看出`[4]int{2:3}`，4表示数组有4个元素，2 和 3 分别表示该数组索引为2（初始索引为0）的值为3，而其他没有指定值的，就是 int 类型的零值，即0。

## 切片

切片（Slice）与数组一样，也是可以容纳若干类型相同的元素的容器。与数组不同的是，无法通过切片类型来确定其值的长度。每个切片值都会将数组作为其底层数据结构。我们也把这样的数组称为切片的底层数组。

切片是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内（意思是这是个左闭右开的区间）

```
import (
    "fmt"
)

func main() {
    myarr := [...]int{1, 2, 3}
    fmt.Printf("%d 的类型是: %T", myarr[0:2], myarr[0:2])
}
```

输出 如下

```
[1 2] 的类型是: []int
```

切片的构造，有四种方式

1. 对数组进行片段截取，主要有如下两种写法

   ```
   // 定义一个数组
   myarr := [5]int{1,2,3,4,5}
   
   // 【第一种】
   // 1 表示从索引1开始，直到到索引为 2 (3-1)的元素
   mysli1 := myarr[1:3]
   
   // 【第二种】
   // 1 表示从索引1开始，直到到索引为 2 (3-1)的元素
   mysli2 := myarr[1:3:4]
   ```

   如果你把上面的 `mysli1` 和 `mysli2` 打印出来，会发现他们居然是一样的。那第二种的 `myarr[1:3:4]` 的 4有什么用呢？

   在切片时，若不指定第三个数，那么切片终止索引会一直到原数组的最后一个数。而如果指定了第三个数，那么切片终止索引只会到原数组的该索引值。

   用下面这段代码来验证一下

   ```
   package main
   
   import "fmt"
   
   func main(){
       myarr := [5]int{1,2,3,4,5}
       fmt.Printf("myarr 的长度为：%d，容量为：%d\n", len(myarr), cap(myarr))
   
       mysli1 := myarr[1:3]
       fmt.Printf("mysli1 的长度为：%d，容量为：%d\n", len(mysli1), cap(mysli1))
       fmt.Println(mysli1)
   
       mysli2 := myarr[1:3:4]
       fmt.Printf("mysli2 的长度为：%d，容量为：%d\n", len(mysli2), cap(mysli2))
       fmt.Println(mysli2)
   }
   ```

   输出如下，说明切片的第三个数，影响的只是切片的容量，而不会影响长度

   ```
   myarr 的长度为：5，容量为：5
   mysli1 的长度为：2，容量为：4
   [2 3]
   mysli2 的长度为：2，容量为：3
   [2 3]
   ```

2. 从头声明赋值（例子如下）

   ```
   // 声明字符串切片
   var strList []string
   
   // 声明整型切片
   var numList []int
   
   // 声明一个空切片
   var numListEmpty = []int{}
   ```

3. 使用 make 函数构造，make 函数的格式：`make( []Type, size, cap )`

   这个函数刚好指出了，一个切片具备的三个要素：类型（Type），长度（size），容量（cap）

   ```
   import (
    "fmt"
   )
   
   func main() {
    a := make([]int, 2)
    b := make([]int, 2, 10)
    fmt.Println(a, b)
    fmt.Println(len(a), len(b))
    fmt.Println(cap(a), cap(b))
   }
   ```

   输出 如下

   ```
   [0 0] [0 0]
   2 2
   2 10
   ```

4. 使用和数组一样，偷懒的方法

   ```
   import (
    "fmt"
   )
   
   func main() {
       a := []int{4:2}
       fmt.Println(a)
       fmt.Println(len(a), cap(a))
   }
   ```

   输出如下

   ```
   [0 0 0 0 2]
   5 5
   ```

关于 len 和 cap 的概念，可能不好理解 ，这里举个例子：

- 公司名，相当于字面量，也就是变量名。
- 公司里的所有工位，相当于已分配到的内存空间
- 公司里的员工，相当于元素。
- cap 代表你这个公司最多可以容纳多少员工
- len 代表你这个公司当前有多少个员工

由于 切片是引用类型，所以你不对它进行赋值的话，它的零值（默认值）是 nil

```
var myarr []int
fmt.Println(myarr == nil)
// true
```

数组 与 切片 有相同点，它们都是可以容纳若干类型相同的元素的容器

也有不同点，数组的容器大小固定，而切片本身是引用类型，它更像是 Python 中的 list ，我们可以对它 append 进行元素的添加。

```
import (
    "fmt"
)

func main() {
    myarr := []int{1}
    // 追加一个元素
    myarr = append(myarr, 2)
    // 追加多个元素
    myarr = append(myarr, 3, 4)
    // 追加一个切片, ... 表示解包，不能省略
    myarr = append(myarr, []int{7, 8}...)
    // 在第一个位置插入元素
    myarr = append([]int{0}, myarr...)
    // 在中间插入一个切片(两个元素)
    myarr = append(myarr[:5], append([]int{5,6}, myarr[5:]...)...)
    fmt.Println(myarr)
}
```

输出 如下

```
[0 1 2 3 4 5 6 7 8]
```

## 字典

字典（Map 类型），是由若干个 `key:value` 这样的键值对映射组合在一起的数据结构。

它是哈希表的一个实现，这就要求它的每个映射里的key，都是唯一的，可以使用 `==` 和 `!=` 来进行判等操作，换句话说就是key必须是可哈希的。

什么叫可哈希的？简单来说，一个不可变对象，都可以用一个哈希值来唯一表示，这样的不可变对象，比如字符串类型的对象（可以说除了切片、 字典，函数之外的其他内建类型都算）。

意思就是，你的 key 不能是切片，不能是字典，不能是函数。。

字典由key和value组成，它们各自有各自的类型。

在声明字典时，必须指定好你的key和value是什么类型的，然后使用 map 关键字来告诉Go这是一个字典。

```
map[KEY_TYPE]VALUE_TYPE
```

### 声明初始化字典

三种声明并初始化字典的方法

```
// 第一种方法
var scores map[string]int = map[string]int{"english": 80, "chinese": 85}

// 第二种方法
scores := map[string]int{"english": 80, "chinese": 85}

// 第三种方法
scores := make(map[string]int)
scores["english"] = 80
scores["chinese"] = 85
```

要注意的是，第一种方法如果拆分成多步（声明、初始化、再赋值），和其他两种有很大的不一样了，相对会比较麻烦。

```
import "fmt"

func main() {
    // 声明一个名为 score 的字典
    var scores map[string]int

    // 未初始化的 score 的零值为nil，无法直接进行赋值
    if scores == nil {
        // 需要使用 make 函数先对其初始化
        scores = make(map[string]int)
    }

    // 经过初始化后，就可以直接赋值
    scores["chinese"] = 90
    fmt.Println(scores)
}
```

### **字典的相关操作**

添加元素

```
scores["math"] = 95
```

更新元素，若key已存在，则直接更新value

```
scores["math"] = 100
```

读取元素，直接使用 `[key]` 即可 ，如果 key 不存在，也不报错，会返回其value-type 的零值。

```
fmt.Println(scores["math"])
```

删除元素，使用 delete 函数，如果 key 不存在，delete 函数会静默处理，不会报错。

```
delete(scores, "math")
```

当访问一个不存在的key时，并不会直接报错，而是会返回这个 value 的零值，如果 value的类型是int，就返回0。

```
package main

import "fmt"

func main() {
    scores := make(map[string]int)
    fmt.Println(scores["english"]) // 输出 0
}
```

### 判断 key 是否存在

当key不存在，会返回value-type的零值 ，所以你不能通过返回的结果是否是零值来判断对应的 key 是否存在，因为 key 对应的 value 值可能恰好就是零值。

其实字典的下标读取可以返回两个值，使用第二个返回值都表示对应的 key 是否存在，若存在ok为true，若不存在，则ok为false

```
import "fmt"

func main() {
    scores := map[string]int{"english": 80, "chinese": 85}
    math, ok := scores["math"]
    if ok {
        fmt.Printf("math 的值是: %d", math)
    } else {
        fmt.Println("math 不存在")
    }
}
```

我们将上面的代码再优化一下

```
import "fmt"

func main() {
    scores := map[string]int{"english": 80, "chinese": 85}
    if math, ok := scores["math"]; ok {
        fmt.Printf("math 的值是: %d", math)
    } else {
        fmt.Println("math 不存在")
    }
}
```

### **如何对字典进行循环**

Go 语言中没有提供类似 Python 的 keys() 和 values() 这样方便的函数，想要获取，你得自己循环。

循环还分三种

1. 获取 key 和 value

```
import "fmt"

func main() {
    scores := map[string]int{"english": 80, "chinese": 85}

    for subject, score := range scores {
        fmt.Printf("key: %s, value: %d\n", subject, score)
    }
}
```

1. 只获取key，这里注意不用占用符。

```
import "fmt"

func main() {
    scores := map[string]int{"english": 80, "chinese": 85}

    for subject := range scores {
        fmt.Printf("key: %s\n", subject)
    }
}
```

1. 只获取 value，用一个占位符替代。

```
import "fmt"

func main() {
    scores := map[string]int{"english": 80, "chinese": 85}

    for _, score := range scores {
        fmt.Printf("value: %d\n", score)
    }
}
```

## 布尔类型 bool

bool 类型表示一个布尔值，值为 true 或者 false。

与其他语言不同，在 Go 中，真值用 true 表示，不但不与 1 相等，并且更加严格，不同类型无法进行比较，而假值用 false 表示，同样与 0 无法比较。

```go
package main

import "fmt"

func main() {  
    a := true
    b := false
    fmt.Println("a:", a, "b:", b)
    c := a && b
    fmt.Println("c:", c)
    d := a || b
    fmt.Println("d:", d)
}
```

在上面的程序中，a 赋值为 true，b 赋值为 false。

c 赋值为 a && b。仅当 a 和 b 都为 true 时，操作符 && 才返回 true。因此，在这里 c 为 false。

当 a 或者 b 为 true 时，操作符 || 返回 true。在这里，由于 a 为 true，因此 d 也为 true。将得到程序的输出如下。

```go
a: true b: false  
c: false  
d: true
```

Go 中确实不如 Python 那样灵活，bool 与 int 不能直接转换，如果要转换，需要自己实现函数。

**bool 转 int**

```go
func bool2int(b bool) int {
    if b {
        return 1
    }
    return 0
}
```

**int 转 bool**

```go
func int2bool(i int) bool {
    return i != 0
}
```

在 Go 中使用 `!` 符号对逻辑值取反：

```go
import "fmt"

var male bool = true
func main()  {
    fmt.Println( !male == false)
    // 或者
    fmt.Println( male != false)
}

// output: true
```

在 Go 语言中，使用 `&&` 表示`且`，用 `||` 表示 `或`，并且有短路行为（即左边表达式已经可以确认整个表达式的值，那么右边将不会再被求值。

```go
import "fmt"

var age int = 15
var gender string = "male"
func main()  {
    //  && 两边的表达式都会执行
    fmt.Println( age > 18 && gender == "male")
    // gender == "male" 并不会执行
    fmt.Println( age < 18 || gender == "male")
}

// output: false
// output: true
```

## 指针

当我们定义一个变量 name

```
var name string = "Go编程时光"
```

此时，name 是变量名，它只是编程语言中方便程序员编写和理解代码的一个标签。

当我们访问这个标签时，机算机会返回给我们它指向的内存地址里存储的值：`Go编程时光`。

出于某些需要，我们会将这个内存地址赋值给另一个变量名，通常叫做 ptr（pointer的简写），而这个变量，我们称之为指针变量。

换句话说，指针变量（一个标签）的值是指针，也就是内存地址。

根据变量指向的值，是否是内存地址，我把变量分为两种：

- 普通变量：存数据值本身
- 指针变量：存值的内存地址

### 指针的创建

指针创建有三种方法

**第一种方法**

先定义对应的变量，再通过变量取得内存地址，创建指针

```
// 定义普通变量
aint := 1
// 定义指针变量
ptr := &aint
```

**第二种方法**

先创建指针，分配好内存后，再给指针指向的内存地址写入对应的值。

```
// 创建指针
astr := new(string)
// 给指针赋值
*astr = "Go编程时光"
```

**第三种方法**

先声明一个指针变量，再从其他变量取得内存地址赋值给它

```
aint := 1
var bint *int  // 声明一个指针
bint = &aint   // 初始化
```

上面的三段代码中，指针的操作都离不开这两个符号：

- `&` ：从一个普通变量中取得内存地址
- `*`：当`*`在赋值操作符（=）的右边，是从一个指针变量中取得变量值，当`*`在赋值操作符（=）的左边，是指该指针指向的变量

通过下面这段代码，你可以熟悉这两个符号的用法

```
package main

import "fmt"

func main() {
    aint := 1     // 定义普通变量
    ptr := &aint  // 定义指针变量
    fmt.Println("普通变量存储的是：", aint)
    fmt.Println("普通变量存储的是：", *ptr)
    fmt.Println("指针变量存储的是：", &aint)
    fmt.Println("指针变量存储的是：", ptr)
}
```

输出如下

```
普通变量存储的是： 1
普通变量存储的是： 1
指针变量存储的是： 0xc0000100a0
指针变量存储的是： 0xc0000100a0
```

要想打印指针指向的内存地址，方法有两种

```
// 第一种
fmt.Printf("%p", ptr)

// 第二种
fmt.Println(ptr)
```

### 指针的类型

我们知道字符串的类型是 string，整型是int，那么指针如何表示呢？

写段代码试验一下就知道了

```
package main

import "fmt"

func main() {
    astr := "hello"
    aint := 1
    abool := false
    arune := 'a'
    afloat := 1.2

    fmt.Printf("astr 指针类型是：%T\n", &astr)
    fmt.Printf("aint 指针类型是：%T\n", &aint)
    fmt.Printf("abool 指针类型是：%T\n", &abool)
    fmt.Printf("arune 指针类型是：%T\n", &arune)
    fmt.Printf("afloat 指针类型是：%T\n", &afloat)
}
```

输出如下，可以发现用 `*`+所指向变量值的数据类型，就是对应的指针类型。

```
astr 指针类型是：*string
aint 指针类型是：*int
abool 指针类型是：*bool
arune 指针类型是：*int32
afloat 指针类型是：*float64
```

所以若我们定义一个只接收指针类型的参数的函数，可以这么写

```
func mytest(ptr *int)  {
    fmt.Println(*ptr)
}
```

### 指针的零值

当指针声明后，没有进行初始化，其零值是 nil。

```
func main() {
    a := 25
    var b *int  // 声明一个指针

    if b == nil {
        fmt.Println(b)
        b = &a  // 初始化：将a的内存地址给b
        fmt.Println(b)
    }
}
```

输出如下

```
<nil>
0xc0000100a0
```

### 指针与切片

切片与指针一样，都是引用类型。

如果我们想通过一个函数改变一个数组的值，有两种方法

1. 将这个数组的切片做为参数传给函数
2. 将这个数组的指针做为参数传给函数

尽管二者都可以实现我们的目的，但是按照 Go 语言的使用习惯，建议使用第一种方法，因为第一种方法，写出来的代码会更加简洁，易读。具体你可以参数下面两种方法的代码实现

**使用切片**

```
func modify(sls []int) {
    sls[0] = 90
}

func main() {
    a := [3]int{89, 90, 91}
    modify(a[:])
    fmt.Println(a)
}
```

**使用指针**

```
func modify(arr *[3]int) {
    (*arr)[0] = 90
}

func main() {
    a := [3]int{89, 90, 91}
    modify(&a)
    fmt.Println(a)
}
```







## 类型转换

Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。

```go
package main

import (  
    "fmt"
)

func main() {  
    i := 55      //int
    j := 67.8    //float64
    sum := i + j //不允许 int + float64
    fmt.Println(sum)
}
```

上面的代码在 C 语言中是完全合法的，然而在 Go 中，却是行不通的。i 的类型是 int ，而 j 的类型是 float64 ，试图把两个不同类型的数相加，Go 不允许这样的操作。如果运行程序，你会得到 `main.go:10: invalid operation: i + j (mismatched types int and float64)`。

要修复这个错误，i 和 j 应该是相同的类型。在这里，把 j 转换为 int 类型。把 v 转换为 T 类型的语法是 T(v)。

```go
package main

import (  
    "fmt"
)

func main() {  
    i := 55      //int
    j := 67.8    //float64
    sum := i + int(j) //j is converted to int
    fmt.Println(sum)
}
```

把一个变量赋值给另一个不同类型的变量，需要显式的类型转换。

```go
package main

import (  
    "fmt"
)

func main() {  
    i := 10
    var j float64 = float64(i) // 若没有显式转换，该语句会报错
    fmt.Println("j", j)
}
```
