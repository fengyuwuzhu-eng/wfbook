# 包和文件

[TOC]

## 概述

Go 语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以 `.go` 为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包 `gopl.io/ch1/helloworld` 对应的目录路径是 `$GOPATH/src/gopl.io/ch1/helloworld` 。

每个包都对应一个独立的名字空间。例如，在 image 包中的 Decode 函数和在 unicode/utf16 包中的 Decode 函数是不同的。要在外部引用该函数，必须显式使用 image.Decode 或 utf16.Decode 形式访问。

包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。

为了演示包基本的用法，先假设我们的温度转换软件已经很流行，我们希望到 Go 语言社区也能使用这个包。我们该如何做呢？

让我们创建一个名为 gopl.io/ch2/tempconv 的包。（这里我们没有按照惯例按顺序对例子进行编号，因此包路径看起来更像一个真实的包）包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问；虽然在现实中，这样小的包一般只需要一个文件。

我们把变量的声明、对应的常量，还有方法都放到 tempconv.go 源文件中：

gopl.io/ch2/tempconv

```go
// Package tempconv performs Celsius and Fahrenheit conversions.
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC     Celsius = 0
    BoilingC      Celsius = 100
)

func (c Celsius) String() string    { return fmt.Sprintf("%g°C", c) }
func (f Fahrenheit) String() string { return fmt.Sprintf("%g°F", f) }
```

转换函数则放在另一个 conv.go 源文件中：

```go
package tempconv

// CToF converts a Celsius temperature to Fahrenheit.
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

// FToC converts a Fahrenheit temperature to Celsius.
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将通过类似 tempconv.CToF 的形式访问。而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。要注意的是 tempconv.go 源文件导入了 fmt 包，但是 conv.go 源文件并没有，因为这个源文件中的代码并没有用到 fmt 包。

因为包级别的常量名都是以大写字母开头，它们可以像 tempconv.AbsoluteZeroC 这样被外部代码访问：

```go
fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC) // "Brrrr! -273.15°C"
```

要将摄氏温度转换为华氏温度，需要先用 import 语句导入 gopl.io/ch2/tempconv 包，然后就可以使用下面的代码进行转换了：

```go
fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
```

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的 doc.go 文件中。

**练习 2.1：** 向tempconv包添加类型、常量和函数用来处理Kelvin绝对温度的转换，Kelvin 绝对零度是−273.15°C，Kelvin绝对温度1K和摄氏度1°C的单位间隔是一样的。

## 导入包

在 Go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似 "gopl.io/ch2/tempconv" 的字符串对应包的导入路径。Go 语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用 Go 语言自带的 go 工具箱时，一个导入路径代表一个目录中的一个或多个 Go 源文件。

除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如 gopl.io/ch2/tempconv 包的名字一般是 tempconv 。

要使用 gopl.io/ch2/tempconv 包，需要先导入：

gopl.io/ch2/cf

```go
// Cf converts its numeric argument to Celsius and Fahrenheit.
package main

import (
    "fmt"
    "os"
    "strconv"

    "gopl.io/ch2/tempconv"
)

func main() {
    for _, arg := range os.Args[1:] {
        t, err := strconv.ParseFloat(arg, 64)
        if err != nil {
            fmt.Fprintf(os.Stderr, "cf: %v\n", err)
            os.Exit(1)
        }
        f := tempconv.Fahrenheit(t)
        c := tempconv.Celsius(t)
        fmt.Printf("%s = %s, %s = %s\n",
            f, tempconv.FToC(f), c, tempconv.CToF(c))
    }
}
```

导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。上面的导入声明将允许我们以 tempconv.CToF 的形式来访问 gopl.io/ch2/tempconv 包中的内容。在默认情况下，导入的包绑定到 tempconv 名字（指包声明语句指定的名字），但是也可以绑定到另一个名称，以避免名字冲突。

cf 程序将命令行输入的一个温度在 Celsius 和 Fahrenheit 温度单位之间转换：

```go
$ go build gopl.io/ch2/cf
$ ./cf 32
32°F = 0°C, 32°C = 89.6°F
$ ./cf 212
212°F = 100°C, 212°C = 413.6°F
$ ./cf -40
-40°F = -40°C, -40°C = -40°F
```

如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。这种强制规则可以有效减少不必要的依赖，虽然在调试期间可能会让人讨厌，因为删除一个类似 log.Print("got here!") 的打印语句可能导致需要同时删除 log 包导入声明，否则，编译器将会发出一个错误。在这种情况下，我们需要将不必要的导入删除或注释掉。

不过有更好的解决方案，我们可以使用 golang.org/x/tools/cmd/goimports 导入工具，它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成 goimports 工具，然后在保存文件的时候自动运行。类似的还有 gofmt 工具，可以用来格式化 Go 源文件。

**练习 2.2：** 写一个通用的单位转换程序，用类似cf程序的方式从命令行读取参数，如果缺省的话则是从标准输入读取参数，然后做类似Celsius和Fahrenheit的单位转换，长度单位可以对应英尺和米，重量单位可以对应磅和公斤等。

## 包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：

```go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```

如果包中含有多个 .go 源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将 .go 文件根据文件名排序，然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的 init 初始化函数来简化初始化工作。每个文件都可以包含多个 init 初始化函数

```go
func init() { /* ... */ }
```

这样的 init 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的 init 初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，main 包最后被初始化。以这种方式，可以确保在 main 函数执行之前，所有依赖的包都已经完成初始化工作了。

下面的代码定义了一个 PopCount 函数，用于返回一个数字中含二进制 1bit 的个数。它使用 init 初始化函数来生成辅助表格 pc ，pc 表格用于处理每个 8bit 宽度的数字含二进制的 1bit 的 bit 个数，这样的话在处理 64bit 宽度的数字时就没有必要循环 64 次，只需要 8 次查表就可以了。（这并不是最快的统计 1bit 数目的算法，但是它可以方便演示 init 函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。

gopl.io/ch2/popcount

```go
package popcount

// pc[i] is the population count of i.
var pc [256]byte

func init() {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
    return int(pc[byte(x>>(0*8))] +
        pc[byte(x>>(1*8))] +
        pc[byte(x>>(2*8))] +
        pc[byte(x>>(3*8))] +
        pc[byte(x>>(4*8))] +
        pc[byte(x>>(5*8))] +
        pc[byte(x>>(6*8))] +
        pc[byte(x>>(7*8))])
}
```

对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理，像下面这样：

```go
// pc[i] is the population count of i.
var pc [256]byte = func() (pc [256]byte) {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
    return
}()
```

要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：

```go
for i, _ := range pc {
```

我们在下一节和10.5节还将看到其它使用init函数的地方。

**练习 2.3：** 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。（11.4节将展示如何系统地比较两个不同实现的性能。）

**练习 2.4：** 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和查表算法的性能差异。

**练习 2.5：** 表达式`x&(x-1)`用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数，然后比较性能。



在实际中，把所有源代码编写在一个文件的方法并不好用。以这种方式编写，代码的重用和维护都会很困难。而包（Package）解决了这样的问题。

每个 Go 程序都是由包组成的。程序运行的入口是包 "main" 。

例如，假如我们正在开发一个 Go  图像处理程序，它提供了图像的裁剪、锐化、模糊和彩色增强等功能。一种组织程序的方式就是根据不同的特性，把代码放到不同的包中。比如裁剪可以是一个单独的包，而锐化是另一个包。这种方式的优点是，由于彩色增强可能需要一些锐化的功能，因此彩色增强的代码只需要简单地导入锐化功能的包，就可以使用锐化的功能了。这样的方式使得代码易于重用。

## main 函数和 main 包

所有可执行的 Go 程序都必须包含一个 main 函数。这个函数是程序运行的入口。main 函数应该放置于 main 包中。

**`package packagename` 这行代码指定了某一源文件属于一个包。它应该放在每一个源文件的第一行。**

下面开始为我们的程序创建一个 main 函数和 main 包。**在 Go 工作区内的 src 文件夹中创建一个文件夹，命名为 `geometry`**。在 `geometry` 文件夹中创建一个 `geometry.go` 文件。

在 geometry.go 中编写下面代码。

```go
// geometry.go
package main 

import "fmt"

func main() {  
    fmt.Println("Geometrical shape properties")
}
```

`package main` 这一行指定该文件属于 main 包。`import "packagename"` 语句用于导入一个已存在的包。在这里导入了 `fmt` 包，包内含有 Println 方法。接下来是 main 函数，它会打印 `Geometrical shape properties`。

## 导入包

```go
import "XXX"

import (
    "XXX"
    "XXX"
)
```

键入 `go install geometry`，编译上述程序。该命令会在 `geometry` 文件夹内搜索拥有 main 函数的文件。在这里，它找到了 `geometry.go`。接下来，它编译并产生一个名为 `geometry` （在 windows 下是 `geometry.exe`）的二进制文件，该二进制文件放置于工作区的 bin 文件夹。现在，工作区的目录结构会是这样：

```bash
src
    geometry
        gemometry.go
bin
    geometry
```

键入 `workspacepath/bin/geometry`，运行该程序。应该会输出 `Geometrical shape properties`。

## 创建自定义的包

我们将组织代码，使得所有与矩形有关的功能都放入 `rectangle` 包中。

创建一个自定义包 `rectangle`，它有一个计算矩形的面积和对角线的函数。

**属于某一个包的源文件都应该放置于一个单独命名的文件夹里。按照 Go 的惯例，应该用包名命名该文件夹。**

因此，我们在 `geometry` 文件夹中，创建一个命名为 `rectangle` 的文件夹。在 `rectangle` 文件夹中，所有文件都会以 `package rectangle` 作为开头，因为它们都属于 rectangle 包。

在我们之前创建的 rectangle 文件夹中，再创建一个名为 `rectprops.go` 的文件，添加下列代码。

```go
// rectprops.go
package rectangle

import "math"

func Area(len, wid float64) float64 {  
    area := len * wid
    return area
}

func Diagonal(len, wid float64) float64 {  
    diagonal := math.Sqrt((len * len) + (wid * wid))
    return diagonal
}
```

在上面的代码中，我们创建了两个函数用于计算 `Area` 和 `Diagonal`。矩形的面积是长和宽的乘积。矩形的对角线是长与宽平方和的平方根。`math` 包下面的 `Sqrt` 函数用于计算平方根。

注意到函数 Area 和 Diagonal 都是以大写字母开头的。这是有必要的。

## 导入自定义包

为了使用自定义包，我们必须要先导入它。导入自定义包的语法为 `import path`。我们必须指定自定义包相对于工作区内 `src` 文件夹的相对路径。我们目前的文件夹结构是：

```
src
    geometry
        geometry.go
        rectangle
            rectprops.go
```

`import "geometry/rectangle"` 这一行会导入 rectangle 包。

在 `geometry.go` 里面添加下面的代码：

```go
// geometry.go
package main 

import (  
    "fmt"
    "geometry/rectangle" // 导入自定义包
)

func main() {  
    var rectLen, rectWidth float64 = 6, 7
    fmt.Println("Geometrical shape properties")
    /*Area function of rectangle package used*/
    fmt.Printf("area of rectangle %.2f\n", rectangle.Area(rectLen, rectWidth))
    /*Diagonal function of rectangle package used*/
    fmt.Printf("diagonal of the rectangle %.2f ", rectangle.Diagonal(rectLen, rectWidth))
}
```

上面的代码导入了 `rectangle` 包，并调用了里面的 Area 和 Diagonal 函数，得到矩形的面积和对角线。Printf 内的格式说明符 `%.2f` 会将浮点数截断到小数点两位。应用程序的输出为：

```go
Geometrical shape properties  
area of rectangle 42.00  
diagonal of the rectangle 9.22
```

## 导出名字（Exported Names）

将 rectangle 包中的函数 Area 和 Diagonal 首字母大写，在 Go 中这具有特殊意义。在 Go  中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。在这里，我们需要在 main 包中访问 Area 和  Diagonal 函数，因此会将它们的首字母大写。

在 `rectprops.go` 中，如果函数名从 `Area(len, wid float64)` 变为 `area(len, wid float64)`，并且在 `geometry.go` 中， `rectangle.Area(rectLen, rectWidth)` 变为 `rectangle.area(rectLen, rectWidth)`， 则该程序运行时，编译器会抛出错误 `geometry.go:11: cannot refer to unexported name rectangle.area`。因为如果想在包外访问一个函数，它应该首字母大写。

## init 函数

所有包都可以包含一个 `init` 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。init 函数的形式如下：

```go
func init() {  
}
```

init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。

包的初始化顺序如下：

1. 首先初始化包级别（Package Level）的变量。
2. 紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。

如果一个包导入了另一个包，会先初始化被导入的包。尽管一个包可能会被导入多次，但是它只会被初始化一次。

首先在 `rectprops.go` 文件中添加了一个 init 函数。

```go
// rectprops.go
package rectangle

import "math"  
import "fmt"

/*
 * init function added
 */
func init() {  
    fmt.Println("rectangle package initialized")
}

func Area(len, wid float64) float64 {  
    area := len * wid
    return area
}

func Diagonal(len, wid float64) float64 {  
    diagonal := math.Sqrt((len * len) + (wid * wid))
    return diagonal
}
```

我们添加了一个简单的 init 函数，它仅打印 `rectangle package initialized`。

现在我们来修改 main 包。我们知道矩形的长和宽都应该大于 0，我们将在 `geometry.go` 中使用 init 函数和包级别的变量来检查矩形的长和宽。

修改 `geometry.go` 文件如下所示：

```go
// geometry.go
package main 

import (  
    "fmt"
    "geometry/rectangle" // 导入自定义包
    "log"
)
/*
 * 1. 包级别变量
*/
var rectLen, rectWidth float64 = 6, 7 

/*
*2. init 函数会检查长和宽是否大于0
*/
func init() {  
    println("main package initialized")
    if rectLen < 0 {
        log.Fatal("length is less than zero")
    }
    if rectWidth < 0 {
        log.Fatal("width is less than zero")
    }
}

func main() {  
    fmt.Println("Geometrical shape properties")
    fmt.Printf("area of rectangle %.2f\n", rectangle.Area(rectLen, rectWidth))
    fmt.Printf("diagonal of the rectangle %.2f ",rectangle.Diagonal(rectLen, rectWidth))
}
```

我们对 `geometry.go` 做了如下修改：

1. 变量 **rectLen** 和 **rectWidth** 从 main 函数级别移到了包级别。
2. 添加了 init 函数。当 rectLen 或 rectWidth 小于 0 时，init 函数使用 **log.Fatal** 函数打印一条日志，并终止了程序。

main 包的初始化顺序为：

1. 首先初始化被导入的包。因此，首先初始化了 rectangle 包。
2. 接着初始化了包级别的变量 **rectLen** 和 **rectWidth**。
3. 调用 init 函数。
4. 最后调用 main 函数。

当运行该程序时，会有如下输出。

```go
rectangle package initialized  
main package initialized  
Geometrical shape properties  
area of rectangle 42.00  
diagonal of the rectangle 9.22
```

果然，程序会首先调用 rectangle 包的 init 函数，然后，会初始化包级别的变量 **rectLen** 和 **rectWidth**。接着调用 main 包里的 init 函数，该函数检查 rectLen 和 rectWidth 是否小于 0，如果条件为真，则终止程序。现在你可以认为 `if rectLen < 0` 能够检查 `rectLen` 是否小于 0，并且如果是，则终止程序。`rectWidth` 条件的编写也是类似的。在这里两个条件都为假，因此程序继续执行。最后调用了 main 函数。

让我们接着稍微修改这个程序来学习使用 init 函数。

将 `geometry.go` 中的 `var rectLen, rectWidth float64 = 6, 7` 改为 `var rectLen, rectWidth float64 = -6, 7`。我们把 `rectLen` 初始化为负数。

现在当运行程序时，会得到：

```go
rectangle package initialized  
main package initialized  
2017/04/04 00:28:20 length is less than zero
```

像往常一样， 会首先初始化 rectangle 包，然后是 main 包中的包级别的变量 rectLen 和 rectWidth。rectLen 为负数，因此当运行 init 函数时，程序在打印 `length is less than zero` 后终止。

## 使用空白标识符（Blank Identifier）

导入了包，却不在代码中使用它，这在 Go 中是非法的。当这么做时，编译器是会报错的。其原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。将 `geometry.go` 中的代码替换为如下代码：

```go
// geometry.go
package main 

import (
    "geometry/rectangle" // 导入自定的包
)

func main() {

}
```

上面的程序将会抛出错误 `geometry.go:6: imported and not used: "geometry/rectangle"`。

然而，在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。遇到这种情况就可以使用空白标识符 `_` 。

下面的代码可以避免上述程序的错误：

```go
package main

import (  
    "geometry/rectangle" 
)

var _ = rectangle.Area // 错误屏蔽器

func main() {

}
```

`var _ = rectangle.Area` 这一行屏蔽了错误。我们应该了解这些错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们，包括那些还没有使用过的包。由此建议在 import 语句下面的包级别范围中写上错误屏蔽器。

有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。例如，我们或许需要确保调用了 rectangle 包的 init 函数，而不需要在代码中使用它。这种情况也可以使用空白标识符，如下所示。

```go
package main 

import (
    _ "geometry/rectangle" 
)
func main() {

}
```

运行上面的程序，会输出 `rectangle package initialized`。尽管在所有代码里，我们都没有使用这个包，但还是成功初始化了它。



### 可见性规则

使用大小写来决定该**常量**、**变量**、**类型**、**接口**、**结构**或**函数**是否可以被外部包所调用。
函数名首字母**小写**即为private;函数名首字母**大写**即为public.

### 别名

```go
import (
	io "fmt"
)

io.Println("hello world!")
```

### 省略调用

不可与别名同时使用。

```go
import (
	. "fmt"
)

func main() {
Println("hello world!")
}
```

关于包，根据本地测试得出以下几点：

- 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。
- 文件夹名与包名没有直接关系，并非需要一致。
- 同一个文件夹下的文件只能有一个包名，否则编译报错。

文件结构:

```bash
Test
--helloworld.go

myMath
--myMath1.go
--myMath2.go
```

测试代码:

```bash
// helloworld.go
package main

import (
"fmt"
"./myMath"
)

func main(){
    fmt.Println("Hello World!")
    fmt.Println(mathClass.Add(1,1))
    fmt.Println(mathClass.Sub(1,1))
}
```

```bash
// myMath1.go
package mathClass
func Add(x,y int) int {
    return x + y
}
```

```bash
// myMath2.go
package mathClass
func Sub(x,y int) int {
    return x - y
}
```



