# 子程序(函数)

Perl 子程序（subroutine）也就是用户定义的函数。

Perl 子程序即执行一个特殊任务的一段分离的代码，它可以使减少重复代码且使程序易读。

Perl 子程序是一段封装了一系列操作或计算的代码块，它可以被反复调用，以便在程序中重复使用。

Perl 子程序有助于模块化程序，使得代码更易于理解、维护和重用。

Perl 子程序可以出现在程序的任何地方，语法格式如下：

```
sub subroutine{
   statements;
}
```

调用子程序语法格式：

```
subroutine( 参数列表 );
```

在 Perl 5.0 以下版本调用子程序方法如下：

```
&subroutine( 参数列表 );
```

在新版本上，虽然也支持该调用方法，但不推荐使用。

接下来我们来看一个简单是实例：

## 实例

\#!/usr/bin/perl  # 函数定义 sub Hello{   print "Hello, World!\n"; }  # 函数调用 Hello();

执行以上程序，输出结果为：

```
Hello, World!
```

------

## 向子程序传递参数

Perl 子程序可以和其他编程一样接受多个参数，子程序参数使用特殊数组 @_ 标明。

因此子程序第一个参数为 $_[0], 第二个参数为 $_[1], 以此类推。

不论参数是标量型还是数组型的，用户把参数传给子程序时，perl默认按引用的方式调用它们。

## 实例

\#!/usr/bin/perl  # 定义求平均值函数 sub Average{   # 获取所有传入的参数   $n = scalar(@_);   $sum = 0;    foreach $item (@_){      $sum += $item;   }   $average = $sum / $n;   print '传入的参数为 : ',"@_\n";           # 打印整个数组   print "第一个参数值为 : $_[0]\n";         # 打印第一个参数   print "传入参数的平均值为 : $average\n";  # 打印平均值 }  # 调用函数 Average(10, 20, 30);

执行以上程序，输出结果为：

```
传入的参数为 : 10 20 30
第一个参数值为 : 10
传入参数的平均值为 : 20
```

用户可以通过改变 @_ 数组中的值来改变相应实际参数的值。

### 向子程序传递列表

由于 @_ 变量是一个数组，所以它可以向子程序中传递列表。

但如果我们需要传入标量和数组参数时，需要把列表放在最后一个参数上，如下所示：

## 实例

\#!/usr/bin/perl  # 定义函数 sub PrintList{   my @list = @_;   print "列表为 : @list\n"; } $a = 10; @b = (1, 2, 3, 4);  # 列表参数 PrintList($a, @b);

以上程序将标量和数组合并了，输出结果为：

```
列表为 : 10 1 2 3 4
```

我们可以向子程序传入多个数组和哈希，但是在传入多个数组和哈希时，会导致丢失独立的标识。所以我们需要使用引用（下一章节会介绍）来传递。

## 向子程序传递哈希

当向子程序传递哈希表时，它将复制到 @_ 中，哈希表将被展开为键/值组合的列表。

## 实例

\#!/usr/bin/perl  # 方法定义 sub PrintHash{   my (%hash) = @_;    foreach my $key ( keys %hash ){      my $value = $hash{$key};      print "$key : $value\n";   } } %hash = ('name' => 'runoob', 'age' => 3);  # 传递哈希 PrintHash(%hash);

以上程序执行输出结果为：

```
age : 3
name : runoob
```

------

## 子程序返回值

子程序可以向其他编程语言一样使用 return 语句来返回函数值。

如果没有使用 return 语句，则子程序的最后一行语句将作为返回值。

## 实例

\#!/usr/bin/perl  # 方法定义 sub add_a_b{   # 不使用 return   $_[0]+$_[1];      # 使用 return   # return $_[0]+$_[1];   } print add_a_b(1, 2)

以上程序执行输出结果为：

```
3
```

在 Perl 中，可以使用引用来返回多个数组和哈希。引用是一种指向数据结构（如数组或哈希）的标量值，通过引用，我们可以将多个数组和哈希打包成一个返回值传递给调用程序。这样可以保持数据结构的独立性和完整性。

## 实例

**sub** return_multiple_data {
   my @array1 = (1, 2, 3);
   my @array2 = ('a', 'b', 'c');
   my %hash1 = ('key1' => 'value1', 'key2' => 'value2');
   my %hash2 = ('foo' => 'bar', 'baz' => 'qux');
   
   return (\@array1, \@array2, \%hash1, \%hash2);
 }
 
 my ($array_ref1, $array_ref2, $hash_ref1, $hash_ref2) = return_multiple_data();
 
 *# 使用引用访问返回的数据*
 print "Array 1: @{$array_ref1}**\n**";
 print "Array 2: @{$array_ref2}**\n**";
 print "Hash 1: " . join(", ", %{$hash_ref1}) . "**\n**";
 print "Hash 2: " . join(", ", %{$hash_ref2}) . "**\n**";

以上代码中 return_multiple_data 子程序返回了四个数据结构的引用。

在调用程序中，我们通过解引用这些引用来访问返回的数组和哈希，从而保持了它们的独立性和完整性。

输出结果为：

```
Array 1: 1 2 3
Array 2: a b c
Hash 1: key1, value1, key2, value2
Hash 2: foo, bar, baz, qux
```

------

## 子程序的私有变量

默认情况下，Perl 中所有的变量都是全局变量，这就是说变量在程序的任何地方都可以调用。

如果我们需要设置私有变量，可以使用 **my** 操作符来设置。

**my** 操作符用于创建词法作用域变量，通过 **my** 创建的变量，存活于声明开始的地方，直到闭合作用域的结尾。

闭合作用域指的可以是一对花括号中的区域，可以是一个文件，也可以是一个 if, while, for, foreach, eval字符串。

以下实例演示了如何声明一个或多个私有变量：

```
sub somefunc {
   my $variable; # $variable 在方法 somefunc() 外不可见
   my ($another, @an_array, %a_hash); #  同时声明多个变量
}
```

## 实例

\#!/usr/bin/perl  # 全局变量 $string = "Hello, World!";  # 函数定义 sub PrintHello{   # PrintHello 函数的私有变量   my $string;   $string = "Hello, Runoob!";   print "函数内字符串：$string\n"; } # 调用函数 PrintHello(); print "函数外字符串：$string\n";

以上程序执行输出结果为：

```
函数内字符串：Hello, Runoob!
函数外字符串：Hello, World!
```

------

## 变量的临时赋值

我们可以使用 local 为全局变量提供临时的值，在退出作用域后将原来的值还回去。

local 定义的变量不存在于主程序中，但存在于该子程序和该子程序调用的子程序中。定义时可以给其赋值，如：

## 实例

\#!/usr/bin/perl  # 全局变量 $string = "Hello, World!";  sub PrintRunoob{   # PrintHello 函数私有变量   local $string;   $string = "Hello, Runoob!";   # 子程序调用的子程序   PrintMe();   print "PrintRunoob 函数内字符串值：$string\n"; } sub PrintMe{   print "PrintMe 函数内字符串值：$string\n"; }  sub PrintHello{   print "PrintHello 函数内字符串值：$string\n"; }  # 函数调用 PrintRunoob(); PrintHello(); print "函数外部字符串值：$string\n";

以上程序执行输出结果为：

```
PrintMe 函数内字符串值：Hello, Runoob!
PrintRunoob 函数内字符串值：Hello, Runoob!
PrintHello 函数内字符串值：Hello, World!
函数外部字符串值：Hello, World!
```

------

## 静态变量

state操作符功能类似于C里面的static修饰符，state关键字将局部变量变得持久。

state也是词法变量，所以只在定义该变量的词法作用域中有效，举个例子：

## 实例

\#!/usr/bin/perl  use feature 'state';  sub PrintCount{   state $count = 0; # 初始化变量    print "counter 值为：$count\n";   $count++; }  for (1..5){   PrintCount(); }

以上程序执行输出结果为：

```
counter 值为：0
counter 值为：1
counter 值为：2
counter 值为：3
counter 值为：4
```

> 注1：state仅能创建闭合作用域为子程序内部的变量。
>
> 注2：state是从Perl  5.9.4开始引入的，所以使用前必须加上 use。
>
> 注3：state可以声明标量、数组、哈希。但在声明数组和哈希时，不能对其初始化（至少Perl 5.14不支持）。

------

## 子程序调用上下文

子程序调用过程中，会根据上下文来返回不同类型的值，比如以下 localtime() 子程序，在标量上下文返回字符串，在列表上下文返回列表:

## 实例

\#!/usr/bin/perl  # 标量上下文 my $datestring = localtime( time ); print $datestring;  print "\n";  # 列表上下文 # $year 的值是从 1900 年作为起始年开始的计数 ($sec,$min,$hour,$mday,$mon, $year,$wday,$yday,$isdst) = localtime(time); printf("%d-%d-%d %d:%d:%d",$year+1900,$mon+1,$mday,$hour,$min,$sec);  print "\n";

以上程序执行输出结果为：

```
Sun Jun 12 15:58:09 2016
2106-6-12 15:58:9
```

 [Perl 时间日期](https://www.runoob.com/perl/perl-date-time.html) 

[Perl 引用](https://www.runoob.com/perl/perl-references.html) 

<iframe id="aswift_2" name="aswift_2" style="left: 0px; top: 0px; border: 0px; width: 847px; height: 0px; min-height: auto; max-height: none; min-width: auto; max-width: none;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="847" height="0" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-5751451760833794&amp;output=html&amp;h=280&amp;slotname=1691338467&amp;adk=2377280972&amp;adf=342612028&amp;pi=t.ma~as.1691338467&amp;w=847&amp;abgtt=6&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1753770138&amp;rafmt=1&amp;format=847x280&amp;url=https%3A%2F%2Fwww.runoob.com%2Fperl%2Fperl-subroutines.html&amp;fwr=0&amp;fwrattr=true&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;dt=1753770102273&amp;bpp=1&amp;bdt=709&amp;idt=205&amp;shv=r20250724&amp;mjsv=m202507220101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D3aa81bb6bde61f08%3AT%3D1752463956%3ART%3D1753770103%3AS%3DALNI_MZvE77nlQaP0TQJGMUXXc7r1coxNQ&amp;gpic=UID%3D0000116049a303d5%3AT%3D1752463956%3ART%3D1753770103%3AS%3DALNI_MblZa2LgM8NtZx64UEoV9WWJCa-vg&amp;eo_id_str=ID%3D744f0a35a6bbe975%3AT%3D1752463956%3ART%3D1753770103%3AS%3DAA-AfjbZI2kdxrLKEhZ78-5aruWN&amp;prev_fmts=0x0%2C728x90%2C160x600&amp;nras=1&amp;correlator=5573081445943&amp;frm=20&amp;pv=1&amp;u_tz=480&amp;u_his=12&amp;u_h=1080&amp;u_w=1920&amp;u_ah=1032&amp;u_aw=1920&amp;u_cd=24&amp;u_sd=1&amp;adx=549&amp;ady=6933&amp;biw=1920&amp;bih=947&amp;scr_x=0&amp;scr_y=3183&amp;eid=31093580%2C95331833%2C95362655%2C95366912%2C95366913%2C42533293%2C95366855%2C95359266%2C95367165&amp;oid=2&amp;psts=AOrYGsmW-NVaW7w3j8q-GfHEdcSKJ-7X2B-lkhPN7iuWDZSu54TILtIhcv99AMW87o-gw5UzleUskpC-7OYOLizmwpqEPJMC&amp;pvsid=1749849299446161&amp;tmod=475486581&amp;uas=1&amp;nvt=1&amp;ref=https%3A%2F%2Fwww.runoob.com%2Fperl%2Fperl-operators.html&amp;fc=1920&amp;brdim=-1928%2C-8%2C-1928%2C-8%2C1920%2C0%2C1936%2C1048%2C1920%2C947&amp;vis=1&amp;rsz=%7C%7CoEebr%7C&amp;abl=CS&amp;pfx=0&amp;fu=128&amp;bc=31&amp;bz=1.01&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;dtd=35764" data-google-container-id="a!3" tabindex="0" title="Advertisement" aria-label="Advertisement" data-google-query-id="CN6U_vC24Y4DFVCH6QUdhnIxiQ" data-load-complete="true"></iframe>

##      	    	    	        1  篇笔记   写笔记    

1. 

     心绪留香

    mrl***w@163.com

    111

   **my 和 local 的区别**

   内部 -> 外部：

   - （1）my 和  local 都只在一个 block 里有效，出去就失效；
   - （2）但是 local 的变量可以继续在这个 block 中调用的子程序中存在；
   - （3）如果有与外界同名的变量，两者在 block 退出后都不影响外界同名变量；

   外部 -> 内部：

   （1）外部设置 my、local、缺省均队内有效，但是同名变量外部 my，在 block 内部 local 是不允许的。因为二者在 block 中调用的子程序中均有效，会冲突。

   （2）如果在一个 block 中有一个 my 修饰的变量和外界的一个变量同名，而且又需要在这个 block 中使用外界变量时，两个办法：

   - 第一个办法，用 main 的 package 修饰这个变量名 $main::global。
   - 第二个办法，用 our 修饰 our $global，那么该 block 中接下来出现的所有 $global 都是外界的 global。

   （3）编写脚本时，注意作用域，防止外部影响内部。

   [心绪留香](javascript:;)

     心绪留香

    mrl***w@163.com

   7年前 (2019-01-04)