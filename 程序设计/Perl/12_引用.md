# 引用

引用就是指针，Perl 引用是一个标量类型可以指向变量、数组、哈希表（也叫关联数组）甚至子程序，可以应用在程序的任何地方。



------

## 创建引用

定义变量的时候，在变量名前面加个\，就得到了这个变量的一个引用，比如:

```
$scalarref = \$foo;     # 标量变量引用
$arrayref  = \@ARGV;    # 列表的引用
$hashref   = \%ENV;     # 哈希的引用
$coderef   = \&handler; # 子过程引用
$globref   = \*foo;     # GLOB句柄引用
```

在数组中我们可以用匿名数组引用，使用 [] 定义：

```
$aref= [ 1,"foo",undef,13 ];
```

匿名数组的元素仍然可以是匿名数组，所以我们可以用这种方法构造数组的数组，可以构造任意维度的数组。

```
my $aref = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
]
```

在哈希中我们可以用匿名哈希引用，使用 {} 定义：

```
$href= { APR =>4, AUG =>8 };
```

我们也可以创建一个没有子程序名的匿名子程序引用:

```
$coderef = sub { print "Runoob!\n" };
```

------

## 取消引用

取消引用可以根据不同的类型使用  $, @ 或 % 来取消，实例如下：

## 实例

\#!/usr/bin/perl  $var = 10;  # $r 引用 $var 标量 $r = \$var;  # 输出本地存储的 $r 的变量值 print "$var 为 : ", $$r, "\n";  @var = (1, 2, 3); # $r 引用  @var 数组 $r = \@var; # 输出本地存储的 $r 的变量值 print "@var 为: ",  @$r, "\n";  %var = ('key1' => 10, 'key2' => 20); # $r 引用  %var 哈希 $r = \%var; # 输出本地存储的 $r 的变量值 print "\%var 为 : ", %$r, "\n";

执行以上实例执行结果为：

```
10 为 : 10
1 2 3 为: 123
\%var 为 : key110key220
```

如果你不能确定变量类型，你可以使用 **ref** 来判断，返回值列表如下，如果没有以下的值返回 false：

```
SCALAR
ARRAY
HASH
CODE
GLOB
REF
```

实例如下：

## 实例

\#!/usr/bin/perl  $var = 10; $r = \$var; print "r 的引用类型 : ", ref($r), "\n";  @var = (1, 2, 3); $r = \@var; print "r 的引用类型 : ", ref($r), "\n";  %var = ('key1' => 10, 'key2' => 20); $r = \%var; print "r 的引用类型 : ", ref($r), "\n";

执行以上实例执行结果为：

```
r 的引用类型 : SCALAR
r 的引用类型 : ARRAY
r 的引用类型 : HASH
```

------

## 循环引用

循环引用在两个引用相互包含时出现。你需要小心使用，不然会导致内存泄露，如下实例：

## 实例

\#!/usr/bin/perl  my $foo = 100; $foo = \$foo;  print "Value of foo is : ", $$foo, "\n";

执行以上实例执行结果为：

```
Value of foo is : REF(0x9aae38)
```

------

## 引用函数

函数引用格式: \& 

调用引用函数格式: & + 创建的引用名。

实例如下：

## 实例

\#!/usr/bin/perl  # 函数定义 sub PrintHash{   my (%hash) = @_;      foreach $item (%hash){      print "元素 : $item\n";   } } %hash = ('name' => 'runoob', 'age' => 3);  # 创建函数的引用 $cref = \&PrintHash;  # 使用引用调用函数 &$cref(%hash);

执行以上实例执行结果为：

```
元素 : age
元素 : 3
元素 : name
元素 : runoob
```

 [Perl 子程序(函数)](https://www.runoob.com/perl/perl-subroutines.html) 

[Perl 格式化输出](https://www.runoob.com/perl/perl-formats.html) 

<iframe id="aswift_2" name="aswift_2" style="left: 0px; top: 0px; border: 0px; width: 847px; height: 0px; min-height: auto; max-height: none; min-width: auto; max-width: none;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="847" height="0" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-5751451760833794&amp;output=html&amp;h=280&amp;slotname=1691338467&amp;adk=2377280972&amp;adf=342612028&amp;pi=t.ma~as.1691338467&amp;w=847&amp;abgtt=6&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1753770157&amp;rafmt=1&amp;format=847x280&amp;url=https%3A%2F%2Fwww.runoob.com%2Fperl%2Fperl-references.html&amp;fwr=0&amp;fwrattr=true&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;dt=1753770157538&amp;bpp=1&amp;bdt=451&amp;idt=308&amp;shv=r20250724&amp;mjsv=m202507220101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3D3aa81bb6bde61f08%3AT%3D1752463956%3ART%3D1753770103%3AS%3DALNI_MZvE77nlQaP0TQJGMUXXc7r1coxNQ&amp;gpic=UID%3D0000116049a303d5%3AT%3D1752463956%3ART%3D1753770103%3AS%3DALNI_MblZa2LgM8NtZx64UEoV9WWJCa-vg&amp;eo_id_str=ID%3D744f0a35a6bbe975%3AT%3D1752463956%3ART%3D1753770103%3AS%3DAA-AfjbZI2kdxrLKEhZ78-5aruWN&amp;prev_fmts=0x0%2C728x90&amp;nras=1&amp;correlator=3034495403572&amp;frm=20&amp;pv=1&amp;u_tz=480&amp;u_his=13&amp;u_h=1080&amp;u_w=1920&amp;u_ah=1032&amp;u_aw=1920&amp;u_cd=24&amp;u_sd=1&amp;adx=549&amp;ady=3496&amp;biw=1920&amp;bih=947&amp;scr_x=0&amp;scr_y=0&amp;eid=95362655%2C95366915%2C95366849%2C95359266%2C95367169&amp;oid=2&amp;pvsid=7472051938359775&amp;tmod=475486581&amp;uas=0&amp;nvt=1&amp;ref=https%3A%2F%2Fwww.runoob.com%2Fperl%2Fperl-subroutines.html&amp;fc=1920&amp;brdim=-1928%2C-8%2C-1928%2C-8%2C1920%2C0%2C1936%2C1048%2C1920%2C947&amp;vis=1&amp;rsz=%7C%7CoEebr%7C&amp;abl=CS&amp;pfx=0&amp;fu=128&amp;bc=31&amp;bz=1.01&amp;ifi=3&amp;uci=a!3&amp;btvi=1&amp;fsb=1&amp;dtd=315" data-google-container-id="a!3" tabindex="0" title="Advertisement" aria-label="Advertisement" data-load-complete="true" data-google-query-id="CO-fufq24Y4DFYpJwgUdH58fBg"></iframe>

##      	    	    	        1  篇笔记   写笔记    

1. 

     pang

    845***999@qq.com

    24

   1、当在构建子函数时，如果传入的参数仅为标量，则不需要引用。如果传入的参数为数组、哈希、标量的混合，则需要引用，并且在子函数中进行解引用。如果不使用引用，则作为输入的 @_，perl 无法区分变量，则整个打包了。

   ```
   sub {
     my $input = $_[0]; #单标量
     my ($input1,$input2..) = @_; #多标量
   }
   ```

   ```
   example($a,\@b);
   sub example {
     my ($input1,$input2)=@_;
     my @array = @$input2; #以此类推
   }
   ```

   2、相反的，在子函数返回变量时，同样需要有引用与解引的过程，与述相似。

   [pang](javascript:;)

     pang

    845***999@qq.com

   4年前 (2022-01-26)