- #### 3、查看本机IP

```dart
 ifconfig eth0 | awk -F "[ :]+" 'NR==2 {print $3}'
```


营养吸收会少，没法运输到全身；四肢秉受的营养不足，所以四肢会无力，肌肉会消瘦，因为脾主四肢、主肌肉；另外，人的肺气就会弱，因为“脾土生肺金”，肺气的来源是脾胃之气生发的，而“肺主皮毛”，那么人体体表的这些防卫系统——皮毛功能就会弱，出现头发没有光泽、掉发、皮肤干黄等症状……

什么是胃虚

就是人受纳食物的功能有问题，比如你吃了东西马上胃就胀，也就是吃不下去了，不能消化了，呕吐、呕酸水等，这都是胃虚、胃气上逆的表现。

什么是脾胃不和

脾和胃，都是属于消化系统的，在中医看来，它们本来是相表里的(互为表里的还有肝和胆、心和小肠、肺和大肠、肾和膀胱)。

如果脾胃不和了，比如说胃强脾弱，胃亢进，胃口特别好，特别能吃，但是吃了不吸收，不能运化——脾弱了，吃了就腹泻或者吃了以后肚子越来越胀，这就是胃强脾弱。

脾胃不和就是脾胃两个不能合作了，本来一个管接受的，另一个是帮助吸收的，但是如果能接受不能吸收，不能运化，不能向全身输动，就是脾胃不和。

脾胃不和通常还指脾胃与其他脏腑之间不能协调，比如肝气不舒、情绪不好也会引起脾胃不和，严格地说，这种脾胃不和叫做肝脾不和。

还有一种情况，是脾胃和外界不合。比如说你突然到了一个地方，水土特别不服，吃了什么东西，喝了比较硬的水，之后闹肚子，这也叫脾胃不和，是脾胃跟外界不合，跟当地的环境不合。

什么是积食

积食是脾胃虚弱里边的一个类型。积食会引起脾胃虚弱，脾胃虚弱又会引起积食，它们之间是互为因果的。

积食，有的是积在胃，就是吃东西多了，导致胃堵了，比如说孩子吃鸡腿，一下吃了三个，接下来不想吃别的了，有时甚至会往上呕酸水。

那么积在脾是什么意思呢？就是当积食长期地积在胃后没有被消除，慢慢地脾就被伤掉了，会给孩子带来更严重的危害。

如果积在胃里，可能吃点山楂之类的就消掉了，没事了。但是当积在脾以后，脾的功能被伤了，这是经过一个长期过程形成的，是积食发展到后来的更严重后果。

积食到了这步，孩子总爱腹泻，或者经常大便干燥——大便前边是硬的，后边是软的，不成型，吃一点东西肚子就爱胀，严重的孩子肚子会胀得像球一样。这样的孩子看上去四肢比较消瘦，这是因为肌肉缺乏营养来源了，然后会没有力气，经常出汗、气喘等，都是因为脾功能受伤了，它运化不了食物，就全部堵在那了。

脾积是长期形成的，因为胃积一两次，是不会导致身体状况改变的，但如果脾伤了以后，孩子身体状况就会改变。

积在脾的表现可能没有积在胃那么明显，因为如果积在胃，会出现一些比较突出的症状，比如口中味道大、突然食欲不振，甚至呕吐酸水、未消化食物等。

但是，积在脾，却往往是慢性的过程，在不知不觉中，慢慢开始变得虚弱，正气不足，因为不是突然出现的，往往没有胃积那么明显，但脾积伤害孩子会更严重一些。

总的说来，脾胃虚、脾胃不和、积食对孩子身心的影响都比较大。一般来讲，在孩子身上出现的毛病，由积食引起的多，最后会导致脾胃不和、脾虚。

如果孩子脾虚，家长一定要特别予以重视，因为脾虚已经是进入一个慢性疾病的状态了，而普通的积食多是急症，只要一消，可能第二天就好了，但脾虚不会是今天补，明天就好的，它要一点一点地调养。


web服务器：Nginx  
Web程序：PHP+Node  
搜素引擎：ElasticSearch  
队列服务：Gearman  
缓存服务：Redis+Memcache  
前端构建工具:npm+bower+gulp  
PHP CLI工具：Composer+PHPUnit


Vagrant  
PHPBrew  



十大历史上最知名的反坦克武器
　　伴随着1916年第一次世界大战索姆河战场上隆隆碾过战壕的大游民坦克登上历史舞台，围绕着坦克与反坦克一直是一对螺旋上升的矛盾课题，为了针对这位“陆战之王”，一系列反坦克武器被开发出来，而坦克自身的战斗力也是与日俱增。恰逢坦克诞生一百年，那么在这个百年之交，笔者就为大家盘点一番历史上出现的那些知反坦克武器。

游民星空

反坦克枪：

　　一战中，反坦克枪是专门设计出来击穿车辆装甲的步枪，它最主要的攻击对象就是坦克。这种步枪随着坦克刚出现的时代也同时投入战场，可是随着车辆装甲愈来愈厚，直到第二次世界大战初期反坦克枪失去效用，甚至无法对中型以上的坦克构成有效威胁，反坦克枪逐渐失去了装备的意义。不过越战的出现让反坦克枪再次焕发生机，因为他们发现了新的猎物——直升机，反坦克枪也拥有了全新的名字“反器材武器”。

游民星空
芬兰L39拉赫蒂20mm反坦克步枪

Gew.98毛瑟步枪配K子弹

　　1898年，7.92毫米口径1898年式毛瑟步枪成为德国陆军制式步枪，德国陆军命名为Gewehr 98（简称：Gew.98）。英军坦克的出现让德军的各种直射火力无能为力，最初提升贯穿力的尝试是使用“反向弹头”（reversed bullet），这种方式下仍使用和一般步枪相同的弹药和弹头，只是弹头是反着装入弹壳内，并增加装药量。更进一步的发展是采用特制的穿甲弹头，例如说像德军的“K子弹”（K bullet，德军正式名称：Patrone SmK Kurz 7.92mm），它也能由一般步枪发射。K子弹有着增量的推进药，并使用铁芯弹头，在与装甲表面垂直射入的情况下，它有约30%的机率能贯穿当时坦克8mm厚的装甲，而在100米距离射击的情况下，最多能击穿12-13mm厚的装甲。

游民星空
一战是德军装备的主力Gew.98毛瑟步枪

游民星空
反向安装弹头增强穿甲能力的子弹

德国毛瑟M1918 13.2毫米反坦克步枪

　　不过K子弹毕竟是一种概率武器，当时世界各国都需要更大威力的子弹，专职反坦克武器的开发工作还是提上了日程，最简单的方法就是使用更大口径的子弹来对付坦克，毛瑟M1918 13.2毫米反坦克步枪为德意志帝国陆军于第一次世界大战中针对协约国（主要是英国）的装甲车辆所研发生产的反装甲武器，初次登场时间是1918年2月。由于毛瑟开发的13×92mm子弹宣告完成，加上当时德意志帝国陆军都采用Gew.98步枪，因此毛瑟产生将G98步枪“巨大化”的概念并进入量产。毛瑟反坦克步枪同时采用Maschinengewehr 08的两脚架作为稳定支架。随后世界各国也相继推出自己的反坦克枪，如苏联的PTRS-41（cod5中有过出场）、日本九七式反坦克步枪、Boys反坦克步枪等。

游民星空
出现在《战地1》中的德国毛瑟M1918 13.2毫米反坦克步枪与大游民坦克

巴雷特

　　前文说过，二战初期反坦克枪即被打入冷宫，但是直升机的出现让这种武器又焕发了新的生命，美国武器设计师朗尼•巴雷特看到了其中的商机，设计生产了发射12.7mm的巴雷特。这种武器可以用来狩猎、狙击、反制轻型装甲车、雷达等军事器材，故称反器材武器。需要说明的是，巴雷特其实是民用武器，只不过美国军方觉得挺好用也采购而已，但经常出现对巴雷特实际威力进行夸大的文章。巴雷特发射的是12.7mm机枪弹，这种弹药美国陆军的魂——.50口径M2重机枪也在用，的确杀伤力可观，可完全到不了“轻松击穿主战坦克”的地步（说不定豹一的车尾35mm14°装甲极近距离怼射可以哦）。

游民星空

反坦克投掷物

　　既然枪发射的子弹很难击穿坦克，同时即便击穿了也可能会出现后效不足的问题，武器设计师和前线的官兵们同时也将注意力放在了火药上，许多以爆炸和燃烧为战斗机理的武器边应运而生。

游民星空
德军士兵在投掷PWM反坦克手榴弹

反坦克手榴弹

　　最早的反坦克手榴弹诞生在德国，不过这个手榴弹是半路出家的——并不是专门研制的武器，而是用六枚将手柄拆下来的24式手榴弹的弹头绑在1枚没有拆手柄的手榴弹上，组合成集束手榴弹。不过当时的坦克装甲普遍都不厚，这玩意还能凑合着用。但随着时代的进步，坦克也在进步，用集束手榴弹来对付坦克已经渐渐显得力不从心了。再说集束手榴弹那个重量实在是太大，投掷者至少要有运动员的身板，否则光是爆炸后产生的冲击波和破片都能把投掷者给一起报销了。于是专门进行破甲的聚能装药战斗部反坦克手榴弹出现，一般使用磁性吸附在坦克表面，或者是粘性等方式进行定向爆炸，使用手榴弹中的聚能装药融化锥形铜罩来穿透装甲，例如的RPG-43手榴弹、英国No.74粘性反坦克手榴弹

游民星空
《解放2突破》中出现的RPG-43反坦克手榴弹和波波沙战斗马扎

炸药包等IED（简易爆炸装置）

　　炸药包的作战原理更是人尽皆知，许多电影都有反应，《地雷战》中也将这写简易爆炸物的作战效能描写的淋漓尽致，《集结号》更是有直接使用炸药包进行反坦克作业的演示。炸药包的杀伤机理是使用爆炸来震碎敌军坦克装甲、造成内部装备崩落，甚至可以震晕震死车组成员，乃至掀翻战车。

游民星空
被IED埋伏而击毁的M1

莫洛托夫鸡尾酒

　　在《拯救大兵瑞恩》中，大家一定对美军使用燃烧瓶报销德军雪貂自走炮印象深刻。历史上莫洛托夫鸡尾酒是土制燃烧弹的别称。莫洛托夫鸡尾酒是游击队等非正规部队、街头暴动群众的常用武器。其实最早使用土制燃烧弹作为反坦克武器的是苏联人在西班牙内战中的应用，不过后来却被芬兰人发扬光大。后来苏联在卫国战争面对着如潮水般的德国坦克时，又想到了这种可怕的武器。由于德国坦克的尾部往往是防御最少的，但恰恰是坦克发动机和油箱的所在之处。当莫诺托夫鸡尾酒在坦克的尾部燃烧时，可能令坦克的发动机过热而抛锚和油缸爆炸。当苏联士兵在近距离以燃烧弹快速突击，坦克的灵活性不足应付，于是陷入被动。这亦是莫洛托夫鸡尾酒在当时能“一战成名”的原因之一。二战东线战役中莫诺托夫鸡尾酒的使用达到顶峰，它最便宜有效的反坦克武器﹐对坦克的效能超过集束手榴弹，只要将它投入坦克脆弱的发动机排气口里，使用汽油机的德国坦克边很容易燃烧起火。后来这种便宜却易于制造的非制式武器也被战争双发大量使用，并出现在了《CS：GO》等多种游戏中，时至今日依旧活跃在冲突地区。

游民星空
《拯救大兵瑞恩》中出现的莫洛托夫鸡尾酒对黄鼠狼坦克歼击车攻击

游民星空
反坦克炮

　　当然，反坦克的话，还是得让专业的来，反坦克炮需要有初速快、弹道平直的特点，而早已发展成熟的高射炮同样具有这样的特点，于是在二战中，许多国家都推出了基于本国高射炮而衍生出的专业反坦克炮。

游民星空
中国86式100毫米滑膛炮

17磅反坦克炮

　　76.2mm的17磅反坦克炮是英国在二战设计和制造的。1940年开始设计——作为6磅反坦克炮的后继型号，1942年开始生产，1943年使用了25磅榴弹炮的炮架，并首次参战。17磅反坦克炮一般是牵引式的，当然，也大量的装备在英国坦克上作为坦克主炮使用。它是二战期间，盟军最有效的反坦克炮。当它使用脱壳穿甲弹（APDS）的时候，能对付德国最厚重的坦克装甲。17磅反坦克炮也被装在国外制造的坦克上面，比如装备在M4谢尔曼坦克上，改装成的萤火虫坦克，让英国的坦克部队有直接对抗德国坦克的能力。也是英国二战中最好的反坦克炮，曾打出波卡基村神话的米歇尔•魏特曼虎式就有被装备着17磅反坦克炮的萤火虫坦克击毁的传言。

游民星空
英国17磅反坦克炮开火瞬间

88毫米高射炮

　　作为二次世界大战中使用得最成功的火炮系统，一型非常成功的中口径高炮，但最为人津津乐道的却是它无与伦比的反坦克能力。88毫米高射炮无疑是成功的设计，在开发初期，88mm属于当时罕见的大口径，并使其赋予弹丸较高的炮口初速，这个特点为它日后成为有效的反坦克武器奠定了基础。后期德国人也以88毫米高射炮为蓝本推出了专职进行反坦克的Pak 43反坦克炮，甚至还将后续型号搬上了虎式、虎王坦克。在整个二战过程中，盟军任何型号的坦克都难以抵挡其正面进攻，巴巴罗萨行动中阻挡德军一个步兵师的KV-2坦克，便是被88炮击毁。值得说明的是，有人说88炮打坦克是是1940年五月隆美尔指挥的第七坦克师从比利时境内向敦克尔克高速挺进，中途遭遇一支英军的反冲击时炮兵们临时拍脑子的发现其实并不是。反坦克弹药与高射反战机弹药不同，需要特别研发并装备，88既然能对英军坦克做出有效的打击，说明在研发时便有此设计，且装备有专用的反坦克弹药。

游民星空

自行反坦克炮及坦克歼击车

　　虽然17磅和88炮可以提供性能优异的反坦克火力，可是这些武器的机动能力严重不足，只能使用车辆或人力拖曳，被发现了很可能被空军及炮兵洗地，于是反坦克火力的车载化是大势所趋，使用坦克底盘便是其中一个选择，为坦克换装更大威力的反坦克炮，让拖拽式反坦克炮摇身一变变为自行反坦克炮。

游民星空
奇葩的炮口朝向车尾的弓箭手自行反坦克炮，开火时驾驶员不能坐在自己的位置上，否则会被后坐力怼死

猎豹坦克歼击车

　　如果说二战中最优秀的自行反坦克炮是谁的话，猎豹绝对是有力的竞争者，猎豹自行反坦克炮基于豹式底盘改装，搭载了虎王使用的KwK43/L71型88mm加农炮，机动与火力上佳。“猎豹”坦克歼击车可以在2000m的射击距离上击穿除IS-2外所有对方坦克的装甲，这在二战期间是很少见的。德军规定，“猎豹”坦克歼击车只允许用来执行反坦克作战任务，由集团军指挥。可见，德军是把它当作重要的反坦克武器来使用的。该车的机动性能也不错，最大速度达到55km/h，行程显得小一些。猎豹坦克歼击车采用的黑豹坦克底盘，正面装甲的厚度与黑豹坦克一样，为80mm 55°倾角的装甲，可以抵御绝大多数盟军坦克的正面攻击，甚至是IS-2、潘兴坦克都无法有效的在较远距离击穿其正面装甲。而谢尔曼坦克或T-34坦克更是无能为力。而它惊人的火力可以在2000米轻松击毁绝大部分的盟军坦克。

游民星空
《战争雷霆》中的猎豹坦克歼击车

SU-152自行火炮

　　而来自苏联的SU-152自行火炮（二战时苏联没有对自行火炮与自行反坦克炮、坦克歼击车做出明确划分）则使用了KV-1s坦克的底盘，搭载一门ML-20型火炮，口径高达152mm，既可以进行直射反坦克作业，也可以知性曲射轰炸任务，1943年5月，苏联组建了第一个装备这种新型突击炮的团。苏军坦克手对这种新型突击炮反映很好，因为它能有效的对抗德军新型坦克（“虎”和“豹”）。库尔斯克战役中，SU-152突击炮得了一个新的呢称——“动物杀手”（德军坦克取名多为动物）。在12天的战斗中，该团就摧毁德军12辆“虎”式坦克和7辆“斐迪南”重型坦克歼击车。

游民星空
同样出现在《战争雷霆》中的SU-152自行火炮，他和猎豹究竟谁更强呢？

PTZ-89自行反坦克炮

　　PTZ-89自行反坦克炮是中国人民解放军的一种自行反坦克炮车，也是世界上第一种进入现役的120毫米自行反坦克炮。该炮的出现弥补了我军大口径自行反坦克炮的空白。此车主要配属于机械化师的自行火炮团内，兼任中口径自行火炮与反装甲火力，该炮的出现弥补了解放军陆军当时直瞄反装甲火力的不足，和我军大口径自行反坦克炮的空白。PTZ-89自行反坦克炮的内部结构来看，是典型的自行火炮的结构，装有解放军现役坦克装甲车辆中唯一规格的大口径加农炮，采用了与解放军新一代改进型坦克基本相同的火控系统，规格上明显比中型和主战坦克轻，全重仅31吨。

游民星空
国产PTZ-89自行反坦克炮开火瞬间
攻击机、强击机

　　看了不少地上的反坦克武器，我们来看看空中的威胁，由于空中打击手段的崛起，坦克受到的空中威胁越来越大，各国也积极推出俯冲轰炸机、强击机、攻击机来增强对地打击能力，坦克的日子不好过啊。

游民星空
越战中挂载马桶的A-1H攻击机

Ju87斯图卡俯冲轰炸机

　　在凡尔赛条约的限制下，德国被禁止拥有空军。但是，伴随着德国实力的恢复，希特勒宣称不再遵守这个约束。斯图卡俯冲轰炸机是由Hans Pohlmann 设计，并于1935年首次试飞，一战的王牌飞行员Robort Ritter von Greim试飞了这架世界上第一个具备专业反坦克能力的作战飞机。这架 JU-87是依循旧的经验制造的，但是Pohlmann赋予了它新的特性：能够垂直的向目标进行俯冲攻击，这种轰炸的精确程度远远超过了水平轰炸。德国空军的第一个俯冲轰炸机单位于1937年诞生，并且有一部分JU 87A-1S交付给派往西班牙执行军事干涉任务的空军部队。当时德国空军中的很多军官对斯图卡轰炸机并不感兴趣，认为其飞行速度太慢，且过于笨重，容易成为敌军战斗机的靶子。然而，斯图卡在西班牙优异的表现，终于赢得了大多数德国空军军官广泛的赞誉。JU-87作为一架出色的俯冲轰炸机，在不少的经典战役中基于他的优良性能都发挥出色。 同时德国又是一个充满王牌飞行员的强大国家。在列宁格勒战役中，当时驻扎在此的第7俯冲轰炸航空团发挥出色。其中王牌艾迪•埃特上尉出击50余次，共打击苏军坦克187辆、火炮526门，令苏军闻风丧胆，被授予铁十字勋章 。

游民星空
被称为尖啸死神的Ju87斯图卡

强-5

　　强-5强击机，是中国参照歼-6战斗机自行研制的一型单座双发超音速喷气强击机。中国空军组建之初，因沿海岛屿解放作战而十分重视对地攻击，并组建强击航空兵，配备从前苏联引进的伊尔-10强击机。在上个世纪五十年代初解放军攻占一江山岛等两栖作战中，苏制伊尔-10强击机作战能力突出，给中国军方留下深刻印象。后来为寻求后继机型，中国空军下达了超音速强击机的研制任务。强-5左右翼各一门23毫米机炮，可以用自身挂载的炸弹、导弹、火箭及机炮进行反坦克作战。

游民星空
强-5进行战术轰炸瞬间，注意机翼上的火箭巢

A-10

　　被称为疣猪的A-10雷电攻击机有着堪称强悍的对地攻击能力，A-10攻击机的前机身内左下侧安装了1门30mm的GAU-8型7管加特林式机炮，机炮安装的下俯角为2°。最大备弹量1350发。整个机炮系统重约1.8吨，每分钟可以发射4000发贫铀穿甲弹，在整个海湾战争144架A-10机群出了将近8100次任务，一共摧毁了伊拉克1,000台以上的坦克、2,000台其他战斗车辆以及1,200个火炮据点，外加部份的雷达设施和机动性高的飞毛腿导弹发射器。

游民星空
A-10和其装备的巨大加特林式机炮
武装直升机

　　空中的打击当然不仅仅停留在固定翼飞机上，直升机尤其是专业的现代武装直升机对坦克的威胁更为明显，因为武装直升机可快可悬停，同时拥有多种打击和发现坦克的手段，可以称得上树梢上的杀手。

游民星空
《荣誉勋章》中出现的武装直升机进攻场景

米-24

　　米-24雌鹿武装运输直升机是苏联米里直升机设计局设计的苏联也是世界的第一代武装加运输的多用途中型直升机。米-24在机头拥有一门双管30mm机炮，在机翼上可以挂载多种武器，从无制导火箭弹到专用反坦克导弹都可以选择，载重大、火力强、装甲厚的特点，不光可以提供直接的强大火力支援，还可以运载突击分队，或后送伤员。而且苏联飞行员还经常飞出不可思议的机动动作，比如横滚……

游民星空
米-24开火瞬间

AH-64D长弓阿帕奇武装直升机

　　美国AH-64D长弓阿帕奇直升机是AH-64阿帕奇武装直升机的改进型，其最明显的特点就是在旋翼上的一个长弓毫米波雷达，可以全天候搜索/跟踪十几公里范围内的地面目标，极大提高了飞机的战场侦察能力。长弓雷达天线安装在主旋翼轴的顶部，可进行360度的全向扫描，也可以对某个扇形区进行重点扫描，发现机载红外设备发现不了的伪装目标，并通过目标探测和分类设备将目标信号特性与数据库进行比较，依次排列出对载机的威胁等级，也让其携带16枚反坦克导弹或76枚70毫米火箭弹作战效能倍增。

游民星空

武直-10

　　而由昌河飞机工业（集团）有限责任公司中国直升机设计研究所设计的武直-10则是中国的骄傲，武直-10是中国人民解放军第一种专业武装直升机和亚洲各国第一种自研专业武装直升机。结束了中国人民解放军陆军航空兵长期依赖法国海豚直升机的改型兼当武装直升机的历史，大大提高了中国人民解放军陆军航空兵的航空突击与反装甲能力。武直-10配备一座旋转式机炮塔，机体两侧武器短翼可挂载反坦克导弹以及空空导弹，采用串列双座式设计，在设计上符合西方专业武装直升机的主要特征。2012年11月12日，直-10在第九届中国国际航空航天博览会中首次正式曝光。2012年11月18日，中国中央电视台公布的军事新闻中，直-10已经正式加入现役，开始列装中国人民解放军陆军航空兵部队。

游民星空
无后坐力炮及反坦克火箭筒：

　　看完了填上飞的，对于血肉之躯的步兵来说，最趁手同时也是反映最快捷的恐怕是各种各样的反坦克榴弹和一款趁手的筒子了，这些筒子反射弹丸的方式既有无后坐力炮原理也有火箭原理，构成了每个国家反坦克计划中最后的一环。

游民星空
美国的把组卡巴祖卡火箭筒

m18无后坐力炮

　　二战伊始，美国人的战术思想还比较落后，坦克的主要武器是机枪，反坦克武器基本等于没有（如果M2算的话那就是有），面对欧洲早已横扫法国的德军装甲部队杀伤能力严重不足，这样的情况自然是多路反坦克武器上马，1943年第一批M18很快就被运到了欧洲和太平洋战场，首个接收它们的部队是位于欧洲的第17伞兵师。虽然作为轻型武器来说，其高爆弹的威力不俗，但是破甲弹63.5毫米的贯穿能力就颇为使人失望了。与之相比，巴祖卡火箭筒的穿甲能力为120毫米。这主要是因为用以提高精确度的膛线减缓了炮弹的速度，降低了威力。在太平洋战区，官兵们表示新的57毫米无坐力炮是一种极为成功的“手提火炮”。1945年6月9日，M18在冲绳岛战役中首次投入使用，同时提供的配套炮弹为高爆弹和烟雾弹。在太平洋地形复杂的岛屿上同日军进行艰难的拉锯战时，M18是能够提供有效的炮火支援。士兵们唯一的怨言就是希望能够提供更多的炮弹。在朝鲜战争中，M18被用于摧毁敌人的机枪据点。作为反坦克武器则缺乏效率，要想用M18击穿T-34型坦克只有打击它的后面装甲才行。因而美军士兵更愿意使用口径更大的M20型超级巴祖卡来攻击T-34。国民革命军接收并在M18型无后座力炮的基础上仿制出了民国36型无后坐力炮，中国人民解放军获取胜利后将这些M18和其图纸加以研究，开发出了52式无后坐力炮。这种武器被运用在了越南战争中， 坦桑尼亚也获得了部分52式，52式可以同时使用美国和中国的弹药，而M18却不能使用它的炮弹。

游民星空
m18无后坐力炮，炮弹上的空洞就是用来平衡后座力的排气孔

RPG-7

　　RPG-7最初被苏联设计出来的时候就是要执行反坦克作战，经过不断的改进，尤其是对弹药的改进，让RPG-7获得了越来越好的破甲深度，采用PG-7V式火箭弹拥有将近264mm的破甲厚度，可是随着技术的进步爆炸反应装甲的出现，，破甲战斗部效果被严重削弱，于是设计师推出了拥有两个聚能装药战斗部的PG-7VR弹药，前端下战斗部引爆爆炸反应装甲后，主战斗部依然拥有600mm的穿甲能力。

游民星空

陶氏导弹

　　可是火箭弹毕竟射程有限且精度不佳，想要让步兵更加有效的进行反坦克作战还是需要导弹这种武器，尤其是重型反坦克导弹，其中陶氏反坦克导弹作为最著名的反坦克导弹家族一直服役至今，TOW意为管射、光学追踪、线控导引，是由雷声公司研发的反坦克和精确攻击导弹系统。陶氏导弹系统现在世界上最广泛使用的反坦克导弹，该导弹广泛部署在美军斯特瑞克、布拉德利和悍马装甲车上。最新版本的陶氏导弹采用无线电指令链路代替导线制导系统。该导弹也可配备串联战斗部或爆炸成型弹丸（EFP），由地面三脚架、装甲车和直升机发射，最大射程为4.5千米。


安装和登录命令：login、 shutdown、 halt、 reboot 、mount、umount 、chsh

文件处理命令：file、 mkdir、 grep、dd、 find、 mv 、ls 、diff、 cat、 ln

系统管理相关命令：df、 top、 free、 quota 、 groupadd kill、 crontab、 tar、last

网络操作命令：ifconfig、 ip 、ping 、 netstat 、telnet、 ftp、 route、 rlogin rcp 、finger 、mail 、nslookup

系统安全相关命令： passwd 、su、 umask 、chgrp、 chmod、chown、chattr、sudo、 pswho











##### **16.2 设置主机清单**

在初次使用Ansible服务时，大家可能会遇到这种情况：参数明明已经修改了，但却不生效。这是因为Ansible服务的主配置文件存在优先级的顺序关系，默认存放在/etc/ansible目录中的主配置文件优先级最低。如果在当前目录或用户家目录中也存放着一份主配置文件，则以当前目录或用户家目录中的主配置文件为主。同时存在多个Ansible服务主配置文件时，具体优先级顺序如表16-2所示。

表16-2                   Ansible服务主配置文件优先级顺序

| 优先级 | 文件位置                 |
| ------ | ------------------------ |
| 高     | ./ansible.cfg            |
| 中     | ~/.ansible.cfg           |
| 低     | /etc/ansible/ansible.cfg |



既然Ansible服务是用于实现主机批量自动化控制的管理工具，受管的主机一定不是一两台台，而是数十台甚至成百上千台，那么主机清单（inventory）在生产环境中就可以帮上大忙了。用户可以把要管理的主机IP地址预先写入/etc/ansible/hosts文件，这样后续再通过执行ansible命令来执行任务时就自动包含这些主机了，也就不需要每次都重复输入受管主机的地址了。例如，要管理5台主机，对应的IP地址如表16-3所示。

表16-3                   受管主机信息

| 操作系统 | IP地址        | 功能用途  |
| -------- | ------------- | --------- |
| RHEL 8   | 192.168.10.20 | dev       |
| RHEL 8   | 192.168.10.21 | test      |
| RHEL 8   | 192.168.10.22 | prod      |
| RHEL 8   | 192.168.10.23 | prod      |
| RHEL 8   | 192.168.10.24 | balancers |



首先需要说明的是，受管主机的系统默认使用RHEL 8，这是为了避免大家在准备实验机阶段产生歧义而给出的建议值，也可以用其他Linux系统。主机清单文件/etc/ansible/hosts中默认存在大量的注释信息，建议全部删除，然后替换成实验信息。

```
[root@linuxprobe ~]# vim /etc/ansible/hosts
192.168.10.20
192.168.10.21
192.168.10.22
192.168.10.23
192.168.10.24
```

为了增加实验难度，“通吃”生产环境中的常见需求，我们又为这5台主机分别规划了功能用途，有开发机（dev）、测试机（test）、产品机（prod）（两台）和负载均衡机（balancers）。在对主机进行分组标注后，后期在管理时就方便多了。

```
[root@linuxprobe ~]# vim /etc/ansible/hosts
[dev]
192.168.10.20
[test]
192.168.10.21
[prod]
192.168.10.22
192.168.10.23
[balancers]
192.168.10.24
```

主机清单文件在修改后会立即生效，一般使用“ansible-inventory --graph”命令以结构化的方式显示出受管主机的信息。因为我们对受管主机进行了分组，因此这种方式非常便于我们的阅读。

```
[root@linuxprobe ~]# ansible-inventory --graph
@all:
  |--@balancers:
  |  |--192.168.10.24
  |--@dev:
  |  |--192.168.10.20
  |--@prod:
  |  |--192.168.10.22
  |  |--192.168.10.23
  |--@test:
  |  |--192.168.10.21
  |--@ungrouped:
```

等等！先不要着急开始后面的实验。前文讲过，Ansible服务是基于SSH协议进行自动化控制的，这是开展后面实验的前提条件。第9章曾经讲到，sshd服务在初次连接时会要求用户接受一次对方主机的指纹信息。准备输入受管主机的账号和密码。例如，正常的第一次SSH远程连接过程是这样的：

```
[root@linuxprobe ~]# ssh 192.168.10.10
The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.
ECDSA key fingerprint is SHA256:QRW1wrqdwN0PI2bsUvBlW5XOIpBjE+ujCB8yiCqjMQQ.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.
root@192.168.10.10's password: 此处应输入管理员密码后回车确认
Activate the web console with: systemctl enable --now cockpit.socket

Last login: Mon Mar 29 06:30:15 2021
[root@linuxprobe ~]# 
```

众所周知，自动化运维的一个好处就是能提高工作效率。但是，如果每次执行操作都要输入受管主机的密码，也是比较麻烦的事情。好在Ansible服务已经对此有了解决办法，那就是使用如表16-4所示的变量。

表16-4                   Ansible常用变量汇总

| 参数                                             | 作用          |
| ------------------------------------------------ | ------------- |
| ansible_ssh_host                                 | 受管主机名    |
| ansible_ssh_port                                 | 端口号        |
| ansible_ssh_user                                 | 默认账号      |
| ansible_ssh_pass                                 | 默认密码      |
| ansible_[shell](https://www.linuxcool.com/)_type | Shell终端类型 |



用户只需要将对应的变量及信息填写到主机清单文件中，在执行任务时便会自动对账号和密码进行匹配，而不用每次重复输入它们。继续修改主机清单文件：

```
[root@linuxprobe ~]# vim /etc/ansible/hosts
[dev]
192.168.10.20
[test]
192.168.10.21
[prod]
192.168.10.22
192.168.10.23
[balancers]
192.168.10.24
[all:vars]
ansible_user=root
ansible_password=redhat
```

还剩最后一步。将Ansible主配置文件中的第71行设置成默认不需要SSH协议的指纹验证，以及将第107行设置成默认执行剧本时所使用的管理员名称为root：

```
[root@linuxprobe ~]# vim /etc/ansible/ansible.cfg
69
70 # uncomment this to disable SSH key host checking
71 host_key_checking = False
72
………………省略部分输出信息………………
104
105 # default user to use for playbooks if user is not specified
106 # (/usr/bin/ansible will use current user as default)
107 remote_user = root
108
```

不需要重启服务，在以上操作完全搞定后就可以开始后面的实验了。由于刚才是将Ansible服务器设置成了桥接及DHCP模式，现在请同学们自行将网络适配器修改回“仅主机模式”（见图16-3）以及192.168.10.10/24的IP地址。在修改完成后重启网卡，然后自行在主机之间执行ping操作。保证主机之间的网络能够互通是后续实验的基石。

```
[root@linuxprobe ~]# ifconfig
ens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.10.10  netmask 255.255.255.0  broadcast 192.168.10.255
        inet6 fe80::d0bb:17c8:880d:e719  prefixlen 64  scopeid 0x20
        ether 00:0c:29:7d:27:bf  txqueuelen 1000  (Ethernet)
        RX packets 32  bytes 5134 (5.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 43  bytes 4845 (4.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
………………省略部分输出信息………………
```

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/设置虚拟机网卡模式.png)

图16-3 将虚拟机网卡改回仅主机模式

##### **16.3 运行临时命令**

Ansible服务的强大之处在于只需要一条命令，便可以操控成千上万台的主机节点，而ansible命令便是最得力的工具之一。前文提到，Ansible服务实际上只是一个框架，能够完成工作的是模块化功能代码。Ansible的常用模块大致有20多个（见表16-5），本书将会在后面的实验中逐一详解。

偶尔遇到书中没有提及的模块，大家可以使用“ansible-doc模块名称”的命令格式自行查询，或是使用ansibe-doc -l命令列出所有的模块信息以供选择。

表16-5                   Ansible服务常用模块名称及作用

| 模块名称       | 模块作用                                 |
| -------------- | ---------------------------------------- |
| ping           | 检查受管节点主机网络是否能够联通。       |
| yum            | 安装、更新及卸载软件包。                 |
| yum_repository | 管理主机的软件仓库配置文件。             |
| template       | 复制模板文件到受管节点主机。             |
| copy           | 新建、修改及复制文件。                   |
| user           | 创建、修改及删除用户。                   |
| group          | 创建、修改及删除用户组。                 |
| service        | 启动、关闭及查看服务状态。               |
| get_url        | 从网络中下载文件。                       |
| file           | 设置文件权限及创建快捷方式。             |
| cron           | 添加、修改及删除计划任务。               |
| command        | 直接执行用户指定的命令。                 |
| shell          | 直接执行用户指定的命令（支持特殊字符）。 |
| debug          | 输出调试或报错信息。                     |
| mount          | 挂载硬盘设备文件。                       |
| filesystem     | 格式化硬盘设备文件。                     |
| lineinfile     | 通过正则表达式修改文件内容。             |
| setup          | 收集受管节点主机上的系统及变量信息。     |
| firewalld      | 添加、修改及删除防火墙策略。             |
| lvg            | 管理主机的物理卷及卷组设备。             |
| lvol           | 管理主机的逻辑卷设备。                   |



在Ansible服务中，ansible是用于执行临时任务的命令，也就在是执行后即结束（与剧本文件的可重复执行不同）。在使用ansible命令时，必须指明受管主机的信息，如果已经设置过主机清单文件（/etc/ansible/hosts），则可以使用all参数来指代全体受管主机，或是用dev、test等主机组名称来指代某一组的主机。

ansible命令常用的语法格式为“ansible受管主机节点 -m模块名称[-a模块参数]”，常见的参数如表16-6所示。其中，-a是要传递给模块的参数，只有功能极其简单的模块才不需要额外参数，所以大多情况下-m与-a参数都会同时出现。

表16-6                   ansible命令常用参数

| 参数      | 作用                    |
| --------- | ----------------------- |
| -k        | 手动输入SSH协议密码     |
| -i        | 指定主机清单文件        |
| -m        | 指定要使用的模块名      |
| -M        | 指定要使用的模块路径    |
| -S        | 使用su命令              |
| -T        | 设置SSH协议连接超时时间 |
| -a        | 设置传递给模块的参数    |
| --version | 查看版本信息            |
| -h        | 帮助信息                |



如果想实现某个功能，但是却不知道用什么模块，又或者是知道了模块名称，但不清楚模块具体的作用，则建议使用ansible-doc命令进行查找。例如，列举出当前Ansible服务所支持的所有模块信息：

```
[root@linuxprobe ~]# ansible-doc -l 
a10_server                                           Manage A10 Networks AX/SoftAX/Thunder/v...
a10_server_axapi3                                    Manage A10 Networks AX/SoftAX/Thunder/v...           
a10_service_group                                    Manage A10 Networks AX/SoftAX/Thunder/v...
a10_virtual_server                                   Manage A10 Networks AX/SoftAX/Thunder/v...
aci_aaa_user                                         Manage AAA users (aaa:User)                                              
aci_aaa_user_certificate                             Manage AAA user certificates (aaa:User...                        
aci_access_port_block_to_access_port                 Manage port blocks of Fabric interface ...
aci_access_port_to_interface_policy_leaf_profile     Manage Fabric interface policy leaf pro...
aci_access_sub_port_block_to_access_port             Manage sub port blocks of Fabric interf...
aci_aep                                              Manage attachable Access Entity Profile...
aci_aep_to_domain                                    Bind AEPs to Physical or Virtual Domain...   
aci_bd_subnet                                        Manage Subnets (fv:Subnet)                 
………………省略部分输出信息………………
```

一般情况下，很难通过名称来判别一个模块的作用，要么是参考模块后面的介绍信息，要么是平时多学多练，进行积累。例如，接下来随机查看一个模块的详细信息。ansible-doc命令会在屏幕上显示出这个模块的作用、可用参数及实例等信息：

```
[root@linuxprobe ~]# ansible-doc a10_server
> A10_SERVER    (/usr/lib/python3.6/site-packages/ansible/modules/network/a10/a10_server.py)

     Manage SLB (Server Load Balancer) server objects on A10 Networks devices via aXAPIv2.

  * This module is maintained by The Ansible Community
………………省略部分输出信息………………
```

在16.2节，已经成功地将受管主机的IP地址填写到主机清单文件中，接下来小试牛刀，检查一下这些主机的网络连通性。ping模块用于进行简单的网络测试（类似于常用的ping命令）。可以使用ansible命令直接针对所有主机调用ping模块，不需要增加额外的参数，返回值若为SUCCESS，则表示主机当前在线。

```
[root@linuxprobe ~]# ansible all -m ping
192.168.10.20 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
192.168.10.21 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
192.168.10.22 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
192.168.10.23 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}192.168.10.24 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false,
    "ping": "pong"
}
```

### **Tips**

由于5台受控主机的输出信息大致相同，因此为了提升读者的阅读体验，本章后续的输出结果默认仅保留192.168.10.20主机的输出值，其余相同的输出信息将会被省略。

是不是感觉很方便呢？！一次就能知道所有主机的在线情况。除了使用-m参数直接指定模块名称之外，还可以用-a参数将参数传递给模块，让模块的功能更高级，更好地满足当前生产的需求。例如，yum_repository模块的作用是管理主机的软件仓库，能够添加、修改及删除软件仓库的配置信息，参数相对比较复杂。遇到这种情况时，建议先用ansible-doc命令对其进行了解。尤其是下面的EXAMPLES结构段会有该模块的实例，对用户来说有非常高的参考价值。

```
[root@linuxprobe ~]# ansible-doc yum_repository
> YUM_REPOSITORY    (/usr/lib/python3.6/site-packages/ansible/modules/packaging>

        Add or remove YUM repositories in RPM-based Linux
        distributions. If you wish to update an existing repository
        definition use [ini_file] instead.

  * This module is maintained by The Ansible Core Team

……………………省略部分输出信息………………

EXAMPLES:

- name: Add repository
  yum_repository:
    name: epel
    description: EPEL YUM repo
    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/

- name: Add multiple repositories into the same file (1/2)
  yum_repository:
    name: epel
    description: EPEL YUM repo
    file: external_repos
    baseurl: https://download.fedoraproject.org/pub/epel/$releasever/$basearch/
    gpgcheck: no

- name: Add multiple repositories into the same file (2/2)
  yum_repository:
    name: rpmforge
    description: RPMforge YUM repo
    file: external_repos
    baseurl: http://apt.sw.be/redhat/el7/en/$basearch/rpmforge
```

还好，参数并不是很多，而且与此前学过的/etc/yum.repos.d/目录中的配置文件基本相似。现在，想为主机清单中的所有服务器新增一个如表16-7所示的软件仓库，该怎么操作呢？

表16-7                   新增软件仓库信息

| 仓库名称    | EX294_BASE                                     |
| ----------- | ---------------------------------------------- |
| 仓库描述    | EX294 base software                            |
| 仓库地址    | file:///media/cdrom/BaseOS                     |
| GPG签名     | 启用                                           |
| GPG密钥文件 | file:///media/cdrom/RPM-GPG-KEY-redhat-release |



我们可以对照着EXAMPLE实例段，逐一对应填写需求值和参数，其标准格式是在-a参数后接整体参数（用单引号圈起），而各个参数字段的值则用双引号圈起。这是最严谨的写法。在执行下述命令后如果出现CHANGED字样，则表示修改已经成功：

```
[root@linuxprobe ~]# ansible all -m yum_repository -a 'name="EX294_BASE" description="EX294 base software" baseurl="file:///media/cdrom/BaseOS" gpgcheck=yes enabled=1 gpgkey="file:///media/cdrom/RPM-GPG-KEY-redhat-release"'

192.168.10.20 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": true,
    "repo": "EX294_BASE",
    "state": "present"
}
```

在命令执行成功后，可以到主机清单中的任意机器上查看新建成功的软件仓库配置文件。尽管这个实验的参数很多，但是并不难。

```
[root@linuxprobe ~]# cat /etc/yum.repos.d/EX294_BASE.repo 
[EX294_BASE]
baseurl = file:///media/cdrom/BaseOS
enabled = 1
gpgcheck = 1
gpgkey = file:///media/cdrom/RPM-GPG-KEY-redhat-release
name = EX294 base software
```

##### **16.4 剧本文件实战**

在很多情况下，仅仅执行单个命令或调用某一个模块，根本无法满足复杂工作的需要。Ansible服务允许用户根据需求，在类似于Shell脚本的模式下编写自动化运维脚本，然后由程序自动、重复地执行，从而大大提高了工作效率。

Ansible服务的剧本（playbook）文件采用YAML语言编写，具有强制性的格式规范，它通过空格将不同信息分组，因此有时会因一两个空格错位而导致报错。大家在使用时要万分小心。YAML文件的开头需要先写3个减号（---），多个分组的信息需要间隔一致才能执行，而且上下也要对齐，后缀名一般为.yml。剧本文件在执行后，会在屏幕上输出运行界面，内容会根据工作的不同而变化。在运行界面中，绿色表示成功，黄色表示执行成功并进行了修改，而红色则表示执行失败。

剧本文件的结构由4部分组成，分别是target、variable、task、handler，其各自的作用如下。

> **target**：用于定义要执行剧本的主机范围。
>
> **variable**：用于定义剧本执行时要用到的变量。
>
> **task**：用于定义将在远程主机上执行的任务列表。
>
> **handler**：用于定义执行完成后需要调用的后续任务。

YAML语言编写的Ansible剧本文件会按照从上到下的顺序自动运行，其形式类似于第4章介绍的Shell脚本，但格式有严格的要求。例如，创建一个名为packages.yml的剧本，让dev、test和prod组的主机可以自动安装数据库软件，并且将dev组主机的软件更新至最新。

安装和更新软件需要使用yum模块。先看一下帮助信息中的示例吧：

```
[root@linuxprobe ~]# ansible-doc yum
> YUM    (/usr/lib/python3.6/site-packages/ansible/modules/packaging/os/yum.py)

        Installs, upgrade, downgrades, removes, and lists packages and
        groups with the `yum' package manager. This module only works
        on Python 2. If you require Python 3 support see the [dnf]
        module.

  * This module is maintained by The Ansible Core Team
  * note: This module has a corresponding action plugin.

………………省略部分输出信息………………

EXAMPLES:

- name: install the latest version of Apache
  yum:
    name: httpd
    state: latest
```

在配置Ansible剧本文件时，ansible-doc命令提供的帮助信息真是好用。在知道yum模块的使用方法和格式后，就可以开始编写剧本了。初次编写剧本文件时，请务必看准格式，模块及play（动作）格式也要上下对齐，否则会出现“参数一模一样，但不能执行”的情况。

综上，一个剧本正确的写法应该是：

```
[root@linuxprobe ~]# vim packages.yml
---
- name: 安装软件包
  hosts: dev,test,prod
  tasks:
          - name: one
            yum:
                    name: mariadb
                    state: latest
[root@linuxprobe ~]#
```

其中，name字段表示此项play（动作）的名字，用于在执行过程中提示用户执行到了哪一步，以及帮助管理员在日后阅读时能想起这段代码的作用。大家可以在name字段自行命名，没有任何限制。hosts字段表示要在哪些主机上执行该剧本，多个主机组之间用逗号间隔；如果需要对全部主机进行操作，则使用all参数。tasks字段用于定义要执行的任务，每个任务都要有一个独立的name字段进行命名，并且每个任务的name字段和模块名称都要严格上下对齐，参数要单独缩进。

而错误的剧本文件是下面这样的：

```
[root@linuxprobe ~]# vim packages.yml
---
- name: 安装软件包
  hosts: dev,test,prod
  tasks:
          - name: one
            yum:
            name: mariadb
            state: latest
```

大家可以感受到YAML语言对格式要求有多严格吧。

在编写Ansible剧本文件时，RHEL 8系统自带的Vim编辑器具有自动缩进功能，这可以给我们提供很多帮助。在确认无误后就可以用ansible-playbook命令运行这个剧本文件了。

```
[root@linuxprobe ~]# ansible-playbook packages.yml 

PLAY [安装软件包] *******************************************************************

TASK [Gathering Facts] **************************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]

TASK [one] **************************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]

PLAY RECAP **************************************************************************
192.168.10.20  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.21  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.22  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.23  : ok=2   changed=1  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
```

在执行成功后，我们主要观察最下方的输出信息。其中，ok和changed表示执行及修改成功。如遇到unreachable或failed大于0的情况，建议手动检查剧本是否在所有主机中都正确运行了，以及有无安装失败的情况。在正确执行过packages.yml文件后，随机切换到dev、test、prod组中的任意一台主机上，再次安装mariadb软件包，此时会提示该服务已经存在。这说明刚才的操作一切顺利！

```
[root@linuxprobe ~]# dnf install mariadb
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 1:05:53 ago on Thu 15 Apr 2021 08:29:11 AM CST.
Package mariadb-3:10.3.11-1.module+el8+2765+cfa4f87b.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
```

##### **16.5 创建及使用角色**

在日常编写剧本时，会存在剧本越来越长的情况，这不利于进行阅读和维护，而且还无法让其他剧本灵活地调用其中的功能代码。角色（role）这一功能则是自Ansible  1.2版本开始引入的新特性，用于层次性、结构化地组织剧本。角色功能分别把变量、文件、任务、模块及处理器配置放在各个独立的目录中，然后对其进行便捷加载。简单来说，角色功能是把常用的一些功能“类模块化”，然后在用的时候加载即可。

Ansible服务的角色功能类似于编程中的封装技术—将具体的功能封装起来，用户不仅可以方便地调用它，而且甚至可以不用完全理解其中的原理。就像普通消费者不需要深入理解汽车刹车是如何实现的，制动总泵、刹车分泵、真空助力器、刹车盘、刹车鼓、刹车片或ABS泵都藏于底层结构中，用户只需要用脚轻踩刹车踏板就能制动汽车。这便是技术封装的好处。

角色的好处就在于将剧本组织成了一个简洁的、可重复调用的抽象对象，使得用户把注意力放到剧本的宏观大局上，统筹各个关键性任务，只有在需要时才去深入了解细节。角色的获取有3种方法，分别是加载系统内置角色、从外部环境获取角色以及自行创建角色。

###### **16.5.1 加载系统内置角色**

在使用RHEL系统的内置角色时，我们不需要联网就能实现。用户只需要配置好软件仓库的配置文件，然后安装包含系统角色的软件包rhel-system-roles，随后便可以在系统中找到它们了，然后就能够使用剧本文件调用角色了。

```
[root@linuxprobe ~]# dnf install -y rhel-system-roles
Updating Subscription Management repositories.
Unable to read consumer identity
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Last metadata expiration check: 1:06:26 ago on Tue 13 Apr 2021 07:22:03 AM CST.
Dependencies resolved.
================================================================================
 Package                  Arch          Version          Repository        Size
================================================================================
Installing:
 rhel-system-roles        noarch        1.0-5.el8        AppStream        127 k

Transaction Summary
================================================================================
Install  1 Package

………………省略部分输出信息………………  

Installed:
  rhel-system-roles-1.0-5.el8.noarch                                            

Complete!
```

安装完毕后，使用ansible-galaxy list命令查看RHEL 8系统中有哪些自带的角色可用：

```
[root@linuxprobe ~]# ansible-galaxy list
# /usr/share/ansible/roles
- linux-system-roles.kdump, (unknown version)
- linux-system-roles.network, (unknown version)
- linux-system-roles.postfix, (unknown version)
- linux-system-roles.selinux, (unknown version)
- linux-system-roles.timesync, (unknown version)
- rhel-system-roles.kdump, (unknown version)
- rhel-system-roles.network, (unknown version)
- rhel-system-roles.postfix, (unknown version)
- rhel-system-roles.selinux, (unknown version)
- rhel-system-roles.timesync, (unknown version)
# /etc/ansible/roles
[WARNING]: - the configured path /root/.ansible/roles does not exist.
```

大家千万不要低估这些由系统镜像自带的角色，它们在日常的工作中能派上大用场。这些角色的主要功能如表16-8所示。

表16-8                   ansible系统角色描述

| 角色名称                   | 作用                  |
| -------------------------- | --------------------- |
| rhel-system-roles.kdump    | 配置kdump崩溃恢复服务 |
| rhel-system-roles.network  | 配置网络接口          |
| rhel-system-roles.selinux  | 配置SELinux策略及模式 |
| rhel-system-roles.timesync | 配置网络时间协议      |
| rhel-system-roles.postfix  | 配置邮件传输服务      |
| rhel-system-roles.firewall | 配置防火墙服务        |
| rhel-system-roles.tuned    | 配置系统调优选项      |



以rhel-system-roles.timesync角色为例，它用于设置系统的时间和NTP服务，让主机能够同步准确的时间信息。剧本模板文件存放在/usr/share/doc/rhel-system-roles/目录中，可以复制过来修改使用：

```
[root@linuxprobe ~]# cp /usr/share/doc/rhel-system-roles/timesync/example-timesync-playbook.yml timesync.yml
```

NTP服务器主要用于同步计算机的时间，可以提供高精度的时间校准服务，帮助计算机校对系统时钟。在复制来的剧本模板文件中，删除掉多余的代码，将NTP服务器的地址填写到timesync_ntp_servers变量的hostname字段中即可。该变量的参数含义如表16-9所示。稍后timesync角色就会自动为用户配置参数信息了。

表16-9                  timesync_ntp_servers变量参数含义

| 参数     | 作用            |
| -------- | --------------- |
| hostname | NTP服务器主机名 |
| iburst   | 启用快速同步    |



```
[root@linuxprobe ~]# vim timesync.yml 
---
- hosts: all
  vars:
    timesync_ntp_servers:
      - hostname: pool.ntp.org
        iburst: yes
  roles:
    - rhel-system-roles.timesync
```

###### **16.5.2 从外部获取角色**

Ansible Galaxy是Ansible的一个官方社区，用于共享角色和功能代码，用户可以在网站自由地共享和下载Ansible角色。该社区是管理和使用角色的不二之选。

在图16-4所示的Ansible  Galaxy官网中，左侧有3个功能选项，分别是首页（Home）、搜索（Search）以及社区（Community）。单击Search按钮进入到搜索界面，这里以nginx服务为例进行搜索，即可找到Nginx官方发布的角色信息，如图16-5所示。

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/首页-1024x387.png)

图 16-4 Ansible Galaxy 官网首页

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/搜索界面-1024x447.png)

图16-5 搜索界面中找到nginx角色信息

### **Tips**

Ansible Galaxy 官网首页：https://galaxy.ansible.com

当单击nginx角色进入到详情页面后，会显示这个项目的软件版本、评分、下载次数等信息。在Installation字段可以看到相应的安装方式，如图16-6所示。在保持虚拟机能够连接外网的前提下，可以按这个页面提示的命令进行安装。

这时，如果需要使用这个角色，可以在虚拟机联网的状态下直接按照“ansible-galaxy install角色名称”的命令格式自动获取：

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/Nginx-1024x377.png)

图16-6 nginx角色详情页

```
[root@linuxprobe ~]# ansible-galaxy install nginxinc.nginx
- downloading role 'nginx', owned by nginxinc
- downloading role from https://github.com/nginxinc/ansible-role-nginx/archive/0.19.1.tar.gz
- extracting nginxinc.nginx to /etc/ansible/roles/nginxinc.nginx
- nginxinc.nginx (0.19.1) was installed successfully
```

执行完毕后，再次查看系统中已有的角色，便可找到nginx角色信息了：

```
[root@linuxprobe ~]# ansible-galaxy list
# /etc/ansible/roles
- nginxinc.nginx, 0.19.1
# /usr/share/ansible/roles
- linux-system-roles.kdump, (unknown version)
- linux-system-roles.network, (unknown version)
- linux-system-roles.postfix, (unknown version)
- linux-system-roles.selinux, (unknown version)
- linux-system-roles.timesync, (unknown version)
- rhel-system-roles.kdump, (unknown version)
- rhel-system-roles.network, (unknown version)
- rhel-system-roles.postfix, (unknown version)
- rhel-system-roles.selinux, (unknown version)
- rhel-system-roles.timesync, (unknown version)
```

这里还存在两种特殊情况。

> 在国内访问Ansible Galaxy官网时可能存在不稳定的情况，导致访问不了或者网速较慢。
>
> 某位作者是将作品上传到了自己的网站，或者除Ansible Galaxy官网以外的其他平台。

在这两种情况下，就不能再用“ansible-galaxy install角色名称”的命令直接加载了，而是需要手动先编写一个YAML语言格式的文件，指明网址链接和角色名称，然后再用-r参数进行加载。

例如，刘遄老师在本书的配套网站（www.linuxprobe.com）上传了一个名为nginx_core的角色软件包（一个用于对nginx网站进行保护的插件）。这时需要编写如下所示的一个yml配置文件：

```
[root@linuxprobe ~]# cat nginx.yml
---
- src: https://www.linuxprobe.com/Software/nginxinc-nginx_core-0.3.0.tar.gz
  name: nginx-core
```

随后使用ansible-galaxy命令的-r参数加载这个文件，即可查看到新角色信息了：

```
[root@linuxprobe ~]# ansible-galaxy install -r nginx.yml
- downloading role from https://www.linuxprobe.com/nginxinc-nginx_core-0.3.0.tar.gz
- extracting nginx to /etc/ansible/roles/nginx
- nginx was installed successfully
[root@linuxprobe ~]# ansible-galaxy list
# /etc/ansible/roles
- nginx-core, (unknown version)
- nginxinc.nginx, 0.19.1
# /usr/share/ansible/roles
- linux-system-roles.kdump, (unknown version)
- linux-system-roles.network, (unknown version)
- linux-system-roles.postfix, (unknown version)
- linux-system-roles.selinux, (unknown version)
- linux-system-roles.timesync, (unknown version)
- rhel-system-roles.kdump, (unknown version)
- rhel-system-roles.network, (unknown version)
- rhel-system-roles.postfix, (unknown version)
- rhel-system-roles.selinux, (unknown version)
- rhel-system-roles.timesync, (unknown version)
```

###### **16.5.3 创建新的角色**

除了能够使用系统自带的角色和从Ansible Galaxy中获取的角色之外，也可以自行创建符合工作需求的角色。这种定制化的编写工作能够更好地贴合生产环境的实际情况，但难度也会稍高一些。

接下来将会创建一个名为apache的新角色，它能够帮助我们自动安装、运行httpd网站服务，设置防火墙的允许规则，以及根据每个主机生成独立的index.html首页文件。用户在调用这个角色后能享受到“一条龙”的网站部署服务。

在Ansible的主配置文件中，第68行定义的是角色保存路径。如果用户新建的角色信息不在规定的目录内，则无法使用ansible-galaxy  list命令找到。因此需要手动填写新角色的目录路径，或是进入/etc/ansible/roles目录内再进行创建。为了避免后期角色信息过于分散导致不好管理，我们还是决定在默认目录下进行创建，不再修改。

```
[root@linuxprobe roles]# vim /etc/ansible/ansible.cfg
 66 
 67 # additional paths to search for roles in, colon separated
 68 #roles_path    = /etc/ansible/roles
 69 
```

在ansible-galaxy命令后面跟一个init参数，创建一个新的角色信息，且建立成功后便会在当前目录下生成出一个新的目录：

```
[root@linuxprobe ~]# cd /etc/ansible/roles
[root@linuxprobe roles]# ansible-galaxy init apache
- Role apache was created successfully
[root@linuxprobe roles]# ls
apache nginx nginxinc.nginx
```

此时的apache即是角色名称，也是用于存在角色信息的目录名称。切换到该目录下，查看它的结构：

```
[root@linuxprobe roles]# cd apache
[root@linuxprobe apache]# ls
defaults  files  handlers  meta  README.md  tasks  templates  tests  vars
```

在创建新角色时，最关键的便是能够正确理解目录结构。通俗来说，就是要把正确的信息放入正确的目录中，这样在调用角色时才能有正确的效果。角色信息对应的目录结构及含义如表16-10所示。

表16-10                  Ansible角色目录结构及含义

| 目录      | 含义                                           |
| --------- | ---------------------------------------------- |
| defaults  | 包含角色变量的默认值（优先级低）。             |
| files     | 包含角色执行tasks任务时做引用的静态文件。      |
| handlers  | 包含角色的处理程序定义。                       |
| meta      | 包含角色的作者、许可证、频台和依赖关系等信息。 |
| tasks     | 包含角色所执行的任务。                         |
| templates | 包含角色任务所使用的Jinja2模板。               |
| tests     | 包含用于测试角色的剧本文件。                   |
| vars      | 包含角色变量的默认值（优先级高）。             |



下面准备创建新角色。

**第1步**：打开用于定义角色任务的tasks/main.yml文件。在该文件中不需要定义要执行的主机组列表，因为后面会单独编写剧本进行调用，此时应先对apache角色能做的事情（任务）有一个明确的思路，在调用角色后yml文件会按照从上到下的顺序自动执行。

> **任务1**：安装httpd网站服务。
>
> **任务2**：运行httpd网站服务，并加入到开机启动项中。
>
> **任务3**：配置防火墙，使其放行HTTP协议。
>
> **任务4**：根据每台主机的变量值，生成不同的主页文件。

先写出第一个任务。使用yum模块安装httpd网站服务程序（注意格式）：

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
```

第2步：使用service模块启动httpd网站服务程序，并加入到启动项中，保证能够一直为用户提供服务。在初次使用模块前，先用ansible-doc命令查看一下帮助和实例信息。由于篇幅的限制，这里对信息进行了删减，仅保留了有用的内容。

```
[root@linuxprobe apache]# ansible-doc service
> SERVICE    (/usr/lib/python3.6/site-packages/ansible/modules/system/service.py)

        Controls services on remote hosts. Supported init systems
        include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.
        For Windows targets, use the [win_service] module instead.

  * This module is maintained by The Ansible Core Team
  * note: This module has a corresponding action plugin.

………………省略部分输出信息………………

EXAMPLES:

- name: Start service httpd, if not started
  service:
    name: httpd
    state: started

- name: Enable service httpd, and not touch the state
  service:
    name: httpd
    enabled: yes
```

真幸运，默认的EXAMPLES示例使用的就是httpd网站服务。通过输出信息可得知，启动服务为“state: started”参数，而加入到开机启动项则是“enabled: yes”参数。继续编写：

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
- name: two
  service:
          name: httpd
          state: started
          enabled: yes
```

第3步：配置防火墙的允许策略，让其他主机可以正常访问。在配置防火墙时，需要使用firewalld模块。同样也是先看一下帮助示例：

```
[root@linuxprobe defaults]# ansible-doc firewalld
> FIREWALLD    (/usr/lib/python3.6/site-packages/ansible/modules/system/firewalld.py)

        This module allows for addition or deletion of services and
        ports (either TCP or UDP) in either running or permanent
        firewalld rules.

  * This module is maintained by The Ansible Community
OPTIONS (= is mandatory):
EXAMPLES:

- firewalld:
    service: https
    permanent: yes
    state: enabled

- firewalld:
    port: 8081/tcp
    permanent: yes
    state: disabled
    immediate: yes
```

依据输出信息可得知，在firewalld模块设置防火墙策略时，指定协议名称为“service: http”参数，放行该协议为“state: enabled”参数，设置为永久生效为“permanent: yes”参数，当前立即生效为“immediate:  yes”参数。参数虽然多了一些，但是基本与在第8章节学习的一致，并不需要担心。继续编写：

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
- name: two
  service:
          name: httpd
          state: started
          enabled: yes
- name: three
  firewalld:
          service: http
          permanent: yes
          state: enabled
          immediate: yes
```

第4步：让每台主机显示的主页文件均不相同。在使用Ansible的常规模块时，都是采用“查询版主示例并模仿”的方式搞定的，这里为了增加难度，我们再提出个新需求，即能否让每台主机上运行的httpd网站服务都能显示不同的内容呢？例如显示当前服务器的主机名及IP地址。这就要用到template模块及Jinja2技术了。

我们依然使用ansible-doc命令来查询template模块的使用方法。示例部分依然大有帮助：

```
[root@linuxprobe apache]# ansible-doc template
> TEMPLATE    (/usr/lib/python3.6/site-packages/ansible/modules/files/template.>

        Templates are processed by the L(Jinja2 templating
        language,http://jinja.pocoo.org/docs/). Documentation on the
        template formatting can be found in the L(Template Designer
        Documentation,http://jinja.pocoo.org/docs/templates/).
        Additional variables listed below can be used in templates.
        `ansible_managed' (configurable via the `defaults' section of
        `ansible.cfg') contains a string which can be used to describe
        the template name, host, modification time of the template
        file and the owner uid. `template_host' contains the node name
        of the template's machine. `template_uid' is the numeric user
        id of the owner. `template_path' is the path of the template.
        `template_fullpath' is the absolute path of the template.
        `template_destpath' is the path of the template on the remote
        system (added in 2.8). `template_run_date' is the date that
        the template was rendered.

  * This module is maintained by The Ansible Core Team
  * note: This module has a corresponding action plugin.

………………省略部分输出信息………………

EXAMPLES:

- name: Template a file to /etc/files.conf
  template:
    src: /mytemplates/foo.j2
    dest: /etc/file.conf
    owner: bin
    group: wheel
    mode: '0644'
```

从template模块的输出信息中可得知，这是一个用于复制文件模板的模块，能够把文件从Ansible服务器复制到受管主机上。其中，src参数用于定义本地文件的路径，dest参数用于定义复制到受管主机的文件路径，而owner、group、mode参数可选择性地设置文件归属及权限信息。

正常来说，我们可以直接复制文件的操作，受管主机上会获取到一个与Ansible服务器上的文件一模一样的文件。但有时候，我们想让每台客户端根据自身系统的情况产生不同的文件信息，这就需要用到Jinja2技术了，Jinja2格式的模板文件后缀是.j2。继续编写：

```
[root@linuxprobe apache]# vim tasks/main.yml
---
- name: one
  yum:
          name: httpd
          state: latest
- name: two
  service:
          name: httpd
          state: started
          enabled: yes
- name: three
  firewalld:
          service: http
          permanent: yes
          state: enabled
          immediate: yes
- name: four
  template:
          src: index.html.j2
          dest: /var/www/html/index.html
```

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/jinja.png)

Jinja2是Python语言中一个被广泛使用的模板引擎，最初的设计思想源自Django的模块引擎。Jinja2基于此发展了其语法和一系列强大的功能，能够让受管主机根据自身变量产生出不同的文件内容。换句话说，正常情况下的复制操作会让新旧文件一模一样，但在使用Jinja2技术时，不是在原始文件中直接写入文件内容，而是写入一系列的变量名称。在使用template模块进行复制的过程中，由Ansible服务负责在受管主机上收集这些变量名称所对应的值，然后再逐一填写到目标文件中，从而让每台主机的文件都根据自身系统的情况独立生成。

例如，想要让每个网站的输出信息值为“Welcome  to主机名on主机地址”，也就是用每个主机自己独有的名称和IP地址来替换文本中的内容，这样就有趣太多了。这个实验的难点在于查询到对应的变量名称、主机名及地址所对应的值保存在哪里？可以用setup模块进行查询。

```
[root@linuxprobe apache]# ansible-doc setup
> SETUP    (/usr/lib/python3.6/site-packages/ansible/modules/system/setup.py)

        This module is automatically called by playbooks to gather
        useful variables about remote hosts that can be used in
        playbooks. It can also be executed directly by
        `/usr/bin/ansible' to check what variables are available to a
        host. Ansible provides many `facts' about the system,
        automatically. This module is also supported for Windows
        targets.
```

setup模块的作用是自动收集受管主机上的变量信息，使用-a参数外加filter命令可以对收集来的信息进行二次过滤。相应的语法格式为ansible all -m setup -a  'filter="*关键词*"'，其中*号是第3章节讲到的通配符，用于进行关键词查询。例如，如果想搜索各个主机的名称，可以使用通配符搜索所有包含fqdn关键词的变量值信息。

FQDN（Fully Qualified Domain  Name，完全限定域名）用于在逻辑上准确表示出主机的位置。FQDN常常被作为主机名的完全表达形式，比/etc/hostname文件中定义的主机名更加严谨和准确。通过输出信息可得知，ansible_fqdn变量保存有主机名称。随后进行下一步操作：

```
[root@linuxprobe ~]# ansible all -m setup -a 'filter="*fqdn*"'
192.168.10.20 | SUCCESS => {
    "ansible_facts": {
        "ansible_fqdn": "linuxprobe.com",
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false
}
………………省略部分输出信息………………
```

用于指定主机地址的变量可以用ip作为关键词进行检索。可以看到，ansible_all_ipv4_addresses变量中的值是我们想要的信息。如果想输出IPv6形式的地址，则可用ansible_all_ipv6_addresses变量。

```
[root@linuxprobe ~]# ansible all -m setup -a 'filter="*ip*"'
192.168.10.20 | SUCCESS => {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "192.168.10.20",
            "192.168.122.1"
        ],
        "ansible_all_ipv6_addresses": [
            "fe80::d0bb:17c8:880d:e719"
        ],
        "ansible_default_ipv4": {},
        "ansible_default_ipv6": {},
        "ansible_fips": false,
        "discovered_interpreter_python": "/usr/libexec/platform-python"
    },
    "changed": false
}
………………省略部分输出信息………………
```

在确认了主机名与IP地址所对应的具体变量名称后，在角色所对应的templates目录内新建一个与上面的template模块参数相同的文件名称（index.html.j2）。Jinja2在调用变量值时，格式为在变量名称的两侧格加两个大括号：

```
[root@linuxprobe apache]# vim templates/index.html.j2
Welcome to {{ ansible_fqdn }} on {{ ansible_all_ipv4_addresses }}
```

进行到这里，任务基本就算完成了。最后要做的就是编写一个用于调用apache角色的yml文件，以及执行这个文件。

```
[root@linuxprobe apache]# cd ~
[root@linuxprobe ~]# vim roles.yml
---
- name: 调用自建角色
  hosts: all
  roles:
          - apache
[root@linuxprobe ~]# ansible-playbook roles.yml 
PLAY [调用自建角色] **************************************************************************

TASK [Gathering Facts] **********************************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]
ok: [192.168.10.24]

TASK [apache : one] *************************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
changed: [192.168.10.24]

TASK [apache : two] *************************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
changed: [192.168.10.24]

TASK [apache : three] ***********************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
changed: [192.168.10.24]

TASK [apache : four] ***********************************************************************
changed: [192.168.10.20]
changed: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23] 
changed: [192.168.10.24]

PLAY RECAP **********************************************************************************
192.168.10.20   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.21   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.22   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.23   : ok=5   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0   
192.168.10.24   : ok=4   changed=4  unreachable=0   failed=0   skipped=0   rescued=0   ignored=0
```

执行完毕后，在浏览器中随机输入几台主机的IP地址，即可访问到包含主机FQDN和IP地址的网页了，如图16-7～图16-9所示。

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/访问网站-1024x170.png)

图16-7 随机访问一台主机节点的网站首页

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/2-34-1024x160.png)

图16-8 随机访问一台主机节点的网站首页![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/3-15-1024x166.png)

图16-9 随机访问一台主机节点的网站首页

实验相当成功！



##### **16.6 创建和使用逻辑卷**

创建一个能批量、自动管理逻辑卷设备的剧本，不但能大大提高硬盘设备的管理效率，而且还能避免手动创建带来的错误。例如，我们想在每台受管主机上都创建出一个名为data的逻辑卷设备，大小为150MB，归属于research卷组。如果创建成功，则进一步用Ext4文件系统进行格式化操作；如果创建失败，则给用户输出一条报错提醒，以便排查原因。

在这种情况下，使用Ansible剧本要比使用Shell脚本的优势大，原因主要有下面两点。

> Ansible模块化的功能让操作更标准，只要在执行过程中无报错，那么便会依据远程主机的系统版本及配置自动做出判断和操作，不用担心因系统变化而导致命令失效的问题。
>
> Ansible服务在执行剧本文件时会进行判断：如果该文件或该设备已经被创建过，或是某个动作（play）已经被执行过，则绝对不会再重复执行；而使用Shell脚本有可能导致设备被重复格式化，导致数据丢失。

首先在prod组的两台主机上分别添加一块硬盘设备，大小为20GB，类型为SCSI，其余选项选择默认值，如图16-10～图16-12所示。

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/1-42.png)

图16-10 添加一块新硬盘
 ![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/2-33.png)

图16-11 设置硬盘类型

![第16章 使用Ansible服务实现自动化运维第16章 使用Ansible服务实现自动化运维](https://www.linuxprobe.com/wp-content/uploads/2021/03/3-14.png)

图16-12 新硬盘添加完毕

通过回忆第7章学习过的逻辑卷的知识，我们应该让剧本文件依次创建物理卷（PV）、卷组（VG）及逻辑卷（LV）。需要先使用lvg模块让设备支持逻辑卷技术，然后创建一个名为research的卷组。lvg模块的帮助信息如下：

```
[root@linuxprobe ~]# ansible-doc lvg
> LVG    (/usr/lib/python3.6/site-packages/ansible/modules/system/lvg.py)

        This module creates, removes or resizes volume groups.

  * This module is maintained by The Ansible Community

………………省略部分输出信息………………

EXAMPLES:

- name: Create a volume group on top of /dev/sda1 with physical extent size = 3>
  lvg:
    vg: vg.services
    pvs: /dev/sda1
    pesize: 32

- name: Create a volume group on top of /dev/sdb with physical extent size = 12>
  lvg:
    vg: vg.services
    pvs: /dev/sdb
    pesize: 128K
```

通过输出信息可得知，创建PV和VG的lvg模块总共有3个必备参数。其中，vg参数用于定义卷组的名称，pvs参数用于指定硬盘设备的名称，pesize参数用于确定最终卷组的容量大小（可以用PE个数或容量值进行指定）。这样一来，我们先创建出一个由/dev/sdb设备组成的名称为research、大小为150MB的卷组设备。

```
[root@linuxprobe ~]# vim lv.yml
---
- name: 创建和使用逻辑卷
  hosts: all
  tasks:
          - name: one
            lvg:
                    vg: research
                    pvs: /dev/sdb
                    pesize: 150M
```

由于刚才只在prod组的两台主机上添加了新硬盘设备文件，因此在执行上述操作时其余3台主机会提示未创建成功，这属于正常情况。接下来使用lvol模块创建出逻辑卷设备。还是按照惯例，先查看模块的帮助信息：

```
[root@linuxprobe ~]# ansible-doc lvol
> LVOL    (/usr/lib/python3.6/site-packages/ansible/modules/system/lvol.py)

        This module creates, removes or resizes logical volumes.

  * This module is maintained by The Ansible Community

………………省略部分输出信息………………

EXAMPLES:

- name: Create a logical volume of 512m
  lvol:
    vg: firefly
    lv: test
    size: 512

- name: Create a logical volume of 512m with disks /dev/sda and /dev/sdb
  lvol:
    vg: firefly
    lv: test
    size: 512
    pvs: /dev/sda,/dev/sdb
```

通过输出信息可得知，lvol是用于创建逻辑卷设备的模块。其中，vg参数用于指定卷组名称，lv参数用于指定逻辑卷名称，size参数则用于指定最终逻辑卷设备的容量大小（不用加单位，默认为MB）。填写好参数，创建出一个大小为150MB、归属于research卷组且名称为data的逻辑卷设备：

```
[root@linuxprobe ~]# vim lv.yml
---
- name: 创建和使用逻辑卷
  hosts: all
  tasks:
          - name: one
            lvg:
                    vg: research
                    pvs: /dev/sdb
                    pesize: 150M
          - name: two
            lvol:
                    vg: research
                    lv: data
                    size: 150M
```

这样还不够好，如果还能将创建出的/dev/research/data逻辑卷设备自动用Ext4文件系统进行格式化操作，则又能帮助运维管理员减少一些工作量。可使用filesystem模块来完成设备的文件系统格式化操作。该模块的帮助信息如下：

```
[root@linuxprobe ~]# ansible-doc filesystem
> FILESYSTEM    (/usr/lib/python3.6/site-packages/ansible/modules/system/filesy>

        This module creates a filesystem.

  * This module is maintained by The Ansible Community

………………省略部分输出信息………………

EXAMPLES:

- name: Create a ext2 filesystem on /dev/sdb1
  filesystem:
    fstype: ext2
    dev: /dev/sdb1
```

filesystem模块的参数真是简练，fstype参数用于指定文件系统的格式化类型，dev参数用于指定要格式化的设备文件路径。继续编写：

```
[root@linuxprobe ~]# vim lv.yml
---
- name: 创建和使用逻辑卷
  hosts: all
  tasks:
          - name: one
            lvg:
                    vg: research
                    pvs: /dev/sdb
                    pesize: 150M
          - name: two
            lvol:
                    vg: research
                    lv: data
                    size: 150M
          - name: three
            filesystem:
                    fstype: ext4
                    dev: /dev/research/data 
```

这样按照顺序执行下来，逻辑卷设备就能够自动创建好了。等一下，还有个问题没有解决。现在只有prod组的主机上添加了新的硬盘设备文件，其余主机是无法按照既定模块顺利完成操作的。这时就要使用类似于第4章学习的if条件语句的方式进行判断—如果失败……，则……。

首先用block操作符将上述的3个模块命令作为一个整体（相当于对这3个模块的执行结果作为一个整体进行判断），然后使用rescue操作符进行救援，且只有block块中的模块执行失败后才会调用rescue中的救援模块。其中，debug模块的msg参数的作用是，如果block中的模块执行失败，则输出一条信息到屏幕，用于提醒用户。完成编写后的剧本是下面这个样子：

```
[root@linuxprobe ~]# vim lv.yml
---
- name: 创建和使用逻辑卷
  hosts: all
  tasks:
          - block:
                  - name: one
                    lvg:
                            vg: research
                            pvs: /dev/sdb
                            pesize: 150M
                  - name: two
                    lvol:
                            vg: research
                            lv: data
                            size: 150M
                  - name: three
                    filesystem:
                            fstype: ext4
                            dev: /dev/research/data
            rescue:
                    - debug:
                            msg: "Could not create logical volume of that size"
```

YAML语言对格式有着硬性的要求，既然rescue是对block内的模块进行救援的功能代码，因此recue和block两个操作符必须严格对齐，错开一个空格都会导致剧本执行失败。确认无误后，执行lv.yml剧本文件检阅一下效果：

```
[root@linuxprobe ~]# ansible-playbook lv.yml 

PLAY [创建和使用逻辑卷] *********************************************************

TASK [Gathering Facts] *********************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]
ok: [192.168.10.24]

TASK [one] *********************************************************************
fatal: [192.168.10.20]: FAILED! => {"changed": false, "msg": "Device /dev/sdb not found."}
fatal: [192.168.10.21]: FAILED! => {"changed": false, "msg": "Device /dev/sdb not found."}
changed: [192.168.10.22]
changed: [192.168.10.23]
fatal: [192.168.10.24]: FAILED! => {"changed": false, "msg": "Device /dev/sdb not found."}

TASK [two] *********************************************************************
changed: [192.168.10.22]
changed: [192.168.10.23]

TASK [three] *********************************************************************
changed: [192.168.10.22]
changed: [192.168.10.23]

TASK [debug] *******************************************************************
ok: [192.168.10.20] => {
    "msg": "Could not create logical volume of that size"
}
ok: [192.168.10.21] => {
    "msg": "Could not create logical volume of that size"
}
ok: [192.168.10.24] => {
    "msg": "Could not create logical volume of that size"
}

PLAY RECAP *********************************************************************
192.168.10.20  : ok=2  changed=0  unreachable=0  failed=0  skipped=0  rescued=1  ignored=0   
192.168.10.21  : ok=2  changed=0  unreachable=0  failed=0  skipped=0  rescued=1  ignored=0   
192.168.10.22  : ok=4  changed=3  unreachable=0  failed=0  skipped=0  rescued=0  ignored=0   
192.168.10.23  : ok=4  changed=3  unreachable=0  failed=0  skipped=0  rescued=0  ignored=0   
192.168.10.24  : ok=2  changed=0  unreachable=0  failed=0  skipped=0  rescued=1  ignored=0 
```

在剧本运行完毕后的执行记录（PLAY  RECAP）中可以很清晰地看到只有192.168.10.22及192.168.10.23这两台prod组中的主机执行成功了，其余3台主机均触发了rescue功能。登录到任意一台prod组的主机上，找到新建的逻辑卷设备信息：

```
[root@linuxprobe ~]# lvdisplay 
  --- Logical volume ---
  LV Path                /dev/research/data
  LV Name                data
  VG Name                research
  LV UUID                EOUliC-tbkk-kOJR-8NaH-O9XQ-ijrK-TgEYGj
  LV Write Access        read/write
  LV Creation host, time linuxprobe.com, 2021-04-23 11:00:21 +0800
  LV Status              available
  # open                 0
  LV Size                5.00 GiB
  Current LE             1
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2
………………省略部分输出信息………………
```

##### **16.7 判断主机组名**

在上面的剧本实验中，我们可以让不同的主机根据自身不同的变量信息而生成出独特的网站主页文件，但却无法对某个主机组进行针对性的操作。其实，在每个客户端中都会有一个名为inventory_hostname的变量，用于定义每台主机所对应的Ansible服务的主机组名称，也就是/etc/ansible/hosts文件中所对应的分组信息，例如dev、test、prod、balancers。

inventory_hostname是Ansible服务中的魔法变量，这意味着无法使用setup模块直接进行查询，诸如ansible  all -m setup -a 'filter="*关键词*"'这样的命令将对它失效。魔法变量需要在执行剧本文件时的Gathering  Facts阶段进行搜集，直接查询是看不到的，只能在剧本文件中进行调用。

在获得了存储主机组名称的变量名称后，接下来开始实战。这里的需求如下：

> 若主机在dev分组中，则修改/etc/issue文件内容为Development；
>
> 若主机在test分组中，则修改/etc/issue文件内容为Test；
>
> 若主机在prod分组中，则修改/etc/issue文件内容为Production。

根据表16-5所提及的Ansible常用模块名称及作用，可以看到copy模块的主要作用是新建、修改及复制文件，更符合当前的需要，此时便派上了用场。先查询copy模块的帮助信息：

```
[root@linuxprobe ~]# ansible-doc copy
> COPY    (/usr/lib/python3.6/site-packages/ansible/modules/files/copy.py)

        The `copy' module copies a file from the local or remote
        machine to a location on the remote machine. Use the [fetch]
        module to copy files from remote locations to the local box.
        If you need variable interpolation in copied files, use the
        [template] module. Using a variable in the `content' field
        will result in unpredictable output. For Windows targets, use
        the [win_copy] module instead.

  * This module is maintained by The Ansible Core Team
  * note: This module has a corresponding action plugin.

………………省略部分输出信息………………

EXAMPLES:

- name: Copy file with owner and permissions
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: '0644'

- name: Copy using inline content
  copy:
    content: '# This file was moved to /etc/other.conf'
    dest: /etc/mine.conf
```

在输出信息中列举了两种管理文件内容的示例。第一种用于文件的复制行为，第二种是通过content参数定义内容，通过dest参数指定新建文件的名称。显然，第二种更加符合当前的实验场景。编写剧本文件如下：

```
[root@linuxprobe ~]# vim issue.yml
---
- name: 修改文件内容
  hosts: all
  tasks:
          - name: one
            copy:
                    content: 'Development'
                    dest: /etc/issue
          - name: two
            copy:
                    content: 'Test'
                    dest: /etc/issue
          - name: three
            copy:
                    content: 'Production'
                    dest: /etc/issue
```

但是，如果按照这种顺序执行下去，每一台主机的/etc/issue文件都会被重复修改3次，最终定格在“Production”字样，这显然缺少了一些东西。我们应该依据inventory_hostname变量中的值进行判断。若主机为dev组，则执行第一个动作；若主机为test组，则执行第二个动作；若主机为prod组，则执行第三个动作。因此，要进行3次判断。

when是用于判断的语法，我们将其用在每个动作的下方进行判断，使得只有在满足条件才会执行：

```
[root@linuxprobe ~]# vim issue.yml
---
- name: 修改文件内容
  hosts: all
  tasks:
          - name: one
            copy:
                    content: 'Development'
                    dest: /etc/issue
            when: "inventory_hostname in groups.dev"
          - name: two
            copy:
                    content: 'Test'
                    dest: /etc/issue
            when: "inventory_hostname in groups.test"
          - name: three
            copy:
                    content: 'Production'
                    dest: /etc/issue
            when: "inventory_hostname in groups.prod"
```

执行剧本文件，在过程中可清晰地看到由于when语法的作用，未在指定主机组中的主机将被跳过（skipping）：

```
[root@linuxprobe ~]# ansible-playbook issue.yml 

PLAY [修改文件内容] ************************************************************************

TASK [Gathering Facts] ********************************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]
ok: [192.168.10.24]

TASK [one] ********************************************************************************
changed: [192.168.10.20]
skipping: [192.168.10.21]
skipping: [192.168.10.22]
skipping: [192.168.10.23] 
skipping: [192.168.10.24]

TASK [two] ********************************************************************************
skipping: [192.168.10.20]
changed: [192.168.10.21]
skipping: [192.168.10.23]
skipping: [192.168.10.24]
skipping: [192.168.10.25]

TASK [three] ******************************************************************************
skipping: [192.168.10.20]
skipping: [192.168.10.21]
changed: [192.168.10.22]
changed: [192.168.10.23]
skipping: [192.168.10.24]

PLAY RECAP ********************************************************************************
192.168.10.20   : ok=2  changed=1  unreachable=0  failed=0  skipped=2  rescued=0  ignored=0   
192.168.10.21   : ok=2  changed=1  unreachable=0  failed=0  skipped=2  rescued=0  ignored=0   
192.168.10.22   : ok=2  changed=1  unreachable=0  failed=0  skipped=2  rescued=0  ignored=0   
192.168.10.23   : ok=2  changed=1  unreachable=0  failed=0  skipped=2  rescued=0  ignored=0 
192.168.10.24   : ok=1  changed=0  unreachable=0  failed=0  skipped=3  rescued=0  ignored=0 
```

登录到dev组的192.168.10.20主机上，查看文件内容：

```
[root@linuxprobe ~]# cat /etc/issue 
Development
```

登录到test组的192.168.10.21主机上，查看文件内容：

```
[root@linuxprobe ~]# cat /etc/issue 
Test
```

登录到prod组的192.168.10.22/23主机上，查看文件内容：

```
[root@linuxprobe ~]# cat /etc/issue 
Production
```

##### **16.8 管理文件属性**

我们学习剧本的目的是为了满足日常的工作需求，把重复的事情写入到脚本中，然后再批量执行下去，从而提高运维工作的效率。其中，创建文件、管理权限以及设置快捷方式几乎是每天都用到的技能。尤其是在第5章学习文件的一般权限、特殊权限、隐藏权限时，往往还会因命令的格式问题而导致出错。这么多命令该怎么记呢？

Ansible服务将常用的文件管理功能都合并到了file模块中，大家不用再为了寻找模块而“东奔西跑”了。先来看一下file模块的帮助信息：

```
[root@linuxprobe ~]# ansible-doc file
> FILE    (/usr/lib/python3.6/site-packages/ansible/modules/files/file.py)

        Set attributes of files, symlinks or directories.
        Alternatively, remove files, symlinks or directories. Many
        other modules support the same options as the `file' module -
        including [copy], [template], and [assemble]. For Windows
        targets, use the [win_file] module instead.

  * This module is maintained by The Ansible Core Team

………………省略部分输出信息………………

EXAMPLES:

- name: Change file ownership, group and permissions
  file:
    path: /etc/foo.conf
    owner: foo
    group: foo
    mode: '0644'

- name: Create a symbolic link
  file:
    src: /file/to/link/to
    dest: /path/to/symlink
    owner: foo
    group: foo
    state: link

- name: Create a directory if it does not exist
  file:
    path: /etc/some_directory
    state: directory
    mode: '0755'

- name: Remove file (delete file)
  file:
    path: /etc/foo.txt
    state: absent
```

通过上面的输出示例，大家已经能够了解file模块的基本参数了。其中，path参数定义了文件的路径，owner参数定义了文件所有者，group参数定义了文件所属组，mode参数定义了文件权限，src参数定义了源文件的路径，dest参数定义了目标文件的路径，state参数则定义了文件类型。

可见，file模块基本上把第5章学习过的管理文件权限的功能都包含在内了。我们来就来挑战下面的实验吧：

> 请创建出一个名为/linuxprobe的新目录，所有者及所属组均为root管理员身份；
>
> 设置所有者和所属于组拥有对文件的完全控制权，而其他人则只有阅读和执行权限；
>
> 给予SGID特殊权限；
>
> 仅在dev主机组的主机上实施。

第二条要求是算术题，即将权限描述转换为数字表示法，即可读为4、可写为2、可执行为1。大家可以先自行默默计算一下答案。此前在编写剧本文件时，hosts参数对应的一直是all，即全体主机，这次需要修改为仅对dev主机组成员生效，请小心谨慎。编写模块代码如下：

```
[root@linuxprobe ~]# vim chmod.yml
---
- name: 管理文件属性
  hosts: dev
  tasks:
          - name: one
            file:
                    path: /linuxprobe
                    state: directory 
                    owner: root
                    group: root
                    mode: '2775'
```

一不小心把题目出简单了，这里没能完全展示出file模块的强大之处。我们临时添加一个需求：请再创建一个名称为/linuxcool的快捷方式文件，指向刚刚建立的/linuxprobe目录。这样用户在访问两个目录时就能有相同的内容了。在使用file模块设置快捷方式时，不需要再单独创建目标文件，Ansible服务会帮我们完成：

```
[root@linuxprobe ~]# vim chmod.yml
---
- name: 管理文件属性
  hosts: dev
  tasks:
          - name: one
            file:
                    path: /linuxprobe
                    state: directory 
                    owner: root
                    group: root
                    mode: '2775'
          - name: two
            file:
                    src: /linuxprobe
                    dest: /linuxcool
                    state: link
```

剧本文件的执行过程如下所示：

```
[root@linuxprobe ~]# ansible-playbook chmod.yml 

PLAY [管理文件属性] ***************************************************************

TASK [Gathering Facts] ***********************************************************
ok: [192.168.10.20]
ok: [192.168.10.21]
ok: [192.168.10.22]
ok: [192.168.10.23]
ok: [192.168.10.24]

TASK [one] ***********************************************************************
changed: [192.168.10.20]
skipping: [192.168.10.21]
skipping: [192.168.10.22]
skipping: [192.168.10.23]
skipping: [192.168.10.24]

TASK [two] ***********************************************************************
changed: [192.168.10.20]
skipping: [192.168.10.21]
skipping: [192.168.10.22]
skipping: [192.168.10.23]
skipping: [192.168.10.24]

PLAY RECAP ***********************************************************************
192.168.10.20   : ok=3  changed=2  unreachable=0  failed=0  skipped=0  rescued=0  ignored=0   
192.168.10.22   : ok=1  changed=0  unreachable=0  failed=0  skipped=3  rescued=0  ignored=0
192.168.10.22   : ok=1  changed=0  unreachable=0  failed=0  skipped=3  rescued=0  ignored=0
192.168.10.22   : ok=1  changed=0  unreachable=0  failed=0  skipped=3  rescued=0  ignored=0
192.168.10.22   : ok=1  changed=0  unreachable=0  failed=0  skipped=3  rescued=0  ignored=0
```

进入到dev组的主机中，可以看到/linuxprobe目录及/linuxcool的快捷方式均已经被顺利创建：

```
[root@linuxprobe ~]# ls -ld /linuxprobe
drwxrwsr-x. 2 root root 6 Apr 20 09:52 /linuxprobe
[root@linuxprobe ~]# ls -ld /linuxcool
lrwxrwxrwx. 1 root root 11 Apr 20 09:52 /linuxcool -> /linuxprobe
```

##### **16.9 管理密码库文件**

自Ansible  1.5版本发布后，vault作为一项新功能进入到了运维人员的视野。它不仅能对密码、剧本等敏感信息进行加密，而且还可以加密变量名称和变量值，从而确保数据不会被他人轻易阅读。使用ansible-vault命令可以实现内容的新建（create）、加密（encrypt）、解密（decrypt）、修改密码（rekey）及查看（view）等功能。

下面通过示例来学习vault的具体用法。

第1步：创建出一个名为locker.yml的配置文件，其中保存了两个变量值：

```
[root@linuxprobe ~]# vim locker.yml
---
pw_developer: Imadev
pw_manager: Imamgr
```

第2步：使用ansible-vault命令对文件进行加密。由于需要每次输入密码比较麻烦，因此还应新建一个用于保存密码值的文本文件，以便让ansible-vault命令自动调用。为了保证数据的安全性，在新建密码文件后将该文件的权限设置为600，确保仅管理员可读可写：

```
[root@linuxprobe ~]# vim /root/secret.txt
whenyouwishuponastar
[root@linuxprobe ~]# chmod 600 /root/secret.txt
```

在Ansible服务的主配置文件中，在第140行的vault_password_file参数后指定密码值保存的文件路径，准备进行调用：

```
[root@linuxprobe ~]# vim /etc/ansible/ansible.cfg
137 
138 # If set, configures the path to the Vault password file as an alternative to
139 # specifying --vault-password-file on the command line.
140 vault_password_file = /root/secret.txt
141 
```

第3步：在设置好密码文件的路径后，Ansible服务便会自动进行加载。用户也就不用在每次加密或解密时都重复输入密码了。例如，在加密刚刚创建的locker.yml文件时，只需要使用encrypt参数即可：

```
[root@linuxprobe ~]# ansible-vault encrypt locker.yml
Encryption successful
```

文件将使用AES 256加密方式进行加密，也就是意味着密钥有2256种可能。查看到加密后的内容为：

```
[root@linuxprobe ~]# cat locker.yml 
$ANSIBLE_VAULT;1.1;AES256
38653234313839336138383931663837333533396161343730353530313038313631653439366335
3432346333346239386334663836643432353434373733310a306662303565633762313232663763
38366334316239376262656230643531656665376166663635656436363338626464333430343162
6664643035316133650a333331393538616130656136653630303239663561663237373733373638
62383234303061623865633466336636363961623039343236356336356361613736333739623961
6334303865663838623363333339396637363061626363383266
```

如果不想使用原始密码了呢？也可以使用rekey参数手动对文件进行改密操作，同时应结合--ask-vault-pass参数进行修改，否则Ansible服务会因接收不到用户输入的旧密码值而拒绝新的密码变更请求：

```
[root@linuxprobe ~]# ansible-vault rekey --ask-vault-pass locker.yml 
Vault password: 输入旧的密码
New Vault password: 输入新的密码
Confirm New Vault password: 再输入新的密码
Rekey successful
```

第4步：如果想查看和修改加密文件中的内容，该怎么操作呢？对于已经加密过的文件，需要使用ansible-vault命令的edit参数进行修改，随后用view参数即可查看到修改后的内容。ansible-vault命令对加密文件的编辑操作默认使用的是Vim编辑器，在修改完毕后请记得执行wq操作保存后退出：

```
[root@linuxprobe ~]# ansible-vault edit locker.yml
---
pw_developer: Imadev
pw_manager: Imamgr
pw_production: Imaprod
```

最后，再用view参数进行查看，便是最新的内容了：

```
[root@linuxprobe ~]# ansible-vault view locker.yml
Vault password: 输入密码后敲击回车确认
--- 
pw_developer: Imadev 
pw_manager: Imamgr 
pw_production: Imaprod
```