# Using Ansible modules and plugins[](https://docs.ansible.com/ansible/latest/module_plugin_guide/index.html#using-ansible-modules-and-plugins)

Note

**Making Open Source More Inclusive**

Red Hat is committed to replacing problematic language in our code,  documentation, and web properties. We are beginning with these four  terms: master, slave, blacklist, and whitelist. We ask that you open an  issue or pull request if you come upon a term that we have missed. For  more details, see [our CTO Chris Wright’s message](https://www.redhat.com/en/blog/making-open-source-more-inclusive-eradicating-problematic-language).

Welcome to the Ansible guide for working with modules, plugins, and collections.

Ansible modules are units of code that can control system resources or execute system commands. Ansible provides a module library that you can execute directly on remote hosts or through playbooks. You can also write custom modules.

Similar to modules are plugins, which are pieces of code that extend core Ansible functionality. Ansible uses a plugin architecture to enable a rich, flexible, and expandable feature set. Ansible ships with several plugins and lets you easily use your own plugins.

- [Introduction to modules](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_intro.html)
- Module maintenance and support
  - [Maintenance](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#maintenance)
  - [Issue Reporting](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#issue-reporting)
  - [Support](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#support)
- [Rejecting modules](https://docs.ansible.com/ansible/latest/module_plugin_guide/plugin_filtering_config.html)
- Working with plugins
  - [Action plugins](https://docs.ansible.com/ansible/latest/plugins/action.html)
  - [Become plugins](https://docs.ansible.com/ansible/latest/plugins/become.html)
  - [Cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html)
  - [Callback plugins](https://docs.ansible.com/ansible/latest/plugins/callback.html)
  - [Cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html)
  - [Connection plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html)
  - [Docs fragments](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html)
  - [Filter plugins](https://docs.ansible.com/ansible/latest/plugins/filter.html)
  - [Httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html)
  - [Inventory plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.html)
  - [Lookup plugins](https://docs.ansible.com/ansible/latest/plugins/lookup.html)
  - [Modules](https://docs.ansible.com/ansible/latest/plugins/module.html)
  - [Module utilities](https://docs.ansible.com/ansible/latest/plugins/module_util.html)
  - [Netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html)
  - [Shell plugins](https://docs.ansible.com/ansible/latest/plugins/shell.html)
  - [Strategy plugins](https://docs.ansible.com/ansible/latest/plugins/strategy.html)
  - [Terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html)
  - [Test plugins](https://docs.ansible.com/ansible/latest/plugins/test.html)
  - [Vars plugins](https://docs.ansible.com/ansible/latest/plugins/vars.html)
- [Modules and plugins index](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_plugins_index.html)

# Introduction to modules[](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_intro.html#introduction-to-modules)

Modules (also referred to as “task plugins” or “library plugins”) are discrete units of code that can be used from the command line or in a  playbook task. Ansible executes each module, usually on the remote  managed node, and collects return values. In Ansible 2.10 and later,  most modules are hosted in collections.

You can execute modules from the command line.

```
ansible webservers -m service -a "name=httpd state=started"
ansible webservers -m ping
ansible webservers -m command -a "/sbin/reboot -t now"
```

Each module supports taking arguments.  Nearly all modules take `key=value` arguments, space delimited.  Some modules take no arguments, and the  command/shell modules simply take the string of the command you want to  run.

From playbooks, Ansible modules are executed in a very similar way.

```
- name: reboot the servers
  command: /sbin/reboot -t now
```

Another way to pass arguments to a module is using YAML syntax, also called ‘complex args’.

```
- name: restart webserver
  service:
    name: httpd
    state: restarted
```

All modules return JSON format data. This means modules can be  written in any programming language. Modules should be idempotent, and  should avoid making any changes if they detect that the current state  matches the desired final state. When used in an Ansible playbook,  modules can trigger ‘change events’ in the form of notifying [handlers](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_handlers.html#handlers) to run additional tasks.

You can access the documentation for each module from the command line with the ansible-doc tool.

```
ansible-doc yum
```

For a list of all available modules, see the [Collection docs](https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections), or run the following at a command prompt.

```
ansible-doc -l
```

# Module maintenance and support[](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#module-maintenance-and-support)

If you are using a module and you discover a bug, you may want to  know where to report that bug, who is responsible for fixing it, and how you can track changes to the module. If you are a Red Hat subscriber,  you may want to know whether you can get support for the issue you are  facing.

Starting in Ansible 2.10, most modules live in collections. The  distribution method for each collection reflects the maintenance and  support for the modules in that collection.

- [Maintenance](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#maintenance)
- [Issue Reporting](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#issue-reporting)
- [Support](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#support)

## [Maintenance](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#id2)[](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#maintenance)

| Collection                    | Code location                                                | Maintained by            |
| ----------------------------- | ------------------------------------------------------------ | ------------------------ |
| ansible.builtin               | [ansible/ansible repo](https://github.com/ansible/ansible/tree/devel/lib/ansible/modules) on GitHub | core team                |
| distributed on Galaxy         | various; follow `repo` link                                  | community or partners    |
| distributed on Automation Hub | various; follow `repo` link                                  | content team or partners |

## [Issue Reporting](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#id3)[](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#issue-reporting)

If you find a bug that affects a plugin in the main Ansible repo, also known as `ansible-core`:

> 1. Confirm that you are running the latest stable version of Ansible or the devel branch.
> 2. Look at the [issue tracker in the Ansible repo](https://github.com/ansible/ansible/issues) to see if an issue has already been filed.
> 3. Create an issue if one does not already exist. Include as much detail as you can about the behavior you discovered.

If you find a bug that affects a plugin in a Galaxy collection:

> 1. Find the collection on Galaxy.
> 2. Find the issue tracker for the collection.
> 3. Look there to see if an issue has already been filed.
> 4. Create an issue if one does not already exist. Include as much detail as you can about the behavior you discovered.

Some partner collections may be hosted in private repositories.

If you are not sure whether the behavior you see is a bug, if you  have questions, if you want to discuss development-oriented topics, or  if you just want to get in touch, use one of our Google mailing lists or chat channels (using Matrix at ansible.im or using IRC at [irc.libera.chat](https://libera.chat/)) to [communicate with Ansiblers](https://docs.ansible.com/ansible/latest/community/communication.html#communication).

If you find a bug that affects a module in an Automation Hub collection:

> 1. If the collection offers an Issue Tracker link on Automation Hub, click there and open an issue on the collection repository. If it does  not, follow the standard process for reporting issues on the [Red Hat Customer Portal](https://access.redhat.com/). You must have a subscription to the Red Hat Ansible Automation Platform to create an issue on the portal.

## [Support](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#id4)[](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_support.html#support)

All plugins that remain in `ansible-core` and all collections hosted in Automation Hub are supported by Red Hat.  No other plugins or collections are supported by Red Hat. If you have a  subscription to the Red Hat Ansible Automation Platform, you can find  more information and resources on the [Red Hat Customer Portal.](https://access.redhat.com/)

# Rejecting modules[](https://docs.ansible.com/ansible/latest/module_plugin_guide/plugin_filtering_config.html#rejecting-modules)

If you want to avoid using certain modules, you can add them to a  reject list to prevent Ansible from loading them. To reject plugins,  create a yaml configuration file. The default location for this file is `/etc/ansible/plugin_filters.yml`. You can select a different path for the reject list using the [PLUGIN_FILTERS_CFG](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#plugin-filters-cfg) setting in the `defaults` section of your ansible.cfg. Here is an example reject list:

```
---
filter_version: '1.0'
module_rejectlist:
  # Deprecated
  - docker
  # We only allow pip, not easy_install
  - easy_install
```

The file contains two fields:

> - A file version so that you can update the format while keeping  backwards compatibility in the future. The present version should be the string, `"1.0"`
> - A list of modules to reject. Ansible will not load any module in this list when it searches for a module to invoke for a task.

# Working with plugins[](https://docs.ansible.com/ansible/latest/plugins/plugins.html#working-with-plugins)

Plugins are pieces of code that augment Ansible’s core functionality. Ansible uses a plugin architecture to enable a rich, flexible and  expandable feature set.

Ansible ships with a number of handy plugins, and you can easily write your own.

This section covers the various types of plugins that are included with Ansible:

- [Action plugins](https://docs.ansible.com/ansible/latest/plugins/action.html)
- [Become plugins](https://docs.ansible.com/ansible/latest/plugins/become.html)
- [Cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html)
- [Callback plugins](https://docs.ansible.com/ansible/latest/plugins/callback.html)
- [Cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html)
- [Connection plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html)
- [Docs fragments](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html)
- [Filter plugins](https://docs.ansible.com/ansible/latest/plugins/filter.html)
- [Httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html)
- [Inventory plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.html)
- [Lookup plugins](https://docs.ansible.com/ansible/latest/plugins/lookup.html)
- [Modules](https://docs.ansible.com/ansible/latest/plugins/module.html)
- [Module utilities](https://docs.ansible.com/ansible/latest/plugins/module_util.html)
- [Netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html)
- [Shell plugins](https://docs.ansible.com/ansible/latest/plugins/shell.html)
- [Strategy plugins](https://docs.ansible.com/ansible/latest/plugins/strategy.html)
- [Terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html)
- [Test plugins](https://docs.ansible.com/ansible/latest/plugins/test.html)
- [Vars plugins](https://docs.ansible.com/ansible/latest/plugins/vars.html)

# Action plugins[](https://docs.ansible.com/ansible/latest/plugins/action.html#action-plugins)

- [Enabling action plugins](https://docs.ansible.com/ansible/latest/plugins/action.html#enabling-action-plugins)
- [Using action plugins](https://docs.ansible.com/ansible/latest/plugins/action.html#using-action-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/action.html#plugin-list)

Action plugins act in conjunction with [modules](https://docs.ansible.com/ansible/6/user_guide/modules.html#working-with-modules) to execute the actions required by playbook tasks. They usually execute automatically in the background doing prerequisite work before modules  execute.

The ‘normal’ action plugin is used for modules that do not already have an action plugin. If necessary, you can [create custom action plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-actions).



## [Enabling action plugins](https://docs.ansible.com/ansible/latest/plugins/action.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/action.html#enabling-action-plugins)

You can enable a custom action plugin by either dropping it into the `action_plugins` directory adjacent to your play, inside a role, or by putting it in one of the action plugin directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).



## [Using action plugins](https://docs.ansible.com/ansible/latest/plugins/action.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/action.html#using-action-plugins)

Action plugin are executed by default when an associated module is used; no action is required.

## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/action.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/action.html#plugin-list)

You cannot list action plugins directly, they show up as their counterpart modules:

Use `ansible-doc -l` to see the list of available modules. Use `ansible-doc <name>` to see specific documentation and examples, this should note if the module has a corresponding action plugin.

# Become plugins[](https://docs.ansible.com/ansible/latest/plugins/become.html#become-plugins)

- [Enabling Become Plugins](https://docs.ansible.com/ansible/latest/plugins/become.html#enabling-become-plugins)
- [Using Become Plugins](https://docs.ansible.com/ansible/latest/plugins/become.html#using-become-plugins)
- [Plugin List](https://docs.ansible.com/ansible/latest/plugins/become.html#plugin-list)

New in version 2.8.

Become plugins work to ensure that Ansible can use certain privilege escalation systems when running the basic commands to work with the target machine as well as the modules required to execute the tasks specified in the play.

These utilities (`sudo`, `su`, `doas`, and so on) generally let you ‘become’ another user to execute a command with the permissions of that user.



## [Enabling Become Plugins](https://docs.ansible.com/ansible/latest/plugins/become.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/become.html#enabling-become-plugins)

The become plugins shipped with Ansible are already enabled. Custom plugins can be added by placing them into a `become_plugins` directory adjacent to your play, inside a role, or by placing them in one of the become plugin directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).



## [Using Become Plugins](https://docs.ansible.com/ansible/latest/plugins/become.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/become.html#using-become-plugins)

In addition to the default configuration settings in [Ansible Configuration Settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) or the `--become-method` command line option, you can use the `become_method` keyword in a play or, if you need to be ‘host specific’, the connection variable `ansible_become_method` to select the plugin to use.

You can further control the settings for each plugin via other configuration options detailed in the plugin themselves (linked below).



## [Plugin List](https://docs.ansible.com/ansible/latest/plugins/become.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/become.html#plugin-list)

You can use `ansible-doc -t become -l` to see the list of available plugins. Use `ansible-doc -t become <plugin name>` to see specific documentation and examples.

# Cache plugins[](https://docs.ansible.com/ansible/latest/plugins/cache.html#cache-plugins)

- [Enabling fact cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html#enabling-fact-cache-plugins)
- [Enabling inventory cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html#enabling-inventory-cache-plugins)
- [Using cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html#using-cache-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/cache.html#plugin-list)

Cache plugins allow Ansible to store gathered facts or inventory  source data without the performance hit of retrieving them from source.

The default cache plugin is the [memory](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/memory_cache.html#memory-cache) plugin, which only caches the data for the current execution of  Ansible. Other plugins with persistent storage are available to allow  caching the data across runs. Some of these cache plugins write to  files, others write to databases.

You can use different cache plugins for inventory and facts. If you  enable inventory caching without setting an inventory-specific cache  plugin, Ansible uses the fact cache plugin for both facts and inventory. If necessary, you can [create custom cache plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-cache-plugins).



## [Enabling fact cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/cache.html#enabling-fact-cache-plugins)

Fact caching is always enabled. However, only one fact cache plugin  can be active at a time. You can select the cache plugin to use for fact caching in the Ansible configuration, either with an environment  variable:

```
export ANSIBLE_CACHE_PLUGIN=jsonfile
```

or in the `ansible.cfg` file:

```
[defaults]
fact_caching=redis
```

If the cache plugin is in a collection use the fully qualified name:

```
[defaults]
fact_caching = namespace.collection_name.cache_plugin_name
```

To enable a custom cache plugin, save it in a `cache_plugins` directory adjacent to your play, inside a role, or in one of the directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).

You also need to configure other settings specific to each plugin. Consult the individual plugin documentation or the Ansible [configuration](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) for more details.

## [Enabling inventory cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/cache.html#enabling-inventory-cache-plugins)

Inventory caching is disabled by default. To cache inventory data,  you must enable inventory caching and then select the specific cache  plugin you want to use. Not all inventory plugins support caching, so  check the documentation for the inventory plugin(s) you want to use. You can enable inventory caching with an environment variable:

```
export ANSIBLE_INVENTORY_CACHE=True
```

or in the `ansible.cfg` file:

```
[inventory]
cache=True
```

or if the inventory plugin accepts a YAML configuration source, in the configuration file:

```
# dev.aws_ec2.yaml
plugin: aws_ec2
cache: True
```

Only one inventory cache plugin can be active at a time. You can set it with an environment variable:

```
export ANSIBLE_INVENTORY_CACHE_PLUGIN=jsonfile
```

or in the ansible.cfg file:

```
[inventory]
cache_plugin=jsonfile
```

or if the inventory plugin accepts a YAML configuration source, in the configuration file:

```
# dev.aws_ec2.yaml
plugin: aws_ec2
cache_plugin: jsonfile
```

To cache inventory with a custom plugin in your plugin path, follow the [developer guide on cache plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-cache-plugins).

To cache inventory with a cache plugin in a collection, use the FQCN:

```
[inventory]
cache_plugin=collection_namespace.collection_name.cache_plugin
```

If you enable caching for inventory plugins without selecting an  inventory-specific cache plugin, Ansible falls back to caching inventory with the fact cache plugin you configured. Consult the individual  inventory plugin documentation or the Ansible [configuration](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) for more details.



## [Using cache plugins](https://docs.ansible.com/ansible/latest/plugins/cache.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/cache.html#using-cache-plugins)

Cache plugins are used automatically once they are enabled.



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/cache.html#id5)[](https://docs.ansible.com/ansible/latest/plugins/cache.html#plugin-list)

You can use `ansible-doc -t cache -l` to see the list of available plugins. Use `ansible-doc -t cache <plugin name>` to see specific documentation and examples.

# Callback plugins[](https://docs.ansible.com/ansible/latest/plugins/callback.html#callback-plugins)

- [Example callback plugins](https://docs.ansible.com/ansible/latest/plugins/callback.html#example-callback-plugins)
- [Enabling callback plugins](https://docs.ansible.com/ansible/latest/plugins/callback.html#enabling-callback-plugins)
- [Setting a callback plugin for `ansible-playbook`](https://docs.ansible.com/ansible/latest/plugins/callback.html#setting-a-callback-plugin-for-ansible-playbook)
- [Setting a callback plugin for ad hoc commands](https://docs.ansible.com/ansible/latest/plugins/callback.html#setting-a-callback-plugin-for-ad-hoc-commands)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/callback.html#plugin-list)

Callback plugins enable adding new behaviors to Ansible when  responding to events. By default, callback plugins control most of the  output you see when running the command line programs, but can also be  used to add additional output, integrate with other tools and marshal  the events to a storage backend. If necessary, you can [create custom callback plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-callbacks).



## [Example callback plugins](https://docs.ansible.com/ansible/latest/plugins/callback.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/callback.html#example-callback-plugins)

The [log_plays](https://docs.ansible.com/ansible/2.9/plugins/callback/log_plays.html#log-plays-callback) callback is an example of how to record playbook events to a log file, and the [mail](https://docs.ansible.com/ansible/2.9/plugins/callback/mail.html#mail-callback) callback sends email on playbook failures.

The [say](https://docs.ansible.com/ansible/2.9/plugins/callback/say.html#say-callback) callback responds with computer synthesized speech in relation to playbook events.



## [Enabling callback plugins](https://docs.ansible.com/ansible/latest/plugins/callback.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/callback.html#enabling-callback-plugins)

You can activate a custom callback by either dropping it into a `callback_plugins` directory adjacent to your play, inside a role, or by putting it in one of the callback directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).

Plugins are loaded in alphanumeric order. For example, a plugin implemented in a file named 1_first.py would run before a plugin file named 2_second.py.

Most callbacks shipped with Ansible are disabled by default and need to be enabled in your [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) file in order to function. For example:

```
#callbacks_enabled = timer, mail, profile_roles, collection_namespace.collection_name.custom_callback
```

## [Setting a callback plugin for `ansible-playbook`](https://docs.ansible.com/ansible/latest/plugins/callback.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/callback.html#setting-a-callback-plugin-for-ansible-playbook)

You can only have one plugin be the main manager of your console  output. If you want to replace the default, you should define  CALLBACK_TYPE = stdout in the subclass and then configure the stdout  plugin in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings). For example:

```
stdout_callback = dense
```

or for my custom callback:

```
stdout_callback = mycallback
```

This only affects [ansible-playbook](https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html#ansible-playbook) by default.

## [Setting a callback plugin for ad hoc commands](https://docs.ansible.com/ansible/latest/plugins/callback.html#id5)[](https://docs.ansible.com/ansible/latest/plugins/callback.html#setting-a-callback-plugin-for-ad-hoc-commands)

The [ansible](https://docs.ansible.com/ansible/latest/cli/ansible.html#ansible) ad hoc command specifically uses a different callback plugin for stdout, so there is an extra setting in [Ansible Configuration Settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) you need to add to use the stdout callback defined above:

```
[defaults]
bin_ansible_callbacks=True
```

You can also set this as an environment variable:

```
export ANSIBLE_LOAD_CALLBACK_PLUGINS=1
```



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/callback.html#id6)[](https://docs.ansible.com/ansible/latest/plugins/callback.html#plugin-list)

You can use `ansible-doc -t callback -l` to see the list of available plugins. Use `ansible-doc -t callback <plugin name>` to see specific documents and examples.

# Cliconf plugins[](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#cliconf-plugins)

- [Adding cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#adding-cliconf-plugins)
- [Using cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#using-cliconf-plugins)
- [Viewing cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#viewing-cliconf-plugins)

Cliconf plugins are abstractions over the CLI interface to network  devices. They provide a standard interface for Ansible to execute tasks  on those network devices.

These plugins generally correspond one-to-one to network device  platforms. Ansible loads the appropriate cliconf plugin automatically  based on the `ansible_network_os` variable.



## [Adding cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#adding-cliconf-plugins)

You can extend Ansible to support other network devices by dropping a custom plugin into the `cliconf_plugins` directory.



## [Using cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#using-cliconf-plugins)

The cliconf plugin to use is determined automatically from the `ansible_network_os` variable. There should be no reason to override this functionality.

Most cliconf plugins can operate without configuration. A few have  additional options that can be set to affect how tasks are translated  into CLI commands.

Plugins are self-documenting. Each plugin should document its configuration options.



## [Viewing cliconf plugins](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/cliconf.html#viewing-cliconf-plugins)

These plugins have migrated to collections on [Ansible Galaxy](https://galaxy.ansible.com). If you installed Ansible version 2.10 or later using `pip`, you have access to several cliconf plugins. To list all available cliconf plugins on your control node, type `ansible-doc -t cliconf -l`. To view plugin-specific documentation and examples, use `ansible-doc -t cliconf`.

# Connection plugins[](https://docs.ansible.com/ansible/latest/plugins/connection.html#connection-plugins)

- [`ssh` plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html#ssh-plugins)
- [Adding connection plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html#adding-connection-plugins)
- [Using connection plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html#using-connection-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/connection.html#plugin-list)

Connection plugins allow Ansible to connect to the target hosts so it can execute tasks on them. Ansible ships with many connection plugins,  but only one can be used per host at a time.

By default, Ansible ships with several connection plugins. The most commonly used are the [paramiko SSH](https://docs.ansible.com/ansible/2.9/plugins/connection/paramiko_ssh.html#paramiko-ssh-connection), native ssh (just called [ssh](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ssh_connection.html#ssh-connection)), and [local](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/local_connection.html#local-connection) connection types.  All of these can be used in playbooks and with **/usr/bin/ansible** to decide how you want to talk to remote machines. If necessary, you can [create custom connection plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-connection-plugins).

The basics of these connection types are covered in the [getting started](https://docs.ansible.com/ansible/2.9/user_guide/intro_getting_started.html#intro-getting-started) section.



## [`ssh` plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/connection.html#ssh-plugins)

Because ssh is the default protocol used in system administration and the protocol most used in Ansible, ssh options are included in the  command line tools. See [ansible-playbook](https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html#ansible-playbook) for more details.



## [Adding connection plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/connection.html#adding-connection-plugins)

You can extend Ansible to support other transports (such as SNMP or message bus) by dropping a custom plugin into the `connection_plugins` directory.



## [Using connection plugins](https://docs.ansible.com/ansible/latest/plugins/connection.html#id5)[](https://docs.ansible.com/ansible/latest/plugins/connection.html#using-connection-plugins)

You can set the connection plugin globally via [configuration](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings), at the command line (`-c`, `--connection`), as a [keyword](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords) in your play, or by setting a [variable](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#behavioral-parameters), most often in your inventory. For example, for Windows machines you might want to set the [winrm](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/winrm_connection.html#winrm-connection) plugin as an inventory variable.

Most connection plugins can operate with minimal configuration. By default they use the [inventory hostname](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/inventory_hostnames_lookup.html#inventory-hostnames-lookup) and defaults to find the target host.

Plugins are self-documenting. Each plugin should document its  configuration options. The following are connection variables common to  most connection plugins:

- [ansible_host](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_vars_facts.html#magic-variables-and-hostvars)

  The name of the host to connect to, if different from the [inventory](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory) hostname.

- [ansible_port](https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#faq-setting-users-and-ports)

  The ssh port number, for [ssh](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ssh_connection.html#ssh-connection) and [paramiko_ssh](https://docs.ansible.com/ansible/2.9/plugins/connection/paramiko_ssh.html#paramiko-ssh-connection) it defaults to 22.

- [ansible_user](https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#faq-setting-users-and-ports)

  The default user name to use for log in. Most plugins default to the ‘current user running Ansible’.

Each plugin might also have a specific version of a variable that overrides the general version. For example, `ansible_ssh_host` for the [ssh](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ssh_connection.html#ssh-connection) plugin.



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/connection.html#id6)[](https://docs.ansible.com/ansible/latest/plugins/connection.html#plugin-list)

You can use `ansible-doc -t connection -l` to see the list of available plugins. Use `ansible-doc -t connection <plugin name>` to see detailed documentation and examples.

# Docs fragments[](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#docs-fragments)

- [Enabling docs fragments](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#enabling-docs-fragments)
- [Using docs fragments](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#using-docs-fragments)

Docs fragments allow you to document common parameters of multiple plugins or modules in a single place.



## [Enabling docs fragments](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#enabling-docs-fragments)

You can add a custom docs fragment by dropping it into a `doc_fragments` directory adjacent to your collection or role, just like any other plugin.



## [Using docs fragments](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/docs_fragment.html#using-docs-fragments)

Only collection developers and maintainers use docs fragments. For more information on using docs fragments, see [Documentation fragments](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_documenting.html#module-docs-fragments) or [Using documentation fragments in collections](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_shared.html#docfragments-collections).

# Filter plugins[](https://docs.ansible.com/ansible/latest/plugins/filter.html#filter-plugins)

- [Enabling filter plugins](https://docs.ansible.com/ansible/latest/plugins/filter.html#enabling-filter-plugins)
- [Using filter plugins](https://docs.ansible.com/ansible/latest/plugins/filter.html#using-filter-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/filter.html#plugin-list)

Filter plugins manipulate data. With the right filter you can extract a particular value, transform data types and formats, perform  mathematical calculations, split and concatenate strings, insert dates  and times, and do much more.  Ansible uses the [standard filters](https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters) shipped with Jinja2 and adds some specialized filter plugins. You can [create custom Ansible filters as plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-filter-plugins).



## [Enabling filter plugins](https://docs.ansible.com/ansible/latest/plugins/filter.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/filter.html#enabling-filter-plugins)

You can add a custom filter plugin by dropping it into a `filter_plugins` directory adjacent to your play, inside a role, or by putting it in one of the filter plugin directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).



## [Using filter plugins](https://docs.ansible.com/ansible/latest/plugins/filter.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/filter.html#using-filter-plugins)

You can use filters anywhere you can use templating in Ansible: in a play, in variables file, or in a Jinja2 template for the [template](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#template-module) module. For more information on using filter plugins, see [Using filters to manipulate data](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_filters.html#playbooks-filters).  Filters can return any type of data, but if you want to always return a boolean (`True` or `False`) you should be looking at a test instead.

```
vars:
   yaml_string: "{{ some_variable|to_yaml }}"
```

Filters are the preferred way to manipulate data in Ansible, you can identify a filter because it is normally preceded by a `|`, with the expression on the left of it being the first input of the  filter. Additional parameters may be passed into the filter itself as  you would to most programming functions. These parameters can be either `positional` (passed in order) or `named` (passed as key=value pairs). When passing both types, positional arguments should go first.

```
passing_positional: {{ (x == 32) | ternary('x is 32', 'x is not 32') }}
passing_extra_named_parameters: {{ some_variable | to_yaml(indent=8, width=1337) }}
passing_both: {{ some_variable| ternary('true value', 'false value', none_val='NULL') }}
```

In the documentation, filters will always have a C(_input) option  that corresponds to the expression to the left of c(|). A C(positional:) field in the documentation will show which options are positional and  in which order they are required.

## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/filter.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/filter.html#plugin-list)

You can use `ansible-doc -t filter -l` to see the list of available plugins. Use `ansible-doc -t filter <plugin name>` to see specific documents and examples.

# Httpapi plugins[](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#httpapi-plugins)

- [Adding httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#adding-httpapi-plugins)
- [Using httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#using-httpapi-plugins)
- [Viewing httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#viewing-httpapi-plugins)

Httpapi plugins tell Ansible how to interact with a remote device’s HTTP-based API and execute tasks on the device.

Each plugin represents a particular dialect of API. Some are  platform-specific (Arista eAPI, Cisco NXAPI), while others might be  usable on a variety of platforms (RESTCONF). Ansible loads the  appropriate httpapi plugin automatically based on the `ansible_network_os` variable.



## [Adding httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#adding-httpapi-plugins)

You can extend Ansible to support other APIs by dropping a custom plugin into the `httpapi_plugins` directory. See [Developing httpapi plugins](https://docs.ansible.com/ansible/latest/network/dev_guide/developing_plugins_network.html#developing-plugins-httpapi) for details.



## [Using httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#using-httpapi-plugins)

The httpapi plugin to use is determined automatically from the `ansible_network_os` variable.

Most httpapi plugins can operate without configuration. Additional options may be defined by each plugin.

Plugins are self-documenting. Each plugin should document its configuration options.

The following sample playbook shows the httpapi plugin for an Arista network device, assuming an inventory variable set as `ansible_network_os=eos` for the httpapi plugin to trigger off:

```
- hosts: leaf01
  connection: httpapi
  gather_facts: false
  tasks:

    - name: type a simple arista command
      eos_command:
        commands:
          - show version | json
      register: command_output

    - name: print command output to terminal window
      debug:
        var: command_output.stdout[0]["version"]
```

See the full working example [on GitHub](https://github.com/network-automation/httpapi).



## [Viewing httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#viewing-httpapi-plugins)

These plugins have migrated to collections on [Ansible Galaxy](https://galaxy.ansible.com). If you installed Ansible version 2.10 or later using `pip`, you have access to several httpapi plugins. To list all available httpapi plugins on your control node, type `ansible-doc -t httpapi -l`. To view plugin-specific documentation and examples, use `ansible-doc -t httpapi`.

# Inventory plugins[](https://docs.ansible.com/ansible/latest/plugins/inventory.html#inventory-plugins)

- [Enabling inventory plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.html#enabling-inventory-plugins)
- [Using inventory plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.html#using-inventory-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/inventory.html#plugin-list)

Inventory plugins allow users to point at data sources to compile the inventory of hosts that Ansible uses to target tasks, either using the `-i /path/to/file` and/or `-i 'host1, host2'` command line parameters or from other configuration sources. If necessary, you can [create custom inventory plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-inventory-plugins).



## [Enabling inventory plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/inventory.html#enabling-inventory-plugins)

Most inventory plugins shipped with Ansible are enabled by default or can be used by with the `auto` plugin.

In some circumstances, for example, if the inventory plugin does not  use a YAML configuration file, you may need to enable the specific  plugin. You can do this by setting `enable_plugins` in your [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) file in the `[inventory]` section. Modifying this will override the default list of enabled  plugins. Here is the default list of enabled plugins that ships with  Ansible:

```
[inventory]
enable_plugins = host_list, script, auto, yaml, ini, toml
```

If the plugin is in a collection and is not being picked up by the auto statement, you can append the fully qualified name:

```
[inventory]
enable_plugins = host_list, script, auto, yaml, ini, toml, namespace.collection_name.inventory_plugin_name
```

Or, if it is a local plugin, perhaps stored in the path set by [DEFAULT_INVENTORY_PLUGIN_PATH](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#default-inventory-plugin-path), you could reference it as follows:

```
[inventory]
enable_plugins = host_list, script, auto, yaml, ini, toml, my_plugin
```

If you use a plugin that supports a YAML configuration source, make sure that the name matches the name provided in the `plugin` entry of the inventory source file.



## [Using inventory plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/inventory.html#using-inventory-plugins)

To use an inventory plugin, you must provide an inventory source.  Most of the time this is a file containing host information or a YAML  configuration file with options for the plugin. You can use the `-i` flag to provide inventory sources or configure a default inventory path.

```
ansible hostname -i inventory_source -m ansible.builtin.ping
```

To start using an inventory plugin with a YAML configuration source,  create a file with the accepted filename schema documented for the  plugin in question, then add `plugin: plugin_name`. Use the fully qualified name if the plugin is in a collection.

```
# demo.aws_ec2.yml
plugin: amazon.aws.aws_ec2
```

Each plugin should document any naming restrictions. In addition, the YAML config file must end with the extension `yml` or `yaml` to be enabled by default with the `auto` plugin (otherwise, see the section above on enabling plugins).

After providing any required options, you can view the populated inventory with `ansible-inventory -i demo.aws_ec2.yml --graph`:

```
@all:
  |--@aws_ec2:
  |  |--ec2-12-345-678-901.compute-1.amazonaws.com
  |  |--ec2-98-765-432-10.compute-1.amazonaws.com
  |--@ungrouped:
```

If you are using an inventory plugin in a playbook-adjacent collection and want to test your setup with `ansible-inventory`, use the `--playbook-dir` flag.

Your inventory source might be a directory of inventory configuration files. The constructed inventory plugin only operates on those hosts  already in inventory, so you may want the constructed inventory  configuration parsed at a particular point (such as last). Ansible  parses the directory recursively, alphabetically. You cannot configure  the parsing approach, so name your files to make it work predictably.  Inventory plugins that extend constructed features directly can work  around that restriction by adding constructed options in addition to the inventory plugin options. Otherwise, you can use `-i` with multiple sources to impose a specific order, for example `-i demo.aws_ec2.yml -i clouds.yml -i constructed.yml`.

You can create dynamic groups using host variables with the constructed `keyed_groups` option. The option `groups` can also be used to create groups and `compose` creates and modifies host variables. Here is an aws_ec2 example utilizing constructed features:

```
# demo.aws_ec2.yml
plugin: amazon.aws.aws_ec2
regions:
  - us-east-1
  - us-east-2
keyed_groups:
  # add hosts to tag_Name_value groups for each aws_ec2 host's tags.Name variable
  - key: tags.Name
    prefix: tag_Name_
    separator: ""
  # If you have a tag called "Role" which has the value "Webserver", this will add the group
  # role_Webserver and add any hosts that have that tag assigned to it.
  - key: tags.Role
    prefix: role
groups:
  # add hosts to the group development if any of the dictionary's keys or values is the word 'devel'
  development: "'devel' in (tags|list)"
  # add hosts to the "private_only" group if the host doesn't have a public IP associated to it
  private_only: "public_ip_address is not defined"
compose:
  # use a private address where a public one isn't assigned
  ansible_host: public_ip_address|default(private_ip_address)
  # alternatively, set the ansible_host variable to connect with the private IP address without changing the hostname
  # ansible_host: private_ip_address
  # if you *must* set a string here (perhaps to identify the inventory source if you have multiple
  # accounts you want to use as sources), you need to wrap this in two sets of quotes, either ' then "
  # or " then '
  some_inventory_wide_string: '"Yes, you need both types of quotes here"'
```

Now the output of `ansible-inventory -i demo.aws_ec2.yml --graph`:

```
@all:
  |--@aws_ec2:
  |  |--ec2-12-345-678-901.compute-1.amazonaws.com
  |  |--ec2-98-765-432-10.compute-1.amazonaws.com
  |  |--...
  |--@development:
  |  |--ec2-12-345-678-901.compute-1.amazonaws.com
  |  |--ec2-98-765-432-10.compute-1.amazonaws.com
  |--@role_Webserver
  |  |--ec2-12-345-678-901.compute-1.amazonaws.com
  |--@tag_Name_ECS_Instance:
  |  |--ec2-98-765-432-10.compute-1.amazonaws.com
  |--@tag_Name_Test_Server:
  |  |--ec2-12-345-678-901.compute-1.amazonaws.com
  |--@ungrouped
```

If a host does not have the variables in the configuration above (in other words, `tags.Name`, `tags`, `private_ip_address`), the host will not be added to groups other than those that the inventory plugin creates and the `ansible_host` host variable will not be modified.

Inventory plugins that support caching can use the general settings for the fact cache defined in the `ansible.cfg` file’s `[defaults]` section or define inventory-specific settings in the `[inventory]` section. Individual plugins can define plugin-specific cache settings in their config file:

```
# demo.aws_ec2.yml
plugin: amazon.aws.aws_ec2
cache: true
cache_plugin: ansible.builtin.jsonfile
cache_timeout: 7200
cache_connection: /tmp/aws_inventory
cache_prefix: aws_ec2
```

Here is an example of setting inventory caching with some fact caching defaults for the cache plugin used and the timeout in an `ansible.cfg` file:

```
[defaults]
fact_caching = ansible.builtin.jsonfile
fact_caching_connection = /tmp/ansible_facts
cache_timeout = 3600

[inventory]
cache = yes
cache_connection = /tmp/ansible_inventory
```



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/inventory.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/inventory.html#plugin-list)

You can use `ansible-doc -t inventory -l` to see the list of available plugins. Use `ansible-doc -t inventory <plugin name>` to see plugin-specific documentation and examples.

# Lookup plugins[](https://docs.ansible.com/ansible/latest/plugins/lookup.html#lookup-plugins)

- [Enabling lookup plugins](https://docs.ansible.com/ansible/latest/plugins/lookup.html#enabling-lookup-plugins)
- [Using lookup plugins](https://docs.ansible.com/ansible/latest/plugins/lookup.html#using-lookup-plugins)
- [Forcing lookups to return lists: `query` and `wantlist=True`](https://docs.ansible.com/ansible/latest/plugins/lookup.html#forcing-lookups-to-return-lists-query-and-wantlist-true)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/lookup.html#plugin-list)

Lookup plugins are an Ansible-specific extension to the Jinja2  templating language. You can use lookup plugins to access data from  outside sources (files, databases, key/value stores, APIs, and other  services) within your playbooks. Like all [templating](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html#playbooks-templating), lookups execute and are evaluated on the Ansible control machine.  Ansible makes the data returned by a lookup plugin available using the  standard templating system. You can use lookup plugins to load variables or templates with information from external sources. You can [create custom lookup plugins](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-lookup-plugins).

Note

- Lookups are executed with a working directory relative to the role or play, as opposed to local tasks, which are executed relative the executed script.
- Pass `wantlist=True` to lookups to use in Jinja2 template “for” loops.
- By default, lookup return values are marked as unsafe for  security reasons. If you trust the outside source your lookup accesses,  pass `allow_unsafe=True` to allow Jinja2 templates to evaluate lookup values.

Warning

- Some lookups pass arguments to a shell. When using variables from a remote/untrusted source, use the |quote filter to ensure safe usage.



## [Enabling lookup plugins](https://docs.ansible.com/ansible/latest/plugins/lookup.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/lookup.html#enabling-lookup-plugins)

Ansible enables all lookup plugins it can find. You can activate a custom lookup by either dropping it into a `lookup_plugins` directory adjacent to your play, inside the `plugins/lookup/` directory of a collection you have installed, inside a standalone role, or in one of the lookup directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).



## [Using lookup plugins](https://docs.ansible.com/ansible/latest/plugins/lookup.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/lookup.html#using-lookup-plugins)

You can use lookup plugins anywhere you can use templating in  Ansible: in a play, in variables file, or in a Jinja2 template for the [template](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#template-module) module. For more information on using lookup plugins, see [Lookups](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_lookups.html#playbooks-lookups).

```
vars:
  file_contents: "{{ lookup('file', 'path/to/file.txt') }}"
```

Lookups are an integral part of loops. Wherever you see `with_`, the part after the underscore is the name of a lookup. For this reason, lookups are expected to output lists; for example, `with_items` uses the [items](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/items_lookup.html#items-lookup) lookup:

```
tasks:
  - name: count to 3
    debug: msg={{ item }}
    with_items: [1, 2, 3]
```

You can combine lookups with [filters](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_filters.html#playbooks-filters), [tests](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_tests.html#playbooks-tests) and even each other to do some complex data generation and manipulation. For example:

```
tasks:
  - name: valid but useless and over complicated chained lookups and filters
    debug: msg="find the answer here:\n{{ lookup('url', 'https://google.com/search/?q=' + item|urlencode)|join(' ') }}"
    with_nested:
      - "{{ lookup('consul_kv', 'bcs/' + lookup('file', '/the/question') + ', host=localhost, port=2000')|shuffle }}"
      - "{{ lookup('sequence', 'end=42 start=2 step=2')|map('log', 4)|list) }}"
      - ['a', 'c', 'd', 'c']
```

New in version 2.6.

You can control how errors behave in all lookup plugins by setting `errors` to `ignore`, `warn`, or `strict`. The default setting is `strict`, which causes the task to fail if the lookup returns an error. For example:

To ignore lookup errors:

```
- name: if this file does not exist, I do not care .. file plugin itself warns anyway ...
  debug: msg="{{ lookup('file', '/nosuchfile', errors='ignore') }}"
[WARNING]: Unable to find '/nosuchfile' in expected paths (use -vvvvv to see paths)

ok: [localhost] => {
    "msg": ""
}
```

To get a warning instead of a failure:

```
- name: if this file does not exist, let me know, but continue
  debug: msg="{{ lookup('file', '/nosuchfile', errors='warn') }}"
[WARNING]: Unable to find '/nosuchfile' in expected paths (use -vvvvv to see paths)

[WARNING]: An unhandled exception occurred while running the lookup plugin 'file'. Error was a <class 'ansible.errors.AnsibleError'>, original message: could not locate file in lookup: /nosuchfile

ok: [localhost] => {
    "msg": ""
}
```

To get a fatal error (the default):

```
- name: if this file does not exist, FAIL (this is the default)
  debug: msg="{{ lookup('file', '/nosuchfile', errors='strict') }}"
[WARNING]: Unable to find '/nosuchfile' in expected paths (use -vvvvv to see paths)

fatal: [localhost]: FAILED! => {"msg": "An unhandled exception occurred while running the lookup plugin 'file'. Error was a <class 'ansible.errors.AnsibleError'>, original message: could not locate file in lookup: /nosuchfile"}
```



## [Forcing lookups to return lists: `query` and `wantlist=True`](https://docs.ansible.com/ansible/latest/plugins/lookup.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/lookup.html#forcing-lookups-to-return-lists-query-and-wantlist-true)

New in version 2.5.

In Ansible 2.5, a new Jinja2 function called `query` was added for invoking lookup plugins. The difference between `lookup` and `query` is largely that `query` will always return a list. The default behavior of `lookup` is to return a string of comma separated values. `lookup` can be explicitly configured to return a list using `wantlist=True`.

This feature provides an easier and more consistent interface for interacting with the new `loop` keyword, while maintaining backwards compatibility with other uses of `lookup`.

The following examples are equivalent:

```
lookup('dict', dict_variable, wantlist=True)

query('dict', dict_variable)
```

As demonstrated above, the behavior of `wantlist=True` is implicit when using `query`.

Additionally, `q` was introduced as a shortform of `query`:

```
q('dict', dict_variable)
```



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/lookup.html#id5)[](https://docs.ansible.com/ansible/latest/plugins/lookup.html#plugin-list)

You can use `ansible-doc -t lookup -l` to see the list of available plugins. Use `ansible-doc -t lookup <plugin name>` to see specific documents and examples.

# Modules[](https://docs.ansible.com/ansible/latest/plugins/module.html#modules)

- [Enabling modules](https://docs.ansible.com/ansible/latest/plugins/module.html#enabling-modules)
- [Using modules](https://docs.ansible.com/ansible/latest/plugins/module.html#using-modules)

Modules are the main building blocks of Ansible playbooks. Although  we do not generally speak of “module plugins”, a module is a type of  plugin. For a developer-focused description of the differences between  modules and other plugins, see [Modules and plugins: what is the difference?](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html#modules-vs-plugins).



## [Enabling modules](https://docs.ansible.com/ansible/latest/plugins/module.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/module.html#enabling-modules)

You can enable a custom module by dropping it into one of these locations:

- any directory added to the `ANSIBLE_LIBRARY` environment variable (`$ANSIBLE_LIBRARY` takes a colon-separated list like `$PATH`)
- `~/.ansible/plugins/modules/`
- `/usr/share/ansible/plugins/modules/`

For more information on using local custom modules, see [Adding a module outside of a collection](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html#local-modules).



## [Using modules](https://docs.ansible.com/ansible/latest/plugins/module.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/module.html#using-modules)

For information on using modules in ad hoc tasks, see [Introduction to ad hoc commands](https://docs.ansible.com/ansible/latest/command_guide/intro_adhoc.html#intro-adhoc). For information on using modules in playbooks, see [Ansible playbooks](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html#playbooks-intro).

# Module utilities[](https://docs.ansible.com/ansible/latest/plugins/module_util.html#module-utilities)

- [Enabling module utilities](https://docs.ansible.com/ansible/latest/plugins/module_util.html#enabling-module-utilities)
- [Using module utilities](https://docs.ansible.com/ansible/latest/plugins/module_util.html#using-module-utilities)

Module utilities contain shared code used by multiple plugins. You can write [custom module utilities](https://docs.ansible.com/ansible/latest/dev_guide/developing_module_utilities.html#developing-module-utilities).



## [Enabling module utilities](https://docs.ansible.com/ansible/latest/plugins/module_util.html#id1)[](https://docs.ansible.com/ansible/latest/plugins/module_util.html#enabling-module-utilities)

You can add a custom module utility by dropping it into a `module_utils` directory adjacent to your collection or role, just like any other plugin.



## [Using module utilities](https://docs.ansible.com/ansible/latest/plugins/module_util.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/module_util.html#using-module-utilities)

For information on using module utilities, see [Using and developing module utilities](https://docs.ansible.com/ansible/latest/dev_guide/developing_module_utilities.html#developing-module-utilities).

# Netconf plugins[](https://docs.ansible.com/ansible/latest/plugins/netconf.html#netconf-plugins)

- [Adding netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html#adding-netconf-plugins)
- [Using netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html#using-netconf-plugins)
- [Listing netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html#listing-netconf-plugins)

Netconf plugins are abstractions over the Netconf interface to  network devices. They provide a standard interface for Ansible to  execute tasks on those network devices.

These plugins generally correspond one-to-one to network device  platforms. Ansible loads the appropriate netconf plugin automatically  based on the `ansible_network_os` variable. If the platform supports standard Netconf implementation as  defined in the Netconf RFC specification, Ansible loads the `default` netconf plugin. If the platform supports propriety Netconf RPCs, Ansible loads the platform-specific netconf plugin.



## [Adding netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/netconf.html#adding-netconf-plugins)

You can extend Ansible to support other network devices by dropping a custom plugin into the `netconf_plugins` directory.



## [Using netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/netconf.html#using-netconf-plugins)

The netconf plugin to use is determined automatically from the `ansible_network_os` variable. There should be no reason to override this functionality.

Most netconf plugins can operate without configuration. A few have  additional options that can be set to affect how tasks are translated  into netconf commands. A ncclient device specific handler name can be  set in the netconf plugin or else the value of `default` is used as per ncclient device handler.

Plugins are self-documenting. Each plugin should document its configuration options.



## [Listing netconf plugins](https://docs.ansible.com/ansible/latest/plugins/netconf.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/netconf.html#listing-netconf-plugins)

These plugins have migrated to collections on [Ansible Galaxy](https://galaxy.ansible.com). If you installed Ansible version 2.10 or later using `pip`, you have access to several netconf plugins. To list all available netconf plugins on your control node, type `ansible-doc -t netconf -l`. To view plugin-specific documentation and examples, use `ansible-doc -t netconf`.

# Shell plugins[](https://docs.ansible.com/ansible/latest/plugins/shell.html#shell-plugins)

- [Enabling shell plugins](https://docs.ansible.com/ansible/latest/plugins/shell.html#enabling-shell-plugins)
- [Using shell plugins](https://docs.ansible.com/ansible/latest/plugins/shell.html#using-shell-plugins)

Shell plugins work to ensure that the basic commands Ansible runs are properly formatted to work with the target machine and allow the user to configure certain behaviors related to how Ansible executes tasks.



## [Enabling shell plugins](https://docs.ansible.com/ansible/latest/plugins/shell.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/shell.html#enabling-shell-plugins)

You can add a custom shell plugin by dropping it into a `shell_plugins` directory adjacent to your play, inside a role, or by putting it in one of the shell plugin directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).

Warning

You should not alter which plugin is used unless you have a setup in which the default `/bin/sh` is not a POSIX compatible shell or is not available for execution.



## [Using shell plugins](https://docs.ansible.com/ansible/latest/plugins/shell.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/shell.html#using-shell-plugins)

In addition to the default configuration settings in [Ansible Configuration Settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings), you can use the connection variable [ansible_shell_type](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#ansible-shell-type) to select the plugin to use. In this case, you will also want to update the [ansible_shell_executable](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#ansible-shell-executable) to match.

You can further control the settings for each plugin via other configuration options detailed in the plugin themselves (linked below).

# Strategy plugins[](https://docs.ansible.com/ansible/latest/plugins/strategy.html#strategy-plugins)

- [Enabling strategy plugins](https://docs.ansible.com/ansible/latest/plugins/strategy.html#enabling-strategy-plugins)
- [Using strategy plugins](https://docs.ansible.com/ansible/latest/plugins/strategy.html#using-strategy-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/strategy.html#plugin-list)

Strategy plugins control the flow of play execution by handling task  and host scheduling. For more information on using strategy plugins and  other ways to control execution order, see [Controlling playbook execution: strategies and more](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_strategies.html#playbooks-strategies).



## [Enabling strategy plugins](https://docs.ansible.com/ansible/latest/plugins/strategy.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/strategy.html#enabling-strategy-plugins)

All strategy plugins shipped with Ansible are enabled by default. You can enable a custom strategy plugin by putting it in one of the lookup directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).



## [Using strategy plugins](https://docs.ansible.com/ansible/latest/plugins/strategy.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/strategy.html#using-strategy-plugins)

Only one strategy plugin can be used in a play, but you can use  different ones for each play in a playbook or ansible run. By default  Ansible uses the [linear](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/linear_strategy.html#linear-strategy) plugin. You can change this default in Ansible [configuration](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) using an environment variable:

```
export ANSIBLE_STRATEGY=free
```

or in the ansible.cfg file:

```
[defaults]
strategy=linear
```

You can also specify the strategy plugin in the play via the [strategy keyword](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords) in a play:

```
- hosts: all
  strategy: debug
  tasks:
    - copy: src=myhosts dest=/etc/hosts
      notify: restart_tomcat

    - package: name=tomcat state=present

  handlers:
    - name: restart_tomcat
      service: name=tomcat state=restarted
```



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/strategy.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/strategy.html#plugin-list)

You can use `ansible-doc -t strategy -l` to see the list of available plugins. Use `ansible-doc -t strategy <plugin name>` to see plugin-specific specific documentation and examples.

# Terminal plugins[](https://docs.ansible.com/ansible/latest/plugins/terminal.html#terminal-plugins)

- [Adding terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html#adding-terminal-plugins)
- [Using terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html#using-terminal-plugins)
- [Viewing terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html#viewing-terminal-plugins)

Terminal plugins contain information on how to prepare a particular  network device’s SSH shell is properly initialized to be used with  Ansible. This typically includes disabling automatic paging, detecting  errors in output, and enabling privileged mode if supported and required on the device.

These plugins correspond one-to-one to network device platforms.  Ansible loads the appropriate terminal plugin automatically based on the `ansible_network_os` variable.



## [Adding terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/terminal.html#adding-terminal-plugins)

You can extend Ansible to support other network devices by dropping a custom plugin into the `terminal_plugins` directory.



## [Using terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/terminal.html#using-terminal-plugins)

Ansible determines which terminal plugin to use automatically from the `ansible_network_os` variable. There should be no reason to override this functionality.

Terminal plugins operate without configuration. All options to control the terminal are exposed in the `network_cli` connection plugin.

Plugins are self-documenting. Each plugin should document its configuration options.



## [Viewing terminal plugins](https://docs.ansible.com/ansible/latest/plugins/terminal.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/terminal.html#viewing-terminal-plugins)

These plugins have migrated to collections on [Ansible Galaxy](https://galaxy.ansible.com). If you installed Ansible version 2.10 or later using `pip`, you have access to several terminal plugins. To list all available terminal plugins on your control node, type `ansible-doc -t terminal -l`. To view plugin-specific documentation and examples, use `ansible-doc -t terminal`.

# Test plugins[](https://docs.ansible.com/ansible/latest/plugins/test.html#test-plugins)

- [Enabling test plugins](https://docs.ansible.com/ansible/latest/plugins/test.html#enabling-test-plugins)
- [Using test plugins](https://docs.ansible.com/ansible/latest/plugins/test.html#using-test-plugins)
  - [Using test plugins with lists](https://docs.ansible.com/ansible/latest/plugins/test.html#using-test-plugins-with-lists)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/test.html#plugin-list)

Test plugins evaluate template expressions and return True or False. With test plugins you can create [conditionals](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_conditionals.html#playbooks-conditionals) to implement the logic of your tasks, blocks, plays, playbooks, and roles. Ansible uses the standard tests `_ shipped as part of Jinja, and adds some specialized test  plugins. You can :ref:`create custom Ansible test plugins  <developing_test_plugins>.



## [Enabling test plugins](https://docs.ansible.com/ansible/latest/plugins/test.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/test.html#enabling-test-plugins)

You can add a custom test plugin by dropping it into a `test_plugins` directory adjacent to your play, inside a role, or by putting it in one of the test plugin directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).



## [Using test plugins](https://docs.ansible.com/ansible/latest/plugins/test.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/test.html#using-test-plugins)

You can use tests anywhere you can use templating in Ansible: in a play, in variables file, or in a Jinja2 template for the [template](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html#template-module) module. For more information on using test plugins, see [Tests](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_tests.html#playbooks-tests).

Tests always return `True` or `False`, they are always a boolean, if you need a different return type, you should be looking at filters.

You can recognize test plugins by the use of the `is` statement in a template, they can also be used as part of the `select` family of filters.

```
vars:
  is_ready: '{{ task_result is success }}'

tasks:
- name: conditionals are always in 'template' context
  action: dostuff
  when: task_result is failed
```

Tests will always have an `_input` and this is normally what is on the left side of `is`. Tests can also take additional parameters as you would to most programming functions. These parameters can be either `positional` (passed in order) or `named` (passed as key=value pairs). When passing both types, positional arguments should go first.

```
tasks:
- name: pass positional parameter to match test
  action: dostuff
  when: myurl is match("https://example.com/users/.*/resources")

- name: pass named parameter to truthy test
  action: dostuff
  when: myvariable is truthy(convert_bool=True)

- name: pass both types to 'version' test
  action: dostuff
  when: sample_semver_var is version('2.0.0-rc.1+build.123', 'lt', version_type='semver')
```

### [Using test plugins with lists](https://docs.ansible.com/ansible/latest/plugins/test.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/test.html#using-test-plugins-with-lists)

As mentioned above, one way to use tests is with the `select` familiy of filters (`select`, `reject`, `selectattr`, `rejectattr`).

```
# give me only defined variables from a list of variables, using 'defined' test
good_vars: "{{ all_vars|select('defined') }}"

# this uses the 'equalto' test to filter out non 'fixed' type of addresses from a list
only_fixed_addresses:  "{{ all_addresses|selectattr('type', 'equalsto', 'fixed') }}"

# this does the opposite of the previous one
only_fixed_addresses:  "{{ all_addresses|rejectattr('type', 'equalsto', 'fixed') }}"
```

## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/test.html#id5)[](https://docs.ansible.com/ansible/latest/plugins/test.html#plugin-list)

You can use `ansible-doc -t filter -l` to see the list of available plugins. Use `ansible-doc -t filter <plugin name>` to see specific documents and examples.

# Vars plugins[](https://docs.ansible.com/ansible/latest/plugins/vars.html#vars-plugins)

- [Enabling vars plugins](https://docs.ansible.com/ansible/latest/plugins/vars.html#enabling-vars-plugins)
- [Using vars plugins](https://docs.ansible.com/ansible/latest/plugins/vars.html#using-vars-plugins)
- [Plugin list](https://docs.ansible.com/ansible/latest/plugins/vars.html#plugin-list)

Vars plugins inject additional variable data into Ansible runs that  did not come from an inventory source, playbook, or command line.  Playbook constructs like ‘host_vars’ and ‘group_vars’ work using vars  plugins. For more details about variables in Ansible, see [Using Variables](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#playbooks-variables).

Vars plugins were partially implemented in Ansible 2.0 and rewritten to be fully implemented starting with Ansible 2.4.

The [host_group_vars](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/host_group_vars_vars.html#host-group-vars-vars) plugin shipped with Ansible enables reading variables from [Assigning a variable to one machine: host variables](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#host-variables) and [Assigning a variable to many machines: group variables](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#group-variables).



## [Enabling vars plugins](https://docs.ansible.com/ansible/latest/plugins/vars.html#id2)[](https://docs.ansible.com/ansible/latest/plugins/vars.html#enabling-vars-plugins)

You can activate a custom vars plugin by either dropping it into a `vars_plugins` directory adjacent to your play, inside a role, or by putting it in one of the directory sources configured in [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).

Most vars plugins are disabled by default. To enable a vars plugin, set `vars_plugins_enabled` in the `defaults` section of [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings) or set the `ANSIBLE_VARS_ENABLED` environment variable to the list of vars plugins you want to execute. By default, the [host_group_vars](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/host_group_vars_vars.html#host-group-vars-vars) plugin shipped with Ansible is enabled.

Starting in Ansible 2.10, you can use vars plugins in collections.  All vars plugins in collections must be explicitly enabled and must use  the fully qualified collection name in the format `namespace.collection_name.vars_plugin_name`.

```
[defaults]
vars_plugins_enabled = host_group_vars,namespace.collection_name.vars_plugin_name
```



## [Using vars plugins](https://docs.ansible.com/ansible/latest/plugins/vars.html#id3)[](https://docs.ansible.com/ansible/latest/plugins/vars.html#using-vars-plugins)

By default, vars plugins are used on demand automatically after they are enabled.

Starting in Ansible 2.10, vars plugins can be made to run at specific times. ansible-inventory does not use these settings, and always loads vars plugins.

The global setting `RUN_VARS_PLUGINS` can be set in `ansible.cfg` using `run_vars_plugins` in the `defaults` section or by the `ANSIBLE_RUN_VARS_PLUGINS` environment variable. The default option, `demand`, runs any enabled vars plugins relative to inventory sources whenever variables are demanded by tasks. You can use the option `start` to run any enabled vars plugins relative to inventory sources after importing that inventory source instead.

You can also control vars plugin execution on a per-plugin basis for vars plugins that support the `stage` option. To run the [host_group_vars](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/host_group_vars_vars.html#host-group-vars-vars) plugin after importing inventory you can add the following to [ansible.cfg](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings):

```
[vars_host_group_vars]
stage = inventory
```



## [Plugin list](https://docs.ansible.com/ansible/latest/plugins/vars.html#id4)[](https://docs.ansible.com/ansible/latest/plugins/vars.html#plugin-list)

You can use `ansible-doc -t vars -l` to see the list of available vars plugins. Use `ansible-doc -t vars <plugin name>` to see plugin-specific documentation and examples.

# Modules and plugins index[](https://docs.ansible.com/ansible/latest/module_plugin_guide/modules_plugins_index.html#modules-and-plugins-index)

You can find an index of modules and plugins at [Indexes of all modules and plugins](https://docs.ansible.com/ansible/latest/collections/all_plugins.html#all-modules-and-plugins).

​        