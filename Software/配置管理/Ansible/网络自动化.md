# Network Getting Started[](https://docs.ansible.com/ansible/latest/network/getting_started/index.html#network-getting-started)

Ansible collections support a wide range of vendors, device types,  and actions, so you can manage your entire network with a single  automation tool. With Ansible, you can:

- Automate repetitive tasks to speed routine network changes and free up your time for more strategic work
- Leverage the same simple, powerful, and agentless automation tool for network tasks that operations and development use
- Separate the data model (in a playbook or role) from the  execution layer (through Ansible modules) to manage heterogeneous  network devices
- Benefit from community and vendor-generated sample playbooks and roles to help accelerate network automation projects
- Communicate securely with network hardware over SSH or HTTPS

**Who should use this guide?**

This guide is intended for network engineers using Ansible for the  first time. If you understand networks but have never used Ansible, work through the guide from start to finish.

This guide is also useful for experienced Ansible users automating  network tasks for the first time. You can use Ansible commands,  playbooks and modules to configure hubs, switches, routers, bridges and  other network devices. But network modules are different from Linux/Unix and Windows modules, and you must understand some network-specific  concepts to succeed. If you understand Ansible but have never automated a network task, start with the second section.

This guide introduces basic Ansible concepts and guides you through  your first Ansible commands, playbooks and inventory entries.

Getting Started Guide

- Basic Concepts
  - [Control node](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#control-node)
  - [Managed nodes](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#managed-nodes)
  - [Inventory](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#inventory)
  - [Playbooks](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#playbooks)
  - [Modules](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#modules)
  - [Plugins](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#plugins)
  - [Collections](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#collections)
  - [AAP](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#aap)
- How Network Automation is Different
  - [Execution on the control node](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#execution-on-the-control-node)
  - [Multiple communication protocols](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols)
  - [Collections organized by network platform](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#collections-organized-by-network-platform)
  - [Privilege Escalation: `enable` mode, `become`, and `authorize`](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#privilege-escalation-enable-mode-become-and-authorize)
- Run Your First Command and Playbook
  - [Prerequisites](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#prerequisites)
  - [Install Ansible](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#install-ansible)
  - [Establish a manual connection to a managed node](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#establish-a-manual-connection-to-a-managed-node)
  - [Run your first network Ansible command](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#run-your-first-network-ansible-command)
  - [Create and run your first network Ansible Playbook](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#create-and-run-your-first-network-ansible-playbook)
  - [Gathering facts from network devices](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#gathering-facts-from-network-devices)
- Build Your Inventory
  - [Basic inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#basic-inventory)
  - [Add variables to the inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#add-variables-to-the-inventory)
  - [Group variables within inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#group-variables-within-inventory)
  - [Variable syntax](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#variable-syntax)
  - [Group inventory by platform](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#group-inventory-by-platform)
  - [Verifying the inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#verifying-the-inventory)
  - [Protecting sensitive variables with `ansible-vault`](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#protecting-sensitive-variables-with-ansible-vault)
- Use Ansible network roles
  - [Understanding roles](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#understanding-roles)
- Beyond the basics
  - [A typical Ansible filetree](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#a-typical-ansible-filetree)
  - [Tracking changes to inventory and playbooks: source control with git](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#tracking-changes-to-inventory-and-playbooks-source-control-with-git)
- Working with network connection options
  - [Setting timeout options](https://docs.ansible.com/ansible/latest/network/getting_started/network_connection_options.html#setting-timeout-options)
- Resources and next steps
  - [Documents](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#documents)
  - [Events (on video and in person)](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#events-on-video-and-in-person)
  - [GitHub repos](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#github-repos)
  - [Chat channels](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#chat-channels)

# Basic Concepts[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#basic-concepts)

These concepts are common to all uses of Ansible, including network  automation. You need to understand them to use Ansible for network  automation. This basic introduction provides the background you need to  follow the examples in this guide.

- [Control node](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#control-node)
- [Managed nodes](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#managed-nodes)
- [Inventory](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#inventory)
- [Playbooks](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#playbooks)
  - [Plays](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#plays)
    - [Roles](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#roles)
    - [Tasks](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#tasks)
    - [Handlers](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#handlers)
- [Modules](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#modules)
- [Plugins](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#plugins)
- [Collections](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#collections)
- [AAP](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#aap)

## [Control node](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#control-node)

The machine from which you run the Ansible CLI tools (`ansible-playbook` , `ansible`, `ansible-vault` and others). You can use any computer that meets the software requirements as a  control node - laptops, shared desktops, and servers can all run  Ansible. Multiple control nodes are possible, but Ansible itself does not  coordinate across them, see `AAP` for such features.

## [Managed nodes](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#managed-nodes)

Also referred to as ‘hosts’, these are the target devices (servers,  network appliances or any computer) you aim to manage with Ansible. Ansible is not normally installed on managed nodes, unless you are using `ansible-pull`, but this is rare and not the recommended setup.

## [Inventory](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id3)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#inventory)

A list of managed nodes provided by one or more ‘inventory sources’.  Your inventory can specify information specific to each node, like IP  address. It is also used for assigning groups, that both allow for node selection in the Play and bulk variable assignment. To learn more about inventory, see [the Working with Inventory](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory) section. Sometimes an inventory source file is also referred to as a ‘hostfile’.

## [Playbooks](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id4)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#playbooks)

They contain Plays (which are the basic unit of Ansible execution).  This is both an ‘execution concept’ and how we describe the files on  which `ansible-playbook` operates. Playbooks are written in YAML and are easy to read, write, share and understand. To learn more about playbooks, see [Ansible playbooks](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html#about-playbooks).

### [Plays](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id5)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#plays)

The main context for Ansible execution, this playbook object maps managed nodes (hosts) to tasks. The Play contains variables, roles and an ordered lists of tasks and can be run repeatedly. It basically consists of an implicit loop over the mapped hosts and tasks and defines how to iterate over them.

#### [Roles](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id6)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#roles)

A limited distribution of reusable Ansible content (tasks, handlers,  variables, plugins, templates and files) for use inside of a Play. To use any Role resource, the Role itself must be imported into the  Play.

#### [Tasks](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id7)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#tasks)

The definition of an ‘action’ to be applied to the managed host.  Tasks must always be contained in a Play, directly or indirectly (Role,  or imported/included task list file). You can execute a single task once with an ad hoc command using `ansible` or `ansible-console` (both create a virtual Play).

#### [Handlers](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id8)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#handlers)

A special form of a Task, that only executes when notified by a previous task which resulted in a ‘changed’ status.

## [Modules](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id9)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#modules)

The code or binaries that Ansible copies to and executes on each  managed node (when needed) to accomplish the action defined in each  Task. Each module has a particular use, from administering users on a specific type of database to managing VLAN interfaces on a specific type of  network device. You can invoke a single module with a task, or invoke several different  modules in a playbook. Ansible modules are grouped in collections. For an idea of how many  collections Ansible includes, see the [Collection Index](https://docs.ansible.com/ansible/latest/collections/index.html#list-of-collections).

## [Plugins](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id10)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#plugins)

Pieces of code that expand Ansible’s core capabilities, they can control how you connect to a managed node (connection plugins), manipulate data (filter plugins) and even control what is displayed in the console (callback plugins). See [Working with plugins](https://docs.ansible.com/ansible/latest/plugins/plugins.html#working-with-plugins) for details.

## [Collections](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id11)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#collections)

A format in which Ansible content is distributed that can contain  playbooks, roles, modules, and plugins. You can install and use  collections through [Ansible Galaxy](https://galaxy.ansible.com). To learn more about collections, see [Using Ansible collections](https://docs.ansible.com/ansible/latest/collections_guide/index.html#collections). Collection resources can be used independently and discretely from each other.

## [AAP](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#id12)[](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#aap)

Short for ‘Ansible Automation Platform’. This is a product that  includes enterprise level features and integrates many tools of the  Ansible ecosystem: ansible-core, awx, galaxyNG, and so on.

# How Network Automation is Different[](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#how-network-automation-is-different)

Network automation uses the basic Ansible concepts, but there are  important differences in how the network modules work. This introduction prepares you to understand the exercises in this guide.

- [Execution on the control node](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#execution-on-the-control-node)
- [Multiple communication protocols](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols)
- [Collections organized by network platform](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#collections-organized-by-network-platform)
- [Privilege Escalation: `enable` mode, `become`, and `authorize`](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#privilege-escalation-enable-mode-become-and-authorize)
  - [Using `become` for privilege escalation](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#using-become-for-privilege-escalation)

## [Execution on the control node](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#execution-on-the-control-node)

Unlike most Ansible modules, network modules do not run on the  managed nodes. From a user’s point of view, network modules work like  any other modules. They work with ad hoc commands, playbooks, and roles. Behind the scenes, however, network modules use a different methodology than the other (Linux/Unix and Windows) modules use. Ansible is written and executed in Python. Because the majority of network devices can not run Python, the Ansible network modules are executed on the Ansible  control node, where `ansible` or `ansible-playbook` runs.

Network modules also use the control node as a destination for backup files, for those modules that offer a `backup` option. With Linux/Unix modules, where a configuration file already  exists on the managed node(s), the backup file gets written by default  in the same directory as the new, changed file. Network modules do not  update configuration files on the managed nodes, because network  configuration is not written in files. Network modules write backup  files on the control node, usually in the backup directory under the playbook root directory.

## [Multiple communication protocols](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols)

Because network modules execute on the control node instead of on the managed nodes, they can support multiple communication protocols. The  communication protocol (XML over SSH, CLI over SSH, API over HTTPS)  selected for each network module depends on the platform and the purpose of the module. Some network modules support only one protocol; some  offer a choice. The most common protocol is CLI over SSH. You set the  communication protocol with the `ansible_connection` variable:

| Value of ansible_connection   | Protocol            | Requires           | Persistent? |
| ----------------------------- | ------------------- | ------------------ | ----------- |
| ansible.netcommon.network_cli | CLI over SSH        | network_os setting | yes         |
| ansible.netcommon.netconf     | XML over SSH        | network_os setting | yes         |
| ansible.netcommon.httpapi     | API over HTTP/HTTPS | network_os setting | yes         |
| local                         | depends on provider | provider setting   | no          |

Note

`ansible.netcommon.httpapi` deprecates `eos_eapi` and `nxos_nxapi`. See [Httpapi plugins](https://docs.ansible.com/ansible/latest/plugins/httpapi.html#httpapi-plugins) for details and an example.

The `ansible_connection: local` has been deprecated. Please use one of the persistent connection types  listed above instead. With persistent connections, you can define the  hosts and credentials only once, rather than in every task. You also  need to set the `network_os` variable for the specific network platform you are communicating with.  For more details on using each connection type on various platforms, see the [platform-specific](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#platform-options) pages.

## [Collections organized by network platform](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#id3)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#collections-organized-by-network-platform)

A network platform is a set of network devices with a common  operating system that can be managed by an Ansible collection, for  example:

- Arista: [arista.eos](https://galaxy.ansible.com/arista/eos)
- Cisco: [cisco.ios](https://galaxy.ansible.com/cisco/ios), [cisco.iosxr](https://galaxy.ansible.com/cisco/iosxr), [cisco.nxos](https://galaxy.ansible.com/cisco/nxos)
- Juniper: [junipernetworks.junos](https://galaxy.ansible.com/junipernetworks/junos)
- VyOS [vyos.vyos](https://galaxy.ansible.com/vyos/vyos)

All modules within a network platform share certain requirements. Some network platforms have specific differences - see the [platform-specific](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#platform-options) documentation for details.



## [Privilege Escalation: `enable` mode, `become`, and `authorize`](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#id4)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#privilege-escalation-enable-mode-become-and-authorize)

Several network platforms support privilege escalation, where certain tasks must be done by a privileged user. On network devices this is  called the `enable` mode (the equivalent of `sudo` in *nix administration). Ansible network modules offer privilege  escalation for those network devices that support it. For details of  which platforms support `enable` mode, with examples of how to use it, see the [platform-specific](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#platform-options) documentation.

### [Using `become` for privilege escalation](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#id5)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#using-become-for-privilege-escalation)

Use the top-level Ansible parameter `become: yes` with `become_method: enable` to run a task, play, or playbook with escalated privileges on any  network platform that supports privilege escalation. You must use either `connection: network_cli` or `connection: httpapi` with `become: yes` with `become_method: enable`. If you are using `network_cli` to connect Ansible to your network devices, a `group_vars` file would look like:

```
ansible_connection: ansible.netcommon.network_cli
ansible_network_os: cisco.ios.ios
ansible_become: yes
ansible_become_method: enable
```

For more information, see [Become and Networks](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_privilege_escalation.html#become-network)

# Run Your First Command and Playbook[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#run-your-first-command-and-playbook)

Put the concepts you learned to work with this quick tutorial.  Install Ansible, execute a network configuration command manually,  execute the same command with Ansible, then create a playbook so you can execute the command any time on multiple network devices.

- [Prerequisites](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#prerequisites)
- [Install Ansible](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#install-ansible)
- [Establish a manual connection to a managed node](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#establish-a-manual-connection-to-a-managed-node)
- [Run your first network Ansible command](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#run-your-first-network-ansible-command)
- [Create and run your first network Ansible Playbook](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#create-and-run-your-first-network-ansible-playbook)
- [Gathering facts from network devices](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#gathering-facts-from-network-devices)

## [Prerequisites](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#prerequisites)

Before you work through this tutorial you need:

- Ansible 2.10 (or higher) installed
- One or more network devices that are compatible with Ansible
- Basic Linux command line knowledge
- Basic knowledge of network switch & router configuration

## [Install Ansible](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#install-ansible)

Install Ansible using your preferred method. See [Installing Ansible](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installation-guide). Then return to this tutorial.

Confirm the version of Ansible (must be >= 2.10):

```
ansible --version
```

## [Establish a manual connection to a managed node](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#id3)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#establish-a-manual-connection-to-a-managed-node)

To confirm your credentials, connect to a network device manually and retrieve its configuration. Replace the sample user and device name  with your real credentials. For example, for a VyOS router:

```
ssh my_vyos_user@vyos.example.net
show config
exit
```

This manual connection also establishes the authenticity of the  network device, adding its RSA key fingerprint to your list of known  hosts. (If you have connected to the device before, you have already  established its authenticity.)

## [Run your first network Ansible command](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#id4)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#run-your-first-network-ansible-command)

Instead of manually connecting and running a command on the network  device, you can retrieve its configuration with a single, stripped-down  Ansible command:

```
ansible all -i vyos.example.net, -c ansible.netcommon.network_cli -u my_vyos_user -k -m vyos.vyos.vyos_facts -e ansible_network_os=vyos.vyos.vyos
```

- The flags in this command set seven values:

  the host group(s) to which the command should apply (in this case, all) the inventory (-i, the device or devices to target - without the trailing comma -i points to an inventory file) the connection method (-c, the method for connecting and executing ansible) the user (-u, the username for the SSH connection) the SSH connection method (-k, please prompt for the password) the module (-m, the Ansible module to run, using the fully qualified collection name (FQCN)) an extra variable ( -e, in this case, setting the network OS value)

NOTE: If you use `ssh-agent` with ssh keys, Ansible loads them automatically. You can omit `-k` flag.

Note

If you are running Ansible in a virtual environment, you will also need to add the variable `ansible_python_interpreter=/path/to/venv/bin/python`

## [Create and run your first network Ansible Playbook](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#id5)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#create-and-run-your-first-network-ansible-playbook)

If you want to run this command every day, you can save it in a playbook and run it with `ansible-playbook` instead of `ansible`. The playbook can store a lot of the parameters you provided with flags  at the command line, leaving less to type at the command line. You need  two files for this - a playbook and an inventory file.

1. Download [`first_playbook.yml`](https://docs.ansible.com/ansible/latest/_downloads/588d4b6e9316c8eb903fbe2485b14d64/first_playbook.yml), which looks like this:

```
---

- name: Network Getting Started First Playbook
  connection: ansible.netcommon.network_cli
  gather_facts: false
  hosts: all
  tasks:

    - name: Get config for VyOS devices
      vyos.vyos.vyos_facts:
        gather_subset: all

    - name: Display the config
      debug:
        msg: "The hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}"
```

The playbook sets three of the seven values from the command line above: the group (`hosts: all`), the connection method (`connection: ansible.netcommon.network_cli`) and the module (in each task). With those values set in the playbook,  you can omit them on the command line. The playbook also adds a second  task to show the config output. When a module runs in a playbook, the  output is held in memory for use by future tasks instead of written to  the console. The debug task here lets you see the results in your shell.

1. Run the playbook with the command:

```
ansible-playbook -i vyos.example.net, -u ansible -k -e ansible_network_os=vyos.vyos.vyos first_playbook.yml
```

The playbook contains one play with two tasks, and should generate output like this:

```
$ ansible-playbook -i vyos.example.net, -u ansible -k -e ansible_network_os=vyos.vyos.vyos first_playbook.yml

PLAY [Network Getting Started First Playbook]
***************************************************************************************************************************

TASK [Get config for VyOS devices]
***************************************************************************************************************************
ok: [vyos.example.net]

TASK [Display the config]
***************************************************************************************************************************
ok: [vyos.example.net] => {
    "msg": "The hostname is vyos and the OS is VyOS 1.1.8"
}
```

1. Now that you can retrieve the device config, try updating it with Ansible. Download [`first_playbook_ext.yml`](https://docs.ansible.com/ansible/latest/_downloads/47cc11a5d29fe635cb56cb6e1cd74e0f/first_playbook_ext.yml), which is an extended version of the first playbook:

```
---

- name: Network Getting Started First Playbook Extended
  connection: ansible.netcommon.network_cli
  gather_facts: false
  hosts: all
  tasks:

    - name: Get config for VyOS devices
      vyos.vyos.vyos_facts:
        gather_subset: all

    - name: Display the config
      debug:
        msg: "The hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}"

    - name: Update the hostname
      vyos.vyos.vyos_config:
        backup: yes
        lines:
          - set system host-name vyos-changed

    - name: Get changed config for VyOS devices
      vyos.vyos.vyos_facts:
        gather_subset: all

    - name: Display the changed config
      debug:
        msg: "The new hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}"
```

The extended first playbook has five tasks in a single play. Run it  with the same command you used above. The output shows you the change  Ansible made to the config:

```
$ ansible-playbook -i vyos.example.net, -u ansible -k -e ansible_network_os=vyos.vyos.vyos first_playbook_ext.yml

PLAY [Network Getting Started First Playbook Extended]
************************************************************************************************************************************

TASK [Get config for VyOS devices]
**********************************************************************************************************************************
ok: [vyos.example.net]

TASK [Display the config]
*************************************************************************************************************************************
ok: [vyos.example.net] => {
    "msg": "The hostname is vyos and the OS is VyOS 1.1.8"
}

TASK [Update the hostname]
*************************************************************************************************************************************
changed: [vyos.example.net]

TASK [Get changed config for VyOS devices]
*************************************************************************************************************************************
ok: [vyos.example.net]

TASK [Display the changed config]
*************************************************************************************************************************************
ok: [vyos.example.net] => {
    "msg": "The new hostname is vyos-changed and the OS is VyOS 1.1.8"
}

PLAY RECAP
************************************************************************************************************************************
vyos.example.net           : ok=5    changed=1    unreachable=0    failed=0
```



## [Gathering facts from network devices](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#id6)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#gathering-facts-from-network-devices)

The `gather_facts` keyword now supports gathering network device facts in standardized  key/value pairs. You can feed these network facts into further tasks to  manage the network device.

You can also use the new `gather_network_resources` parameter with the network `*_facts` modules (such as [arista.eos.eos_facts](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_facts_module.html#ansible-collections-arista-eos-eos-facts-module)) to return just a subset of the device configuration, as shown below.

```
- hosts: arista
  gather_facts: True
  gather_subset: interfaces
  module_defaults:
    arista.eos.eos_facts:
      gather_network_resources: interfaces
```

The playbook returns the following interface facts:

```
"network_resources": {
      "interfaces": [
          {
              "description": "test-interface",
              "enabled": true,
              "mtu": "512",
              "name": "Ethernet1"
          },
          {
              "enabled": true,
              "mtu": "3000",
              "name": "Ethernet2"
          },
          {
              "enabled": true,
              "name": "Ethernet3"
          },
          {
              "enabled": true,
              "name": "Ethernet4"
          },
          {
              "enabled": true,
              "name": "Ethernet5"
          },
          {
              "enabled": true,
              "name": "Ethernet6"
          },
      ]
  }
```

Note that this returns a subset of what is returned by just setting `gather_subset: interfaces`.

You can store these facts and use them directly in another task, such as with the [eos_interfaces](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_interfaces_module.html#ansible-collections-arista-eos-eos-interfaces-module) resource module.

# Build Your Inventory[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#build-your-inventory)

Running a playbook without an inventory requires several command-line flags. Also, running a playbook against a single device is not a huge  efficiency gain over making the same change manually. The next step to  harnessing the full power of Ansible is to use an inventory file to  organize your managed nodes into groups with information like the `ansible_network_os` and the SSH user. A fully-featured inventory file can serve as the  source of truth for your network. Using an inventory file, a single  playbook can maintain hundreds of network devices with a single command. This page shows you how to build an inventory file, step by step.

- [Basic inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#basic-inventory)
- [Add variables to the inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#add-variables-to-the-inventory)
- [Group variables within inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#group-variables-within-inventory)
- [Variable syntax](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#variable-syntax)
- [Group inventory by platform](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#group-inventory-by-platform)
- [Verifying the inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#verifying-the-inventory)
- [Protecting sensitive variables with `ansible-vault`](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#protecting-sensitive-variables-with-ansible-vault)

## [Basic inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#basic-inventory)

First, group your inventory logically. Best practice is to group  servers and network devices by their What (application, stack or  microservice), Where (datacenter or region), and When (development  stage):

- **What**: db, web, leaf, spine
- **Where**: east, west, floor_19, building_A
- **When**: dev, test, staging, prod

Avoid spaces, hyphens, and preceding numbers (use `floor_19`, not `19th_floor`) in your group names. Group names are case sensitive.

This tiny example data center illustrates a basic group structure. You can group groups using the syntax `[metagroupname:children]` and listing groups as members of the metagroup. Here, the group `network` includes all leafs and all spines; the group `datacenter` includes all network devices plus all webservers.

```
---

leafs:
  hosts:
    leaf01:
      ansible_host: 10.16.10.11
    leaf02:
      ansible_host: 10.16.10.12

spines:
  hosts:
    spine01:
      ansible_host: 10.16.10.13
    spine02:
      ansible_host: 10.16.10.14

network:
  children:
    leafs:
    spines:

webservers:
  hosts:
    webserver01:
      ansible_host: 10.16.10.15
    webserver02:
      ansible_host: 10.16.10.16

datacenter:
  children:
    network:
    webservers:
```

You can also create this same inventory in INI format.

```
[leafs]
leaf01
leaf02

[spines]
spine01
spine02

[network:children]
leafs
spines

[webservers]
webserver01
webserver02

[datacenter:children]
network
webservers
```

## [Add variables to the inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#add-variables-to-the-inventory)

Next, you can set values for many of the variables you needed in your first Ansible command in the inventory, so you can skip them in the `ansible-playbook` command. In this example, the inventory includes each network device’s  IP, OS, and SSH user. If your network devices are only accessible by IP, you must add the IP to the inventory file. If you access your network  devices using hostnames, the IP is not necessary.

```
---

leafs:
  hosts:
    leaf01:
      ansible_host: 10.16.10.11
      ansible_network_os: vyos.vyos.vyos
      ansible_user: my_vyos_user
    leaf02:
      ansible_host: 10.16.10.12
      ansible_network_os: vyos.vyos.vyos
      ansible_user: my_vyos_user

spines:
  hosts:
    spine01:
      ansible_host: 10.16.10.13
      ansible_network_os: vyos.vyos.vyos
      ansible_user: my_vyos_user
    spine02:
      ansible_host: 10.16.10.14
      ansible_network_os: vyos.vyos.vyos
      ansible_user: my_vyos_user

network:
  children:
    leafs:
    spines:

webservers:
  hosts:
    webserver01:
      ansible_host: 10.16.10.15
      ansible_user: my_server_user
    webserver02:
      ansible_host: 10.16.10.16
      ansible_user: my_server_user

datacenter:
  children:
    network:
    webservers:
```

## [Group variables within inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id3)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#group-variables-within-inventory)

When devices in a group share the same variable values, such as OS or SSH user, you can reduce duplication and simplify maintenance by  consolidating these into group variables:

```
---

leafs:
  hosts:
    leaf01:
      ansible_host: 10.16.10.11
    leaf02:
      ansible_host: 10.16.10.12
  vars:
    ansible_network_os: vyos.vyos.vyos
    ansible_user: my_vyos_user

spines:
  hosts:
    spine01:
      ansible_host: 10.16.10.13
    spine02:
      ansible_host: 10.16.10.14
  vars:
    ansible_network_os: vyos.vyos.vyos
    ansible_user: my_vyos_user

network:
  children:
    leafs:
    spines:

webservers:
  hosts:
    webserver01:
      ansible_host: 10.16.10.15
    webserver02:
      ansible_host: 10.16.10.16
  vars:
    ansible_user: my_server_user

datacenter:
  children:
    network:
    webservers:
```

## [Variable syntax](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id4)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#variable-syntax)

The syntax for variable values is different in inventory, in playbooks, and in the `group_vars` files, which are covered below. Even though playbook and `group_vars` files are both written in YAML, you use variables differently in each.

- In an ini-style inventory file you **must** use the syntax `key=value` for variable values: `ansible_network_os=vyos.vyos.vyos`.
- In any file with the `.yml` or `.yaml` extension, including playbooks and `group_vars` files, you **must** use YAML syntax: `key: value`.
- In `group_vars` files, use the full `key` name: `ansible_network_os: vyos.vyos.vyos`.
- In playbooks, use the short-form `key` name, which drops the `ansible` prefix: `network_os: vyos.vyos.vyos`.

## [Group inventory by platform](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id5)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#group-inventory-by-platform)

As your inventory grows, you may want to group devices by platform.  This allows you to specify platform-specific variables easily for all  devices on that platform:

```
---

leafs:
  hosts:
    leaf01:
      ansible_host: 10.16.10.11
    leaf02:
      ansible_host: 10.16.10.12

spines:
  hosts:
    spine01:
      ansible_host: 10.16.10.13
    spine02:
      ansible_host: 10.16.10.14

network:
  children:
    leafs:
    spines:
  vars:
    ansible_connection: ansible.netcommon.network_cli
    ansible_network_os: vyos.vyos.vyos
    ansible_user: my_vyos_user

webservers:
  hosts:
    webserver01:
      ansible_host: 10.16.10.15
    webserver02:
      ansible_host: 10.16.10.16
  vars:
    ansible_user: my_server_user

datacenter:
  children:
    network:
    webservers:
```

With this setup, you can run `first_playbook.yml` with only two flags:

```
ansible-playbook -i inventory.yml -k first_playbook.yml
```

With the `-k` flag, you provide the SSH password(s) at the prompt. Alternatively, you can store SSH and other secrets and passwords securely in your  group_vars files with `ansible-vault`. See [Protecting sensitive variables with ansible-vault](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#network-vault) for details.

## [Verifying the inventory](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id6)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#verifying-the-inventory)

You can use the [ansible-inventory](https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html#ansible-inventory) CLI command to display the inventory as Ansible sees it.

```
ansible-inventory -i test.yml --list
  {
    "_meta": {
        "hostvars": {
            "leaf01": {
                "ansible_connection": "ansible.netcommon.network_cli",
                "ansible_host": "10.16.10.11",
                "ansible_network_os": "vyos.vyos.vyos",
                "ansible_user": "my_vyos_user"
            },
            "leaf02": {
                "ansible_connection": "ansible.netcommon.network_cli",
                "ansible_host": "10.16.10.12",
                "ansible_network_os": "vyos.vyos.vyos",
                "ansible_user": "my_vyos_user"
            },
            "spine01": {
                "ansible_connection": "ansible.netcommon.network_cli",
                "ansible_host": "10.16.10.13",
                "ansible_network_os": "vyos.vyos.vyos",
                "ansible_user": "my_vyos_user"
            },
            "spine02": {
                "ansible_connection": "ansible.netcommon.network_cli",
                "ansible_host": "10.16.10.14",
                "ansible_network_os": "vyos.vyos.vyos",
                "ansible_user": "my_vyos_user"
            },
            "webserver01": {
                "ansible_host": "10.16.10.15",
                "ansible_user": "my_server_user"
            },
            "webserver02": {
                "ansible_host": "10.16.10.16",
                "ansible_user": "my_server_user"
            }
        }
    },
    "all": {
        "children": [
            "datacenter",
            "ungrouped"
        ]
    },
    "datacenter": {
        "children": [
            "network",
            "webservers"
        ]
    },
    "leafs": {
        "hosts": [
            "leaf01",
            "leaf02"
        ]
    },
    "network": {
        "children": [
            "leafs",
            "spines"
        ]
    },
    "spines": {
        "hosts": [
            "spine01",
            "spine02"
        ]
    },
    "webservers": {
        "hosts": [
            "webserver01",
            "webserver02"
        ]
    }
  }
```



## [Protecting sensitive variables with `ansible-vault`](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#id7)[](https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html#protecting-sensitive-variables-with-ansible-vault)

The `ansible-vault` command provides encryption for files and/or individual variables like  passwords. This tutorial will show you how to encrypt a single SSH  password. You can use the commands below to encrypt other sensitive  information, such as database passwords, privilege-escalation passwords  and more.

First you must create a password for ansible-vault itself. It is used as the encryption key, and with this you can encrypt dozens of  different passwords across your Ansible project. You can access all  those secrets (encrypted values) with a single password (the  ansible-vault password) when you run your playbooks. Here’s a simple  example.

1. Create a file and write your password for ansible-vault to it:

```
echo "my-ansible-vault-pw" > ~/my-ansible-vault-pw-file
```

1. Create the encrypted ssh password for your VyOS network devices,  pulling your ansible-vault password from the file you just created:

```
ansible-vault encrypt_string --vault-id my_user@~/my-ansible-vault-pw-file 'VyOS_SSH_password' --name 'ansible_password'
```

If you prefer to type your ansible-vault password rather than store it in a file, you can request a prompt:

```
ansible-vault encrypt_string --vault-id my_user@prompt 'VyOS_SSH_password' --name 'ansible_password'
```

and type in the vault password for `my_user`.

The [`--vault-id`](https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html#cmdoption-ansible-playbook-vault-id) flag allows different vault passwords for different users or different levels of access. The output includes the user name `my_user` from your `ansible-vault` command and uses the YAML syntax `key: value`:

```
ansible_password: !vault |
       $ANSIBLE_VAULT;1.2;AES256;my_user
       66386134653765386232383236303063623663343437643766386435663632343266393064373933
       3661666132363339303639353538316662616638356631650a316338316663666439383138353032
       63393934343937373637306162366265383461316334383132626462656463363630613832313562
       3837646266663835640a313164343535316666653031353763613037656362613535633538386539
       65656439626166666363323435613131643066353762333232326232323565376635
Encryption successful
```

This is an example using an extract from a  YAML inventory, as the INI format does not support inline vaults:

```
...

vyos: # this is a group in yaml inventory, but you can also do under a host
  vars:
    ansible_connection: ansible.netcommon.network_cli
    ansible_network_os: vyos.vyos.vyos
    ansible_user: my_vyos_user
    ansible_password:  !vault |
         $ANSIBLE_VAULT;1.2;AES256;my_user
         66386134653765386232383236303063623663343437643766386435663632343266393064373933
         3661666132363339303639353538316662616638356631650a316338316663666439383138353032
         63393934343937373637306162366265383461316334383132626462656463363630613832313562
         3837646266663835640a313164343535316666653031353763613037656362613535633538386539
         65656439626166666363323435613131643066353762333232326232323565376635

 ...
```

To use an inline vaulted variables with an INI inventory you need to store it in a ‘vars’ file in YAML format, it can reside in host_vars/ or group_vars/ to be automatically picked up or referenced from a play through `vars_files` or `include_vars`.

To run a playbook with this setup, drop the `-k` flag and add a flag for your `vault-id`:

```
ansible-playbook -i inventory --vault-id my_user@~/my-ansible-vault-pw-file first_playbook.yml
```

Or with a prompt instead of the vault password file:

```
ansible-playbook -i inventory --vault-id my_user@prompt first_playbook.yml
```

To see the original value, you can use the debug module. Please note if your YAML file defines the ansible_connection variable (as we used in our example), it will take effect when you  execute the command below. To prevent this, please make a copy of the  file without the ansible_connection variable.

```
cat vyos.yml | grep -v ansible_connection >> vyos_no_connection.yml

ansible localhost -m debug -a var="ansible_password" -e "@vyos_no_connection.yml" --ask-vault-pass
Vault password:

localhost | SUCCESS => {
    "ansible_password": "VyOS_SSH_password"
}
```

Warning

Vault content can only be decrypted with the password that was used  to encrypt it. If you want to stop using one password and move to a new  one, you can update and re-encrypt existing vault content with `ansible-vault rekey myfile`, then provide the old password and the new password. Copies of vault  content still encrypted with the old password can still be decrypted  with old password.

For more details on building inventory files, see [the introduction to inventory](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory); for more details on ansible-vault, see [the full Ansible Vault documentation](https://docs.ansible.com/ansible/latest/vault_guide/vault.html#vault).

Now that you understand the basics of commands, playbooks, and  inventory, it’s time to explore some more complex Ansible Network  examples.

# Use Ansible network roles[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#use-ansible-network-roles)

Roles are sets of Ansible defaults, files, tasks, templates,  variables, and other Ansible components that work together. As you saw  on [Run Your First Command and Playbook](https://docs.ansible.com/ansible/latest/network/getting_started/first_playbook.html#first-network-playbook), moving from a command to a playbook makes it easy to run multiple tasks and repeat the same tasks in the same order. Moving from a playbook to a role makes it even easier to reuse and share your ordered tasks. You  can look at [Ansible Galaxy](https://docs.ansible.com/ansible/latest/galaxy/user_guide.html#ansible-galaxy), which lets you share your roles and use others’ roles, either directly or as inspiration.

- [Understanding roles](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#understanding-roles)
  - [A sample DNS playbook](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#a-sample-dns-playbook)
  - [Convert the playbook into a role](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#convert-the-playbook-into-a-role)
  - [Variable precedence](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#variable-precedence)
    - [Lowest precedence](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#lowest-precedence)
    - [Highest precedence](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#highest-precedence)
  - [Update an installed role](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#update-an-installed-role)

## [Understanding roles](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#understanding-roles)

So what exactly is a role, and why should you care? Ansible roles are basically playbooks broken up into a known file structure. Moving to  roles from a playbook makes sharing, reading, and updating your Ansible  workflow easier. Users can write their own roles. So for example, you  don’t have to write your own DNS playbook. Instead, you specify a DNS  server and a role to configure it for you.

To simplify your workflow even further, the Ansible Network team has  written a series of roles for common network use cases. Using these  roles means you don’t have to reinvent the wheel. Instead of writing and maintaining your own `create_vlan` playbooks or roles, you can concentrate on designing, codifying and  maintaining the parser templates that describe your network topologies  and inventory, and let Ansible’s network roles do the work. See the [network-related roles](https://galaxy.ansible.com/ansible-network) on Ansible Galaxy.

### [A sample DNS playbook](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#a-sample-dns-playbook)

To demonstrate the concept of what a role is, the example `playbook.yml` below is a single YAML file containing a two-task playbook.  This  Ansible Playbook configures the hostname on a Cisco IOS XE device, then  it configures the DNS (domain name system) servers.

```
---
- name: configure cisco routers
  hosts: routers
  connection: ansible.netcommon.network_cli
  gather_facts: no
  vars:
    dns: "8.8.8.8 8.8.4.4"

  tasks:
   - name: configure hostname
     cisco.ios.ios_config:
       lines: hostname {{ inventory_hostname }}

   - name: configure DNS
     cisco.ios.ios_config:
       lines: ip name-server {{dns}}
```

If you run this playbook using the `ansible-playbook` command, you’ll see the output below.  This example used `-l` option to limit the playbook to only executing on the **rtr1** node.

```
[user@ansible ~]$ ansible-playbook playbook.yml -l rtr1

PLAY [configure cisco routers] *************************************************

TASK [configure hostname] ******************************************************
changed: [rtr1]

TASK [configure DNS] ***********************************************************
changed: [rtr1]

PLAY RECAP *********************************************************************
rtr1                       : ok=2    changed=2    unreachable=0    failed=0
```

This playbook configured the hostname and DNS servers.  You can verify that configuration on the Cisco IOS XE **rtr1** router:

```
rtr1#sh run | i name
hostname rtr1
ip name-server 8.8.8.8 8.8.4.4
```

### [Convert the playbook into a role](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id3)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#convert-the-playbook-into-a-role)

The next step is to convert this playbook into a reusable role. You can create the directory structure manually, or you can use `ansible-galaxy init` to create the standard framework for a role.

```
[user@ansible ~]$ ansible-galaxy init system-demo
[user@ansible ~]$ cd system-demo/
[user@ansible system-demo]$ tree
.
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── README.md
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
  └── main.yml
```

This first demonstration uses only the **tasks** and **vars** directories.  The directory structure would look as follows:

```
[user@ansible system-demo]$ tree
.
├── tasks
│   └── main.yml
└── vars
    └── main.yml
```

Next, move the content of the `vars` and `tasks` sections from the original Ansible Playbook into the role. First, move the two tasks into the `tasks/main.yml` file:

```
[user@ansible system-demo]$ cat tasks/main.yml
---
- name: configure hostname
  cisco.ios.ios_config:
    lines: hostname {{ inventory_hostname }}

- name: configure DNS
  cisco.ios.ios_config:
    lines: ip name-server {{dns}}
```

Next, move the variables into the `vars/main.yml` file:

```
[user@ansible system-demo]$ cat vars/main.yml
---
dns: "8.8.8.8 8.8.4.4"
```

Finally, modify the original Ansible Playbook to remove the `tasks` and `vars` sections and add the keyword `roles`  with the name of the role, in this case `system-demo`.  You’ll have this playbook:

```
---
- name: configure cisco routers
  hosts: routers
  connection: ansible.netcommon.network_cli
  gather_facts: no

  roles:
    - system-demo
```

To summarize, this demonstration now has a total of three directories and three YAML files.  There is the `system-demo` folder, which represents the role.  This `system-demo` contains two folders, `tasks` and `vars`.  There is a `main.yml` is each respective folder.  The `vars/main.yml` contains the variables from `playbook.yml`.  The `tasks/main.yml` contains the tasks from `playbook.yml`.  The `playbook.yml` file has been modified to call the role rather than specifying vars and tasks directly.  Here is a tree of the current working directory:

```
[user@ansible ~]$ tree
.
├── playbook.yml
└── system-demo
    ├── tasks
    │   └── main.yml
    └── vars
        └── main.yml
```

Running the playbook results in identical behavior with slightly different output:

```
[user@ansible ~]$ ansible-playbook playbook.yml -l rtr1

PLAY [configure cisco routers] *************************************************

TASK [system-demo : configure hostname] ****************************************
ok: [rtr1]

TASK [system-demo : configure DNS] *********************************************
ok: [rtr1]

PLAY RECAP *********************************************************************
rtr1             : ok=2    changed=0    unreachable=0    failed=0
```

As seen above each task is now prepended with the role name, in this case `system-demo`.  When running a playbook that contains several roles, this will help  pinpoint where a task is being called from.  This playbook returned `ok` instead of `changed` because it has identical behavior for the single file playbook we started from.

As before, the playbook will generate the following configuration on a Cisco IOS-XE router:

```
rtr1#sh run | i name
hostname rtr1
ip name-server 8.8.8.8 8.8.4.4
```

This is why Ansible roles can be simply thought of as deconstructed  playbooks. They are simple, effective and reusable.  Now another user  can simply include the `system-demo` role instead of having to create a custom “hard coded” playbook.

### [Variable precedence](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id4)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#variable-precedence)

What if you want to change the DNS servers?  You aren’t expected to change the `vars/main.yml` within the role structure. Ansible has many places where you can specify variables for a given play. See [Using Variables](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#playbooks-variables) for details on variables and precedence. There are actually 21 places  to put variables.  While this list can seem overwhelming at first  glance, the vast majority of use cases only involve knowing the spot for variables of least precedence and how to pass variables with most  precedence. See [Variable precedence: Where should I put a variable?](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#ansible-variable-precedence) for more guidance on where you should put variables.

#### [Lowest precedence](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id5)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#lowest-precedence)

The lowest precedence is the `defaults` directory within a role.  This means all the other 20 locations you  could potentially specify the variable will all take higher precedence  than `defaults`, no matter what.  To immediately give the vars from the `system-demo` role the least precedence, rename the `vars` directory to `defaults`.

```
[user@ansible system-demo]$ mv vars defaults
[user@ansible system-demo]$ tree
.
├── defaults
│   └── main.yml
├── tasks
│   └── main.yml
```

Add a new `vars` section to the playbook to override the default behavior (where the variable `dns` is set to 8.8.8.8 and 8.8.4.4).  For this demonstration, set `dns` to 1.1.1.1, so `playbook.yml` becomes:

```
---
- name: configure cisco routers
  hosts: routers
  connection: ansible.netcommon.network_cli
  gather_facts: no
  vars:
    dns: 1.1.1.1
  roles:
    - system-demo
```

Run this updated playbook on **rtr2**:

```
[user@ansible ~]$ ansible-playbook playbook.yml -l rtr2
```

The configuration on the **rtr2** Cisco router will look as follows:

```
rtr2#sh run | i name-server
ip name-server 1.1.1.1
```

The variable configured in the playbook now has precedence over the `defaults` directory.  In fact, any other spot you configure variables would win over the values in the `defaults` directory.

#### [Highest precedence](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id6)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#highest-precedence)

Specifying variables in the `defaults` directory within a role will always take the lowest precedence, while specifying `vars` as extra vars with the `-e` or `--extra-vars=` will always take the highest precedence, no matter what.  Re-running the playbook with the `-e` option overrides both the `defaults` directory (8.8.4.4 and 8.8.8.8) as well as the newly created `vars` within the playbook that contains the 1.1.1.1 dns server.

```
[user@ansible ~]$ ansible-playbook playbook.yml -e "dns=192.168.1.1" -l rtr3
```

The result on the Cisco IOS XE router will only contain the highest precedence setting of 192.168.1.1:

```
rtr3#sh run | i name-server
ip name-server 192.168.1.1
```

How is this useful?  Why should you care?  Extra vars are commonly  used by network operators to override defaults.  A powerful example of  this is with the Job Template Survey feature on AWX or the [Red Hat Ansible Automation Platform](https://docs.ansible.com/ansible/latest/reference_appendices/tower.html#ansible-platform).  It is possible through the web UI to prompt a network operator to fill out parameters with a Web form.  This can be really simple for  non-technical playbook writers to execute a playbook using their Web  browser.

### [Update an installed role](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#id7)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_roles.html#update-an-installed-role)

The Ansible Galaxy page for a role lists all available versions. To  update a locally installed role to a new or different version, use the `ansible-galaxy install` command with the version and `--force` option. You may also need to manually update any dependent roles to support this version. See the role **Read Me** tab in Galaxy for dependent role minimum version requirements.

```
[user@ansible]$ ansible-galaxy install mynamespace.my_role,v2.7.1 --force
```

See also

- [Ansible Galaxy documentation](https://galaxy.ansible.com/docs/)

  Ansible Galaxy user guide

# Beyond the basics[](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#beyond-the-basics)

This page introduces some concepts that help you manage your Ansible  workflow with directory structure and source control. Like the Basic  Concepts at the beginning of this guide, these intermediate concepts are common to all uses of Ansible.

- [A typical Ansible filetree](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#a-typical-ansible-filetree)
- [Tracking changes to inventory and playbooks: source control with git](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#tracking-changes-to-inventory-and-playbooks-source-control-with-git)

## [A typical Ansible filetree](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#a-typical-ansible-filetree)

Ansible expects to find certain files in certain places. As you  expand your inventory and create and run more network playbooks, keep  your files organized in your working Ansible project directory like  this:

```
.
├── backup
│   ├── vyos.example.net_config.2018-02-08@11:10:15
│   ├── vyos.example.net_config.2018-02-12@08:22:41
├── first_playbook.yml
├── inventory
├── group_vars
│   ├── vyos.yml
│   └── eos.yml
├── roles
│   ├── static_route
│   └── system
├── second_playbook.yml
└── third_playbook.yml
```

The `backup` directory and the files in it get created when you run modules like `vyos_config` with the `backup: yes` parameter.

## [Tracking changes to inventory and playbooks: source control with git](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/intermediate_concepts.html#tracking-changes-to-inventory-and-playbooks-source-control-with-git)

As you expand your inventory, roles and playbooks, you should place your Ansible projects under source control. We recommend `git` for source control. `git` provides an audit trail, letting you track changes, roll back mistakes, view history and share the workload of managing, maintaining and  expanding your Ansible ecosystem. There are plenty of tutorials and  guides to using `git` available.

# Working with network connection options[](https://docs.ansible.com/ansible/latest/network/getting_started/network_connection_options.html#working-with-network-connection-options)

Network modules can support multiple connection protocols, such as `ansible.netcommon.network_cli`, `ansible.netcommon.netconf`, and `ansible.netcommon.httpapi`. These connections include some common options you can set to control how the connection to your network device behaves.

Common options are:

- `become` and `become_method` as described in [Privilege Escalation: enable mode, become, and authorize](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#privilege-escalation).
- `network_os` - set to match your network platform you are communicating with. See the [platform-specific](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#platform-options) pages.
- `remote_user` as described in [Setting a remote user](https://docs.ansible.com/ansible/latest/inventory_guide/connection_details.html#connection-set-user).
- Timeout options - `persistent_command_timeout`, `persistent_connect_timeout`, and `timeout`.



## Setting timeout options[](https://docs.ansible.com/ansible/latest/network/getting_started/network_connection_options.html#setting-timeout-options)

When communicating with a remote device, you have control over how  long Ansible maintains the connection to that device, as well as how  long Ansible waits for a command to complete on that device. Each of  these options can be set as variables in your playbook files,  environment variables, or settings in your [ansible.cfg file](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).

For example, the three options for controlling the connection timeout are as follows.

Using vars (per task):

```
- name: save running-config
  cisco.ios.ios_command:
    commands: copy running-config startup-config
    vars:
      ansible_command_timeout: 30
```

Using the environment variable:

```
$export ANSIBLE_PERSISTENT_COMMAND_TIMEOUT=30
```

Using the global configuration (in `ansible.cfg`)

```
[persistent_connection]
command_timeout = 30
```

See [Variable precedence: Where should I put a variable?](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#ansible-variable-precedence) for details on the relative precedence of each of these variables. See  the individual connection type to understand each option.

# Resources and next steps[](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#resources-and-next-steps)

- [Documents](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#documents)
- [Events (on video and in person)](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#events-on-video-and-in-person)
- [GitHub repos](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#github-repos)
- [Chat channels](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#chat-channels)

## [Documents](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#id1)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#documents)

Read more about Ansible for Network Automation:

- [Network Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#platform-options)
- Network Automation on the [Ansible website](https://www.ansible.com/overview/networking)
- Ansible Network [Blog posts](https://www.ansible.com/blog/topic/networks)

## [Events (on video and in person)](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#id2)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#events-on-video-and-in-person)

All sessions at Ansible events are recorded and include many  Network-related topics (use Filter by Category to view only Network  topics). You can also join us for future events in your area. See:

- [Recorded AnsibleFests](https://www.ansible.com/resources/videos/ansiblefest)
- [Recorded AnsibleAutomates](https://www.ansible.com/resources/webinars-training)
- [Upcoming Ansible Events](https://www.ansible.com/community/events) page.

## [GitHub repos](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#id3)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#github-repos)

Ansible hosts module code, examples, demonstrations, and other  content on GitHub. Anyone with a GitHub account is able to create Pull  Requests (PRs) or issues on these repos:

- [Network-Automation](https://github.com/network-automation) is an open community for all things network automation. Have an idea, some playbooks, or roles to share? Email [ansible-network@redhat.com](mailto:ansible-network@redhat.com) and we will add you as a contributor to the repository.
- [Ansible collections](https://github.com/ansible-collections) is the main repository for Ansible-maintained and community collections, including collections for network devices.

## [Chat channels](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#id4)[](https://docs.ansible.com/ansible/latest/network/getting_started/network_resources.html#chat-channels)

Got questions? Chat with us on:

- the `#ansible-network` channel (using Matrix at ansible.im or using IRC at [irc.libera.chat](https://libera.chat/))
- [Ansible Network Slack](https://join.slack.com/t/ansiblenetwork/shared_invite/zt-3zeqmhhx-zuID9uJqbbpZ2KdVeTwvzw) - Network & Security Automation Slack community.  Check out the  #devel channel for discussions on module and plugin development.

# Network Advanced Topics[](https://docs.ansible.com/ansible/latest/network/user_guide/index.html#network-advanced-topics)

Once you have mastered the basics of network automation with Ansible, as presented in [Network Getting Started](https://docs.ansible.com/ansible/latest/network/getting_started/index.html#network-getting-started), use this guide understand platform-specific details, optimization, and  troubleshooting tips for Ansible for network automation.

**Who should use this guide?**

This guide is intended for network engineers using Ansible for  automation. It covers advanced topics. If you understand networks and  Ansible, this guide is for you. You may read through the entire guide if you choose, or use the links below to find the specific information you need.

If you’re new to Ansible, or new to using Ansible for network automation, start with the [Network Getting Started](https://docs.ansible.com/ansible/latest/network/getting_started/index.html#network-getting-started).

Advanced Topics

- Network Resource Modules
  - [Network resource module states](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#network-resource-module-states)
  - [Using network resource modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#using-network-resource-modules)
  - [Example: Verifying the network device configuration has not changed](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#example-verifying-the-network-device-configuration-has-not-changed)
  - [Example: Acquiring and updating VLANs on a network device](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#example-acquiring-and-updating-vlans-on-a-network-device)
- Ansible Network Examples
  - [Prerequisites](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#prerequisites)
  - [Groups and variables in an inventory file](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#groups-and-variables-in-an-inventory-file)
  - [Example 1: collecting facts and creating backup files with a playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#example-1-collecting-facts-and-creating-backup-files-with-a-playbook)
  - [Example 2: simplifying playbooks with platform-independent modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#example-2-simplifying-playbooks-with-platform-independent-modules)
  - [Implementation Notes](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#implementation-notes)
  - [Troubleshooting](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#troubleshooting)
- Parsing semi-structured text with Ansible
  - [Understanding the CLI parser](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#understanding-the-cli-parser)
  - [Parsing the CLI](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-the-cli)
  - [Advanced use cases](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#advanced-use-cases)
- Validate data against set criteria with Ansible
  - [Understanding the validate plugin](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#understanding-the-validate-plugin)
  - [Structuring the data](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#structuring-the-data)
  - [Defining the criteria to validate against](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#defining-the-criteria-to-validate-against)
  - [Validating the data](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#validating-the-data)
- Network Debug and Troubleshooting Guide
  - [How to troubleshoot](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#how-to-troubleshoot)
  - [Troubleshooting socket path issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#troubleshooting-socket-path-issues)
  - [Category “Unable to open shell”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#category-unable-to-open-shell)
  - [Timeout issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#timeout-issues)
  - [Playbook issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#playbook-issues)
  - [Proxy Issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#proxy-issues)
  - [Miscellaneous Issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#miscellaneous-issues)
- Working with command output and prompts in network modules
  - [Conditionals in networking modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#conditionals-in-networking-modules)
  - [Handling prompts in network modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#handling-prompts-in-network-modules)
- Ansible Network FAQ
  - [How can I improve performance for network playbooks?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#how-can-i-improve-performance-for-network-playbooks)
  - [Why is my output sometimes replaced with `********`?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#why-is-my-output-sometimes-replaced-with)
  - [Why do the `*_config` modules always return `changed=true` with abbreviated commands?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#why-do-the-config-modules-always-return-changed-true-with-abbreviated-commands)
- Platform Options
  - [CloudEngine OS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html)
  - [CNOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_cnos.html)
  - [Dell OS6 Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos6.html)
  - [Dell OS9 Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos9.html)
  - [Dell OS10 Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos10.html)
  - [ENOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_enos.html)
  - [EOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eos.html)
  - [ERIC_ECCLI Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eric_eccli.html)
  - [EXOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_exos.html)
  - [FRR Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_frr.html)
  - [ICX Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_icx.html)
  - [IOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ios.html)
  - [IOS-XR Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_iosxr.html)
  - [IronWare Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ironware.html)
  - [Junos OS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_junos.html)
  - [Meraki Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_meraki.html)
  - [Pluribus NETVISOR Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_netvisor.html)
  - [NOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nos.html)
  - [NXOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nxos.html)
  - [RouterOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_routeros.html)
  - [SLX-OS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_slxos.html)
  - [VOSS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_voss.html)
  - [VyOS Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_vyos.html)
  - [WeOS 4 Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_weos4.html)
  - [Netconf enabled Platform Options](https://docs.ansible.com/ansible/latest/network/user_guide/platform_netconf_enabled.html)
  - [Settings by Platform](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform)

# Network Resource Modules[](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#network-resource-modules)

Ansible network resource modules simplify and standardize how you  manage different network devices. Network devices separate configuration into sections (such as interfaces and VLANs) that apply to a network  service. Ansible network resource modules take advantage of this to  allow you to configure subsections or *resources* within the  network device configuration. Network resource modules provide a  consistent experience across different network devices.

- [Network resource module states](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#network-resource-module-states)
- [Using network resource modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#using-network-resource-modules)
- [Example: Verifying the network device configuration has not changed](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#example-verifying-the-network-device-configuration-has-not-changed)
- [Example: Acquiring and updating VLANs on a network device](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#example-acquiring-and-updating-vlans-on-a-network-device)

## [Network resource module states](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#id1)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#network-resource-module-states)

You use the network resource modules by assigning a state to what you want the module to do. The resource modules support the following  states:

- merged

  Ansible merges the on-device configuration with the provided configuration in the task.

- replaced

  Ansible replaces the on-device configuration subsection with the provided configuration subsection in the task.

- overridden

  Ansible overrides the on-device configuration  for the resource with the provided configuration in the task. Use  caution with this state as you could remove your access to the device  (for example, by overriding the management interface configuration).

- deleted

  Ansible deletes the on-device configuration subsection and restores any default settings.

- gathered

  Ansible displays the resource details gathered from the network device and accessed with the `gathered` key in the result.

- rendered

  Ansible renders the provided configuration in  the task in the device-native format (for example, Cisco IOS CLI).  Ansible returns this rendered configuration in the `rendered` key in the result. Note this state does not communicate with the network device and can be used offline.

- parsed

  Ansible parses the configuration from the `running_config` option into Ansible structured data in the `parsed` key in the result. Note this does not gather the configuration from the network device so this state can be used offline.

## [Using network resource modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#using-network-resource-modules)

This example configures the L3 interface resource on a Cisco IOS device, based on different state settings.

> ```
> - name: configure l3 interface
>   cisco.ios.ios_l3_interfaces:
>     config: "{{ config }}"
>     state: <state>
> ```

The following table shows an example of how an initial resource configuration changes with this task for different states.

| Resource starting configuration                              | task-provided configuration (YAML)                           | Final resource configuration on device                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `interface loopback100 ip address 10.10.1.100 255.255.255.0 ipv6 address FC00:100/64 ` | `config: - ipv6: - address: fc00::100/64 - address: fc00::101/64 name: loopback100 ` | *merged*`interface loopback100 ip address 10.10.1.100 255.255.255.0 ipv6 address FC00:100/64 ipv6 address FC00:101/64 ` |
| *replaced*`interface loopback100 no ip address ipv6 address FC00:100/64 ipv6 address FC00:101/64 ` |                                                              |                                                              |
| *overridden*Incorrect use case. This would remove all interfaces from the device (including the mgmt interface) exceptthe configured loopback100 |                                                              |                                                              |
| *deleted*`interface loopback100 no ip address `              |                                                              |                                                              |

Network resource modules return the following details:

- The *before* state -  the existing resource configuration before the task was executed.
- The *after* state - the new resource configuration that exists on the network device after the task was executed.
- Commands - any commands configured on the device.

```
ok: [nxos101] =>
  result:
    after:
      contact: IT Support
      location: Room E, Building 6, Seattle, WA 98134
      users:
      - algorithm: md5
        group: network-admin
        localized_key: true
        password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'
        privacy_password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'
        username: admin
    before:
      contact: IT Support
      location: Room E, Building 5, Seattle HQ
      users:
      - algorithm: md5
        group: network-admin
        localized_key: true
        password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'
        privacy_password: '0x73fd9a2cc8c53ed3dd4ed8f4ff157e69'
        username: admin
    changed: true
    commands:
    - snmp-server location Room E, Building 6, Seattle, WA 98134
    failed: false
```

## [Example: Verifying the network device configuration has not changed](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#example-verifying-the-network-device-configuration-has-not-changed)

The following playbook uses the [arista.eos.eos_l3_interfaces](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_l3_interfaces_module.html#ansible-collections-arista-eos-eos-l3-interfaces-module) module to gather a subset of the network device configuration (Layer 3  interfaces only) and verifies the information is accurate and has not  changed. This playbook passes the results of [arista.eos.eos_facts](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_facts_module.html#ansible-collections-arista-eos-eos-facts-module) directly to the `arista.eos.eos_l3_interfaces` module.

```
- name: Example of facts being pushed right back to device.
  hosts: arista
  gather_facts: false
  tasks:
    - name: grab arista eos facts
      arista.eos.eos_facts:
        gather_subset: min
        gather_network_resources: l3_interfaces

- name: Ensure that the IP address information is accurate.
  arista.eos.eos_l3_interfaces:
    config: "{{ ansible_network_resources['l3_interfaces'] }}"
    register: result

- name: Ensure config did not change.
  assert:
    that: not result.changed
```

## [Example: Acquiring and updating VLANs on a network device](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html#example-acquiring-and-updating-vlans-on-a-network-device)

This example shows how you can use resource modules to:

1. Retrieve the current configuration on a network device.
2. Save that configuration locally.
3. Update that configuration and apply it to the network device.

This example uses the `cisco.ios.ios_vlans` resource module to retrieve and update the VLANs on an IOS device.

1. Retrieve the current IOS VLAN configuration:

```
- name: Gather VLAN information as structured data
  cisco.ios.ios_facts:
     gather_subset:
      - '!all'
      - '!min'
     gather_network_resources:
     - 'vlans'
```

1. Store the VLAN configuration locally:

```
- name: Store VLAN facts to host_vars
  copy:
    content: "{{ ansible_network_resources | to_nice_yaml }}"
    dest: "{{ playbook_dir }}/host_vars/{{ inventory_hostname }}"
```

1. Modify the stored file to update the VLAN configuration locally.
2. Merge the updated VLAN configuration with the existing configuration on the device:

```
- name: Make VLAN config changes by updating stored facts on the controller.
  cisco.ios.ios_vlans:
    config: "{{ vlans }}"
    state: merged
  tags: update_config
```

See also

- [Network Features in Ansible 2.9](https://www.ansible.com/blog/network-features-coming-soon-in-ansible-engine-2.9)

  A introductory blog post on network resource modules.

- [Deep Dive into Network Resource Modules](https://www.ansible.com/deep-dive-into-ansible-network-resource-module)

  A deeper dive presentation into network resource modules.

# Ansible Network Examples[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#ansible-network-examples)

This document describes some examples of using Ansible to manage your network infrastructure.

- [Prerequisites](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#prerequisites)
- [Groups and variables in an inventory file](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#groups-and-variables-in-an-inventory-file)
  - [Ansible vault for password encryption](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#ansible-vault-for-password-encryption)
  - [Common inventory variables](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#common-inventory-variables)
  - [Privilege escalation](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#privilege-escalation)
  - [Jump hosts](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#jump-hosts)
- [Example 1: collecting facts and creating backup files with a playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#example-1-collecting-facts-and-creating-backup-files-with-a-playbook)
  - [Step 1: Creating the inventory](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-1-creating-the-inventory)
  - [Step 2: Creating the playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-2-creating-the-playbook)
  - [Step 3: Running the playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-3-running-the-playbook)
  - [Step 4: Examining the playbook results](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-4-examining-the-playbook-results)
- [Example 2: simplifying playbooks with platform-independent modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#example-2-simplifying-playbooks-with-platform-independent-modules)
  - [Sample playbook with platform-specific modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#sample-playbook-with-platform-specific-modules)
  - [Simplified playbook with `cli_command` platform-independent module](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#simplified-playbook-with-cli-command-platform-independent-module)
  - [Using multiple prompts with the  `ansible.netcommon.cli_command`](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#using-multiple-prompts-with-the-ansible-netcommon-cli-command)
- [Implementation Notes](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#implementation-notes)
  - [Demo variables](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#demo-variables)
  - [Get running configuration](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#get-running-configuration)
- [Troubleshooting](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#troubleshooting)

## [Prerequisites](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id1)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#prerequisites)

This example requires the following:

- **Ansible 2.10** (or higher) installed. See [Installing Ansible](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#intro-installation-guide) for more information.
- One or more network devices that are compatible with Ansible.
- Basic understanding of YAML [YAML Syntax](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-syntax).
- Basic understanding of Jinja2 templates. See [Templating (Jinja2)](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html#playbooks-templating) for more information.
- Basic Linux command line use.
- Basic knowledge of network switch & router configurations.

## [Groups and variables in an inventory file](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#groups-and-variables-in-an-inventory-file)

An `inventory` file is a YAML or INI-like configuration file that defines the mapping of hosts into groups.

In our example, the inventory file defines the groups `eos`, `ios`, `vyos` and a “group of groups” called `switches`. Further details about subgroups and inventory files can be found in the [Ansible inventory Group documentation](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#subgroups).

Because Ansible is a flexible tool, there are a number of ways to  specify connection information and credentials. We recommend using the `[my_group:vars]` capability in your inventory file.

```
[all:vars]
# these defaults can be overridden for any group in the [group:vars] section
ansible_connection=ansible.netcommon.network_cli
ansible_user=ansible

[switches:children]
eos
ios
vyos

[eos]
veos01 ansible_host=veos-01.example.net
veos02 ansible_host=veos-02.example.net
veos03 ansible_host=veos-03.example.net
veos04 ansible_host=veos-04.example.net

[eos:vars]
ansible_become=yes
ansible_become_method=enable
ansible_network_os=arista.eos.eos
ansible_user=my_eos_user
ansible_password=my_eos_password

[ios]
ios01 ansible_host=ios-01.example.net
ios02 ansible_host=ios-02.example.net
ios03 ansible_host=ios-03.example.net

[ios:vars]
ansible_become=yes
ansible_become_method=enable
ansible_network_os=cisco.ios.ios
ansible_user=my_ios_user
ansible_password=my_ios_password

[vyos]
vyos01 ansible_host=vyos-01.example.net
vyos02 ansible_host=vyos-02.example.net
vyos03 ansible_host=vyos-03.example.net

[vyos:vars]
ansible_network_os=vyos.vyos.vyos
ansible_user=my_vyos_user
ansible_password=my_vyos_password
```

If you use ssh-agent, you do not need the `ansible_password` lines. If you use ssh keys, but not ssh-agent, and you have multiple keys, specify the key to use for each connection in the `[group:vars]` section with `ansible_ssh_private_key_file=/path/to/correct/key`. For more information on `ansible_ssh_` options see [Connecting to hosts: behavioral inventory parameters](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#behavioral-parameters).

Warning

Never store passwords in plain text.

### [Ansible vault for password encryption](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#ansible-vault-for-password-encryption)

The “Vault” feature of Ansible allows you to keep sensitive data such as passwords or keys in encrypted files, rather than as plain text in  your playbooks or roles. These vault files can then be distributed or  placed in source control. See [Using encrypted variables and files](https://docs.ansible.com/ansible/latest/vault_guide/vault_using_encrypted_content.html#playbooks-vault) for more information.

Here’s what it would look like if you specified your SSH passwords (encrypted with Ansible Vault) among your variables:

```
ansible_connection: ansible.netcommon.network_cli
ansible_network_os: vyos.vyos.vyos
ansible_user: my_vyos_user
ansible_ssh_pass: !vault |
                  $ANSIBLE_VAULT;1.1;AES256
                  39336231636137663964343966653162353431333566633762393034646462353062633264303765
                  6331643066663534383564343537343334633031656538370a333737656236393835383863306466
                  62633364653238323333633337313163616566383836643030336631333431623631396364663533
                  3665626431626532630a353564323566316162613432373738333064366130303637616239396438
                  9853
```

### [Common inventory variables](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#common-inventory-variables)

The following variables are common for all platforms in the  inventory, though they can be overwritten for a particular inventory  group or host.

- ansible_connection

  Ansible uses the ansible-connection setting to  determine how to connect to a remote device. When working with Ansible  Networking, set this to an appropriate network connection option, such  as``ansible.netcommon.network_cli``, so Ansible treats the remote node  as a network device with a limited execution environment. Without this  setting, Ansible would attempt to use ssh to connect to the remote and  execute the Python script on the network device, which would fail  because Python generally isn’t available on network devices.

- ansible_network_os

  Informs Ansible which Network platform this hosts corresponds to. This is required when using the `ansible.netcommon.*` connection options.

- ansible_user

  The user to connect to the remote device (switch) as. Without this the user that is running `ansible-playbook` would be used. Specifies which user on the network device the connection

- ansible_password

  The corresponding password for `ansible_user` to log in as. If not specified SSH key will be used.

- ansible_become

  If enable mode (privilege mode) should be used, see the next section.

- ansible_become_method

  Which type of become should be used, for `network_cli` the only valid choice is `enable`.

### [Privilege escalation](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id5)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#privilege-escalation)

Certain network platforms, such as Arista EOS and Cisco IOS, have the concept of different privilege modes. Certain network modules, such as  those that modify system state including users, will only work in high  privilege states. Ansible supports `become` when using `connection: ansible.netcommon.network_cli`. This allows privileges to be raised for the specific tasks that need them. Adding `become: yes` and `become_method: enable` informs Ansible to go into privilege mode before executing the task, as shown here:

```
[eos:vars]
ansible_connection=ansible.netcommon.network_cli
ansible_network_os=arista.eos.eos
ansible_become=yes
ansible_become_method=enable
```

For more information, see the [using become with network modules](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_privilege_escalation.html#become-network) guide.

### [Jump hosts](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id6)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#jump-hosts)

If the Ansible Controller does not have a direct route to the remote device and you need to use a Jump Host, please see the [Ansible Network Proxy Command](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#network-delegate-to-vs-proxycommand) guide for details on how to achieve this.

## [Example 1: collecting facts and creating backup files with a playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id7)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#example-1-collecting-facts-and-creating-backup-files-with-a-playbook)

Ansible facts modules gather system information ‘facts’ that are available to the rest of your playbook.

Ansible Networking ships with a number of network-specific facts modules. In this example, we use the `_facts` modules [arista.eos.eos_facts](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_facts_module.html#ansible-collections-arista-eos-eos-facts-module), [cisco.ios.ios_facts](https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_facts_module.html#ansible-collections-cisco-ios-ios-facts-module) and [vyos.vyos.vyos_facts](https://docs.ansible.com/ansible/latest/collections/vyos/vyos/vyos_facts_module.html#ansible-collections-vyos-vyos-vyos-facts-module) to connect to the remote networking device. As the credentials are not  explicitly passed with module arguments, Ansible uses the username and  password from the inventory file.

Ansible’s “Network Fact modules” gather information from the system and store the results in facts prefixed with `ansible_net_`. The data collected by these modules is documented in the Return Values section of the module docs, in this case [arista.eos.eos_facts](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_facts_module.html#ansible-collections-arista-eos-eos-facts-module) and [vyos.vyos.vyos_facts](https://docs.ansible.com/ansible/latest/collections/vyos/vyos/vyos_facts_module.html#ansible-collections-vyos-vyos-vyos-facts-module). We can use the facts, such as `ansible_net_version` late on in the “Display some facts” task.

To ensure we call the correct mode (`*_facts`) the task is conditionally run based on the group defined in the  inventory file, for more information on the use of conditionals in  Ansible Playbooks see [Basic conditionals with when](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_conditionals.html#the-when-statement).

In this example, we will create an inventory file containing some  network switches, then run a playbook to connect to the network devices  and return some information about them.

### [Step 1: Creating the inventory](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id8)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-1-creating-the-inventory)

First, create a file called `inventory`, containing:

```
[switches:children]
eos
ios
vyos

[eos]
eos01.example.net

[ios]
ios01.example.net

[vyos]
vyos01.example.net
```

### [Step 2: Creating the playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id9)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-2-creating-the-playbook)

Next, create a playbook file called `facts-demo.yml` containing the following:

```
- name: "Demonstrate connecting to switches"
  hosts: switches
  gather_facts: no

  tasks:
    ###
    # Collect data
    #
    - name: Gather facts (eos)
      arista.eos.eos_facts:
      when: ansible_network_os == 'arista.eos.eos'

    - name: Gather facts (ios)
      cisco.ios.ios_facts:
      when: ansible_network_os == 'cisco.ios.ios'

    - name: Gather facts (vyos)
      vyos.vyos.vyos_facts:
      when: ansible_network_os == 'vyos.vyos.vyos'

    ###
    # Demonstrate variables
    #
    - name: Display some facts
      debug:
        msg: "The hostname is {{ ansible_net_hostname }} and the OS is {{ ansible_net_version }}"

    - name: Facts from a specific host
      debug:
        var: hostvars['vyos01.example.net']

    - name: Write facts to disk using a template
      copy:
        content: |
          #jinja2: lstrip_blocks: True
          EOS device info:
            {% for host in groups['eos'] %}
            Hostname: {{ hostvars[host].ansible_net_hostname }}
            Version: {{ hostvars[host].ansible_net_version }}
            Model: {{ hostvars[host].ansible_net_model }}
            Serial: {{ hostvars[host].ansible_net_serialnum }}
            {% endfor %}

          IOS device info:
            {% for host in groups['ios'] %}
            Hostname: {{ hostvars[host].ansible_net_hostname }}
            Version: {{ hostvars[host].ansible_net_version }}
            Model: {{ hostvars[host].ansible_net_model }}
            Serial: {{ hostvars[host].ansible_net_serialnum }}
            {% endfor %}

          VyOS device info:
            {% for host in groups['vyos'] %}
            Hostname: {{ hostvars[host].ansible_net_hostname }}
            Version: {{ hostvars[host].ansible_net_version }}
            Model: {{ hostvars[host].ansible_net_model }}
            Serial: {{ hostvars[host].ansible_net_serialnum }}
            {% endfor %}
        dest: /tmp/switch-facts
      run_once: yes

    ###
    # Get running configuration
    #

    - name: Backup switch (eos)
      arista.eos.eos_config:
        backup: yes
      register: backup_eos_location
      when: ansible_network_os == 'arista.eos.eos'

    - name: backup switch (vyos)
      vyos.vyos.vyos_config:
        backup: yes
      register: backup_vyos_location
      when: ansible_network_os == 'vyos.vyos.vyos'

    - name: Create backup dir
      file:
        path: "/tmp/backups/{{ inventory_hostname }}"
        state: directory
        recurse: yes

    - name: Copy backup files into /tmp/backups/ (eos)
      copy:
        src: "{{ backup_eos_location.backup_path }}"
        dest: "/tmp/backups/{{ inventory_hostname }}/{{ inventory_hostname }}.bck"
      when: ansible_network_os == 'arista.eos.eos'

    - name: Copy backup files into /tmp/backups/ (vyos)
      copy:
        src: "{{ backup_vyos_location.backup_path }}"
        dest: "/tmp/backups/{{ inventory_hostname }}/{{ inventory_hostname }}.bck"
      when: ansible_network_os == 'vyos.vyos.vyos'
```

### [Step 3: Running the playbook](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id10)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-3-running-the-playbook)

To run the playbook, run the following from a console prompt:

```
ansible-playbook -i inventory facts-demo.yml
```

This should return output similar to the following:

```
PLAY RECAP
eos01.example.net          : ok=7    changed=2    unreachable=0    failed=0
ios01.example.net          : ok=7    changed=2    unreachable=0    failed=0
vyos01.example.net         : ok=6    changed=2    unreachable=0    failed=0
```

### [Step 4: Examining the playbook results](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id11)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#step-4-examining-the-playbook-results)

Next, look at the contents of the file we created containing the switch facts:

```
cat /tmp/switch-facts
```

You can also look at the backup files:

```
find /tmp/backups
```

If ansible-playbook fails, please follow the debug steps in [Network Debug and Troubleshooting Guide](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#network-debug-troubleshooting).



## [Example 2: simplifying playbooks with platform-independent modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id12)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#example-2-simplifying-playbooks-with-platform-independent-modules)

(This example originally appeared in the [Deep Dive on cli_command for Network Automation](https://www.ansible.com/blog/deep-dive-on-cli-command-for-network-automation) blog post by Sean Cavanaugh -[@IPvSean](https://github.com/IPvSean)).

If you have two or more network platforms in your environment, you  can use the platform-independent modules to simplify your playbooks. You can use platform-independent modules such as `ansible.netcommon.cli_command` or `ansible.netcommon.cli_config` in place of the platform-specific modules such as `arista.eos.eos_config`, `cisco.ios.ios_config`, and `junipernetworks.junos.junos_config`. This reduces the number of tasks and conditionals you need in your playbooks.

Note

Platform-independent modules require the [ansible.netcommon.network_cli](https://docs.ansible.com/ansible/latest/collections/ansible/netcommon/network_cli_connection.html#ansible-collections-ansible-netcommon-network-cli-connection) connection plugin.

### [Sample playbook with platform-specific modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id13)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#sample-playbook-with-platform-specific-modules)

This example assumes three platforms, Arista EOS, Cisco NXOS, and  Juniper JunOS.  Without the platform-independent modules, a sample  playbook might contain the following three tasks with platform-specific  commands:

```
---
- name: Run Arista command
  arista.eos.eos_command:
    commands: show ip int br
  when: ansible_network_os == 'arista.eos.eos'

- name: Run Cisco NXOS command
  cisco.nxos.nxos_command:
    commands: show ip int br
  when: ansible_network_os == 'cisco.nxos.nxos'

- name: Run Vyos command
  vyos.vyos.vyos_command:
    commands: show interface
  when: ansible_network_os == 'vyos.vyos.vyos'
```

### [Simplified playbook with `cli_command` platform-independent module](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id14)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#simplified-playbook-with-cli-command-platform-independent-module)

You can replace these platform-specific modules with the platform-independent `ansible.netcommon.cli_command` module as follows:

```
---
- hosts: network
  gather_facts: false
  connection: ansible.netcommon.network_cli

  tasks:
    - name: Run cli_command on Arista and display results
      block:
      - name: Run cli_command on Arista
        ansible.netcommon.cli_command:
          command: show ip int br
        register: result

      - name: Display result to terminal window
        debug:
          var: result.stdout_lines
      when: ansible_network_os == 'arista.eos.eos'

    - name: Run cli_command on Cisco IOS and display results
      block:
      - name: Run cli_command on Cisco IOS
        ansible.netcommon.cli_command:
          command: show ip int br
        register: result

      - name: Display result to terminal window
        debug:
          var: result.stdout_lines
      when: ansible_network_os == 'cisco.ios.ios'

    - name: Run cli_command on Vyos and display results
      block:
      - name: Run cli_command on Vyos
        ansible.netcommon.cli_command:
          command: show interfaces
        register: result

      - name: Display result to terminal window
        debug:
          var: result.stdout_lines
      when: ansible_network_os == 'vyos.vyos.vyos'
```

If you use groups and group_vars by platform type, this playbook can be further simplified to :

```
---
- name: Run command and print to terminal window
  hosts: routers
  gather_facts: false

  tasks:
    - name: Run show command
      ansible.netcommon.cli_command:
        command: "{{show_interfaces}}"
      register: command_output
```

You can see a full example of this using group_vars and also a configuration backup example at [Platform-independent examples](https://github.com/network-automation/agnostic_example).

### [Using multiple prompts with the  `ansible.netcommon.cli_command`](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id15)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#using-multiple-prompts-with-the-ansible-netcommon-cli-command)

The `ansible.netcommon.cli_command` also supports multiple prompts.

```
---
- name: Change password to default
  ansible.netcommon.cli_command:
    command: "{{ item }}"
    prompt:
      - "New password"
      - "Retype new password"
    answer:
      - "mypassword123"
      - "mypassword123"
    check_all: True
  loop:
    - "configure"
    - "rollback"
    - "set system root-authentication plain-text-password"
    - "commit"
```

See the [ansible.netcommon.cli_command](https://docs.ansible.com/ansible/2.9/modules/cli_command_module.html#cli-command-module) for full documentation on this command.

## [Implementation Notes](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id16)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#implementation-notes)

### [Demo variables](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id17)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#demo-variables)

Although these tasks are not needed to write data to disk, they are  used in this example to demonstrate some methods of accessing facts  about the given devices or a named host.

Ansible `hostvars` allows you to access variables from a named host. Without this we would return the details for the current host, rather than the named host.

For more information, see [Information about Ansible: magic variables](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_vars_facts.html#magic-variables-and-hostvars).

### [Get running configuration](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id18)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#get-running-configuration)

The [arista.eos.eos_config](https://docs.ansible.com/ansible/latest/collections/arista/eos/eos_config_module.html#ansible-collections-arista-eos-eos-config-module) and [vyos.vyos.vyos_config](https://docs.ansible.com/ansible/latest/collections/vyos/vyos/vyos_config_module.html#ansible-collections-vyos-vyos-vyos-config-module) modules have a `backup:` option that when set will cause the module to create a full backup of the current `running-config` from the remote device before any changes are made. The backup file is written to the `backup` folder in the playbook root directory. If the directory does not exist, it is created.

To demonstrate how we can move the backup file to a different  location, we register the result and move the file to the path stored in `backup_path`.

Note that when using variables from tasks in this way we use double quotes (`"`) and double curly-brackets (`{{...}}` to tell Ansible that this is a variable.

## [Troubleshooting](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#id19)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html#troubleshooting)

If you receive an connection error please double check the inventory  and playbook for typos or missing lines. If the issue still occurs  follow the debug steps in [Network Debug and Troubleshooting Guide](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#network-debug-troubleshooting).

See also

- [Ansible for Network Automation](https://docs.ansible.com/ansible/latest/network/index.html#network-guide)
- [How to build your inventory](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory)
- [Keeping vaulted variables visible](https://docs.ansible.com/ansible/latest/tips_tricks/ansible_tips_tricks.html#tip-for-variables-and-vaults)

# Parsing semi-structured text with Ansible[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-semi-structured-text-with-ansible)

The [cli_parse](https://docs.ansible.com/ansible/latest/collections/ansible/utils/cli_parse_module.html#ansible-collections-ansible-utils-cli-parse-module) module parses semi-structured data such as network configurations into  structured data to allow programmatic use of the data from that device.  You can pull information from a network device and update a CMDB in one  playbook. Use cases include automated troubleshooting, creating dynamic  documentation, updating IPAM (IP address management) tools and so on.

- [Understanding the CLI parser](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#understanding-the-cli-parser)
  - [Why parse the text?](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#why-parse-the-text)
  - [When not to parse the text](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#when-not-to-parse-the-text)
- [Parsing the CLI](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-the-cli)
  - [Parsing with the native parsing engine](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-the-native-parsing-engine)
    - [Networking example](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#networking-example)
    - [Linux example](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#linux-example)
  - [Parsing JSON](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-json)
  - [Parsing with ntc_templates](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-ntc-templates)
  - [Parsing with pyATS](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-pyats)
  - [Parsing with textfsm](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-textfsm)
  - [Parsing with TTP](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-ttp)
  - [Parsing with JC](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-jc)
  - [Converting XML](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#converting-xml)
- [Advanced use cases](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#advanced-use-cases)
  - [Provide a full template path](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#provide-a-full-template-path)
  - [Provide command to parser different than the command run](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#provide-command-to-parser-different-than-the-command-run)
  - [Provide a custom OS value](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#provide-a-custom-os-value)
  - [Parse existing text](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parse-existing-text)

## [Understanding the CLI parser](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id1)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#understanding-the-cli-parser)

The [ansible.utils](https://galaxy.ansible.com/ansible/utils) collection version 1.0.0 or later  includes the [cli_parse](https://docs.ansible.com/ansible/latest/collections/ansible/utils/cli_parse_module.html#ansible-collections-ansible-utils-cli-parse-module) module that can run CLI commands and parse the semi-structured text output. You can use the `cli_parse` module on a device, host, or platform that only supports a command-line interface and the commands issued return semi-structured text. The `cli_parse` module can either run a CLI command on a device and return a parsed result or can simply parse any text document. The `cli_parse` module includes cli_parser plugins to interface with a variety of parsing engines.

### [Why parse the text?](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#why-parse-the-text)

Parsing semi-structured data such as network configurations into  structured data allows programmatic use of the data from that device.  Use cases include automated troubleshooting, creating dynamic  documentation, updating IPAM (IP address management) tools and so on.  You may prefer to do this with Ansible natively to take advantage of  native Ansible constructs such as:

- The `when` clause to conditionally run other tasks or roles
- The `assert` module to check configuration and operational state compliance
- The `template` module to generate reports about configuration and operational state information
- Templates and `command` or `config` modules to generate host, device, or platform commands or configuration
- The current platform `facts` modules to supplement native facts information

By parsing semi-structured text into Ansible native data structures,  you can take full advantage of Ansible’s network modules and plugins.

### [When not to parse the text](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#when-not-to-parse-the-text)

You should not parse semi-structured text when:

- The device, host, or platform has a RESTAPI and returns JSON.
- Existing Ansible facts modules already return the desired data.
- Ansible network resource modules exist for configuration management of the device and resource.

## [Parsing the CLI](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-the-cli)

The `cli_parse` module includes the following cli_parsing plugins:

- `native`

  The native parsing engine built into Ansible and requires no addition python libraries

- `xml`

  Convert XML to an Ansible native data structure

- `textfsm`

  A python module which implements a template based state machine for parsing semi-formatted text

- `ntc_templates`

  Predefined `textfsm` templates packages supporting a variety of platforms and commands

- `ttp`

  A library for semi-structured text parsing using templates, with added capabilities to simplify the process

- `pyats`

  Uses the parsers included with the Cisco Test Automation & Validation Solution

- `jc`

  A python module that converts the output of dozens of popular  Linux/UNIX/macOS/Windows commands and file types to python dictionaries  or lists of dictionaries. Note: this filter plugin can be found in the `community.general` collection.

- `json`

  Converts JSON output at the CLI to an Ansible native data structure

Although Ansible contains a number of plugins that can convert XML to Ansible native data structures, the `cli_parse` module runs the command on devices that return XML and returns the converted data in a single task.

Because `cli_parse` uses a plugin based architecture, it can use additional parsing engines from any Ansible collection.

Note

The `ansible.netcommon.native`  and `ansible.utils.json` parsing engines are fully supported with a Red Hat Ansible Automation  Platform subscription. Red Hat Ansible Automation Platform subscription  support is limited to the use of the `ntc_templates`, pyATS, `textfsm`, `xmltodict`, public APIs as documented.

### [Parsing with the native parsing engine](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id5)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-the-native-parsing-engine)

The native parsing engine is included with the `cli_parse` module. It uses data captured using regular expressions to populate the parsed data structure. The native parsing engine requires a YAML  template file to parse the command output.

#### [Networking example](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id6)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#networking-example)

This example uses the output of a network device command and applies a native template to produce an output in Ansible structured data format.

The `show interface` command output from the network device looks as follows:

```
Ethernet1/1 is up
admin state is up, Dedicated Interface
  Hardware: 100/1000/10000 Ethernet, address: 5254.005a.f8bd (bia 5254.005a.f8bd)
  MTU 1500 bytes, BW 1000000 Kbit, DLY 10 usec
  reliability 255/255, txload 1/255, rxload 1/255
  Encapsulation ARPA, medium is broadcast
  Port mode is access
  full-duplex, auto-speed
  Beacon is turned off
  Auto-Negotiation is turned on  FEC mode is Auto
  Input flow-control is off, output flow-control is off
  Auto-mdix is turned off
  Switchport monitor is off
  EtherType is 0x8100
  EEE (efficient-ethernet) : n/a
  Last link flapped 4week(s) 6day(s)
  Last clearing of "show interface" counters never
<...>
```

Create the native template to match this output and store it as `templates/nxos_show_interface.yaml`:

```
---
- example: Ethernet1/1 is up
  getval: '(?P<name>\S+) is (?P<oper_state>\S+)'
  result:
    "{{ name }}":
      name: "{{ name }}"
      state:
        operating: "{{ oper_state }}"
  shared: true

- example: admin state is up, Dedicated Interface
  getval: 'admin state is (?P<admin_state>\S+),'
  result:
    "{{ name }}":
      name: "{{ name }}"
      state:
        admin: "{{ admin_state }}"

- example: "  Hardware: Ethernet, address: 5254.005a.f8b5 (bia 5254.005a.f8b5)"
  getval: '\s+Hardware: (?P<hardware>.*), address: (?P<mac>\S+)'
  result:
    "{{ name }}":
      hardware: "{{ hardware }}"
      mac_address: "{{ mac }}"
```

This native parser template is structured as a list of parsers, each containing the following key-value pairs:

- `example` - An example line of the text line to be parsed
- `getval` - A regular expression using named capture groups to store the extracted data
- `result` - A data tree, populated as a template, from the parsed data
- `shared` - (optional) The shared key makes the parsed values available to the rest of the parser entries until matched again.

The following example task uses `cli_parse` with the native parser and the example template above to parse the `show interface` command from a Cisco NXOS device:

```
- name: "Run command and parse with native"
  ansible.utils.cli_parse:
    command: show interface
    parser:
      name: ansible.netcommon.native
    set_fact: interfaces
```

Taking a deeper dive into this task:

- The `command` option provides the command you want to run on the device or host.  Alternately, you can provide text from a previous command with the `text` option instead.
- The `parser` option provides information specific to the parser engine.
- The `name` suboption provides the fully qualified collection name (FQCN) of the parsing engine (`ansible.netcommon.native`).
- The `cli_parse` module, by default, looks for the template in the templates directory as `{{ short_os }}_{{ command }}.yaml`.
  - The `short_os` in the template filename is derived from either the host `ansible_network_os` or `ansible_distribution`.
  - Spaces in the network or host command are replace with `_` in the `command` portion of the template filename. In this example, the `show interfaces` network CLI command becomes `show_interfaces` in the filename.

Note

`ansible.netcommon.native` parsing engine is fully supported with a Red Hat Ansible Automation Platform subscription.

Lastly in this task, the `set_fact` option sets the following `interfaces` fact for the device based on the now-structured data returned from `cli_parse`:

```
Ethernet1/1:
    hardware: 100/1000/10000 Ethernet
    mac_address: 5254.005a.f8bd
    name: Ethernet1/1
    state:
    admin: up
    operating: up
Ethernet1/10:
    hardware: 100/1000/10000 Ethernet
    mac_address: 5254.005a.f8c6
<...>
```

#### [Linux example](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id7)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#linux-example)

You can also use the native parser to run commands and parse output from Linux hosts.

The output of a sample Linux  command (`ip addr show`) looks as follows:

```
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s31f6: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
    link/ether x2:6a:64:9d:84:19 brd ff:ff:ff:ff:ff:ff
3: wlp2s0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether x6:c2:44:f7:41:e0 brd ff:ff:ff:ff:ff:ff permaddr d8:f2:ca:99:5c:82
```

Create the native template to match this output and store it as `templates/fedora_ip_addr_show.yaml`:

```
---
- example: '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000'
  getval: |
    (?x)                                                # free-spacing
    \d+:\s                                              # the interface index
    (?P<name>\S+):\s                                    # the name
    <(?P<properties>\S+)>                               # the properties
    \smtu\s(?P<mtu>\d+)                                 # the mtu
    .*                                                  # gunk
    state\s(?P<state>\S+)                               # the state of the interface
  result:
    "{{ name }}":
        name: "{{ name }}"
        loopback: "{{ 'LOOPBACK' in stats.split(',') }}"
        up: "{{ 'UP' in properties.split(',')  }}"
        carrier: "{{ not 'NO-CARRIER' in properties.split(',') }}"
        broadcast: "{{ 'BROADCAST' in properties.split(',') }}"
        multicast: "{{ 'MULTICAST' in properties.split(',') }}"
        state: "{{ state|lower() }}"
        mtu: "{{ mtu }}"
  shared: True

- example: 'inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0'
  getval: |
   (?x)                                                 # free-spacing
   \s+inet\s(?P<inet>([0-9]{1,3}\.){3}[0-9]{1,3})       # the ip address
   /(?P<bits>\d{1,2})                                   # the mask bits
  result:
    "{{ name }}":
        ip_address: "{{ inet }}"
        mask_bits: "{{ bits }}"
```

Note

The `shared` key in the parser template allows the interface name to be used in  subsequent parser entries. The use of examples and free-spacing mode  with the regular expressions makes the template easier to read.

The following example task uses `cli_parse` with the native parser and the example template above to parse the Linux output:

```
- name: Run command and parse
  ansible.utils.cli_parse:
    command: ip addr show
    parser:
      name: ansible.netcommon.native
    set_fact: interfaces
```

This task assumes you previously gathered facts to determine the `ansible_distribution` needed to locate the template. Alternately, you could provide the path in the  `parser/template_path` option.

Lastly in this task, the `set_fact` option sets the following `interfaces` fact for the host, based on the now-structured data returned from `cli_parse`:

```
lo:
  broadcast: false
  carrier: true
  ip_address: 127.0.0.1
  mask_bits: 8
  mtu: 65536
  multicast: false
  name: lo
  state: unknown
  up: true
enp64s0u1:
  broadcast: true
  carrier: true
  ip_address: 192.168.86.83
  mask_bits: 24
  mtu: 1500
  multicast: true
  name: enp64s0u1
  state: up
  up: true
<...>
```

### [Parsing JSON](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id8)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-json)

Although Ansible will natively convert serialized JSON to Ansible native data when recognized, you can also use the `cli_parse` module for this conversion.

Example task:

```
- name: "Run command and parse as json"
  ansible.utils.cli_parse:
    command: show interface | json
    parser:
      name: ansible.utils.json
    register: interfaces
```

Taking a deeper dive into this task:

- The `show interface | json` command is issued on the device.
- The output is set as the `interfaces` fact for the device.
- JSON support is provided primarily for playbook consistency.

Note

The use of `ansible.netcommon.json` is fully supported with a Red Hat Ansible Automation Platform subscription

### [Parsing with ntc_templates](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id9)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-ntc-templates)

The `ntc_templates` python library includes pre-defined `textfsm` templates for parsing a variety of network device commands output.

Example task:

```
- name: "Run command and parse with ntc_templates"
  ansible.utils.cli_parse:
    command: show interface
    parser:
      name: ansible.netcommon.ntc_templates
    set_fact: interfaces
```

Taking a deeper dive into this task:

- The `ansible_network_os` of the device is converted to the ntc_template format `cisco_nxos`. Alternately, you can provide the `os` with the `parser/os` option instead.
- The `cisco_nxos_show_interface.textfsm` template, included with the `ntc_templates` package, parses the output.
- See [the ntc_templates README](https://github.com/networktocode/ntc-templates/blob/master/README.md) for additional information about the `ntc_templates` python library.

Note

Red Hat Ansible Automation Platform subscription support is limited to the use of the `ntc_templates` public APIs as documented.

This task and and the predefined template sets the following fact as the `interfaces` fact for the host:

```
interfaces:
- address: 5254.005a.f8b5
  admin_state: up
  bandwidth: 1000000 Kbit
  bia: 5254.005a.f8b5
  delay: 10 usec
  description: ''
  duplex: full-duplex
  encapsulation: ARPA
  hardware_type: Ethernet
  input_errors: ''
  input_packets: ''
  interface: mgmt0
  ip_address: 192.168.101.14/24
  last_link_flapped: ''
  link_status: up
  mode: ''
  mtu: '1500'
  output_errors: ''
  output_packets: ''
  speed: 1000 Mb/s
- address: 5254.005a.f8bd
  admin_state: up
  bandwidth: 1000000 Kbit
  bia: 5254.005a.f8bd
  delay: 10 usec
```

### [Parsing with pyATS](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id10)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-pyats)

`pyATS` is part of the Cisco Test Automation & Validation Solution. It  includes many predefined parsers for a number of network platforms and  commands. You can use the predefined parsers that are part of the `pyATS` package with the `cli_parse` module.

Example task:

```
- name: "Run command and parse with pyats"
  ansible.utils.cli_parse:
    command: show interface
    parser:
      name: ansible.netcommon.pyats
    set_fact: interfaces
```

Taking a deeper dive into this task:

- The `cli_parse` modules converts the `ansible_network_os` automatically (in this example, `ansible_network_os` set to `cisco.nxos.nxos`, converts to `nxos` for pyATS.  Alternately, you can set the OS with the `parser/os` option instead.
- Using a combination of the command and OS, the pyATS selects the following parser: [https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/parsers/show%2520interface](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/parsers/show%20interface).
- The `cli_parse` module sets `cisco.ios.ios` to `iosxe` for pyATS. You can override this with the `parser/os` option.
- `cli_parse` only uses the predefined parsers in pyATS. See the [pyATS documentation](https://developer.cisco.com/docs/pyats/) and the full list of [pyATS included parsers](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/parsers).

Note

Red Hat Ansible Automation Platform subscription support is limited to the use of the pyATS public APIs as documented.

This task sets the following fact as the `interfaces` fact for the host:

```
mgmt0:
  admin_state: up
  auto_mdix: 'off'
  auto_negotiate: true
  bandwidth: 1000000
  counters:
    in_broadcast_pkts: 3
    in_multicast_pkts: 1652395
    in_octets: 556155103
    in_pkts: 2236713
    in_unicast_pkts: 584259
    rate:
      in_rate: 320
      in_rate_pkts: 0
      load_interval: 1
      out_rate: 48
      out_rate_pkts: 0
    rx: true
    tx: true
  delay: 10
  duplex_mode: full
  enabled: true
  encapsulations:
    encapsulation: arpa
  ethertype: '0x0000'
  ipv4:
    192.168.101.14/24:
      ip: 192.168.101.14
      prefix_length: '24'
  link_state: up
  <...>
```

### [Parsing with textfsm](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id11)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-textfsm)

`textfsm` is a Python module which implements a template-based state machine for parsing semi-formatted text.

The following sample `textfsm` template is stored as `templates/nxos_show_interface.textfsm`

```
Value Required INTERFACE (\S+)
Value LINK_STATUS (.+?)
Value ADMIN_STATE (.+?)
Value HARDWARE_TYPE (.\*)
Value ADDRESS ([a-zA-Z0-9]+.[a-zA-Z0-9]+.[a-zA-Z0-9]+)
Value BIA ([a-zA-Z0-9]+.[a-zA-Z0-9]+.[a-zA-Z0-9]+)
Value DESCRIPTION (.\*)
Value IP_ADDRESS (\d+\.\d+\.\d+\.\d+\/\d+)
Value MTU (\d+)
Value MODE (\S+)
Value DUPLEX (.+duplex?)
Value SPEED (.+?)
Value INPUT_PACKETS (\d+)
Value OUTPUT_PACKETS (\d+)
Value INPUT_ERRORS (\d+)
Value OUTPUT_ERRORS (\d+)
Value BANDWIDTH (\d+\s+\w+)
Value DELAY (\d+\s+\w+)
Value ENCAPSULATION (\w+)
Value LAST_LINK_FLAPPED (.+?)

Start
  ^\S+\s+is.+ -> Continue.Record
  ^${INTERFACE}\s+is\s+${LINK_STATUS},\sline\sprotocol\sis\s${ADMIN_STATE}$$
  ^${INTERFACE}\s+is\s+${LINK_STATUS}$$
  ^admin\s+state\s+is\s+${ADMIN_STATE},
  ^\s+Hardware(:|\s+is)\s+${HARDWARE_TYPE},\s+address(:|\s+is)\s+${ADDRESS}(.*bia\s+${BIA})*
  ^\s+Description:\s+${DESCRIPTION}
  ^\s+Internet\s+Address\s+is\s+${IP_ADDRESS}
  ^\s+Port\s+mode\s+is\s+${MODE}
  ^\s+${DUPLEX}, ${SPEED}(,|$$)
  ^\s+MTU\s+${MTU}.\*BW\s+${BANDWIDTH}.\*DLY\s+${DELAY}
  ^\s+Encapsulation\s+${ENCAPSULATION}
  ^\s+${INPUT_PACKETS}\s+input\s+packets\s+\d+\s+bytes\s\*$$
  ^\s+${INPUT_ERRORS}\s+input\s+error\s+\d+\s+short\s+frame\s+\d+\s+overrun\s+\d+\s+underrun\s+\d+\s+ignored\s\*$$
  ^\s+${OUTPUT_PACKETS}\s+output\s+packets\s+\d+\s+bytes\s\*$$
  ^\s+${OUTPUT_ERRORS}\s+output\s+error\s+\d+\s+collision\s+\d+\s+deferred\s+\d+\s+late\s+collision\s\*$$
  ^\s+Last\s+link\s+flapped\s+${LAST_LINK_FLAPPED}\s\*$$
```

The following task uses the example template for `textfsm` with the `cli_parse` module.

```
- name: "Run command and parse with textfsm"
  ansible.utils.cli_parse:
    command: show interface
    parser:
      name: ansible.utils.textfsm
    set_fact: interfaces
```

Taking a deeper dive into this task:

- The `ansible_network_os` for the device (`cisco.nxos.nxos`) is converted to `nxos`. Alternately you can provide the OS in the `parser/os` option instead.
- The textfsm template name defaulted to `templates/nxos_show_interface.textfsm` using a combination of the OS and command run. Alternately you can override the generated template path with the `parser/template_path` option.
- See the [textfsm README](https://github.com/google/textfsm) for details.
- `textfsm` was previously made available as a filter plugin. Ansible users should transition to the `cli_parse` module.

Note

Red Hat Ansible Automation Platform subscription support is limited to the use of the `textfsm` public APIs as documented.

This task sets the following fact as the `interfaces` fact for the host:

```
- ADDRESS: X254.005a.f8b5
  ADMIN_STATE: up
  BANDWIDTH: 1000000 Kbit
  BIA: X254.005a.f8b5
  DELAY: 10 usec
  DESCRIPTION: ''
  DUPLEX: full-duplex
  ENCAPSULATION: ARPA
  HARDWARE_TYPE: Ethernet
  INPUT_ERRORS: ''
  INPUT_PACKETS: ''
  INTERFACE: mgmt0
  IP_ADDRESS: 192.168.101.14/24
  LAST_LINK_FLAPPED: ''
  LINK_STATUS: up
  MODE: ''
  MTU: '1500'
  OUTPUT_ERRORS: ''
  OUTPUT_PACKETS: ''
  SPEED: 1000 Mb/s
- ADDRESS: X254.005a.f8bd
  ADMIN_STATE: up
  BANDWIDTH: 1000000 Kbit
  BIA: X254.005a.f8bd
```

### [Parsing with TTP](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id12)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-ttp)

TTP is a Python library for semi-structured text parsing using  templates. TTP uses a jinja-like syntax to limit the need for regular  expressions. Users familiar with jinja templating may find the TTP  template syntax familiar.

The following is an example TTP template stored as `templates/nxos_show_interface.ttp`:

```
{{ interface }} is {{ state }}
admin state is {{ admin_state }}{{ ignore(".\*") }}
```

The following task uses this template to parse the `show interface` command output:

```
- name: "Run command and parse with ttp"
  ansible.utils.cli_parse:
    command: show interface
    parser:
      name: ansible.utils.ttp
    set_fact: interfaces
```

Taking a deeper dive in this task:

- The default template path `templates/nxos_show_interface.ttp` was generated using the `ansible_network_os` for the host and `command` provided.
- TTP supports several additional variables that will be passed to the parser. These include:
  - `parser/vars/ttp_init` -  Additional parameter passed when the parser is initialized.
  - `parser/vars/ttp_results` -  Additional parameters used to influence the parser output.
  - `parser/vars/ttp_vars` -  Additional variables made available in the template.
- See the [TTP documentation](https://ttp.readthedocs.io) for details.

The task sets the follow fact as the `interfaces` fact for the host:

```
- admin_state: up,
  interface: mgmt0
  state: up
- admin_state: up,
  interface: Ethernet1/1
  state: up
- admin_state: up,
  interface: Ethernet1/2
  state: up
```

### [Parsing with JC](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id13)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parsing-with-jc)

JC is a python library that converts the output of dozens of common  Linux/UNIX/macOS/Windows command-line tools and file types to python  dictionaries or lists of dictionaries for easier parsing. JC is  available as a filter plugin in the `community.general` collection.

The following is an example using JC to parse the output of the `dig` command:

```
- name: "Run dig command and parse with jc"
  hosts: ubuntu
  tasks:
  - shell: dig example.com
    register: result
  - set_fact:
      myvar: "{{ result.stdout | community.general.jc('dig') }}"
  - debug:
      msg: "The IP is: {{ myvar[0].answer[0].data }}"
```

- The JC project and documentation can be found [here](https://github.com/kellyjonbrazil/jc/).
- See this [blog entry](https://blog.kellybrazil.com/2020/08/30/parsing-command-output-in-ansible-with-jc/) for more information.

### [Converting XML](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id14)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#converting-xml)

Although Ansible contains a number of plugins that can convert XML to Ansible native data structures, the `cli_parse` module runs the command on devices that return XML and returns the converted data in a single task.

This example task runs the `show interface` command and parses the output as XML:

```
- name: "Run command and parse as xml"
    ansible.utils.cli_parse:
      command: show interface | xml
      parser:
        name: ansible.utils.xml
  set_fact: interfaces
```

Note

Red Hat Ansible Automation Platform subscription support is limited to the use of the `xmltodict` public APIs as documented.

This task sets the `interfaces` fact for the host based on this returned output:

```
nf:rpc-reply:
  '@xmlns': http://www.cisco.com/nxos:1.0:if_manager
  '@xmlns:nf': urn:ietf:params:xml:ns:netconf:base:1.0
  nf:data:
    show:
      interface:
        __XML__OPT_Cmd_show_interface_quick:
          __XML__OPT_Cmd_show_interface___readonly__:
            __readonly__:
              TABLE_interface:
                ROW_interface:
                - admin_state: up
                  encapsulation: ARPA
                  eth_autoneg: 'on'
                  eth_bia_addr: x254.005a.f8b5
                  eth_bw: '1000000'
```

## [Advanced use cases](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id15)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#advanced-use-cases)

The `cli_parse` module supports several features to support more complex uses cases.

### [Provide a full template path](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id16)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#provide-a-full-template-path)

Use the `template_path` option to override the default template path in the task:

```
- name: "Run command and parse with native"
  ansible.utils.cli_parse:
    command: show interface
    parser:
      name: ansible.netcommon.native
      template_path: /home/user/templates/filename.yaml
```

### [Provide command to parser different than the command run](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id17)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#provide-command-to-parser-different-than-the-command-run)

Use the `command` suboption for the `parser` to configure the command the parser expects if it is different from the command `cli_parse` runs:

```
- name: "Run command and parse with native"
  ansible.utils.cli_parse:
    command: sho int
    parser:
      name: ansible.netcommon.native
      command: show interface
```

### [Provide a custom OS value](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id18)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#provide-a-custom-os-value)

Use the `os` suboption to the parser to directly set the OS instead of using `ansible_network_os` or `ansible_distribution` to generate the template path or with the specified parser engine:

```
- name: Use ios instead of iosxe for pyats
  ansible.utils.cli_parse:
    command: show something
    parser:
      name: ansible.netcommon.pyats
      os: ios

- name: Use linux instead of fedora from ansible_distribution
  ansible.utils.cli_parse:
    command: ps -ef
    parser:
      name: ansible.netcommon.native
      os: linux
```

### [Parse existing text](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#id19)[](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#parse-existing-text)

Use the `text` option  instead of `command` to parse text collected earlier in the playbook.

```
# using /home/user/templates/filename.yaml
- name: "Parse text from previous task"
  ansible.utils.cli_parse:
    text: "{{ output['stdout'] }}"
    parser:
      name: ansible.netcommon.native
      template_path: /home/user/templates/filename.yaml

 # using /home/user/templates/filename.yaml
- name: "Parse text from file"
  ansible.utils.cli_parse:
    text: "{{ lookup('file', 'path/to/file.txt') }}"
    parser:
      name: ansible.netcommon.native
      template_path: /home/user/templates/filename.yaml

# using templates/nxos_show_version.yaml
- name: "Parse text from previous task"
  ansible.utils.cli_parse:
    text: "{{ sho_version['stdout'] }}"
    parser:
      name: ansible.netcommon.native
      os: nxos
      command: show version
```

See also

- [Developing cli_parser plugins in a collection](https://docs.ansible.com/ansible/latest/network/dev_guide/developing_plugins_network.html#develop-cli-parse-plugins)

# Validate data against set criteria with Ansible[](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#validate-data-against-set-criteria-with-ansible)

The [validate](https://docs.ansible.com/ansible/latest/collections/ansible/utils/validate_module.html#ansible-collections-ansible-utils-validate-module) module validates data against your predefined criteria using a  validation engine. You can pull this data from a device or file,  validate it against your defined criteria, and use the results to  identify configuration or operational state drift and optionally take  remedial action.

- [Understanding the validate plugin](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#understanding-the-validate-plugin)
- [Structuring the data](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#structuring-the-data)
- [Defining the criteria to validate against](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#defining-the-criteria-to-validate-against)
- [Validating the data](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#validating-the-data)

## [Understanding the validate plugin](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#understanding-the-validate-plugin)

The [ansible.utils](https://galaxy.ansible.com/ansible/utils) collection includes the [validate](https://docs.ansible.com/ansible/latest/collections/ansible/utils/validate_module.html#ansible-collections-ansible-utils-validate-module) module.

To validate data:

1. Pull in structured data or convert your data to structured format with the [cli_parse](https://docs.ansible.com/ansible/latest/collections/ansible/utils/cli_parse_module.html#ansible-collections-ansible-utils-cli-parse-module) module.
2. Define the criteria to test that data against.
3. Select a validation engine and test the data to see if it is valid based on the selected criteria and validation engine.

The structure of the data and the criteria depends on the validation engine you select. The examples here use the `jsonschema` validation engine provided in the [ansible.utils](https://galaxy.ansible.com/ansible/utils) collection.Red Hat Ansible Automation Platform subscription supports limited use if jsonschema public APIs as documented.

## [Structuring the data](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#structuring-the-data)

You can pull previously structured data from a file, or use the [cli_parse](https://docs.ansible.com/ansible/latest/collections/ansible/utils/cli_parse_module.html#ansible-collections-ansible-utils-cli-parse-module) module to structure your data.

The following example fetches the operational state of some network  (Cisco NXOS) interfaces and translates that state to structured data  using the `ansible.netcommon.pyats` parser.

```
---
- hosts: nxos
  connection: ansible.netcommon.network_cli
  gather_facts: false
  vars:
    ansible_network_os: cisco.nxos.nxos
    ansible_user: "changeme"
    ansible_password: "changeme"

  tasks:
  - name: "Fetch interface state and parse with pyats"
    ansible.utils.cli_parse:
      command: show interface
      parser:
        name: ansible.netcommon.pyats
    register: nxos_pyats_show_interface

  - name: print structured interface state data
    ansible.builtin.debug:
      msg: "{{ nxos_pyats_show_interface['parsed'] }}"
----
```

This results in the following structured data.

```
ok: [nxos] => {
"changed": false,
"parsed": {
    "Ethernet2/1": {
        "admin_state": "down",
        "auto_mdix": "off",
        "auto_negotiate": false,
        "bandwidth": 1000000,
        "beacon": "off"
        <--output omitted-->
    },
    "Ethernet2/10": {
        "admin_state": "down",
        "auto_mdix": "off",
        "auto_negotiate": false,
        "bandwidth": 1000000,
        "beacon": "off",
        <--output omitted-->
    }
  }
}
```

See [Parsing semi-structured text with Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/cli_parsing.html#cli-parsing) for details on how to parse semi-structured data into structured data.

## [Defining the criteria to validate against](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#id5)[](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#defining-the-criteria-to-validate-against)

This example uses the [jsonschema](https://pypi.org/project/jsonschema/) validation engine to parse the JSON structured data we created in the  prior section. the criteria defines the state we want the data to  conform to. In this instance, we can validate against a desired admin  state of `up` for all the interfaces.

The criteria for `jsonschema` in this example is as follows:

```
$cat criteria/nxos_show_interface_admin_criteria.json
{
      "type" : "object",
      "patternProperties": {
              "^.*": {
                      "type": "object",
                      "properties": {
                              "admin_state": {
                                      "type": "string",
                                      "pattern": "up"
                              }
                      }
              }
      }
 }
```

## [Validating the data](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#id6)[](https://docs.ansible.com/ansible/latest/network/user_guide/validate.html#validating-the-data)

Now that we have the structured data and the criteria, we can validate this data with the [validate](https://docs.ansible.com/ansible/latest/collections/ansible/utils/validate_module.html#ansible-collections-ansible-utils-validate-module) module.

The following tasks check if the current state of the interfaces match the desired state defined in the criteria file.

```
- name: Validate interface admin state
  ansible.utils.validate:
    data: "{{ nxos_pyats_show_interface['parsed'] }}"
    criteria:
      - "{{ lookup('file',  './criteria/nxos_show_interface_admin_criteria.json') | from_json }}"
    engine: ansible.utils.jsonschema
  ignore_errors: true
  register: result

- name: Print the interface names that do not satisfy the desired state
  ansible.builtin.debug:
    msg: "{{ item['data_path'].split('.')[0] }}"
  loop: "{{ result['errors'] }}"
  when: "'errors' in result"
```

In these tasks, we have:

1. Set `data` to  the structured JSON data from the [cli_parse](https://docs.ansible.com/ansible/latest/collections/ansible/utils/cli_parse_module.html#ansible-collections-ansible-utils-cli-parse-module) module.
2. Set `criteria` to the JSON criteria file we defined.
3. Set the validate engine to `jsonschema`.

Note

The value of the criteria option can be a list and should be in a  format that is defined by the validation engine used. You need to  install the [jsonschema](https://pypi.org/project/jsonschema/) on the control node for this example.

The tasks output a list of errors indicating interfaces that do not have admin value in `up` state.

```
TASK [Validate interface for admin state] ***********************************************************************************************************
fatal: [nxos02]: FAILED! => {"changed": false, "errors": [{"data_path": "Ethernet2/1.admin_state", "expected": "up", "found": "down", "json_path": "$.Ethernet2/1.admin_state", "message": "'down' does not match 'up'", "relative_schema": {"pattern": "up", "type": "string"}, "schema_path": "patternProperties.^.*.properties.admin_state.pattern", "validator": "pattern"}, {"data_path": "Ethernet2/10.admin_state", "expected": "up", "found": "down", "json_path": "$.Ethernet2/10.admin_state", "message": "'down' does not match 'up'", "relative_schema": {"pattern": "up", "type": "string"}, "schema_path": "patternProperties.^.*.properties.admin_state.pattern", "validator": "pattern"}], "msg": "Validation errors were found.\nAt 'patternProperties.^.*.properties.admin_state.pattern' 'down' does not match 'up'. \nAt 'patternProperties.^.*.properties.admin_state.pattern' 'down' does not match 'up'. \nAt 'patternProperties.^.*.properties.admin_state.pattern' 'down' does not match 'up'. "}
...ignoring


TASK [Print the interface names that do not satisfy the desired state] ****************************************************************************
Monday 14 December 2020  11:05:38 +0530 (0:00:01.661)       0:00:28.676 *******
ok: [nxos] => {
   "msg": "Ethernet2/1"
}
ok: [nxos] => {
   "msg": "Ethernet2/10"
}
```

This shows Ethernet2/1 and Ethernet2/10 are not in the desired state  based on the defined criteria. You can create a report or take further  action to remediate this to bring the interfaces to the desired state  based on the defined criteria.

# Network Debug and Troubleshooting Guide[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#network-debug-and-troubleshooting-guide)

This section discusses how to debug and troubleshoot network modules in Ansible.

- [How to troubleshoot](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#how-to-troubleshoot)
  - [Enabling Networking logging and how to read the logfile](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enabling-networking-logging-and-how-to-read-the-logfile)
  - [Enabling Networking device interaction logging](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enabling-networking-device-interaction-logging)
  - [Isolating an error](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#isolating-an-error)
- [Troubleshooting socket path issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#troubleshooting-socket-path-issues)
- [Category “Unable to open shell”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#category-unable-to-open-shell)
  - [Error: “[Errno -2\] Name or service not known”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-errno-2-name-or-service-not-known)
  - [Error: “Authentication failed”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-authentication-failed)
  - [Error: “connecting to host  returned an error” or “Bad address”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-connecting-to-host-hostname-returned-an-error-or-bad-address)
  - [Error: “No authentication methods available”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-no-authentication-methods-available)
  - [Clearing Out Persistent Connections](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#clearing-out-persistent-connections)
- [Timeout issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#timeout-issues)
  - [Persistent connection idle timeout](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#persistent-connection-idle-timeout)
  - [Command timeout](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#command-timeout)
  - [Persistent connection retry timeout](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#persistent-connection-retry-timeout)
  - [Timeout issue due to platform specific login menu with `network_cli` connection type](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#timeout-issue-due-to-platform-specific-login-menu-with-network-cli-connection-type)
- [Playbook issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#playbook-issues)
  - [Error: “Unable to enter configuration mode”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-unable-to-enter-configuration-mode)
- [Proxy Issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#proxy-issues)
  - [delegate_to vs ProxyCommand](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#delegate-to-vs-proxycommand)
  - [Using bastion/jump host with netconf connection](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#using-bastion-jump-host-with-netconf-connection)
  - [Enabling jump host setting](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enabling-jump-host-setting)
  - [Example ssh config file (~/.ssh/config)](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#example-ssh-config-file-ssh-config)
- [Miscellaneous Issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#miscellaneous-issues)
  - [Intermittent failure while using `ansible.netcommon.network_cli` connection type](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#intermittent-failure-while-using-ansible-netcommon-network-cli-connection-type)
  - [Task failure due to mismatched error regex within command response using `ansible.netcommon.network_cli` connection type](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#task-failure-due-to-mismatched-error-regex-within-command-response-using-ansible-netcommon-network-cli-connection-type)
  - [Intermittent failure while using `ansible.netcommon.network_cli` connection type due to slower network or remote target host](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#intermittent-failure-while-using-ansible-netcommon-network-cli-connection-type-due-to-slower-network-or-remote-target-host)

## [How to troubleshoot](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#how-to-troubleshoot)

Ansible network automation errors generally fall into one of the following categories:

- Authentication issues

  Not correctly specifying credentials Remote device (network switch/router) not falling back to other other authentication methods SSH key issues

- Timeout issues

  Can occur when trying to pull a large amount of data May actually be masking a authentication issue

- Playbook issues

  Use of `delegate_to`, instead of `ProxyCommand`. See [network proxy guide](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#network-delegate-to-vs-proxycommand) for more information.

Warning

```
unable to open shell
```

The `unable to open shell` message means that the `ansible-connection` daemon has not been able to successfully talk to the remote network device. This generally means that there is an authentication issue. See the “Authentication and connection issues”  section in this document for more information.



### [Enabling Networking logging and how to read the logfile](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enabling-networking-logging-and-how-to-read-the-logfile)

**Platforms:** Any

Ansible includes logging to help diagnose and troubleshoot issues regarding Ansible Networking modules.

Because logging is very verbose, it is disabled by default. It can be enabled with the [`ANSIBLE_LOG_PATH`](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#envvar-ANSIBLE_LOG_PATH) and [`ANSIBLE_DEBUG`](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#envvar-ANSIBLE_DEBUG) options on the ansible-controller, that is the machine running `ansible-playbook`.

Before running `ansible-playbook`, run the following commands to enable logging:

```
# Specify the location for the log file
export ANSIBLE_LOG_PATH=~/ansible.log
# Enable Debug
export ANSIBLE_DEBUG=True

# Run with 4*v for connection level verbosity
ansible-playbook -vvvv ...
```

After Ansible has finished running you can inspect the log file which has been created on the ansible-controller:

```
less $ANSIBLE_LOG_PATH

2017-03-30 13:19:52,740 p=28990 u=fred |  creating new control socket for host veos01:22 as user admin
2017-03-30 13:19:52,741 p=28990 u=fred |  control socket path is /home/fred/.ansible/pc/ca5960d27a
2017-03-30 13:19:52,741 p=28990 u=fred |  current working directory is /home/fred/ansible/test/integration
2017-03-30 13:19:52,741 p=28990 u=fred |  using connection plugin network_cli
...
2017-03-30 13:20:14,771 paramiko.transport userauth is OK
2017-03-30 13:20:15,283 paramiko.transport Authentication (keyboard-interactive) successful!
2017-03-30 13:20:15,302 p=28990 u=fred |  ssh connection done, setting terminal
2017-03-30 13:20:15,321 p=28990 u=fred |  ssh connection has completed successfully
2017-03-30 13:20:15,322 p=28990 u=fred |  connection established to veos01 in 0:00:22.580626
```

From the log notice:

- `p=28990` Is the PID (Process ID) of the `ansible-connection` process
- `u=fred` Is the user running ansible, not the remote-user you are attempting to connect as
- `creating new control socket for host veos01:22 as user admin` host:port as user
- `control socket path is` location on disk where the persistent connection socket is created
- `using connection plugin network_cli` Informs you that persistent connection is being used
- `connection established to veos01 in 0:00:22.580626` Time taken to obtain a shell on the remote device

Note

Port None `creating new control socket for host veos01:None`

If the log reports the port as `None` this means that the default port is being used. A future Ansible release will improve this message so that the port is always logged.

Because the log files are verbose, you can use grep to look for specific information. For example, once you have identified the `pid` from the `creating new control socket for host` line you can search for other connection log entries:

```
grep "p=28990" $ANSIBLE_LOG_PATH
```

### [Enabling Networking device interaction logging](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enabling-networking-device-interaction-logging)

**Platforms:** Any

Ansible includes logging of device interaction in the log file to help diagnose and troubleshoot issues regarding Ansible Networking modules. The messages are logged in the file pointed to by the `log_path` configuration option in the Ansible configuration file or by setting the  [`ANSIBLE_LOG_PATH`](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#envvar-ANSIBLE_LOG_PATH).

Warning

The device interaction messages consist of command executed on the target device and the returned response. Since this log data can contain sensitive information including passwords in plain text it is disabled by default. Additionally, in order to prevent accidental leakage of data, a warning will be shown on every task with this setting enabled, specifying which host has it enabled and where the data is being logged.

Be sure to fully understand the security implications of enabling  this option. The device interaction logging can be enabled either  globally by setting in configuration file or by setting environment or  enabled on per task basis by passing a special variable to the task.

Before running `ansible-playbook` run the following commands to enable logging:

```
# Specify the location for the log file
export ANSIBLE_LOG_PATH=~/ansible.log
```

Enable device interaction logging for a given task

```
- name: get version information
  cisco.ios.ios_command:
    commands:
      - show version
  vars:
    ansible_persistent_log_messages: True
```

To make this a global setting, add the following to your `ansible.cfg` file:

```
[persistent_connection]
log_messages = True
```

or enable the environment variable ANSIBLE_PERSISTENT_LOG_MESSAGES:

```
# Enable device interaction logging
export ANSIBLE_PERSISTENT_LOG_MESSAGES=True
```

If the task is failing on connection initialization itself, you  should enable this option globally. If an individual task is failing intermittently this option  can be enabled for that task itself to find the root cause.

After Ansible has finished running you can inspect the log file which has been created on the ansible-controller

Note

Be sure to fully understand the security implications of enabling this option as it can log sensitive information in log file thus creating security vulnerability.

### [Isolating an error](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id5)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#isolating-an-error)

**Platforms:** Any

As with any effort to troubleshoot it’s important to simplify the test case as much as possible.

For Ansible this can be done by ensuring you are only running against one remote device:

- Using `ansible-playbook --limit switch1.example.net...`
- Using an ad hoc `ansible` command

ad hoc refers to running Ansible to perform some quick command using `/usr/bin/ansible`, rather than the orchestration language, which is `/usr/bin/ansible-playbook`. In this case we can ensure connectivity by attempting to execute a single command on the remote device:

```
ansible -m arista.eos.eos_command -a 'commands=?' -i inventory switch1.example.net -e 'ansible_connection=ansible.netcommon.network_cli' -u admin -k
```

In the above example, we:

- connect to `switch1.example.net` specified in the inventory file `inventory`
- use the module `arista.eos.eos_command`
- run the command `?`
- connect using the username `admin`
- inform the `ansible` command to prompt for the SSH password by specifying `-k`

If you have SSH keys configured correctly, you don’t need to specify the `-k` parameter.

If the connection still fails you can combine it with the enable_network_logging parameter. For example:

```
# Specify the location for the log file
export ANSIBLE_LOG_PATH=~/ansible.log
# Enable Debug
export ANSIBLE_DEBUG=True
# Run with ``-vvvv`` for connection level verbosity
ansible -m arista.eos.eos_command -a 'commands=?' -i inventory switch1.example.net -e 'ansible_connection=ansible.netcommon.network_cli' -u admin -k
```

Then review the log file and find the relevant error message in the rest of this document.



## [Troubleshooting socket path issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id6)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#troubleshooting-socket-path-issues)

**Platforms:** Any

The `Socket path does not exist or cannot be found`  and `Unable to connect to socket` messages indicate that the socket used to communicate with the remote network device is unavailable or does not exist.

For example:

```
fatal: [spine02]: FAILED! => {
    "changed": false,
    "failed": true,
    "module_stderr": "Traceback (most recent call last):\n  File \"/tmp/ansible_TSqk5J/ansible_modlib.zip/ansible/module_utils/connection.py\", line 115, in _exec_jsonrpc\nansible.module_utils.connection.ConnectionError: Socket path XX does not exist or cannot be found. See Troubleshooting socket path issues in the Network Debug and Troubleshooting Guide\n",
    "module_stdout": "",
    "msg": "MODULE FAILURE",
    "rc": 1
}
```

or

```
fatal: [spine02]: FAILED! => {
    "changed": false,
    "failed": true,
    "module_stderr": "Traceback (most recent call last):\n  File \"/tmp/ansible_TSqk5J/ansible_modlib.zip/ansible/module_utils/connection.py\", line 123, in _exec_jsonrpc\nansible.module_utils.connection.ConnectionError: Unable to connect to socket XX. See Troubleshooting socket path issues in Network Debug and Troubleshooting Guide\n",
    "module_stdout": "",
    "msg": "MODULE FAILURE",
    "rc": 1
}
```

Suggestions to resolve:

1. Verify that you have write access to the socket path described in the error message.
2. Follow the steps detailed in [enable network logging](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enable-network-logging).

If the identified error message from the log file is:

```
2017-04-04 12:19:05,670 p=18591 u=fred |  command timeout triggered, timeout value is 30 secs
```

or

```
2017-04-04 12:19:05,670 p=18591 u=fred |  persistent connection idle timeout triggered, timeout value is 30 secs
```

Follow the steps detailed in [timeout issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#timeout-issues)



## [Category “Unable to open shell”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id7)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#category-unable-to-open-shell)

**Platforms:** Any

The `unable to open shell` message means that the `ansible-connection` daemon has not been able to successfully talk to the remote network  device. This generally means that there is an authentication issue. It  is a “catch all” message, meaning you need to enable logging to find the underlying issues.

For example:

```
TASK [prepare_eos_tests : enable cli on remote device] **************************************************
fatal: [veos01]: FAILED! => {"changed": false, "failed": true, "msg": "unable to open shell"}
```

or:

```
TASK [ios_system : configure name_servers] *************************************************************
task path:
fatal: [ios-csr1000v]: FAILED! => {
    "changed": false,
    "failed": true,
    "msg": "unable to open shell",
}
```

Suggestions to resolve:

Follow the steps detailed in [enable_network_logging](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enable-network-logging).

Once you’ve identified the error message from the log file, the specific solution can be found in the rest of this document.

### [Error: “[Errno -2\] Name or service not known”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id8)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-errno-2-name-or-service-not-known)

**Platforms:** Any

Indicates that the remote host you are trying to connect to can not be reached

For example:

```
2017-04-04 11:39:48,147 p=15299 u=fred |  control socket path is /home/fred/.ansible/pc/ca5960d27a
2017-04-04 11:39:48,147 p=15299 u=fred |  current working directory is /home/fred/git/ansible-inc/stable-2.3/test/integration
2017-04-04 11:39:48,147 p=15299 u=fred |  using connection plugin network_cli
2017-04-04 11:39:48,340 p=15299 u=fred |  connecting to host veos01 returned an error
2017-04-04 11:39:48,340 p=15299 u=fred |  [Errno -2] Name or service not known
```

Suggestions to resolve:

- If you are using the `provider:` options ensure that its suboption `host:` is set correctly.
- If you are not using `provider:` nor top-level arguments ensure your inventory file is correct.

### [Error: “Authentication failed”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id9)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-authentication-failed)

**Platforms:** Any

Occurs if the credentials (username, passwords, or ssh keys) passed to `ansible-connection` (through `ansible` or `ansible-playbook`) can not be used to connect to the remote device.

For example:

```
<ios01> ESTABLISH CONNECTION FOR USER: cisco on PORT 22 TO ios01
<ios01> Authentication failed.
```

Suggestions to resolve:

If you are specifying credentials through `password:` (either directly or through `provider:`) or the environment variable ANSIBLE_NET_PASSWORD it is possible that `paramiko` (the Python SSH library that Ansible uses) is using ssh keys, and  therefore the credentials you are specifying are being ignored. To find  out if this is the case, disable “look for keys”. This can be done like  this:

```
export ANSIBLE_PARAMIKO_LOOK_FOR_KEYS=False
```

To make this a permanent change, add the following to your `ansible.cfg` file:

```
[paramiko_connection]
look_for_keys = False
```

### [Error: “connecting to host  returned an error” or “Bad address”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id10)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-connecting-to-host-hostname-returned-an-error-or-bad-address)

This may occur if the SSH fingerprint hasn’t been added to Paramiko’s (the Python SSH library) know hosts file.

When using persistent connections with Paramiko, the connection runs  in a background process.  If the host doesn’t already have a valid SSH  key, by default Ansible will prompt to add the host key.  This will  cause connections running in background processes to fail.

For example:

```
2017-04-04 12:06:03,486 p=17981 u=fred |  using connection plugin network_cli
2017-04-04 12:06:04,680 p=17981 u=fred |  connecting to host veos01 returned an error
2017-04-04 12:06:04,682 p=17981 u=fred |  (14, 'Bad address')
2017-04-04 12:06:33,519 p=17981 u=fred |  number of connection attempts exceeded, unable to connect to control socket
2017-04-04 12:06:33,520 p=17981 u=fred |  persistent_connect_interval=1, persistent_connect_retries=30
```

Suggestions to resolve:

Use `ssh-keyscan` to pre-populate the known_hosts. You need to ensure the keys are correct.

```
ssh-keyscan veos01
```

or

You can tell Ansible to automatically accept the keys

Environment variable method:

```
export ANSIBLE_PARAMIKO_HOST_KEY_AUTO_ADD=True
ansible-playbook ...
```

`ansible.cfg` method:

ansible.cfg

```
[paramiko_connection]
host_key_auto_add = True
```

### [Error: “No authentication methods available”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id11)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-no-authentication-methods-available)

For example:

```
2017-04-04 12:19:05,670 p=18591 u=fred |  creating new control socket for host veos01:None as user admin
2017-04-04 12:19:05,670 p=18591 u=fred |  control socket path is /home/fred/.ansible/pc/ca5960d27a
2017-04-04 12:19:05,670 p=18591 u=fred |  current working directory is /home/fred/git/ansible-inc/ansible-workspace-2/test/integration
2017-04-04 12:19:05,670 p=18591 u=fred |  using connection plugin network_cli
2017-04-04 12:19:06,606 p=18591 u=fred |  connecting to host veos01 returned an error
2017-04-04 12:19:06,606 p=18591 u=fred |  No authentication methods available
2017-04-04 12:19:35,708 p=18591 u=fred |  connect retry timeout expired, unable to connect to control socket
2017-04-04 12:19:35,709 p=18591 u=fred |  persistent_connect_retry_timeout is 15 secs
```

Suggestions to resolve:

No password or SSH key supplied

### [Clearing Out Persistent Connections](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id12)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#clearing-out-persistent-connections)

**Platforms:** Any

In Ansible 2.3, persistent connection sockets are stored in `~/.ansible/pc` for all network devices.  When an Ansible playbook runs, the persistent socket connection is displayed when verbose output is specified.

```
<switch> socket_path: /home/fred/.ansible/pc/f64ddfa760
```

To clear out a persistent connection before it times out (the default timeout is 30 seconds of inactivity), simple delete the socket file.



## [Timeout issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id13)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#timeout-issues)

### [Persistent connection idle timeout](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id14)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#persistent-connection-idle-timeout)

By default, `ANSIBLE_PERSISTENT_CONNECT_TIMEOUT` is set to 30 (seconds). You may see the following error if this value is too low:

```
2017-04-04 12:19:05,670 p=18591 u=fred |  persistent connection idle timeout triggered, timeout value is 30 secs
```

Suggestions to resolve:

Increase value of persistent connection idle timeout:

```
export ANSIBLE_PERSISTENT_CONNECT_TIMEOUT=60
```

To make this a permanent change, add the following to your `ansible.cfg` file:

```
[persistent_connection]
connect_timeout = 60
```

### [Command timeout](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id15)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#command-timeout)

By default, `ANSIBLE_PERSISTENT_COMMAND_TIMEOUT` is set to 30 (seconds). Prior versions of Ansible had this value set to 10 seconds by default. You may see the following error if this value is too low:

```
2017-04-04 12:19:05,670 p=18591 u=fred |  command timeout triggered, timeout value is 30 secs
```

Suggestions to resolve:

- Option 1 (Global command timeout setting): Increase value of command timeout in configuration file or by setting environment variable.

  ```
  export ANSIBLE_PERSISTENT_COMMAND_TIMEOUT=60
  ```

  To make this a permanent change, add the following to your `ansible.cfg` file:

  ```
  [persistent_connection]
  command_timeout = 60
  ```

- Option 2 (Per task command timeout setting): Increase command timeout per task basis. All network modules support a timeout value that can be set on a per task basis. The timeout value controls the amount of time in seconds before the task will fail if the command has not returned.

  For local connection type:

  Suggestions to resolve:

  Some modules support a `timeout` option, which is different to the `timeout` keyword for tasks.

  ```
  - name: save running-config
    cisco.ios.ios_command:
      commands: copy running-config startup-config
      provider: "{{ cli }}"
      timeout: 30
  ```

  Suggestions to resolve:

  If the module does not support the `timeout` option directly, most networking connection plugins can enable similar functionality with the `ansible_command_timeout`  variable.

  ```
  - name: save running-config
    cisco.ios.ios_command:
      commands: copy running-config startup-config
    vars:
      ansible_command_timeout: 60
  ```

Some operations take longer than the default 30 seconds to complete.  One good example is saving the current running config on IOS devices to startup config. In this case, changing the timeout value from the default 30 seconds to 60 seconds will prevent the task from failing before the command completes successfully.

### [Persistent connection retry timeout](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id16)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#persistent-connection-retry-timeout)

By default, `ANSIBLE_PERSISTENT_CONNECT_RETRY_TIMEOUT` is set to 15 (seconds). You may see the following error if this value is too low:

```
2017-04-04 12:19:35,708 p=18591 u=fred |  connect retry timeout expired, unable to connect to control socket
2017-04-04 12:19:35,709 p=18591 u=fred |  persistent_connect_retry_timeout is 15 secs
```

Suggestions to resolve:

Increase the value of the persistent connection idle timeout. Note: This value should be greater than the SSH timeout value (the timeout value under the defaults section in the configuration file) and less than the value of the persistent connection idle timeout (connect_timeout).

```
export ANSIBLE_PERSISTENT_CONNECT_RETRY_TIMEOUT=30
```

To make this a permanent change, add the following to your `ansible.cfg` file:

```
[persistent_connection]
connect_retry_timeout = 30
```

### [Timeout issue due to platform specific login menu with `network_cli` connection type](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id17)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#timeout-issue-due-to-platform-specific-login-menu-with-network-cli-connection-type)

In Ansible 2.9 and later, the network_cli connection plugin configuration options are added to handle the platform specific login menu. These options can be set as group/host or tasks variables.

Example: Handle single login menu prompts with host variables

```
cat host_vars/<hostname>.yaml
---
ansible_terminal_initial_prompt:
  - "Connect to a host"
ansible_terminal_initial_answer:
  - "3"
```

Example: Handle remote host multiple login menu prompts with host variables

```
cat host_vars/<inventory-hostname>.yaml
---
ansible_terminal_initial_prompt:
  - "Press any key to enter main menu"
  - "Connect to a host"
ansible_terminal_initial_answer:
  - "\\r"
  - "3"
ansible_terminal_initial_prompt_checkall: True
```

To handle multiple login menu prompts:

- The values of `ansible_terminal_initial_prompt` and `ansible_terminal_initial_answer` should be a list.
- The prompt sequence should match the answer sequence.
- The value of `ansible_terminal_initial_prompt_checkall` should be set to `True`.

Note

If all the prompts in sequence are not received from remote host at  the time connection initialization it will result in a timeout.

## [Playbook issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id18)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#playbook-issues)

This section details issues are caused by issues with the Playbook itself.

### [Error: “Unable to enter configuration mode”](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id19)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#error-unable-to-enter-configuration-mode)

**Platforms:** Arista EOS and Cisco IOS

This occurs when you attempt to run a task that requires privileged mode in a user mode shell.

For example:

```
TASK [ios_system : configure name_servers] *****************************************************************************
task path:
fatal: [ios-csr1000v]: FAILED! => {
    "changed": false,
    "failed": true,
   "msg": "unable to enter configuration mode",
}
```

Suggestions to resolve:

> Use `connection: ansible.netcommon.network_cli` and `become: yes`

## [Proxy Issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id20)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#proxy-issues)

> 



### [delegate_to vs ProxyCommand](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id21)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#delegate-to-vs-proxycommand)

In order to use a bastion or intermediate jump host to connect to network devices over `cli` transport, network modules support the use of `ProxyCommand`.

To use `ProxyCommand`, configure the proxy settings in the Ansible inventory file to specify the proxy host.

```
[nxos]
nxos01
nxos02

[nxos:vars]
ansible_ssh_common_args='-o ProxyCommand="ssh -W %h:%p -q bastion01"'
```

With the configuration above, simply build and run the playbook as normal with no additional changes necessary.  The network module will now connect to the network device by first connecting to the host specified in `ansible_ssh_common_args`, which is `bastion01` in the above example.

You can also set the proxy target for all hosts by using environment variables.

```
export ANSIBLE_SSH_ARGS='-o ProxyCommand="ssh -W %h:%p -q bastion01"'
```

### [Using bastion/jump host with netconf connection](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id22)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#using-bastion-jump-host-with-netconf-connection)

### [Enabling jump host setting](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id23)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#enabling-jump-host-setting)

- Bastion/jump host with netconf connection can be enabled by:

  Setting Ansible variable `ansible_netconf_ssh_config` either to `True` or custom ssh config file path Setting environment variable `ANSIBLE_NETCONF_SSH_CONFIG` to `True` or custom ssh config file path Setting `ssh_config = 1` or `ssh_config = <ssh-file-path>` under `netconf_connection` section

If the configuration variable is set to 1 the proxycommand and other ssh variables are read from default ssh config file (~/.ssh/config).

If the configuration variable is set to file path the proxycommand and other ssh variables are read from the given custom ssh file path

### [Example ssh config file (~/.ssh/config)](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id24)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#example-ssh-config-file-ssh-config)

```
Host jumphost
  HostName jumphost.domain.name.com
  User jumphost-user
  IdentityFile "/path/to/ssh-key.pem"
  Port 22

# Note: Due to the way that Paramiko reads the SSH Config file,
# you need to specify the NETCONF port that the host uses.
# In other words, it does not automatically use ansible_port
# As a result you need either:

Host junos01
  HostName junos01
  ProxyCommand ssh -W %h:22 jumphost

# OR

Host junos01
  HostName junos01
  ProxyCommand ssh -W %h:830 jumphost

# Depending on the netconf port used.
```

Example Ansible inventory file

```
[junos]
junos01

[junos:vars]
ansible_connection=ansible.netcommon.netconf
ansible_network_os=junipernetworks.junos.junos
ansible_user=myuser
ansible_password=!vault...
```

Note

Using `ProxyCommand` with passwords through variables

By design, SSH doesn’t support providing passwords through environment variables. This is done to prevent secrets from leaking out, for example in `ps` output.

We recommend using SSH Keys, and if needed an ssh-agent, rather than passwords, where ever possible.

## [Miscellaneous Issues](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id25)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#miscellaneous-issues)

### [Intermittent failure while using `ansible.netcommon.network_cli` connection type](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id26)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#intermittent-failure-while-using-ansible-netcommon-network-cli-connection-type)

If the command prompt received in response is not matched correctly within the `ansible.netcommon.network_cli` connection plugin the task might fail intermittently with truncated response or with the error message `operation requires privilege escalation`. Starting in 2.7.1 a new buffer read timer is added to ensure prompts are matched properly and a complete response is send in output. The timer default value is 0.2 seconds and can be adjusted on a per task basis or can be set globally in seconds.

Example Per task timer setting

```
- name: gather ios facts
  cisco.ios.ios_facts:
    gather_subset: all
  register: result
  vars:
    ansible_buffer_read_timeout: 2
```

To make this a global setting, add the following to your `ansible.cfg` file:

```
[persistent_connection]
buffer_read_timeout = 2
```

This timer delay per command executed on remote host can be disabled by setting the value to zero.

### [Task failure due to mismatched error regex within command response using `ansible.netcommon.network_cli` connection type](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id27)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#task-failure-due-to-mismatched-error-regex-within-command-response-using-ansible-netcommon-network-cli-connection-type)

In Ansible 2.9 and later, the `ansible.netcommon.network_cli` connection plugin configuration options are added to handle the stdout and stderr regex to identify if the command execution response consist of a normal response or an error response. These options can be set group/host variables or as tasks variables.

Example: For mismatched error response

```
- name: fetch logs from remote host
  cisco.ios.ios_command:
    commands:
      - show logging
```

Playbook run output:

```
TASK [first fetch logs] ********************************************************
fatal: [ios01]: FAILED! => {
    "changed": false,
    "msg": "RF Name:\r\n\r\n <--nsip-->
           \"IPSEC-3-REPLAY_ERROR: Test log\"\r\n*Aug  1 08:36:18.483: %SYS-7-USERLOG_DEBUG:
            Message from tty578(user id: ansible): test\r\nan-ios-02#"}
```

Suggestions to resolve:

Modify the error regex for individual task.

```
- name: fetch logs from remote host
  cisco.ios.ios_command:
    commands:
      - show logging
  vars:
    ansible_terminal_stderr_re:
      - pattern: 'connection timed out'
        flags: 're.I'
```

The terminal plugin regex options `ansible_terminal_stderr_re` and `ansible_terminal_stdout_re` have `pattern` and `flags` as keys. The value of the `flags` key should be a value that is accepted by the `re.compile` python method.

### [Intermittent failure while using `ansible.netcommon.network_cli` connection type due to slower network or remote target host](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#id28)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#intermittent-failure-while-using-ansible-netcommon-network-cli-connection-type-due-to-slower-network-or-remote-target-host)

In Ansible 2.9 and later, the `ansible.netcommon.network_cli` connection plugin configuration option is added to control the number of attempts to connect to a remote host. The default number of attempts is three. After every retry attempt the delay between retries is increased by power of 2 in seconds until either the maximum attempts are exhausted or either the `persistent_command_timeout` or `persistent_connect_timeout` timers are triggered.

To make this a global setting, add the following to your `ansible.cfg` file:

```
[persistent_connection]
network_cli_retries = 5
```

# Working with command output and prompts in network modules[](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#working-with-command-output-and-prompts-in-network-modules)

- [Conditionals in networking modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#conditionals-in-networking-modules)
- [Handling prompts in network modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#handling-prompts-in-network-modules)

## [Conditionals in networking modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#id1)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#conditionals-in-networking-modules)

Ansible allows you to use conditionals to control the flow of your  playbooks. Ansible networking command modules use the following unique  conditional statements.

- `eq` - Equal
- `neq` - Not equal
- `gt` - Greater than
- `ge` - Greater than or equal
- `lt` - Less than
- `le` - Less than or equal
- `contains` - Object contains specified item

Conditional statements evaluate the results from the commands that are executed remotely on the device.  Once the task executes the command set, the `wait_for` argument can be used to evaluate the results before returning control to the Ansible playbook.

For example:

```
---
- name: wait for interface to be admin enabled
  arista.eos.eos_command:
      commands:
          - show interface Ethernet4 | json
      wait_for:
          - "result[0].interfaces.Ethernet4.interfaceStatus eq connected"
```

In the above example task, the command `show interface Ethernet4 | json` is executed on the remote device and the results are evaluated.  If the path `(result[0].interfaces.Ethernet4.interfaceStatus)` is not equal to “connected”, then the command is retried.  This process continues until either the condition is satisfied or the number of retries has expired (by default, this is 10 retries at 1 second intervals).

The commands module can also evaluate more than one set of command results in an interface.  For instance:

```
---
- name: wait for interfaces to be admin enabled
  arista.eos.eos_command:
      commands:
          - show interface Ethernet4 | json
          - show interface Ethernet5 | json
      wait_for:
          - "result[0].interfaces.Ethernet4.interfaceStatus eq connected"
          - "result[1].interfaces.Ethernet5.interfaceStatus eq connected"
```

In the above example, two commands are executed on the remote device, and the results are evaluated.  By specifying the result index value (0 or 1), the correct result output is checked against the conditional.

The `wait_for` argument must always start with result and then the command index in `[]`, where `0` is the first command in the commands list, `1` is the second command, `2` is the third and so on.

## [Handling prompts in network modules](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/network_working_with_command_output.html#handling-prompts-in-network-modules)

Network devices may require that you answer a prompt before  performing a change on the device. Individual network modules such as [cisco.ios.ios_command](https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_command_module.html#ansible-collections-cisco-ios-ios-command-module) and [cisco.nxos.nxos_command](https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_command_module.html#ansible-collections-cisco-nxos-nxos-command-module) can handle this with a `prompt` parameter.

Note

`prompt` is a Python regex. If you add special characters such as `?` in the `prompt` value, the prompt won’t match and you will get a timeout. To avoid this, ensure that the `prompt` value is a Python regex that matches the actual device prompt. Any special characters must be handled correctly in the `prompt` regex.

You can also use the [ansible.netcommon.cli_command](https://docs.ansible.com/ansible/latest/collections/ansible/netcommon/cli_command_module.html#ansible-collections-ansible-netcommon-cli-command-module) to handle multiple prompts.

```
---
- name: multiple prompt, multiple answer (mandatory check for all prompts)
  ansible.netcommon.cli_command:
    command: "copy sftp sftp://user@host//user/test.img"
    check_all: True
    prompt:
      - "Confirm download operation"
      - "Password"
      - "Do you want to change that to the standby image"
    answer:
      - 'y'
      - <password>
      - 'y'
```

You must list the prompt and the answers in the same order (that is, prompt[0] is answered by answer[0]).

In the above example, `check_all: True` ensures that the task gives the matching answer to each prompt. Without that setting, a task with multiple prompts would give the first answer  to every prompt.

In the following example, the second answer would be ignored and `y` would be the answer given to both prompts. That is, this task only  works because both answers are identical. Also notice again that `prompt` must be a Python regex, which is why the `?` is escaped in the first prompt.

```
---
 - name: reboot ios device
   ansible.netcommon.cli_command:
     command: reload
     prompt:
       - Save\?
       - confirm
     answer:
       - y
       - y
```

See also

- [Rebooting network devices with Ansible](https://www.ansible.com/blog/rebooting-network-devices-with-ansible)

  Examples using `wait_for`, `wait_for_connection`, and `prompt` for network devices.

- [Deep dive on cli_command](https://www.ansible.com/blog/deep-dive-on-cli-command-for-network-automation)

  Detailed overview of how to use the `cli_command`.

# [Ansible Network FAQ](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id1)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#ansible-network-faq)

Topics

- [Ansible Network FAQ](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#ansible-network-faq)
  - [How can I improve performance for network playbooks?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#how-can-i-improve-performance-for-network-playbooks)
    - [Consider `strategy: free` if you are running on multiple hosts](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#consider-strategy-free-if-you-are-running-on-multiple-hosts)
    - [Execute `show running` only if you absolutely must](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#execute-show-running-only-if-you-absolutely-must)
    - [Use `ProxyCommand` only if you absolutely must](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#use-proxycommand-only-if-you-absolutely-must)
    - [Set `--forks` to match your needs](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#set-forks-to-match-your-needs)
  - [Why is my output sometimes replaced with `********`?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#why-is-my-output-sometimes-replaced-with)
  - [Why do the `*_config` modules always return `changed=true` with abbreviated commands?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#why-do-the-config-modules-always-return-changed-true-with-abbreviated-commands)



## [How can I improve performance for network playbooks?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#how-can-i-improve-performance-for-network-playbooks)



### [Consider `strategy: free` if you are running on multiple hosts](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#consider-strategy-free-if-you-are-running-on-multiple-hosts)

The `strategy` plugin tells Ansible how to order multiple tasks on multiple hosts. [Strategy](https://docs.ansible.com/ansible/latest/plugins/strategy.html#strategy-plugins) is set at the playbook level.

The default strategy is `linear`. With strategy set to `linear`, Ansible waits until the current task has run on all hosts before  starting the next task on any host. Ansible may have forks free, but  will not use them until all hosts have completed the current task. If  each task in your playbook must succeed on all hosts before you run the  next task, use the `linear` strategy.

Using the `free` strategy, Ansible uses available forks to execute tasks on each host as quickly as possible. Even if an earlier task is still running on one  host, Ansible executes later tasks on other hosts. The `free` strategy uses available forks more efficiently. If your playbook stalls on each task, waiting for one slow host, consider using `strategy: free` to boost overall performance.



### [Execute `show running` only if you absolutely must](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#execute-show-running-only-if-you-absolutely-must)

The `show running` command is the most resource-intensive command to execute on a network  device, because of the way queries are handled by the network OS. Using  the command in your Ansible playbook will slow performance  significantly, especially on large devices; repeating it will multiply  the performance hit. If you have a playbook that checks the running  config, then executes changes, then checks the running config again, you should expect that playbook to be very slow.



### [Use `ProxyCommand` only if you absolutely must](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id5)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#use-proxycommand-only-if-you-absolutely-must)

Network modules support the use of a [proxy or jump host](https://docs.ansible.com/ansible/latest/network/user_guide/network_debug_troubleshooting.html#network-delegate-to-vs-proxycommand) with the `ProxyCommand` parameter. However, when you use a jump host, Ansible must open a new  SSH connection for every task, even if you are using a persistent  connection type (`network_cli` or `netconf`). To maximize the performance benefits of the persistent connection types introduced in version 2.5, avoid using jump hosts whenever possible.



### [Set `--forks` to match your needs](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id6)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#set-forks-to-match-your-needs)

Every time Ansible runs a task, it forks its own process. The `--forks` parameter defines the number of concurrent tasks - if you retain the default setting, which is `--forks=5`, and you are running a playbook on 10 hosts, five of those hosts will  have to wait until a fork is available. Of course, the more forks you  allow, the more memory and processing power Ansible will use. Since most network tasks are run on the control host, this means your laptop can  quickly become cpu- or memory-bound.



## [Why is my output sometimes replaced with `********`?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id7)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#why-is-my-output-sometimes-replaced-with)

Ansible replaces any string marked `no_log`, including passwords, with `********` in Ansible output. This is done by design, to protect your sensitive  data. Most users are happy to have their passwords redacted. However,  Ansible replaces every string that matches your password with `********`. If you use a common word for your password, this can be a problem. For example, if you choose `Admin` as your password, Ansible will replace every instance of the word `Admin` with `********` in your output. This may make your output harder to read. To avoid this problem, select a secure password that will not occur elsewhere in your Ansible output.



## [Why do the `*_config` modules always return `changed=true` with abbreviated commands?](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#id8)[](https://docs.ansible.com/ansible/latest/network/user_guide/faq.html#why-do-the-config-modules-always-return-changed-true-with-abbreviated-commands)

When you issue commands directly on a network device, you can use abbreviated commands. For example, `int g1/0/11` and `interface GigabitEthernet1/0/11` do the same thing; `shut` and `shutdown` do the same thing. Ansible Network `*_command` modules work with abbreviations, because they run commands through the network OS.

When committing configuration, however, the network OS converts abbreviations into long-form commands. Whether you use `shut` or `shutdown` on `GigabitEthernet1/0/11`, the result in the configuration is the same: `shutdown`.

Ansible Network `*_config` modules compare the text of the commands you specify in `lines` to the text in the configuration. If you use `shut` in the `lines` section of your task, and the configuration reads  `shutdown`, the module returns `changed=true` even though the configuration is already correct. Your task will update the configuration every time it runs.

To avoid this problem, use long-form commands with the `*_config` modules:

```
---
- hosts: all
  gather_facts: no
  tasks:
    - cisco.ios.ios_config:
        lines:
          - shutdown
        parents: interface GigabitEthernet1/0/11
```

# Platform Options[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#platform-options)

Some Ansible Network platforms support multiple connection types, privilege escalation (`enable` mode), or other options. The pages in this section offer standardized  guides to understanding available options on each network platform. We  welcome contributions from community-maintained platforms to this  section.

Platform Options

- CloudEngine OS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#using-cli-in-ansible)
  - [Using NETCONF in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#using-netconf-in-ansible)
  - [Notes](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#notes)
- CNOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_cnos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_cnos.html#using-cli-in-ansible)
- Dell OS6 Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos6.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos6.html#using-cli-in-ansible)
- Dell OS9 Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos9.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos9.html#using-cli-in-ansible)
- Dell OS10 Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos10.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_dellos10.html#using-cli-in-ansible)
- ENOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_enos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_enos.html#using-cli-in-ansible)
- EOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eos.html#using-cli-in-ansible)
  - [Using eAPI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eos.html#using-eapi-in-ansible)
- ERIC_ECCLI Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eric_eccli.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_eric_eccli.html#using-cli-in-ansible)
- EXOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_exos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_exos.html#using-cli-in-ansible)
  - [Using EXOS-API in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_exos.html#using-exos-api-in-ansible)
- FRR Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_frr.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_frr.html#using-cli-in-ansible)
- ICX Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_icx.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_icx.html#using-cli-in-ansible)
- IOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ios.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ios.html#using-cli-in-ansible)
- IOS-XR Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_iosxr.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_iosxr.html#using-cli-in-ansible)
  - [Using NETCONF in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_iosxr.html#using-netconf-in-ansible)
- IronWare Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ironware.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ironware.html#using-cli-in-ansible)
- Junos OS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_junos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_junos.html#using-cli-in-ansible)
  - [Using NETCONF in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_junos.html#using-netconf-in-ansible)
- Meraki Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_meraki.html#connections-available)
- Pluribus NETVISOR Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_netvisor.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_netvisor.html#using-cli-in-ansible)
- NOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nos.html#using-cli-in-ansible)
- NXOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nxos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nxos.html#using-cli-in-ansible)
  - [Using NX-API in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nxos.html#using-nx-api-in-ansible)
  - [Cisco Nexus platform support matrix](https://docs.ansible.com/ansible/latest/network/user_guide/platform_nxos.html#cisco-nexus-platform-support-matrix)
- RouterOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_routeros.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_routeros.html#using-cli-in-ansible)
- SLX-OS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_slxos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_slxos.html#using-cli-in-ansible)
- VOSS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_voss.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_voss.html#using-cli-in-ansible)
- VyOS Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_vyos.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_vyos.html#using-cli-in-ansible)
- WeOS 4 Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_weos4.html#connections-available)
  - [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_weos4.html#using-cli-in-ansible)
- Netconf enabled Platform Options
  - [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_netconf_enabled.html#connections-available)
  - [Using NETCONF in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_netconf_enabled.html#using-netconf-in-ansible)



## Settings by Platform[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform)

|                                                              | `ansible_connection:` settings available |             |         |         |       |
| ------------------------------------------------------------ | ---------------------------------------- | ----------- | ------- | ------- | ----- |
| Network OS                                                   | `ansible_network_os:`                    | network_cli | netconf | httpapi | local |
| [Arista EOS](https://galaxy.ansible.com/arista/eos) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `arista.eos.eos`                         | ✓           |         | ✓       | ✓     |
| [Ciena SAOS6](https://galaxy.ansible.com/ciena/saos6)        | `ciena.saos6.saos6`                      | ✓           |         |         | ✓     |
| [Cisco ASA](https://galaxy.ansible.com/cisco/asa) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `cisco.asa.asa`                          | ✓           |         |         | ✓     |
| [Cisco IOS](https://galaxy.ansible.com/cisco/ios) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `cisco.ios.ios`                          | ✓           |         |         | ✓     |
| [Cisco IOS XR](https://galaxy.ansible.com/cisco/iosxr) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `cisco.iosxr.iosxr`                      | ✓           |         |         | ✓     |
| [Cisco NX-OS](https://galaxy.ansible.com/cisco/nxos) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `cisco.nxos.nxos`                        | ✓           |         | ✓       | ✓     |
| [Cloudengine OS](https://galaxy.ansible.com/community/network) | `community.network.ce`                   | ✓           | ✓       |         | ✓     |
| [Dell OS6](https://github.com/ansible-collections/dellemc.os6) | `dellemc.os6.os6`                        | ✓           |         |         | ✓     |
| [Dell OS9](https://github.com/ansible-collections/dellemc.os9) | `dellemc.os9.os9`                        | ✓           |         |         | ✓     |
| [Dell OS10](https://galaxy.ansible.com/dellemc/os10)         | `dellemc.os10.os10`                      | ✓           |         |         | ✓     |
| [Ericsson ECCLI](https://galaxy.ansible.com/community/network) | `community.network.eric_eccli`           | ✓           |         |         | ✓     |
| [Extreme EXOS](https://galaxy.ansible.com/community/network) | `community.network.exos`                 | ✓           |         | ✓       |       |
| [Extreme IronWare](https://galaxy.ansible.com/community/network) | `community.network.ironware`             | ✓           |         |         | ✓     |
| [Extreme NOS](https://galaxy.ansible.com/community/network)  | `community.network.nos`                  | ✓           |         |         |       |
| [Extreme SLX-OS](https://galaxy.ansible.com/community/network) | `community.network.slxos`                | ✓           |         |         |       |
| [Extreme VOSS](https://galaxy.ansible.com/community/network) | `community.network.voss`                 | ✓           |         |         |       |
| [F5 BIG-IP](https://galaxy.ansible.com/f5networks/f5_modules) |                                          |             |         |         | ✓     |
| [F5 BIG-IQ](https://galaxy.ansible.com/f5networks/f5_modules) |                                          |             |         |         | ✓     |
| [Junos OS](https://galaxy.ansible.com/junipernetworks/junos) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `junipernetworks.junos.junos`            | ✓           | ✓       |         | ✓     |
| [Lenovo CNOS](https://galaxy.ansible.com/community/network)  | `community.network.cnos`                 | ✓           |         |         | ✓     |
| [Lenovo ENOS](https://galaxy.ansible.com/community/network)  | `community.network.enos`                 | ✓           |         |         | ✓     |
| [Meraki](https://galaxy.ansible.com/cisco/meraki)            |                                          |             |         |         | ✓     |
| [MikroTik RouterOS](https://galaxy.ansible.com/community/network) | `community.network.routeros`             | ✓           |         |         |       |
| [Nokia SR OS](https://galaxy.ansible.com/community/network)  |                                          |             |         |         | ✓     |
| [Pluribus Netvisor](https://galaxy.ansible.com/community/network) | `community.network.netvisor`             | ✓           |         |         |       |
| [Ruckus ICX](https://galaxy.ansible.com/community/network)   | `community.network.icx`                  | ✓           |         |         |       |
| [VyOS](https://galaxy.ansible.com/vyos/vyos) [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `vyos.vyos.vyos`                         | ✓           |         |         | ✓     |
| [Westermo WeOS 4](https://galaxy.ansible.com/community/network) | `community.network.weos4`                | ✓           |         |         |       |
| OS that supports Netconf [[†\]](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#id3) | `<network-os>`                           |             | ✓       |         | ✓     |

**[†]** Maintained by Ansible Network Team

# CloudEngine OS Platform Options[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#cloudengine-os-platform-options)

CloudEngine CE OS is part of the [community.network](https://galaxy.ansible.com/community/network) collection and supports multiple connections. This page offers details  on how each connection works in Ansible and how to use it.

- [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#connections-available)
- [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#using-cli-in-ansible)
  - [Example CLI inventory `[ce:vars\]`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-cli-inventory-ce-vars)
  - [Example CLI task](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-cli-task)
- [Using NETCONF in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#using-netconf-in-ansible)
  - [Enabling NETCONF](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#enabling-netconf)
  - [Example NETCONF inventory `[ce:vars\]`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-netconf-inventory-ce-vars)
  - [Example NETCONF task](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-netconf-task)
- [Notes](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#notes)
  - [Modules that work with `ansible.netcommon.network_cli`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#modules-that-work-with-ansible-netcommon-network-cli)
  - [Modules that work with `ansible.netcommon.netconf`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#modules-that-work-with-ansible-netcommon-netconf)

## [Connections available](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id1)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#connections-available)

|                                      | CLI                                                          | NETCONF                                                      |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Protocol                             | SSH                                                          | XML over SSH                                                 |
| Credentials                          | uses SSH keys / SSH-agent if present accepts `-u myuser -k` if using password | uses SSH keys / SSH-agent if present accepts `-u myuser -k` if using password |
| Indirect Access                      | via a bastion (jump host)                                    | via a bastion (jump host)                                    |
| Connection Settings                  | `ansible_connection:``ansible.netcommon.network_cli`         | `ansible_connection:``ansible.netcommon.netconf`             |
| Enable Mode   (Privilege Escalation) | not supported by ce OS                                       | not supported by ce OS                                       |
| Returned Data Format                 | Refer to individual module documentation                     | Refer to individual module documentation                     |

The `ansible_connection: local` has been deprecated. Please use  `ansible_connection: ansible.netcommon.netconf` or `ansible_connection=ansible.netcommon.network_cli` instead.

## [Using CLI in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id2)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#using-cli-in-ansible)

### [Example CLI inventory `[ce:vars\]`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id3)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-cli-inventory-ce-vars)

```
[ce:vars]
ansible_connection=ansible.netcommon.network_cli
ansible_network_os=community.network.ce
ansible_user=myuser
ansible_password=!vault...
ansible_ssh_common_args='-o ProxyCommand="ssh -W %h:%p -q bastion01"'
```

- If you are using SSH keys (including an ssh-agent) you can remove the `ansible_password` configuration.
- If you are accessing your host directly (not through a bastion/jump host) you can remove the `ansible_ssh_common_args` configuration.
- If you are accessing your host through a bastion/jump host, you cannot include your SSH password in the `ProxyCommand` directive. To prevent secrets from leaking out (for example in `ps` output), SSH does not support providing passwords via environment variables.

### [Example CLI task](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id4)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-cli-task)

```
- name: Retrieve CE OS version
  community.network.ce_command:
    commands: display version
  when: ansible_network_os == 'community.network.ce'
```

## [Using NETCONF in Ansible](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id5)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#using-netconf-in-ansible)

### [Enabling NETCONF](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id6)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#enabling-netconf)

Before you can use NETCONF to connect to a switch, you must:

- install the `ncclient` python package on your control node(s) with `pip install ncclient`
- enable NETCONF on the CloudEngine OS device(s)

To enable NETCONF on a new switch using Ansible, use the `community.network.ce_config` module with the CLI connection. Set up your platform-level variables  just like in the CLI example above, then run a playbook task like this:

```
- name: Enable NETCONF
  connection: ansible.netcommon.network_cli
  community.network.ce_config:
    lines:
      - snetconf server enable
  when: ansible_network_os == 'community.network.ce'
```

Once NETCONF is enabled, change your variables to use the NETCONF connection.

### [Example NETCONF inventory `[ce:vars\]`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id7)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-netconf-inventory-ce-vars)

```
[ce:vars]
ansible_connection=ansible.netcommon.netconf
ansible_network_os=community.network.ce
ansible_user=myuser
ansible_password=!vault |
ansible_ssh_common_args='-o ProxyCommand="ssh -W %h:%p -q bastion01"'
```

### [Example NETCONF task](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id8)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#example-netconf-task)

```
- name: Create a vlan, id is 50(ce)
  community.network.ce_vlan:
    vlan_id: 50
    name: WEB
  when: ansible_network_os == 'community.network.ce'
```

## [Notes](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id9)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#notes)

### [Modules that work with `ansible.netcommon.network_cli`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id10)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#modules-that-work-with-ansible-netcommon-network-cli)

```
community.network.ce_acl_interface
community.network.ce_command
community.network.ce_config
community.network.ce_evpn_bgp
community.network.ce_evpn_bgp_rr
community.network.ce_evpn_global
community.network.ce_facts
community.network.ce_mlag_interface
community.network.ce_mtu
community.network.ce_netstream_aging
community.network.ce_netstream_export
community.network.ce_netstream_global
community.network.ce_netstream_template
community.network.ce_ntp_auth
community.network.ce_rollback
community.network.ce_snmp_contact
community.network.ce_snmp_location
community.network.ce_snmp_traps
community.network.ce_startup
community.network.ce_stp
community.network.ce_vxlan_arp
community.network.ce_vxlan_gateway
community.network.ce_vxlan_global
```

### [Modules that work with `ansible.netcommon.netconf`](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#id11)[](https://docs.ansible.com/ansible/latest/network/user_guide/platform_ce.html#modules-that-work-with-ansible-netcommon-netconf)

```
community.network.ce_aaa_server
community.network.ce_aaa_server_host
community.network.ce_acl
community.network.ce_acl_advance
community.network.ce_bfd_global
community.network.ce_bfd_session
community.network.ce_bfd_view
community.network.ce_bgp
community.network.ce_bgp_af
community.network.ce_bgp_neighbor
community.network.ce_bgp_neighbor_af
community.network.ce_dldp
community.network.ce_dldp_interface
community.network.ce_eth_trunk
community.network.ce_evpn_bd_vni
community.network.ce_file_copy
community.network.ce_info_center_debug
community.network.ce_info_center_global
community.network.ce_info_center_log
community.network.ce_info_center_trap
community.network.ce_interface
community.network.ce_interface_ospf
community.network.ce_ip_interface
community.network.ce_lacp
community.network.ce_link_status
community.network.ce_lldp
community.network.ce_lldp_interface
community.network.ce_mlag_config
community.network.ce_netconf
community.network.ce_ntp
community.network.ce_ospf
community.network.ce_ospf_vrf
community.network.ce_reboot
community.network.ce_sflow
community.network.ce_snmp_community
community.network.ce_snmp_target_host
community.network.ce_snmp_user
community.network.ce_static_route
community.network.ce_static_route_bfd
community.network.ce_switchport
community.network.ce_vlan
community.network.ce_vrf
community.network.ce_vrf_af
community.network.ce_vrf_interface
community.network.ce_vrrp
community.network.ce_vxlan_tunnel
community.network.ce_vxlan_vap
```

Warning

Never store passwords in plain text. We recommend using SSH keys to  authenticate SSH connections. Ansible supports ssh-agent to manage your  SSH keys. If you must use passwords to authenticate SSH connections, we  recommend encrypting them with [Ansible Vault](https://docs.ansible.com/ansible/latest/vault_guide/vault_using_encrypted_content.html#playbooks-vault).

See also

[Setting timeout options](https://docs.ansible.com/ansible/latest/network/getting_started/network_connection_options.html#timeout-options)