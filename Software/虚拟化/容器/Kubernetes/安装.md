# 安装
[TOC]
## 概述

可以下载 Kubernetes ，在本地机器、云或自己的数据中心上部署 Kubernetes 集群。

诸如 kube-apiserver 或 kube-proxy 等某些 Kubernetes 组件可以在集群中以容器镜像部署。

> **建议：**
>
> 尽可能将 Kubernetes 组件作为容器镜像运行，并且让 Kubernetes 管理这些组件。 但是运行容器的相关组件，尤其是 kubelet，不在此列。

## 部署工具

* kubectl

   Kubernetes 命令行工具 kubectl ，可以对 Kubernetes 集群运行命令。可以使用 kubectl 来部署应用、监测和管理集群资源以及查看日志。

   kubectl 可安装在各种 Linux 平台、 macOS 和 Windows 上。 

* kubeadm

   <img src="../../../../Image/k/kubeadm-stacked-color.png" style="zoom:25%;" />

   可以使用 kubeadm 工具来创建和管理 Kubernetes 集群。 该工具能够执行必要的动作并用一种用户友好的方式启动一个可用的、安全的集群。

* kind

   让你能够在本地计算机上运行 Kubernetes。 要求安装并配置好 Docker 。

* Kops

* Kubespray

* minikube

   与 `kind` 类似，是一个工具， 能在本地运行 Kubernetes。在你的个人计算机（包括 Windows、macOS 和 Linux PC）上运行一个一体化（all-in-one）或多节点的本地 Kubernetes 集群，以便尝试 Kubernetes 或者开展每天的开发工作。

## 示例环境信息

| ID   | IP             | hostname   |
| ---- | -------------- | ---------- |
| 1    | 192.168.16.105 | k8s-master |
| 2    | 192.168.16.106 | k8s-node1  |
| 3    | 192.168.16.107 | k8s-node2  |

## Kubeadm

### 准备

- 一台兼容的 Linux 主机。
- 每台机器 2 GB 或更多的 RAM。
- 2 CPU 核或更多。
- 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)。
- 节点之中不可以有重复的主机名、MAC 地址或 product_uuid。
- 开启机器上的某些端口。
- **必须**禁用交换分区。

### 确保每个节点上 MAC 地址和 product_uuid 的唯一性   

- 使用命令 `ip link` 或 `ifconfig -a` 来获取网络接口的 MAC 地址。
- 使用 `sudo cat /sys/class/dmi/id/product_uuid` 命令对 product_uuid 校验。

一般来讲，硬件设备会拥有唯一的地址，但是有些虚拟机的地址可能会重复。 Kubernetes 使用这些值来唯一确定集群中的节点。 

### 检查网络适配器

如果有一个以上的网络适配器，同时 Kubernetes 组件通过默认路由不可达，建议预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。

### 允许 iptables 检查桥接流量

确保 `br_netfilter` 模块被加载。这一操作可以通过运行 `lsmod | grep br_netfilter` 来完成。若要显式加载该模块，可执行 `sudo modprobe br_netfilter`。

为了让 Linux 节点上的 iptables 能够正确地查看桥接流量，需要确保在 `sysctl` 配置中将 `net.bridge.bridge-nf-call-iptables` 设置为 1。例如：

```bash
cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF

cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
```

### 检查所需端口

#### 控制平面节点

| 协议 | 方向 | 端口范围  | 作用                    | 使用者                       |
| ---- | ---- | --------- | ----------------------- | ---------------------------- |
| TCP  | 入站 | 6443      | Kubernetes API 服务器   | 所有组件                     |
| TCP  | 入站 | 2379-2380 | etcd 服务器客户端 API   | kube-apiserver, etcd         |
| TCP  | 入站 | 10250     | Kubelet API             | kubelet 自身、控制平面组件   |
| TCP  | 入站 | 10251     | kube-scheduler          | kube-scheduler 自身          |
| TCP  | 入站 | 10252     | kube-controller-manager | kube-controller-manager 自身 |

#### 工作节点

| 协议 | 方向 | 端口范围    | 作用          | 使用者                     |
| ---- | ---- | ----------- | ------------- | -------------------------- |
| TCP  | 入站 | 10250       | Kubelet API   | kubelet 自身、控制平面组件 |
| TCP  | 入站 | 30000-32767 | NodePort 服务 | 所有组件                   |

* 虽然控制平面节点已经包含了 etcd 的端口，也可以使用自定义的外部 etcd 集群，或是指定自定义端口。

### 安装 runtime

为了在 Pod 中运行容器，Kubernetes 使用 Container Runtime 。

```bash
# Linux
默认情况下，Kubernetes 使用 Container Runtime Interface，CRI）来与所选择的 Container Runtime 交互。
如果你不指定运行时，则 kubeadm 会自动尝试检测到系统上已经安装的运行时， 方法是扫描一组众所周知的 Unix 域套接字。 
下面的表格列举了一些容器运行时及其对应的套接字路径：

| 运行时      | 域套接字                          |
| ---------- | ------------------------------- |
| Docker     | /var/run/dockershim.sock        |
| containerd | /run/containerd/containerd.sock |
| CRI-O      | /var/run/crio/crio.sock         |

如果同时检测到 Docker 和 containerd，则优先选择 Docker。 这是必然的，因为 Docker 18.09 附带了 containerd 并且两者都是可以检测到的， 即使你仅安装了 Docker。 如果检测到其他两个或多个运行时，kubeadm 输出错误信息并退出。
kubelet 通过内置的 dockershim CRI 实现与 Docker 集成。

# 其它操作系统
默认情况下， kubeadm 使用 Docker 作为 Container Runtime 。 kubelet 通过内置的 dockershim CRI 实现与 Docker 集成。 
```

### 安装 kubeadm、kubelet 和 kubectl

需要在每台机器上安装以下的软件包：

- `kubeadm`：用来初始化集群的指令。
- `kubelet`：在集群中的每个节点上用来启动 Pod 和容器等。
- `kubectl`：用来与集群通信的命令行工具。

kubeadm **不能** 帮安装或者管理 `kubelet` 或 `kubectl`，所以需要确保它们与通过 kubeadm 安装的控制平面的版本相匹配。 如果不这样做，则存在发生版本偏差的风险，可能会导致一些预料之外的错误和问题。 然而，控制平面与 kubelet 间的相差一个次要版本不一致是支持的，但 kubelet 的版本不可以超过 API 服务器的版本。

> **警告：**
>
> 这些指南不包括系统升级时使用的所有 Kubernetes 程序包。这是因为 kubeadm 和 Kubernetes 有[特殊的升级注意事项](https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/)。

```bash
# Debian
1.更新 apt 包索引并安装使用 Kubernetes apt 仓库所需要的包：
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl

2.下载 Google Cloud 公开签名秘钥：
sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg

3.添加 Kubernetes apt 仓库：
echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list

4.更新 apt 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本：
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl

# Red Hat
1.设置yum repo
cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

2.将 SELinux 设置为 permissive 模式
sudo setenforce 0
sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

3.安装
sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes

4.设置开机启动
sudo systemctl enable --now kubelet

请注意：将 SELinux 设置为 permissive 模式 可以有效地将其禁用。 这是允许容器访问主机文件系统所必需的，而这些操作时为了例如 Pod 网络工作正常。必须这么做，直到 kubelet 做出对 SELinux 的支持进行升级为止。

# 无包管理器的情况
1.安装 CNI 插件（大多数 Pod 网络都需要）：
CNI_VERSION="v0.8.2"
ARCH="amd64"
sudo mkdir -p /opt/cni/bin
curl -L "https://github.com/containernetworking/plugins/releases/download/${CNI_VERSION}/cni-plugins-linux-${ARCH}-${CNI_VERSION}.tgz" | sudo tar -C /opt/cni/bin -xz

2.定义要下载命令文件的目录。
说明：DOWNLOAD_DIR 变量必须被设置为一个可写入的目录。 如果你在运行 Flatcar Container Linux，可将 DOWNLOAD_DIR 设置为 /opt/bin。
DOWNLOAD_DIR=/usr/local/bin
sudo mkdir -p $DOWNLOAD_DIR

3.安装 crictl（kubeadm/kubelet 容器运行时接口（CRI）所需）
CRICTL_VERSION="v1.17.0"
ARCH="amd64"
curl -L "https://github.com/kubernetes-sigs/cri-tools/releases/download/${CRICTL_VERSION}/crictl-${CRICTL_VERSION}-linux-${ARCH}.tar.gz" | sudo tar -C $DOWNLOAD_DIR -xz

4.安装 kubeadm、kubelet、kubectl 并添加 kubelet 系统服务：
RELEASE="$(curl -sSL https://dl.k8s.io/release/stable.txt)"
ARCH="amd64"
cd $DOWNLOAD_DIR
sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/${RELEASE}/bin/linux/${ARCH}/{kubeadm,kubelet,kubectl}
sudo chmod +x {kubeadm,kubelet,kubectl}

RELEASE_VERSION="v0.4.0"
curl -sSL "https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service" | sed "s:/usr/bin:${DOWNLOAD_DIR}:g" | sudo tee /etc/systemd/system/kubelet.service
sudo mkdir -p /etc/systemd/system/kubelet.service.d
curl -sSL "https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf" | sed "s:/usr/bin:${DOWNLOAD_DIR}:g" | sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf

5.激活并启动 kubelet：
systemctl enable --now kubelet
说明：Flatcar Container Linux 发行版会将 /usr/ 目录挂载为一个只读文件系统。 在启动引导集群之前，需要执行一些额外的操作来配置一个可写入的目录。 参见 kubeadm 故障排查指南 以了解如何配置一个可写入的目录。
```

kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环。

### 配置 cgroup 驱动程序 

Container Runtime 和 kubelet 都具有名字为 ["cgroup driver"](https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/) 的属性，该属性对于在 Linux 机器上管理 CGroups 而言非常重要。

> **警告：**
>
> 你需要确保容器运行时和 kubelet 所使用的是相同的 cgroup 驱动，否则 kubelet 进程会失败。
>





## 安装 kubelet、kubeadm 和 kubectl

在所有节点上安装。

* kubelet 运行在 Cluster 所有节点，负责启动 Pod 和容器。
* kubeadm 用于初始化 Cluster 。
* kubectl 是 Kubernetes 命令行工具。

```bash
# all hosts
# Ubuntu
apt-get update && apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat << EOF > /etc/apt/sources.list.d/kubernetes.list
deb http://apt.kubernetes.io/ kubernetes-xenial main
EOF
apt-get update
apt-get install -y kubelet kubeadm kubectl
```

## 创建 Cluster

### 初始化 Master

```bash
# k8s-master
kubeadm init --apiserver-advertise-address 192.168.16.105 --pod-network-cidr=10.244.0.0/16

# --apiserver-advertise-address 指明用 Master 的那个 interface 与 Cluster 的其他节点通信。
# --pod-network-cidr            指定 Pod 网络的范围。此处使用 flannel 网络方案。
```

### 配置 kubectl

```bash
# k8s-master
# Ubuntu
su - krupp	# 建议用普通用户
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

### 安装 Pod 网络

```bash
# k8s-master
# flannel
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
```

### 添加 node 节点

```bash
# node hosts
kubeadm join --token d38a01.134532add343c1883 192.168.16.105:6443\

# 如丢失 token ,可通过如下命令查看、
kubeadm token list

# 查看节点状态
kubectl get nodes
# 状态在所有组件未完成启动前，应该是NotReady

# 查看 Pod 状态。
kubectl get pod --all-namespaces

# 查看某个 Pod 具体情况。
kubectl describe pod pod_name --namespace=kube-system

# 查看集群信息
kubectl cluster-info

Kubernetes control plane is running at https://127.0.0.1:8443
KubeDNS is running at https://127.0.0.1:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
KubeDNSUpstream is running at https://127.0.0.1:8443/api/v1/namespaces/kube-system/services/kube-dns-upstream:dns/proxy
Metrics-server is running at https://127.0.0.1:8443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```

## Kops



## Kubespray

