# 配置规则

[TOC]

## 概述

Prometheus 支持两种类型的规则，可以定期配置和评估：which may be configured and then evaluated at regular intervals: 记录规则和告警规则。

要在 Prometheus 中包含规则，请创建一个包含必要规则语句的文件，并让 Prometheus 通过配置中的 `rule_files` 字段加载该文件。规则文件使用 YAML 。

可以在运行时通过向 Prometheus 进程发送 `SIGHUP` 来重新加载规则文件。仅当所有规则文件格式正确时才应用更改。

> Note about native histograms (experimental feature): Native histogram are always recorded as gauge histograms (for now). Most cases will create gauge histograms naturally, e.g. after `rate()`.
>
> 关于原生直方图（实验特征）的注释：原生直方图始终记录为计量直方图（目前）。大多数情况下会自然地创建量规直方图，例如在rate（）之后。

## 语法检查规则

要在不启动 Prometheus server 的情况下快速检查规则文件的语法是否正确，可以使用 Prometheus 的 `promtool` 命令行实用工具：

```bash
promtool check rules /path/to/example.rules.yml
```

The `promtool` binary is part of the `prometheus` archive offered on the project's [download page](https://prometheus.io/download/).

promtool二进制文件是prometheus存档的一部分，在项目的下载页面上提供。

当文件在语法上有效时，检查器将已解析规则的文本表示输出到标准输出，然后以 `0` 返回状态退出。如果存在任何语法错误或无效的输入参数，它将向标准错误输出错误消息，并以 `1` 返回状态退出。

## 规则组

记录和警报规则存在于规则组中。Rules within a group are run sequentially at a regular interval, with the same evaluation time. 组中的规则以规则的间隔顺序运行，计算时间相同。记录规则的名称必须是有效的度量名称。警报规则的名称必须是有效的标签值。

规则文件的语法为：

```yaml
groups:
  [ - <rule_group> ]
```

一个简单的示例规则文件：

```yaml
groups:
  - name: example
    rules:
    - record: code:prometheus_http_requests_total:sum
      expr: sum by (code) (prometheus_http_requests_total)
```

### `<rule_group>`

```yaml
# The name of the group. Must be unique within a file.
name: <string>

# How often rules in the group are evaluated.
[ interval: <duration> | default = global.evaluation_interval ]

# Limit the number of alerts an alerting rule and series a recording
# rule can produce. 0 is no limit.
[ limit: <int> | default = 0 ]

rules:
  [ - <rule> ... ]
```

## 记录规则

记录规则允许预先计算经常需要的或计算量大的表达式，并将其结果保存为一组新的时间序列。查询预先计算的结果通常会比每次需要时执行原始表达式快得多。这对于仪表板尤其有用，因为仪表板需要在每次刷新时重复查询相同的表达式。

规则的语法为：

```yaml
# The name of the time series to output to. Must be a valid metric name.
record: <string>

# The PromQL expression to evaluate. Every evaluation cycle this is
# evaluated at the current time, and the result recorded as a new set of
# time series with the metric name as given by 'record'.
expr: <string>

# Labels to add or overwrite before storing the result.
labels:
  [ <labelname>: <labelvalue> ]
```

## 告警规则

警报规则允许基于 Prometheus 表达式语言表达式定义警报条件，并向外部服务发送有关触发警报的通知。Whenever the alert expression results in one or more vector elements at a given point in time, the alert counts as active for these elements' label sets.每当警报表达式在给定时间点产生一个或多个向量元素时，警报计数为这些元素的标签集的活动。

规则的语法为：

```yaml
# The name of the alert. Must be a valid label value.
alert: <string>

# The PromQL expression to evaluate. Every evaluation cycle this is
# evaluated at the current time, and all resultant time series become
# pending/firing alerts.
expr: <string>

# Alerts are considered firing once they have been returned for this long.
# Alerts which have not yet fired for long enough are considered pending.
[ for: <duration> | default = 0s ]

# How long an alert will continue firing after the condition that triggered it
# has cleared.
[ keep_firing_for: <duration> | default = 0s ]

# Labels to add or overwrite for each alert.
labels:
  [ <labelname>: <tmpl_string> ]

# Annotations to add to each alert.
annotations:
  [ <labelname>: <tmpl_string> ]
```

### 定义警报规则

警报规则在 Prometheus 中的配置方式与记录规则相同。

带有警报规则的示例文件如下：

```yaml
groups:
- name: example
  rules:
  - alert: HighRequestLatency
    expr: job:request_latency_seconds:mean5m{job="myjob"} > 0.5
    for: 10m
    labels:
      severity: page
    annotations:
      summary: High request latency
```

The optional `for` clause causes Prometheus to wait for a certain duration between first encountering a new expression output vector element and counting an alert as firing for this element. In this case, Prometheus will check that the alert continues to be active during each evaluation for 10 minutes before firing the alert. Elements that are active, but not firing yet, are in the pending state. Alerting rules without the `for` clause will become active on the first evaluation.

可选的for子句使Prometheus在第一次遇到一个新的表达式输出向量元素和将一个alert计数为该元素的触发之间等待一段时间。在这种情况下，Prometheus将在每次评估期间检查警报是否持续激活10分钟，然后再发出警报。活动但尚未触发的元素处于挂起状态。没有for子句的警报规则将在第一次评估时变为活动状态。

The `labels` clause allows specifying a set of additional labels to be attached to the alert. Any existing conflicting labels will be overwritten. The label values can be templated.

labels子句允许指定附加到警报的一组附加标签。任何现有的冲突标签都将被覆盖。标签值可以模板化。

The `annotations` clause specifies a set of informational  labels that can be used to store longer additional information such as  alert descriptions or runbook links. The annotation values can be  templated.

annotations子句指定了一组信息标签，可用于存储更长的附加信息，如警报描述或Runbook链接。注释值可以模板化。

#### Templating

Label and annotation values can be templated using [console templates](https://prometheus.io/docs/visualization/consoles).  The `$labels` variable holds the label key/value pairs of an alert instance. The configured external labels can be accessed via the `$externalLabels` variable. The `$value` variable holds the evaluated value of an alert instance.模板化

标签和注释值可以使用控制台模板来模板化。$labels变量保存警报实例的标签键/值对。配置的外部标签可以通过$externalLabels变量访问。$value变量保存警报实例的评估值。

```yaml
# To insert a firing element's label values:
{{ $labels.<labelname> }}
# To insert the numeric expression value of the firing element:
{{ $value }}
```

Examples:

```yaml
groups:
- name: example
  rules:

  # Alert for any instance that is unreachable for >5 minutes.
  - alert: InstanceDown
    expr: up == 0
    for: 5m
    labels:
      severity: page
    annotations:
      summary: "Instance {{ $labels.instance }} down"
      description: "{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes."

  # Alert for any instance that has a median request latency >1s.
  - alert: APIHighRequestLatency
    expr: api_http_request_latencies_second{quantile="0.5"} > 1
    for: 10m
    annotations:
      summary: "High request latency on {{ $labels.instance }}"
      description: "{{ $labels.instance }} has a median request latency above 1s (current value: {{ $value }}s)"
```

### Inspecting alerts during runtime 在运行时检查警报

To manually inspect which alerts are active (pending or firing), navigate to the "Alerts" tab of your Prometheus instance. This will show you the exact label sets for which each defined alert is currently active.

要手动检查哪些警报处于活动状态（挂起或触发），请导航到Prometheus实例的“警报”选项卡。这将显示每个已定义警报当前处于活动状态的确切标签集。

For pending and firing alerts, Prometheus also stores synthetic time series of the form `ALERTS{alertname="<alert name>", alertstate="<pending or firing>", <additional alert labels>}`. The sample value is set to `1` as long as the alert is in the indicated active (pending or firing) state, and the series is marked stale when this is no longer the case.

对于未决和触发警报，Prometheus还存储形式为ALERTS{alertname=”<alert name>“，alertstate=”<pending or firing>“，<additional alert labels>}的合成时间序列。只要警报处于所指示的活动（挂起或激发）状态，样本值就被设置为1，并且当不再是这种情况时，该系列被标记为陈旧。

### 发送警报通知

Prometheus 的警报规则很好地计算出当前的漏洞，但它们并不是一个成熟的通知解决方案。需要在简单警报定义之上添加总结、通知速率限制、静默和警报依赖关系。Prometheus's alerting rules are good at figuring what is broken *right now*, but they are not a fully-fledged notification solution. Another layer is needed to add summarization, notification rate limiting, silencing and alert dependencies on top of the simple alert definitions. 在 Prometheus 的生态系统中，Alertmanager 承担了这个角色。因此，Prometheus 可以被配置为周期性地将关于警报状态的信息发送到 Alertmanager 实例，该 Alertmanager 实例然后负责分派正确的通知。

Prometheus can be [configured](https://prometheus.io/docs/prometheus/latest/configuration/configuration/) to automatically discover available Alertmanager instances through its service discovery integrations.


Prometheus 可以配置为通过其服务发现集成自动发现可用的 Alertmanager 实例。

# Limiting alerts and series

限制警报和系列

可以按组配置由警报规则和系列产生的记录规则产生的警报的限制。超过限制时，规则生成的所有序列都将被丢弃，如果是警报规则，则规则的所有警报（活动、挂起或非活动）也将被清除。该事件将被记录为评估中的错误，因此不会写入陈旧标记。

A limit for alerts produced by alerting rules and series produced recording rules can be configured per-group. When the limit is exceeded, *all* series produced by the rule are discarded, and if it's an alerting rule, *all* alerts for the rule, active, pending, or inactive, are cleared as well. The event will be recorded as an error in the evaluation, and as such no stale markers are written.
