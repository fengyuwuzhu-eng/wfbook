## 配置管理集成

Cobbler 包含将安装环境与配置管理系统集成的功能，允许配置管理系统通过更改配置文件和设置来处理安装后的系统配置。

Resources are the lego blocks of configuration management. Resources are grouped together via Management Classes, which are then linked to a system.资源是配置管理的乐高积木。资源通过管理类组合在一起，然后链接到系统。Cobbler 支持两种资源类型。资源按下面列出的顺序配置。

The initial provisioning of client systems with cobbler is just one component of their management. 最初使用 cobbler 提供客户机系统只是其管理的一个组成部分。还需要考虑如何使用配置管理系统（CMS）继续管理它们。Cobbler 可以帮助在客户端系统上配置和引入 CMS 。

一个选择是 Cobbler 自己的轻量级 CMS 。

在这里，讨论另一种选择：部署CMS，如

* cfengine3
* puppet
* bcfg2
* Chef
* etc.

Cobbler doesn’t force you to chose a particular CMS (or to use one at all), though it helps if you do some things to link cobbler’s profiles with the “profiles” of the CMS. This, in general, makes management of both a lot easier.

Cobbler 并不强迫选择一个特定的 CMS（或使用一个），虽然它有助于如果你做一些事情，以链接Cobbler的配置文件与CMS的“配置文件”。一般来说，这使得两者的管理都容易得多。

请注意，这里有两个独立的“变量”：可能的客户端操作系统和可能的 CMS 。我们并不试图涵盖所有组合的所有细节；相反，我们说明了原则，并给予一些特定 OS / CMS 组合的说明性示例。目前，cobbler 对基于红帽的操作系统和 Puppet 有更好的支持，因此当前的示例倾向于处理这种组合。

### 背景考虑

#### 机器生命周期

一台典型的计算机有一个生命周期，类似于：

- 安装

- 初始配置

- 持续配置和维护

- 退役

通常安装只发生一次。同样，初始配置只发生一次，通常在安装后不久。相比之下，持续的配置是在很长一段时间内演变的，也许是几年。有时，正在进行的配置的一部分可能涉及从头开始重新安装操作系统。我们可以把这看作是对前一阶段的重复。

不需要在这里考虑退役。

安装显然属于（在我们的上下文中）Cobbler。作为补充，持续的配置显然属于 CMS 。但是初始配置呢？

Some sites consider their initial configuration as the final phase of installation: in our context, that would put it at the back end of Cobbler, and potentially add significant configuration-based complication to the installation-based Cobbler set-up.一些站点将其初始配置视为安装的最后阶段：在我们的上下文中，这将使其位于Cobbler的后端，并可能为基于安装的Cobbler设置添加显著的基于配置的复杂性。

But it is worth considering initial configuration as the first step of ongoing configuration: in our context that would put it as part of the CMS, and keep the Cobbler set-up simple and uncluttered.但值得考虑将初始配置作为持续配置的第一步：在我们的上下文中，将其作为CMS的一部分，并保持Cobbler设置简单和整洁。









### 6.1.1.2. Local package repositories[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#local-package-repositories)

Give consideration to:

- local mirrors of OS repositories
- local repository of local packages
- local repository of pick-and-choose external packages

In particular consider having the packages for your chosen CMS in one of the latter.

### 6.1.1.3. Package management[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#package-management)

Some sites set up Cobbler always to deploy just a minimal subset of packages, then use the CMS to install many others in a large-scale fashion. Other sites may set up Cobbler to deploy tailored sets of packages to different types of machines, then use the CMS to do relatively small-scale fine-tuning of that.

## 6.1.2. General scheme[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#general-scheme)

We need to consider getting Cobbler to install and automatically invoke the CMS software.

Set up Cobbler to include a package repository that contains your chosen CMS:

```
cobbler repo add ...
```

Then (illustrating a Red Hat/Puppet combination) set up the kickstart file to say something like:

```
%packages
puppet

%post
/sbin/chkconfig --add puppet
```

The detail may need to be more substantial, requiring some other associated local packages, files and configuration. You may wish to manage this through kickstart snippets.

David Lutterkort has a [walkthrough for kickstart](http://watzmann.net/blog/2006/12/kickstarting-into-puppet.html). While his example is written for Red Hat (Fedora) and Puppet, the principles are useful for other OS/CMS combinations.

## 6.1.3. Built-In Configuration Management[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#built-in-configuration-management)

Cobbler is not just an installation server, it can also enable two different types of ongoing configuration management system (CMS):

- integration with an established external CMS such as cfengine3, bcfg2, Chef, or puppet.
- its own, much simpler, lighter-weight, internal CMS, discussed here.

### 6.1.3.1. Setting up[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#setting-up)

Cobbler’s internal CMS is focused around packages and templated configuration files, and installing these on client systems.

This all works using the same [Cheetah-powered](https://cheetahtemplate.org) templating engine used in kickstart templating, so once you learn about the power of treating your distribution answer files as templates, you can use the same templating to drive your CMS configuration files.

For example:

```
cobbler profile edit --name=webserver --template-files=/srv/cobbler/x.template=/etc/foo.conf
```

A client system installed via the above profile will gain a file `/etc/foo.conf` which is the result of rendering the template given by `/srv/cobbler/x.template`. Multiple files may be specified; each `template=destination` pair should be placed in a space-separated list enclosed in quotes:

```
--template-files="srv/cobbler/x.template=/etc/xfile.conf srv/cobbler/y.template=/etc/yfile.conf"
```

### 6.1.3.2. Template files[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#template-files)

Because the template files will be parsed by the Cheetah parser, they must conform to the guidelines described in kickstart templating. This is particularly important when the file is generated outside a Cheetah environment. Look for, and act on, Cheetah ‘ParseError’ errors in the Cobbler logs.

Template files follows general Cheetah syntax, so can include Cheetah variables. Any variables you define anywhere in the cobbler object hierarchy (distros, profiles, and systems) are available to your templates. To see all the variables available, use the command:

```
cobbler profile dumpvars --name=webserver
```

Cobbler snippets and other advanced features can also be employed.

### 6.1.3.3. Ongoing maintenance[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#ongoing-maintenance)

Koan can pull down files to keep a system updated with the latest templates and variables:

```
koan --server=cobbler.example.org --profile=foo --update-files
```

You could also use `--server=bar` to retrieve a more specific set of templating. Koan can also autodetect the server if the MAC address is registered.

### 6.1.3.4. Further uses[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#further-uses)

This Cobbler/Cheetah templating system can serve up templates via the magic URLs (see “Leveraging Mod Python” below). To do this ensure that the destination path given to any `--template-files` element is relative, not absolute; then Cobbler and Koan won’t download those files.

For example, in:

```
cobbler profile edit --name=foo --template-files="/srv/templates/a.src=/etc/foo/a.conf /srv/templates/b.src=1"
```

Cobbler and koan would automatically download the rendered `a.src` to replace the file `/etc/foo/a.conf`, but the `b.src` file would not be downloaded to anything because the destination pathname `1` is not absolute.

This technique enables using the Cobbler/Cheetah templating system to build things that other systems can fetch and use, for instance, BIOS config files for usage from a live environment.

### 6.1.3.5. Leveraging Mod Python[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#leveraging-mod-python)

All template files are generated dynamically at run-time. If a change is made to a template, a `--ks-meta` variable or some other variable in Cobbler, the result of template rendering will be different on subsequent runs. This is covered in more depth in the Developer documentation <https://github.com/cobbler/cobbler/wiki>_.

### 6.1.3.6. Possible future developments[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#possible-future-developments)

- Serving and running scripts via `--update-files` (probably staging them through `/var/spool/koan`).
- Auto-detection of the server name if `--ip` is registered.

## 6.1.4. Terraform Provider[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#terraform-provider)

This is developed and maintained by the Cobbler community. You will find more information in the docs under https://registry.terraform.io/providers/cobbler/cobbler/latest/docs.

The code for the Terraform-Provider can be found at: https://github.com/cobbler/terraform-provider-cobbler

## 6.1.5. Ansible[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#ansible)

Official integration:

- https://docs.ansible.com/ansible/latest/collections/community/general/cobbler_inventory.html#ansible-collections-community-general-cobbler-inventory

Community provided integration:

- https://github.com/ac427/my_cm
- https://github.com/AnKosteck/ansible-cluster
- https://github.com/osism/ansible-cobbler
- https://github.com/hakoerber/ansible-roles

## 6.1.6. Saltstack[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#saltstack)

Although we currently can not provide something official we can indeed link some community work here:

- https://github.com/hakoerber/salt-states/tree/master/cobbler

## 6.1.7. Vagrant[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#vagrant)

Although we currently can not provide something official we can indeed link some community work here:

- https://github.com/davegermiquet/vmwarevagrantcobblercentos
- https://github.com/dratushnyy/tools
- https://github.com/mkusanagi/cobbler-kickstart-playground

## 6.1.8. Puppet[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#id1)

There is also an example of Puppet deploying Cobbler: https://github.com/gothicfann/puppet-cobbler

This example is relatively advanced, involving Cobbler “mgmt-classes” to control different types of initial configuration. But if instead you opt to put most of the initial configuration into the Puppet CMS rather than here, then things could be simpler.

### 6.1.8.1. Keeping Class Mappings In Cobbler[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#keeping-class-mappings-in-cobbler)

First, we assign management classes to distro, profile, or system objects.

```
cobbler distro edit --name=distro1 --mgmt-classes="distro1"
cobbler profile add --name=webserver --distro=distro1 --mgmt-classes="webserver likes_llamas" --autoinstall=/etc/cobbler/my.ks
cobbler system edit --name=system --profile=webserver --mgmt-classes="orange" --dns-name=system.example.org
```

For Puppet, the `--dns-name` (shown above) must be set because this is what puppet will be sending to cobbler and is how we find the system. Puppet doesn’t know about the name of the system object in cobbler. To play it safe you probably want to use the FQDN here (which is also what you want if you were using Cobbler to manage your DNS, which you don’t have to be doing).

### 6.1.8.2. External Nodes[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#external-nodes)

For more documentation on Puppet’s external nodes feature, see https://docs.puppetlabs.com.

Cobbler provides one, so configure puppet to use `/usr/bin/cobbler-ext-nodes`:

```
[main]
external_nodes = /usr/bin/cobbler-ext-nodes
```

Note: if you are using puppet 0.24 or later then you will want to also add the following to your configuration file.

```
ode_terminus = exec
```

You may wonder what this does. This is just a very simple script that grabs the data at the following URL, which is a URL that always returns a YAML document in the way that Puppet expects it to be returned. This file contains all the parameters and classes that are to be assigned to the node in question. The magic URL being visited is powered by Cobbler.

```
http://cobbler/cblr/svc/op/puppet/hostname/foo
```

(for developer information about this magic URL, visit https://fedorahosted.org/cobbler/wiki/ModPythonDetails)

And this will return data such as:

```
---
classes:
    - distro1
    - webserver
    - likes_llamas
    - orange
parameters:
    tree: 'http://.../x86_64/tree'
```

Where do the parameters come from? Everything that cobbler tracks in `--ks-meta` is also a parameter. This way you can easily add parameters as easily as you can add classes, and keep things all organized in one place.

What if you have global parameters or classes to add? No problem. You can also add more classes by editing the following fields in `/etc/cobbler/settings.yaml`:

```
# cobbler has a feature that allows for integration with config management
# systems such as Puppet.  The following parameters work in conjunction with

# --mgmt-classes  and are described in furhter detail at:
# https://fedorahosted.org/cobbler/wiki/UsingCobblerWithConfigManagementSystem
mgmt_classes: []
mgmt_parameters:
   from_cobbler: 1
```

### 6.1.8.3. Alternate External Nodes Script[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#alternate-external-nodes-script)

Attached at `puppet_node.py` is an alternate external node script that fills in the nodes with items from a manifests repository (at `/etc/puppet/manifests/`) and networking information from cobbler. It is configured like the above from the puppet side, and then looks for `/etc/puppet/external_node.yaml` for cobbler side configuration. The configuration is as follows.

```
base: /etc/puppet/manifests/nodes
cobbler: <%= cobbler_host %>
no_yaml: puppet::noyaml
no_cobbler: network::nocobbler
bad_yaml: puppet::badyaml
unmanaged: network::unmanaged
```

The output for network information will be in the form of a pseudo data structure that allows puppet to split it apart and create the network interfaces on the node being managed.

## 6.1.9. cfengine support[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#cfengine-support)

Documentation to be added

## 6.1.10. bcfg2 support[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#bcfg2-support)

Documentation to be added

## 6.1.11. Chef support[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#chef-support)

Documentation to be added.

There is some integration information on bootstrapping chef clients with cobbler in [this blog article](https://web.archive.org/web/20140213051741/http://blog.milford.io/2012/03/getting-a-basic-cobbler-server-going-on-centos/)

## 6.1.12. Conclusion[](https://cobbler.readthedocs.io/en/latest/user-guide/configuration-management-integrations.html#conclusion)

Hopefully this should get you started in linking up your provisioning configuration with your CMS implementation. The examples provided are for Puppet, but we can (in the future) presumably extend `--mgmt-classes` to work with other tools… Just let us know what you are interested in, or perhaps take a shot at creating a patch for it.