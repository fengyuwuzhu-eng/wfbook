# Hardware sizing[](https://docs.bareos.org/Appendix/HardwareSizing.html#hardware-sizing)

## Database system[](https://docs.bareos.org/Appendix/HardwareSizing.html#database-system)

### PostgreSQL version[](https://docs.bareos.org/Appendix/HardwareSizing.html#postgresql-version)

It is always advisable to use the **latest** currently **supported** PostgreSQL on your platform.  With identical contents, we have observed that PostgreSQL 12 required *half of the space* of a PostgreSQL 10 installation.

### PostgreSQL setup[](https://docs.bareos.org/Appendix/HardwareSizing.html#postgresql-setup)

The database files should be stored on **SSD storage**. The database configuration should be optimized for the amount of memory that the database has available. A good starting point is using [pgtune](https://pgtune.leopard.in.ua/), a website that allows to set some basic information and generates a PostgreSQL configuration. For pgtune the DB type of the Bareos catalog  database is a “Data Warehouse”.

### The file table[](https://docs.bareos.org/Appendix/HardwareSizing.html#the-file-table)

The by far **biggest table** in the Bareos catalog database is the **file** table. Typically this is about **90-95%** of the database’s total size. The **size of the file table** depends on the number of files that are stored and the average length of a filename (without path).

Roughly 40% of the file table size is consumed by its **indexes**.

The other noticeable table is **path** with its indexes. The amount of space used is roughly 

 of the **file** table.

To have optimum performance, the **memory available** for the Bareos catalog database should be at least the **size of the file and path table indexes**.

### Database size estimation[](https://docs.bareos.org/Appendix/HardwareSizing.html#database-size-estimation)

Depending on the number of files and the average length of filenames, the **database size** can be **estimated** using the following calculations:

To **calculate the number of files** in the DB, the  number of files being backed up from all systems needs to be multiplied  by the number of times that they will be kept in the database.

The **amount of data per file or path** in the DB,  depends on the size of filenames or path length that are being backed  up, but we have analyzed some real-world examples and found that values  between **250 and 350 bytes per row** are usual.

The size of the path indexes is around 60% of the table size.

So the calculation of the size of the file and path tables can be approximated with the following formula:



*Example:* If **2.000.000 files** are backed up during a full backup, a full backup is run **every week** and the retention of the backups is **4 weeks**, the total amount of files would be



About 40% of the File and 60% of path table size should be available as RAM, so about 1GB.

PostgreSQL for its vacuum operation need also disk space to be able  to rewrite the table. And you should also consider to have enough free  space to allow creation of temporary tables used during certain  operations. Heavy consolidation job can take several gigabytes of  temporary space.

## CPU considerations[](https://docs.bareos.org/Appendix/HardwareSizing.html#cpu-considerations)

During backups with Bareos, the amount of CPU consumed is influenced by different parameters.

## System being backed up[](https://docs.bareos.org/Appendix/HardwareSizing.html#system-being-backed-up)

- Often is the backup speed limited by the I/O speed that can be read from the original filesystem.
- The I/O speed of the filesystems being backed up or the network bandwidth are often not fast enough to saturate the CPU.
- The **TLS communication encryption** (enabled by default) also consumes CPU power, especially when the I/O rate is very fast.
- If **data encryption** is configured, the encryption is calculated on the source system and will consume CPU power there.
- If **signatures** are enabled in your fileset, this will require additional CPU cycles to be calculated on the source system.
- If data **compression** is configured, the compression is also executed on the source system and will consume CPU power there.

## Storage Daemon System[](https://docs.bareos.org/Appendix/HardwareSizing.html#storage-daemon-system)

- The Bareos Storage Daemon receives the data from the clients and stores it to the storage media.
- The Bareos Storage Daemon receives the data stream coming from the Clients and  stores the data to local storage media.
- Most CPU Power is consumed by the decryption of the TLS stream  and by calculating Checksums that are verified before storing data to  the storage media.

Depending on the available I/O throughput and the number of parallel jobs, different optimizations can be made:

- For a relative small number of clients that send data at very  high I/O rates, it makes sense to disable Hyperthreading Technologies so that less cores can operate at higher speed.
- For a large number of clients with non-exceptional I/O rates,  more CPU cores will provide better overall performance with parallel  backup jobs than fast CPU cores.

As a starting point, reserve 512 MB of memory and 

 CPU core per concurrent job planned.

## Director[](https://docs.bareos.org/Appendix/HardwareSizing.html#director)

The Bareos Director itself has comparatively low CPU and RAM requirements. Most of the really expensive calculations are done by the database engine.

It is recommended to run the Bareos Director service together with  the database server on the same machine, which minimizes the latency and overhead of the communication with the database.

# Operating Systems[](https://docs.bareos.org/Appendix/OperatingSystems.html#operating-systems)

The Bareos project provides packages, published at https://download.bareos.org/ and https://download.bareos.com/.

Additionally, the following table gives an overview on the available package versions and the operating systems, respectively:

| Operating Systems                                            | Version            | Client                                                      | Director                                                    | Storage                                                     |
| ------------------------------------------------------------ | ------------------ | ----------------------------------------------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |
| **Linux**                                                    |                    |                                                             |                                                             |                                                             |
| Arch Linux                                                   |                    | [X](https://aur.archlinux.org/pkgbase/bareos/)              | [X](https://aur.archlinux.org/pkgbase/bareos/)              | [X](https://aur.archlinux.org/pkgbase/bareos/)              |
| CentOS                                                       | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| Debian                                                       | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| Fedora                                                       | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| Gentoo                                                       |                    | [X](https://packages.gentoo.org/packages/app-backup/bareos) | [X](https://packages.gentoo.org/packages/app-backup/bareos) | [X](https://packages.gentoo.org/packages/app-backup/bareos) |
| openSUSE                                                     | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| (RH)EL                                                       | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| SLES                                                         | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| Ubuntu                                                       | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| [Univention Corporate Linux](https://docs.bareos.org/IntroductionAndTutorial/InstallingBareos.html#section-univentioncorporateserver) | current            | v12.4                                                       | v12.4                                                       | v12.4                                                       |
| [Universal Linux Client](https://docs.bareos.org/IntroductionAndTutorial/InstallingBareosClient.html#section-universallinuxclient) | openSSL 1.1        | v21.0                                                       | v21.0                                                       | v21.0                                                       |
|                                                              |                    |                                                             |                                                             |                                                             |
| **MS Windows**                                               |                    |                                                             |                                                             |                                                             |
| [MS Windows](https://docs.bareos.org/TasksAndConcepts/TheWindowsVersionOfBareos.html#section-windows) 32bit | 10/8/7             | v12.4                                                       | v15.2                                                       | v15.2                                                       |
|                                                              | 2008/Vista/2003/XP | v12.4–v14.2                                                 |                                                             |                                                             |
| [MS Windows](https://docs.bareos.org/TasksAndConcepts/TheWindowsVersionOfBareos.html#section-windows) 64bit | >= 7               | v12.4                                                       | v15.2                                                       | v15.2                                                       |
|                                                              | 2008/Vista         | v12.4–v14.2                                                 |                                                             |                                                             |
|                                                              |                    |                                                             |                                                             |                                                             |
| **Mac OS**                                                   |                    |                                                             |                                                             |                                                             |
| [Mac OS X/Darwin](https://docs.bareos.org/IntroductionAndTutorial/InstallingBareosClient.html#section-macosx) |                    | v14.2                                                       |                                                             |                                                             |
|                                                              |                    |                                                             |                                                             |                                                             |
| **BSD**                                                      |                    |                                                             |                                                             |                                                             |
| [FreeBSD](https://docs.bareos.org/IntroductionAndTutorial/InstallingBareos.html#section-freebsd) | >= 11              | v19.2                                                       | v19.2                                                       | v19.2                                                       |
| OpenBSD                                                      |                    | X                                                           |                                                             |                                                             |
| NetBSD                                                       |                    | X                                                           |                                                             |                                                             |
| **Unix**                                                     |                    |                                                             |                                                             |                                                             |
| AIX                                                          | >= 4.3             | com-13.2                                                    | *                                                           | *                                                           |
| HP-UX                                                        |                    | com-13.2                                                    |                                                             |                                                             |
| [Solaris](https://docs.bareos.org/IntroductionAndTutorial/InstallingBareosClient.html#section-solaris) (i386/Sparc) | >= 11              | com-12.4                                                    | com-12.4                                                    | com-12.4                                                    |

| **vVV.V**    | starting with Bareos version VV.V, this platform is official supported by the Bareos.org project |
| ------------ | ------------------------------------------------------------ |
| **com-VV.V** | starting with Bareos version VV.V, this platform is supported. However, pre-build packages are only available from Bareos.com |
| **X**        | known to work                                                |
| *****        | has been reported to work by the community                   |

# Bareos Programs[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-programs)

## Bareos Daemons[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-daemons)



### Daemon Command Line Options[](https://docs.bareos.org/Appendix/BareosPrograms.html#daemon-command-line-options)

Each of the three daemons (Director, File, Storage)  accepts a small set of options on the command line. In general, each of  the daemons as well as the Console program accepts the following  options:

- -c,--config <path>

  Define the file or directory to use for the configuration. See [Configuration Path Layout](https://docs.bareos.org/Configuration/CustomizingTheConfiguration.html#section-configurationpathlayout).

- -d,--debug-level nnn

  Set the debug level to nnn.  Generally anything between 50 and 200 is reasonable. The higher the  number, the more output is produced. The output is written to standard  output. The debug level can also be set during runtime, see section [bconsole: setdebug](https://docs.bareos.org/TasksAndConcepts/BareosConsole.html#bcommandsetdebug).

- --dt,--debug-timestamps

  Print timestamp in debug output.

- -f,--foreground

  Run the daemon in the foreground. This option is needed to run the daemon under the debugger.

- -g,--group <group>

  Run the daemon under this group. This must be a group name, not a GID.

- -s,--no-signals

  Do not trap signals. This option is needed to run the daemon under the debugger.

- -t,--test-config

  Read the configuration file and print  any error messages, then immediately exit. Useful for syntax testing of  new configuration files.

- -u,--user <user>

  Run the daemon as this user. This must be a user name, not a UID.

- -v,--verbose

  Be more verbose or more complete in printing error and informational messages.

- --xc,--export-configuration

  Print the current configuration and exit.

- --xs,--export-schema

  Print configuration schema in JSON format and exit.

- -h,--help,-?

  Print the version and list of options.



### bareos-dir[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-dir)

Bareos Director.



### bareos-sd[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-sd)

Bareos Storage Daemon.



### bareos-fd[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-fd)

Bareos File Daemon.

## Interactive Programs[](https://docs.bareos.org/Appendix/BareosPrograms.html#interactive-programs)

### bconsole[](https://docs.bareos.org/Appendix/BareosPrograms.html#bconsole)

There is an own chapter on **bconsole**. Please refer to chapter [Bareos Console](https://docs.bareos.org/TasksAndConcepts/BareosConsole.html#section-bconsole).

### bareos-webui[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-webui)

For further information regarding the Bareos Webui, please refer to [Bareos Webui](https://docs.bareos.org/IntroductionAndTutorial/BareosWebui.html#section-webui).



## Volume Utility Commands[](https://docs.bareos.org/Appendix/BareosPrograms.html#volume-utility-commands)

This document describes the utility programs written to  aid Bareos users and developers in dealing with Volumes external to  Bareos and to perform other useful tasks.

### Parameter[](https://docs.bareos.org/Appendix/BareosPrograms.html#parameter)

#### Specifying the Configuration[](https://docs.bareos.org/Appendix/BareosPrograms.html#specifying-the-configuration)

Each of the utilities that deal with Volumes require a valid Bareos  Storage Daemon configuration (actually, the only part of the  configuration file that these programs need is the [`Device (Sd)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_Name) resource definitions). This permits the programs to find the configuration parameters for your [`Archive Device (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_ArchiveDevice). Using the **-c** option a custom Bareos Storage Daemon configuration file or directory can be selected.

#### Specifying a Device[](https://docs.bareos.org/Appendix/BareosPrograms.html#specifying-a-device)

Each of these programs require a **device-name** where the Volume can be found. The device-name is either the name of the Bareos Storage Daemon device ([`Name (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_Name)) or its [`Archive Device (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_ArchiveDevice).

##### Specifying a Device Name For a Tape[](https://docs.bareos.org/Appendix/BareosPrograms.html#specifying-a-device-name-for-a-tape)

In the case of a tape, this is the physical device name such as /dev/nst0 or /dev/rmt/0ubn depending on your system.

Warning

If you have Bareos running and you want to use one of these programs, you will either need to stop the Bareos Storage Daemon or **unmount** any tape drive you want to use, otherwise the drive may get busy because Bareos is using it. After this, you can use the command **mtx** or [mtx-changer script](https://docs.bareos.org/Appendix/Troubleshooting.html#section-mtxchangermanualusage) to load the required volume into the tape drive.

##### Specifying a Device Name For a File[](https://docs.bareos.org/Appendix/BareosPrograms.html#specifying-a-device-name-for-a-file)

If you are attempting to read or write an archive file rather than a tape, the **device-name** can be the full path to the archive location specified at [`Archive Device (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_ArchiveDevice) or this including the filename of the volume. The filename (last part  of the specification) will be stripped and used as the Volume name So,  the path is equivalent to the [`Archive Device (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_ArchiveDevice) and the filename is equivalent to the volume name.

#### Specifying Volumes[](https://docs.bareos.org/Appendix/BareosPrograms.html#specifying-volumes)

Often you must specify the Volume name to the programs  below. The best method to do so is to specify a bootstrap file on the  command line with the **-b** option. As part of the  bootstrap file, you will then specify the Volume name or Volume names if more than one volume is needed. For example, suppose you want to read  tapes **tapevolume1** and **tapevolume2**. First construct a bootstrap file named say, `list.bsr` which contains:

```
Volume=tapevolume1|tapevolume2
```

where each Volume is separated by a vertical bar. Then simply use:

```
bls -b list.bsr /dev/nst0
```

In the case of Bareos Volumes that are on files, you may simply append volumes as follows:

```
bls /var/lib/bareos/storage/volume1\|volume2
```

where the backslash (\) was necessary as a shell escape to permit entering the vertical bar (|).

And finally, if you feel that specifying a Volume name is a bit complicated with a bootstrap file, you can use the **-V** option (on all programs except **bcopy**) to specify one or more Volume names separated by the vertical bar (|). For example:

```
bls /dev/nst0 -V tapevolume1
```

You may also specify an asterisk (*) to indicate that the program should accept any volume. For example:

```
bls /dev/nst0 -V*
```

If your Bareos Storage Daemon has following resource,

bareos-sd.d/device/FileStorage.conf[](https://docs.bareos.org/Appendix/BareosPrograms.html#id12)

```
Device {
  Name = FileStorage
  Archive Device = /var/lib/bareos/storage
  ...
}
```

following calls of **bls** should behave identical:

bls using Storage Device Name[](https://docs.bareos.org/Appendix/BareosPrograms.html#id13)

```
bls FileStorage -V Full1
```

or

bls using the Archive Device of a Storage Device[](https://docs.bareos.org/Appendix/BareosPrograms.html#id14)

```
bls /var/lib/bareos/storage -V Full1
```

or

bls using the Archive Device of a Storage Device and volume name[](https://docs.bareos.org/Appendix/BareosPrograms.html#id15)

```
bls /var/lib/bareos/storage/Full1
```

#### Specifying Maximum Block Size[](https://docs.bareos.org/Appendix/BareosPrograms.html#specifying-maximum-block-size)

If you use Bareos with non-default block sizes defined in the pools ([`Maximum Block Size (Dir->Pool)`](https://docs.bareos.org/Configuration/Director.html#config-Dir_Pool_MaximumBlockSize)), it might be necessary to specify the [`Maximum Block Size (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_MaximumBlockSize) also in the storage device resource, see [Direct access to Volumes with non-default blocksizes](https://docs.bareos.org/TasksAndConcepts/AutochangerSupport.html#direct-access-to-volumes-with-non-default-blocksizes).



### bls[](https://docs.bareos.org/Appendix/BareosPrograms.html#bls)

**bls** can be used to do an **ls** type listing of a Bareos tape or file. It is called:

```
Usage: bls [OPTIONS] device-names...

Positionals:
    device-names   ...
        REQUIRED
        Specify the input device name (either as name of a Bareos Storage 
        Daemon Device resource or identical to the Archive Device in a Bareos 
        Storage Daemon Device resource). 


Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -b,--parse-bootstrap <file>:FILE
        Specify a bootstrap file. 

    -c,--config <path>:PATH(existing)
        Use <path> as configuration file or directory. 

    -D,--director <director>
        Specify a director name found in the storage. Configuration file for 
        the Key Encryption Key selection. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -e,--exclude <file>
        Exclude list. 

    -i,--include-list <file>
        Include list. 

    -j,--list-jobs
        List jobs. 

    -k,--list-blocks
        List blocks. If neither -j or -k specified, list saved files. 

    -L,--dump-labels
        Dump labels. 

    -p,--ignore-errors
        Proceed inspite of IO errors. 

    -v,--verbose
        Default: 0
        Verbose user messages. 

    -V,--volumes <vol1|vol2|...>
        Volume names (separated by |) 
```

Normally if no options are specified, **bls** will produce the equivalent output to the **ls -l** command for each volume.

For example, to list the contents of a tape:

```
bls -V Volume-name /dev/nst0
```

Or to list the contents of a volume file:

```
bls FileStorage -V Full-0001
```

or

```
bls /var/lib/bareos/storage -V Full-0001
```

or

```
bls /var/lib/bareos/storage/Full-0001
```

For example:

```
bls FileStorage -V Full-0001 -v
stored/butil.cc:304-0 Using device: "FileStorage" for reading.
13-Sep 14:47 bls JobId 0: Ready to read from volume "Full-0001" on device "FileStorage" (/var/lib/bareos/storage).
bls JobId 1: -rwxr-xr-x   1 root     root            1797 2022-09-13 14:36:48  /usr/sbin/bareos
bls JobId 1: -rwxr-xr-x   1 root     root            3430 2022-09-13 14:36:48  /usr/sbin/btraceback
bls JobId 1: -rwxr-xr-x   1 root     root         1668872 2022-09-13 14:36:48  /usr/sbin/bareos-fd
bls JobId 1: -rwxr-xr-x   1 root     root           26576 2022-09-13 14:36:48  /usr/sbin/bscrypto
bls JobId 1: -rwxr-xr-x   1 root     root         1189448 2022-09-13 14:36:48  /usr/sbin/bwild
bls JobId 1: -rwxr-xr-x   1 root     root         1188048 2022-09-13 14:36:48  /usr/sbin/bregex
bls JobId 1: -rwxr-xr-x   1 root     root         1210744 2022-09-13 14:36:48  /usr/sbin/bpluginfo
bls JobId 1: -rwxr-xr-x   1 root     root           22568 2022-09-13 14:36:48  /usr/sbin/btestls
bls JobId 1: -rwxr-xr-x   1 root     root           27464 2022-09-13 14:36:48  /usr/sbin/bsmtp
bls JobId 1: -rwxr-xr-x   1 root     root         1516440 2022-09-13 14:36:48  /usr/sbin/bareos-sd
bls JobId 1: -rwxr-xr-x   1 root     root         1249256 2022-09-13 14:36:48  /usr/sbin/bls
bls JobId 1: -rwxr-xr-x   1 root     root         1228344 2022-09-13 14:36:48  /usr/sbin/bextract
bls JobId 1: -rwxr-xr-x   1 root     root         1273720 2022-09-13 14:36:48  /usr/sbin/bscan
bls JobId 1: -rwxr-xr-x   1 root     root         1316656 2022-09-13 14:36:48  /usr/sbin/btape
bls JobId 1: -rwxr-xr-x   1 root     root         1206640 2022-09-13 14:36:48  /usr/sbin/bcopy
bls JobId 1: -rwxr-xr-x   1 root     root         3165200 2022-09-13 14:36:48  /usr/sbin/bareos-dir
bls JobId 1: -rwxr-xr-x   1 root     root         1730080 2022-09-13 14:36:48  /usr/sbin/bareos-dbcheck
bls JobId 1: -rwxr-xr-x   1 root     root         2142248 2022-09-13 14:36:48  /usr/sbin/testfind
bls JobId 1: -rwxr-xr-x   1 root     root         1344768 2022-09-13 14:36:48  /usr/sbin/bconsole
bls JobId 1: drwxr-xr-x   1 root     root             348 2022-09-13 14:36:48  /usr/sbin/
13-Sep 14:47 bls JobId 0: End of Volume at file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Full-0001"
13-Sep 14:47 bls JobId 0: End of all volumes.
23 files and directories found.
13-Sep 14:47 bls JobId 0: Releasing device "FileStorage" (/var/lib/bareos/storage).
```

#### Show Detailed File Information[](https://docs.bareos.org/Appendix/BareosPrograms.html#show-detailed-file-information)

To retrieve information, about how a file is stored on the volume, you can use **bls** in verbose mode:

```
bls FileStorage -V Full-0001 -v
bls: stored/butil.cc:304-0 Using device: "FileStorage" for reading.
13-Sep 14:43 bls JobId 0: Ready to read from volume "Full-0001" on device "FileStorage" (/var/lib/bareos/storage).
Volume Label Record: VolSessionId=1 VolSessionTime=1663079882 JobId=0 DataLen=184
Begin Job Session Record: VolSessionId=1 VolSessionTime=1663079882 JobId=1 DataLen=164
FileIndex=1     Stream=1  UATTR                     DataLen=86    | -rwxr-xr-x   1 root     root            1797 2022-09-13 14:36:48
                                                                  | /usr/sbin/bareos
FileIndex=1     Stream=2  DATA                      DataLen=1797  |
FileIndex=1     Stream=3  MD5                       DataLen=16    | rsFZaeL8A6GFsWv2epxcWw (base64)
FileIndex=2     Stream=1  UATTR                     DataLen=90    | -rwxr-xr-x   1 root     root            3430 2022-09-13 14:36:48
                                                                  | /usr/sbin/btraceback
FileIndex=2     Stream=2  DATA                      DataLen=3430  |
FileIndex=2     Stream=3  MD5                       DataLen=16    | GatM//3Gz1Z3DbUyHnBGdg (base64)
...
End Job Session Record: VolSessionId=1 VolSessionTime=1663079882 JobId=1 DataLen=200
13-Sep 14:43 bls JobId 0: End of Volume at file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Full-0001"
13-Sep 14:43 bls JobId 0: End of all volumes.
End of Physical Medium Record: VolSessionId=0 VolSessionTime=0 JobId=0 DataLen=0
23 files and directories found.
13-Sep 14:43 bls JobId 0: Releasing device "FileStorage" (/var/lib/bareos/storage).
```

For details about the Volume format, see [Storage Media Output Format](https://docs.bareos.org/DeveloperGuide/mediaformat.html#storage-media-output-format).

#### Show Label Information[](https://docs.bareos.org/Appendix/BareosPrograms.html#show-label-information)

Using the **-L** the label information of a Volume is shown:

bls: show volume label[](https://docs.bareos.org/Appendix/BareosPrograms.html#id16)

```
bls -L /var/lib/bareos/storage/Full-0001
bls: stored/butil.cc:304-0 Using device: "/var/lib/bareos/storage" for reading.
13-Sep 14:40 bls JobId 0: Ready to read from volume "Full-0001" on device "FileStorage" (/var/lib/bareos/storage).

Volume Label:
Id                : Bareos 2.0 immortal
VerNo             : 20
VolName           : Full-0001
PrevVolName       :
VolFile           : 0
LabelType         : VOL_LABEL
LabelSize         : 184
PoolName          : Full
MediaType         : File
PoolType          : Backup
HostName          : 76c757a344d8
Date label written: 13-Sep-2022 14:38
13-Sep 14:40 bls JobId 0: Releasing device "FileStorage" (/var/lib/bareos/storage).
```

#### Listing Jobs[](https://docs.bareos.org/Appendix/BareosPrograms.html#listing-jobs)

If you are listing a Volume to determine what Jobs to restore, normally the **-j** option provides you with most of what you will need as long as you don’t have multiple clients. For example:

bls: list jobs[](https://docs.bareos.org/Appendix/BareosPrograms.html#id17)

```
bls FileStorage -V Full-0001 -j
bls: stored/butil.cc:304-0 Using device: "FileStorage" for reading.
13-Sep 14:56 bls JobId 0: Ready to read from volume "Full-0001" on device "FileStorage" (/var/lib/bareos/storage).
Volume Record: File:blk=0:219 SessId=1 SessTime=1663079882 JobId=0 DataLen=184
Begin Job Session Record: File:blk=0:64731 SessId=1 SessTime=1663079882 JobId=1
   Job=backup-bareos-fd.2022-09-13_14.38.22_03 Date=13-Sep-2022 14:38:54 Level=F Type=B
End Job Session Record: File:blk=0:21531986 SessId=1 SessTime=1663079882 JobId=1
   Job=backup-bareos-fd.2022-09-13_14.38.22_03 Date=13-Sep-2022 14:38:55 Level=F Type=B Files=23 Bytes=21,514,771 Errors=0 Status=T
Begin Job Session Record: File:blk=0:21596498 SessId=2 SessTime=1663079882 JobId=2
   Job=BackupCatalog.2022-09-13_14.52.39_05 Date=13-Sep-2022 14:52:57 Level=F Type=B
End Job Session Record: File:blk=0:21632274 SessId=2 SessTime=1663079882 JobId=2
   Job=BackupCatalog.2022-09-13_14.52.39_05 Date=13-Sep-2022 14:52:57 Level=F Type=B Files=83 Bytes=97,574 Errors=0 Status=T
Begin Job Session Record: File:blk=0:21696786 SessId=4 SessTime=1663079882 JobId=4
   Job=backup-bareos-fd.2022-09-13_14.56.13_08 Date=13-Sep-2022 14:56:37 Level=F Type=B
End Job Session Record: File:blk=0:73795419 SessId=4 SessTime=1663079882 JobId=4
   Job=backup-bareos-fd.2022-09-13_14.56.13_08 Date=13-Sep-2022 14:56:38 Level=F Type=B Files=163 Bytes=52,119,713 Errors=0 Status=T
13-Sep 14:56 bls JobId 0: End of Volume at file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Full-0001"
13-Sep 14:56 bls JobId 0: End of all volumes.
13-Sep 14:56 bls JobId 0: Releasing device "FileStorage" (/var/lib/bareos/storage).
```

Adding the **-v** option will display virtually all information that is available for each record.

#### Listing Blocks[](https://docs.bareos.org/Appendix/BareosPrograms.html#listing-blocks)

Normally, except for debugging purposes, you will not  need to list Bareos blocks (the “primitive” unit of Bareos data on the  Volume). However, you can do so with:

```
bls FileStorage -k -V Incremental-0002
bls: stored/butil.cc:304-0 Using device: "FileStorage" for reading.
13-Sep 15:00 bls JobId 0: Ready to read from volume "Incremental-0002" on device "FileStorage" (/var/lib/bareos/storage).
Block: 0 size=234
Block: 1 size=64512
Block: 2 size=64512
...
Block: 474 size=64512
Block: 475 size=53141
13-Sep 15:00 bls JobId 0: End of file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Incremental-0002"
13-Sep 15:00 bls JobId 0: Got EOM at file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Incremental-0002"
13-Sep 15:00 bls JobId 0: Releasing device "FileStorage" (/var/lib/bareos/storage).
End of File on device
```

By adding the **-v** option, you can get more information, which can be useful in knowing what sessions were written to the volume:

```
bls FileStorage -k -v -V Incremental-0002
bls: stored/butil.cc:304-0 Using device: "FileStorage" for reading.
13-Sep 15:00 bls JobId 0: Ready to read from volume "Incremental-0002" on device "FileStorage" (/var/lib/bareos/storage).
File:blk=0:233 blk_num=0 blen=234 First rec FI=VOL_LABEL SessId=3 SessTim=1663079882 Strm=0 rlen=198
File:blk=0:64745 blk_num=1 blen=64512 First rec FI=SOS_LABEL SessId=3 SessTim=1663079882 Strm=3 rlen=171
File:blk=0:129257 blk_num=2 blen=64512 First rec FI=7 SessId=3 SessTim=1663079882 Strm=DATA rlen=30338
File:blk=0:193769 blk_num=3 blen=64512 First rec FI=15 SessId=3 SessTim=1663079882 Strm=DATA rlen=3720
File:blk=0:258281 blk_num=4 blen=64512 First rec FI=16 SessId=3 SessTim=1663079882 Strm=DATA rlen=4920
File:blk=0:322793 blk_num=5 blen=64512 First rec FI=17 SessId=3 SessTim=1663079882 Strm=DATA rlen=61718
...
File:blk=0:30514409 blk_num=473 blen=64512 First rec FI=138 SessId=3 SessTim=1663079882 Strm=DATA rlen=33238
File:blk=0:30578921 blk_num=474 blen=64512 First rec FI=139 SessId=3 SessTim=1663079882 Strm=DATA rlen=34441
File:blk=0:30632062 blk_num=475 blen=53141 First rec FI=139 SessId=3 SessTim=1663079882 Strm=DATA rlen=21545
13-Sep 15:00 bls JobId 0: End of file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Incremental-0002"
13-Sep 15:00 bls JobId 0: Got EOM at file 0 on device "FileStorage" (/var/lib/bareos/storage), Volume "Incremental-0002"
13-Sep 15:00 bls JobId 0: Releasing device "FileStorage" (/var/lib/bareos/storage).
```

Armed with the SessionId and the SessionTime, you can extract just about anything.

If you want to know even more, add a second **-v** to the command line to get a dump of every record in every block.

```
bls -k -vv /var/lib/bareos/storage/Incremental-0002
bls: stored/butil.cc:304-0 Using device: "/var/lib/bareos/storage" for reading.
13-Sep 15:04 bls JobId 0: Ready to read from volume "Incremental-0002" on device "FileStorage" (/var/lib/bareos/storage).
bls: stored/block.cc:99-0 Dump block  24ac278: size=234 BlkNum=0
               Hdrcksum=2fce7bf9 cksum=2fce7bf9
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=VOL_LABEL Strm=0 len=198 p=24ae670
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=1659628785 Strm=64512 len=1 p=24ae742
bls: stored/block.cc:99-0 Dump block  24ac278: size=64512 BlkNum=1
               Hdrcksum=62ebecf1 cksum=62ebecf1
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=SOS_LABEL Strm=3 len=171 p=24ae670
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=1 Strm=UATTR len=96 p=24ae727
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=2 Strm=UATTR len=94 p=24ae793
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=3 Strm=UATTR len=88 p=24ae7fd
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=3 Strm=DATA len=1288 p=24ae861
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=3 Strm=MD5 len=16 p=24aed75
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=4 Strm=UATTR len=87 p=24aed91
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=4 Strm=DATA len=1671 p=24aedf4
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=4 Strm=MD5 len=16 p=24af487
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=5 Strm=UATTR len=92 p=24af4a3
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=5 Strm=DATA len=3075 p=24af50b
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=5 Strm=MD5 len=16 p=24b011a
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=6 Strm=UATTR len=88 p=24b0136
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=6 Strm=DATA len=22776 p=24b019a
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=6 Strm=MD5 len=16 p=24b5a9e
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=7 Strm=UATTR len=88 p=24b5aba
bls: stored/block.cc:112-0    Rec: VId=3 VT=1663079882 FI=7 Strm=DATA len=64944 p=24b5b1e
bls: stored/block.cc:99-0 Dump block  24ac278: size=64512 BlkNum=2
               Hdrcksum=ec9afd49 cksum=ec9afd49
...
```



### bextract[](https://docs.bareos.org/Appendix/BareosPrograms.html#bextract)

If you find yourself using **bextract**, you probably have done something wrong. For example, if you are trying  to recover a file but are having problems, please see the [Restoring When Things Go Wrong](https://docs.bareos.org/Appendix/Troubleshooting.html#section-restorecatalog) chapter.

Normally, you will restore files by running a Restore Job from the Console program. However, **bextract** can be used to extract a single file or a list of files from a Bareos tape or file. In fact, **bextract** can be a useful tool to restore files to an empty system assuming you are able to boot, you have statically linked **bextract** and you have an appropriate bootstrap file.

Please note that some of the current limitations of **bextract** are:

1. It cannot restore access control lists (ACL) that have been backed up along with the file data.
2. It cannot restore encrypted files.
3. The command line length is relatively limited, which means that  you cannot enter a huge number of volumes. If you need to enter more  volumes than the command line supports, please use a bootstrap file (see below).
4. Extracting files from a Windows backup on a Linux system will  only extract the plain files, not the additional Windows file  information. If you have to extract files from a Windows backup, you  should use the Windows version of **bextract**.

```
Usage: bextract [OPTIONS] bareos-archive-device-name target-directory

Positionals:
    bareos-archive-device-name  
        REQUIRED
        Specify the input device name (either as name of a Bareos Storage 
        Daemon Device resource or identical to the Archive Device in a Bareos 
        Storage Daemon Device resource). 

    target-directory  
        REQUIRED
        Specify directory where to store files. 


Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -b,--parse-bootstrap <file>:FILE
        Specify a bootstrap file. 

    -c,--config <path>:PATH(existing)
        Use <path> as configuration file or directory. 

    -D,--director <director>
        Specify a director name specified in the storage. Configuration file 
        for the Key Encryption Key selection. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -e,--exclude <file>
        Exclude list. 

    -i,--include-list <file>
        Include list. 

    -p,--ignore-errors
        Proceed inspite of IO errors. 

    -v,--verbose
        Default: 0
        Verbose user messages. 

    -V,--volumes <vol1|vol2|...>
        Volume names (separated by |). 
```

where bareos-archive-device-name is the Archive  Device (raw device name or full filename) of the device to be read, and  target-directory is a path prefix to prepend to all the files restored.

Warning

On Windows systems, if you specify a prefix of say d:/tmp, any file that would have been restored to `C:/My Documents` will be restored to `D:/tmp/My Documents`. That is, the original drive specification will be stripped. If no prefix is specified, the file will be restored to the original drive.

#### Extracting with Include or Exclude Lists[](https://docs.bareos.org/Appendix/BareosPrograms.html#extracting-with-include-or-exclude-lists)

Using the -e option, you can specify a file containing a list of  files to be excluded. Wildcards can be used in the exclusion list. This  option will normally be used in conjunction with the -i option (see  below). Both the -e and the -i options may be specified at the same time as the -b option. The bootstrap filters will be applied first, then the include list, then the exclude list.

Likewise, and probably more importantly, with the -i option, you can  specify a file that contains a list (one file per line) of files and  directories to include to be restored. The list must contain the full  filename with the path. If you specify a path name only, all files and  subdirectories of that path will be restored. If you specify a line  containing only the filename (e.g. my-file.txt) it probably will not be  extracted because you have not specified the full path.

For example, if the file include-list contains:

```
/etc/bareos
/usr/sbin
```

Then the command:

```
bextract -i include-list -V Volume /dev/nst0 /tmp
```

will restore from the Bareos archive /dev/nst0 all files and directories in  the backup from /etc/bareos and from /usr/sbin. The restored files will  be placed in a file of the original name under the directory /tmp (i.e.  /tmp/etc/bareos/… and /tmp/usr/sbin/…).

#### Extracting With a Bootstrap File[](https://docs.bareos.org/Appendix/BareosPrograms.html#extracting-with-a-bootstrap-file)

The -b option is used to specify a bootstrap file containing the  information needed to restore precisely the files you want. Specifying a bootstrap file is optional but recommended because it gives you the  most control over which files will be restored. For more details on the  bootstrap file, please see [Restoring Files with the Bootstrap File](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bootstrapchapter) chapter of this document. Note, you may also use a bootstrap file produced by the restore command. For example:

```
bextract -b bootstrap-file /dev/nst0 /tmp
```

The bootstrap file allows detailed specification of what files you want  restored (extracted). You may specify a bootstrap file and include  and/or exclude files at the same time. The bootstrap conditions will  first be applied, and then each file record seen will be compared to the include and exclude lists.

#### Extracting From Multiple Volumes[](https://docs.bareos.org/Appendix/BareosPrograms.html#extracting-from-multiple-volumes)

If you wish to extract files that span several Volumes, you can  specify the Volume names in the bootstrap file or you may specify the  Volume names on the command line by separating them with a vertical bar. See the section above under the bls program entitled Listing Multiple  Volumes for more information. The same techniques apply equally well to  the bextract program or read the [Bootstrap](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bootstrapchapter) chapter of this document.

#### Extracting Under Windows[](https://docs.bareos.org/Appendix/BareosPrograms.html#extracting-under-windows)

Warning

If you use **bextract** under Windows, the order of the parameters is essential.

To use **bextract**, the Bareos Storage  Daemon must be installed. As bextract works on tapes or disk volumes,  these must be configured in the Storage Daemon configuration file,  normally found at `C:\ProgrammData\Bareos\`. However, it is not required to start the Bareos Storage Daemon. Normally, if the Storage Daemon would be able to run, **bextract** would not be required.

After installing, **bextract** can be called via command line:

Call of bextract[](https://docs.bareos.org/Appendix/BareosPrograms.html#id18)

```
 .\bextract.exe -c "C:\ProgrammData\Bareos\" -V <Volume> <YourStorage> <YourDestination>
```

If you want to use exclude or include files you need to write  them like you do on Linux. That means each path begins with a “/” and  not with “yourdrive:/”. You need to specify the parameter -e  exclude.list as first parameter. For example:

Example exclude.list[](https://docs.bareos.org/Appendix/BareosPrograms.html#id19)

```
/Program Files/Bareos/bareos-dir.exe
/ProgramData/
```

Call bextract with exclude list[](https://docs.bareos.org/Appendix/BareosPrograms.html#id20)

```
 .\bextract.exe -e exclude.list -c "C:\ProgrammData\Bareos\" -V <Volume> <YourStorage> <YourDestination>
```



### bscan[](https://docs.bareos.org/Appendix/BareosPrograms.html#bscan)

If you find yourself using this program, you have  probably done something wrong. For example, the best way to recover a  lost or damaged Bareos database is to reload the database by using the  bootstrap file that was written when you saved it (default  Bareos-dir.conf file).

The bscan program can be used to re-create a database (catalog)  records from the backup information written to one or more Volumes. This is normally needed only if one or more Volumes have been pruned or  purged from your catalog so that the records on the Volume are no longer in the catalog, or for Volumes that you have archived. Note, if you  scan in Volumes that were previously purged, you will be able to do  restores from those Volumes. However, unless you modify the Job and File retention times for the Jobs that were added by scanning, the next time you run  any backup Job with the same name, the records will be pruned again.  Since it takes a long time to scan Volumes this can be very frustrating.

With some care, **bscan** can also be  used to synchronize your existing catalog with a Volume. Although we  have never seen a case of bscan damaging a catalog, since bscan modifies your catalog, we recommend that you do a simple ASCII backup of your  database before running **bscan** just to be sure.

**bscan** can also be useful in a  disaster recovery situation, after the loss of a hard disk, if you do  not have a valid bootstrap file for reloading your system, or if a  Volume has been recycled but not overwritten, you can use **bscan** to re-create your database, which can then be used to restore your system or a file to its previous state.

It is called:

```
Usage: bscan [OPTIONS] device_name

Positionals:
    device_name  
        REQUIRED
        Specify the input device name (either as name of a Bareos Storage 
        Daemon Device resource or identical to the Archive Device in a Bareos 
        Storage Daemon Device resource). 


Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -b,--parse-bootstrap <bootstrap>:FILE
        Specify a bootstrap file 

    -c,--config <path>:PATH(existing)
        Use <path> as configuration file or directory 

    -D,--director <director>
        Specify a director name specified in the storage. Configuration file 
        for the Key Encryption Key selection. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -n,--dbname <name>
        Default: bareos
        Specify database name. 

    -o,--dbhost <host>
        Specify database host. 

    -P,--dbpassword <password>
        Specify database password. 

    -t,--dbport <port>
        Specify database port. 

    -u,--dbuser <user>
        Default: bareos
        Specify database user name. 

    -m,--update-volume-info
        Update media info in database. 

    -p,--proceed-io
        Proceed inspite of IO errors 

    -r,--list-records
        List records. 

    -S,--show-progress
        Show scan progress periodically. 

    -s,--update-db
        Synchronize or store in database. 

    -V,--volumes <vol1|vol2|...>
        Specify volume names (separated by |). 

    -v,--verbose
        Default: 0
        Verbose user messages. 

    -w,--working-directory <directory>
        Specify working directory. 
```

If you have provided security on your database, you may need to supply either the database name (-b option), the user name  (-u option), and/or the password (-p) options.

NOTE: before **bscan** can work, it  needs at least a bare bones valid database. If your database exists but  some records are missing because they were pruned, then you are all set. If your database was lost or destroyed, then you must first ensure that you have PostgreSQL running, then you must create the Bareos database  (normally named bareos), and you must create the Bareos tables. This is  explained in [Prepare Bareos database](https://docs.bareos.org/IntroductionAndTutorial/InstallingBareos.html#section-createdatabase) chapter of the manual. Finally, before scanning into an empty database,  you must start and stop the Director with the appropriate  Bareos-dir.conf file so that it can create the Client and Storage  records which are not stored on the Volumes. Without these records,  scanning is unable to connect the Job records to the proper client.

Forgetting for the moment the extra complications of a full rebuild  of your catalog, let’s suppose that you did a backup to Volumes “Vol001” and “Vol002”, then sometime later all records of one or both those  Volumes were pruned or purged from the database. By using bscan you can  recreate the catalog entries for those Volumes and then use the restore  command in the Console to restore whatever you want. A command something like:

```
bscan -v -V Vol001|Vol002 /dev/nst0
```

will give you an idea of what is going to happen  without changing your catalog. Of course, you may need to change the  path to the Storage daemon’s conf file, the Volume name, and your tape  (or disk) device name. This command must read the entire tape, so if it  has a lot of data, it may take a long time, and thus you might want to  immediately use the command listed below. Note, if you are writing to a  disk file, replace the device name with the path to the directory that  contains the Volumes. This must correspond to the Archive Device in the conf file.

Then to actually write or store the records in the catalog, add the -s option as follows:

```
bscan -s -m -v -V Vol001|Vol002 /dev/nst0
```

When writing to the database, if **bscan** finds existing records, it will generally either update them if  something is wrong or leave them alone. Thus if the Volumes you are  scanning are all or partially in the catalog already, no harm will be  done to that existing data. Any missing data will simply be added.

If you have multiple tapes, you should scan them with:

```
bscan -s -m -v -V Vol001|Vol002|Vol003 /dev/nst0
```

Since there is a limit on the command line length (511 bytes) accepted by **bscan**, if you have too many Volumes, you will need to manually create a bootstrap file. See the [Bootstrap](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bootstrapchapter) chapter of this manual for more details, in particular the section entitled [Bootstrap for bscan](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bscanbootstrap). Basically, the .bsr file for the above example might look like:

```
Volume=Vol001
Volume=Vol002
Volume=Vol003
```

Note: **bscan** does  not support supplying Volume names on the command line and at the same  time in a bootstrap file. Please use only one or the other.

You should, always try to specify the tapes in the order they are  written. If you do not, any Jobs that span a volume may not be fully or  properly restored. However, bscan can handle scanning tapes that are not sequential. Any incomplete records at the end of the tape will simply  be ignored in that case. If you are simply repairing an existing  catalog, this may be OK, but if you are creating a new catalog from  scratch, it will leave your database in an incorrect state. If you do  not specify all necessary Volumes on a single bscan command, bscan will not be able to  correctly restore the records that span two volumes. In other words, it  is much better to specify two or three volumes on a single bscan command (or in a .bsr file) rather than run bscan two or three times, each with a single volume.

Note, the restoration process using bscan is not identical to the  original creation of the catalog data. This is because certain data such as Client records and other non-essential data such as volume reads,  volume mounts, etc is not stored on the Volume, and thus is not restored by bscan. The results of bscanning are, however, perfectly valid, and  will permit restoration of any or all the files in the catalog using the normal Bareos console commands. If you are starting with an empty  catalog and expecting bscan to reconstruct it, you may be a bit disappointed,  but at a minimum, you must ensure that your Bareos-dir.conf file is the  same as what it previously was – that is, it must contain all the  appropriate Client resources so that they will be recreated in your new  database before running bscan. Normally when the Director starts, it  will recreate any missing Client records in the catalog. Another problem you will have is that even if the Volumes (Media records) are recreated in the database, they will not have their autochanger status and slots properly set. As a result, you will need to repair that by using the **update slots** command. There may be other considerations as well. Rather than  bscanning, you should always attempt to recover you previous catalog  backup.

#### Using bscan to Compare a Volume to an existing Catalog[](https://docs.bareos.org/Appendix/BareosPrograms.html#using-bscan-to-compare-a-volume-to-an-existing-catalog)

If you wish to compare the contents of a Volume to an  existing catalog without changing the catalog, you can safely do so if  and only if you do not specify either the -m or the -s options. However, the comparison routines are not as good or as thorough as they should  be, so we don’t particularly recommend this mode other than for testing.

#### Using bscan to Recreate a Catalog from a Volume[](https://docs.bareos.org/Appendix/BareosPrograms.html#using-bscan-to-recreate-a-catalog-from-a-volume)

This is the mode for which bscan is most useful. You  can either bscan into a freshly created catalog, or directly into your  existing catalog (after having made an ASCII copy as described above).  Normally, you should start with a freshly created catalog that contains  no data.

Starting with a single Volume named TestVolume1, you run a command such as:

```
bscan -V TestVolume1 -v -s -m /dev/nst0
```

If there is more than one volume, simply  append it to the first one separating it with a vertical bar. You may  need to precede the vertical bar with a forward slash escape the shell – e.g. TestVolume1|TestVolume2. The -v option was added for verbose  output (this can be omitted if desired). The -s option that tells **bscan** to store information in the database. The physical device name /dev/nst0 is specified after all the options.

For example, after having done a full backup of a directory, then two incrementals, I reinitialized the catalog database as described above,  and using the bootstrap.bsr file noted above, I entered the following  command:

```
bscan -b bootstrap.bsr -v -s /dev/nst0
```

which produced the following output:

```
bscan: bscan.c:182 Using Database: Bareos, User: bacula
bscan: bscan.c:673 Created Pool record for Pool: Default
bscan: bscan.c:271 Pool type "Backup" is OK.
bscan: bscan.c:632 Created Media record for Volume: TestVolume1
bscan: bscan.c:298 Media type "DDS-4" is OK.
bscan: bscan.c:307 VOL_LABEL: OK for Volume: TestVolume1
bscan: bscan.c:693 Created Client record for Client: Rufus
bscan: bscan.c:769 Created new JobId=1 record for original JobId=2
bscan: bscan.c:717 Created FileSet record "Users Files"
bscan: bscan.c:819 Updated Job termination record for new JobId=1
bscan: bscan.c:905 Created JobMedia record JobId 1, MediaId 1
bscan: Got EOF on device /dev/nst0
bscan: bscan.c:693 Created Client record for Client: Rufus
bscan: bscan.c:769 Created new JobId=2 record for original JobId=3
bscan: bscan.c:708 Fileset "Users Files" already exists.
bscan: bscan.c:819 Updated Job termination record for new JobId=2
bscan: bscan.c:905 Created JobMedia record JobId 2, MediaId 1
bscan: Got EOF on device /dev/nst0
bscan: bscan.c:693 Created Client record for Client: Rufus
bscan: bscan.c:769 Created new JobId=3 record for original JobId=4
bscan: bscan.c:708 Fileset "Users Files" already exists.
bscan: bscan.c:819 Updated Job termination record for new JobId=3
bscan: bscan.c:905 Created JobMedia record JobId 3, MediaId 1
bscan: Got EOF on device /dev/nst0
bscan: bscan.c:652 Updated Media record at end of Volume: TestVolume1
bscan: bscan.c:428 End of Volume. VolFiles=3 VolBlocks=57 VolBytes=10,027,437
```

The key points to note are that bscan prints a line when each major record is created. Due to the volume of output, it does not print a line for each file record unless you supply the -v option  twice or more on the command line.

In the case of a Job record, the new JobId will not normally be the  same as the original Jobid. For example, for the first JobId above, the  new JobId is 1, but the original JobId is 2. This is nothing to be  concerned about as it is the normal nature of databases. bscan will keep everything straight.

Although **bscan** claims that it  created a Client record for Client: Rufus three times, it was actually  only created the first time. This is normal.

You will also notice that it read an end of file after each Job (Got  EOF on device …). Finally the last line gives the total statistics for  the bscan.

If you had added a second -v option to the command line, Bareos would have been even more verbose, dumping virtually all the details of each  Job record it encountered.

Now if you start Bareos and enter a **list jobs** command to the console program, you will get:

list jobs[](https://docs.bareos.org/Appendix/BareosPrograms.html#id21)

```
+-------+----------+------------------+------+-----+----------+----------+---------+
| JobId | Name     | StartTime        | Type | Lvl | JobFiles | JobBytes | JobStat |
+-------+----------+------------------+------+-----+----------+----------+---------+
| 1     | usersave | 2002-10-07 14:59 | B    | F   | 84       | 4180207  | T       |
| 2     | usersave | 2002-10-07 15:00 | B    | I   | 15       | 2170314  | T       |
| 3     | usersave | 2002-10-07 15:01 | B    | I   | 33       | 3662184  | T       |
+-------+----------+------------------+------+-----+----------+----------+---------+
```

which corresponds virtually identically with what the database contained  before it was re-initialized and restored with bscan. All the Jobs and  Files found on the tape are restored including most of the Media record. The Volume (Media) records restored will be marked as Full so that they cannot be rewritten without operator intervention.

It should be noted that **bscan** cannot restore a database to the exact condition it was in previously because a lot of the less important information contained in the database is not  saved to the tape. Nevertheless, the reconstruction is sufficiently  complete, that you can run restore against it and get valid results.

An interesting aspect of restoring a catalog backup using **bscan** is that the backup was made while Bareos was running and writing to a  tape. At the point the backup of the catalog is made, the tape Bareos is writing to will have say 10 files on it, but after the catalog backup  is made, there will be 11 files on the tape Bareos is writing. This  there is a difference between what is contained in the backed up catalog and what is actually on the tape. If after restoring a catalog, you attempt to write on the same tape that was used to backup  the catalog, Bareos will detect the difference in the number of files  registered in the catalog compared to what is on the tape, and will mark the tape in error.

There are two solutions to this problem. The first is possibly the  simplest and is to mark the volume as Used before doing any backups. The second is to manually correct the number of files listed in the Media  record of the catalog. This procedure is documented elsewhere in the  manual and involves using the **update volume** command in **bconsole**.

#### Using bscan to Correct the Volume File Count[](https://docs.bareos.org/Appendix/BareosPrograms.html#using-bscan-to-correct-the-volume-file-count)

If the Storage daemon crashes during a backup Job, the  catalog will not be properly updated for the Volume being used at the  time of the crash. This means that the Storage daemon will have written  say 20 files on the tape, but the catalog record for the Volume  indicates only 19 files.

Bareos refuses to write on a tape that contains a different number of files from what is in the catalog. To correct this situation, you may  run a bscan with the -m option (but without the -s option) to update  only the final Media record for the Volumes read.

#### After bscan[](https://docs.bareos.org/Appendix/BareosPrograms.html#after-bscan)

If you use bscan to enter the contents of the Volume  into an existing catalog, you should be aware that the records you  entered may be immediately pruned during the next job, particularly if  the Volume is very old or had been previously purged. To avoid this,  after running bscan, you can manually set the volume status (VolStatus)  to Read-Only by using the update command in the catalog. This will allow you to restore from the volume without having it immediately purged.  When you have restored and backed up the data, you can reset the VolStatus to Used and the Volume  will be purged from the catalog.

Limitation - bscan:  importing jobs with bscan may break the correct job chain order

The Start Of Session (SOS) record is a special record placed by the  Storage daemon on the storage medium as the first record of an append  session job with a File daemon. This record is needed for finding the beginning of a particular session  (Job), since no records with the same VolSessionId and VolSessionTime  will precede this record. This record is not normally visible outside of the Storage daemon. The Begin Session Label is similar to the Volume Label except that it  contains additional information pertaining to the Session.

Having just a single timestamp generated by the SD in the SOS record  is a limitation because there’s currently no way for bscan to be aware  of a jobs SchedTime, StartTime, EndTime, RealEndTime and JobTDate. Those values are required to keep the historical and correct order of a  CopyJob, a MigrationJob or a VirtualFull.

Due to this fact timestamps of a CopyJob, a MigrationJob or a  VirtualFull will always differ from the timestamp in the original  catalog after using bscan.

Please be aware that this can lead to serious problems when using the Always Incremental backup scheme for example.



### bcopy[](https://docs.bareos.org/Appendix/BareosPrograms.html#bcopy)

The **bcopy** program can  be used to copy one Bareos archive file to another. For example, you may copy a tape to a file, a file to a tape, a file to a file, or a tape to a tape. For tape to tape, you will need two tape drives. In the process of making the copy, no record of the information written to the new  Volume is stored in the catalog. This means that the new Volume, though  it contains valid backup data, cannot be accessed directly from existing catalog entries. If you wish to be able to use the Volume with the Console restore command, for  example, you must first command:bscan the new Volume into the catalog.

```
Usage: bcopy [OPTIONS] input-archive output-archive

Positionals:
    input-archive  
        REQUIRED
        Specify the input device name (either as name of a Bareos Storage 
        Daemon Device resource or identical to the Archive Device in a Bareos 
        Storage Daemon Device resource). 

    output-archive  
        REQUIRED
        Specify the output device name (either as name of a Bareos Storage 
        Daemon Device resource or identical to the Archive Device in a Bareos 
        Storage Daemon Device resource). 


Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -b,--parse-bootstrap <bootstrap>:FILE
        Specify a bootstrap file. 

    -c,--config <path>:PATH(existing)
        Use <path> as configuration file or directory. 

    -D,--director <director>
        Specify a director name specified in the storage. Configuration file 
        for the Key Encryption Key selection. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -i,--input-volumes <vol1|vol2|...>
        specify input Volume names (separated by |) 

    -o,--output-volumes <vol1|vol2|...>
        specify output Volume names (separated by |) 

    -p,--ignore-errors
        Proceed inspite of errors. 

    -v,--verbose
        Default: 0
        Verbose user messages. 

    -w,--working-directory <directory>
        Default: /tmp
        specify working directory. 
```

By using a bootstrap file, you can copy parts of a Bareos archive file to another archive.



### btape[](https://docs.bareos.org/Appendix/BareosPrograms.html#btape)

This program permits a number of elementary tape  operations via a tty command interface. It works only with tapes and not with other kinds of Bareos storage media (DVD, File, …). The test  command, described below, can be very useful for testing older tape  drive compatibility problems. Aside from initial testing of tape drive  compatibility with Bareos, command:btape will be mostly used by developers writing new tape drivers.

command:btape can be dangerous to use with existing  Bareos tapes because it will relabel a tape or write on the tape if so  requested regardless that the tape may contain valuable data, so please  be careful and use it only on blank tapes.

To work properly, **btape** needs to read the Storage daemon’s configuration.

The physical device name must be specified on the command line, and  this same device name must be present in the Storage daemon’s  configuration read by **btape**.

```
Usage: btape [OPTIONS] bareos-archive-device-name

Positionals:
    bareos-archive-device-name  
        REQUIRED
        Specify the input device name (either as name of a Bareos Storage 
        Daemon Device resource or identical to the Archive Device in a Bareos 
        Storage Daemon Device resource). 


Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -b,--parse-bootstrap <file>:FILE
        Specify a bootstrap file. 

    -c,--config <path>:PATH(existing)
        Specify a configuration file or directory. 

    -D,--director <director>
        Specify a director name specified in the storage. Configuration file 
        for the Key Encryption Key selection. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -p,--proceed-io
        Proceed inspite of IO errors 

    -s,--no-signals
        Turn off signals. 

    -v,--verbose
        Default: 0
        Verbose user messages. 

[Option Group: Interactive commands]
  Interactive commands:
    Command    Description
    =======    ===========
    autochanger test autochanger
    bsf        backspace file
    bsr        backspace record
    cap        list device capabilities
    clear      clear tape errors
    eod        go to end of Bareos data for append
    eom        go to the physical end of medium
    fill       fill tape, write onto second volume
    unfill     read filled tape
    fsf        forward space a file
    fsr        forward space a record
    help       print this command
    label      write a Bareos label to the tape
    load       load a tape
    quit       quit btape
    rawfill    use write() to fill tape
    readlabel  read and print the Bareos tape label
    rectest    test record handling functions
    rewind     rewind the tape
    scan       read() tape block by block to EOT and report
    scanblocks Bareos read block by block to EOT and report
    speed      [file_size=n(GB)|nb_file=3|skip_zero|skip_random|skip_raw|skip_block] report drive speed
    status     print tape status
    test       General test Bareos tape functions
    weof       write an EOF on the tape
    wr         write a single Bareos block
    rr         read a single record
    rb         read a single Bareos block
    qfill      quick fill command
  
```

#### Using btape to Verify your Tape Drive[](https://docs.bareos.org/Appendix/BareosPrograms.html#using-btape-to-verify-your-tape-drive)

An important reason for this program is to ensure that a Storage daemon configuration is defined so that Bareos will correctly  read and write tapes.

It is highly recommended that you run the test command before running your first Bareos job to ensure that the parameters you have defined  for your storage device (tape drive) will permit Bareos to function  properly. You only need to mount a blank tape, enter the command, and  the output should be reasonably self explanatory. Please see the [Tape Testing](https://docs.bareos.org/Appendix/Troubleshooting.html#tapetestingchapter) Chapter of this manual for the details.

#### btape Commands[](https://docs.bareos.org/Appendix/BareosPrograms.html#btape-commands)

The full list of commands are:

btape commands[](https://docs.bareos.org/Appendix/BareosPrograms.html#id22)

```
  Command     Description
  =======     ===========
  autochanger test autochanger
  bsf         backspace file
  bsr         backspace record
  cap         list device capabilities
  clear       clear tape errors
  eod         go to end of Bareos data for append
  eom         go to the physical end of medium
  fill        fill tape, write onto second volume
  unfill      read filled tape
  fsf         forward space a file
  fsr         forward space a record
  help        print this command
  label       write a Bareos label to the tape
  load        load a tape
  quit        quit btape
  rawfill     use write() to fill tape
  readlabel   read and print the Bareos tape label
  rectest     test record handling functions
  rewind      rewind the tape
  scan        read() tape block by block to EOT and report
  scanblocks  Bareos read block by block to EOT and report
  speed       report drive speed
  status      print tape status
  test        General test Bareos tape functions
  weof        write an EOF on the tape
  wr          write a single Bareos block
  rr          read a single record
  qfill       quick fill command
```

The most useful commands are:

- test – test writing records and EOF marks and reading them back.
- fill – completely fill a volume with records, then write a few  records on a second volume, and finally, both volumes will be read back. This command writes blocks containing random data, so your drive will  not be able to compress the data, and thus it is a good test of the real physical capacity of your tapes.
- readlabel – read and dump the label on a Bareos tape.
- cap – list the device capabilities and status.

The readlabel command can be used to display the details of a Bareos  tape label. This can be useful if the physical tape label was lost or  damaged.

In the event that you want to relabel a Bareos volume, you can simply use the label command which will write over any existing label.  However, please note for labeling tapes, we recommend that you use the  label command in the Console program since it will never overwrite a  valid Bareos tape.



##### Testing your Tape Drive Speed[](https://docs.bareos.org/Appendix/BareosPrograms.html#testing-your-tape-drive-speed)

To determine the best configuration of your tape drive, you can run the `speed` command available in the **btape** program.

This command can have the following arguments:

- `file_size` specify the file size for this test. This counter is in GB.
- `nb_file` specify the number of file to be written. The amount of data should be greater than your memory (`file_size` * `nb_file`).
- `skip_raw` flag permits to skip tests with raw access.
- `skip_block` flag permits to skip tests with Bareos block access.
- `skip_zero` flag permits to skip tests with constant data.
- `skip_random` flag permits to skip tests with random data.

btape speed[](https://docs.bareos.org/Appendix/BareosPrograms.html#id23)

```
su bareos -g bareos -G tape -s /bin/sh -c '/usr/sbin/btape Drive-0'

*speed file_size=3 skip_raw
btape.c:1078 Test with zero data and Bareos block structure.
btape.c:956 Begin writing 3 files of 3.221 GB with blocks of 129024 bytes.
++++++++++++++++++++++++++++++++++++++++++
btape.c:604 Wrote 1 EOF to "Drive-0" (/dev/nst0)
btape.c:406 Volume bytes=3.221 GB. Write rate = 44.128 MB/s
...
btape.c:383 Total Volume bytes=9.664 GB. Total Write rate = 43.531 MB/s

btape.c:1090 Test with random data, should give the minimum throughput.
btape.c:956 Begin writing 3 files of 3.221 GB with blocks of 129024 bytes.
+++++++++++++++++++++++++++++++++++++++++++
btape.c:604 Wrote 1 EOF to "Drive-0" (/dev/nst0)
btape.c:406 Volume bytes=3.221 GB. Write rate = 7.271 MB/s
+++++++++++++++++++++++++++++++++++++++++++
...
btape.c:383 Total Volume bytes=9.664 GB. Total Write rate = 7.365 MB/s
```

When using compression, the random test will give you the minimum throughput of your drive. The test using constant string will give you the maximum speed of your  hardware chain. (cpu, memory, scsi card, cable, drive, tape).

You can change the block size in the Storage Daemon configuration file. see [`Maximum Block Size (Sd->Device)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Device_MaximumBlockSize)



### bscrypto[](https://docs.bareos.org/Appendix/BareosPrograms.html#bscrypto)

**bscrypto** is used in the process of encrypting tapes (see also [LTO Hardware Encryption](https://docs.bareos.org/TasksAndConcepts/Plugins.html#ltohardwareencryptiongeneral)). The Bareos Storage Daemon and the btools (**bls**, **bextract**, **bscan**, **btape**, **bextract**) will use a so called Bareos Storage Daemon plugin to perform the  setting and clearing of the encryption keys. To bootstrap the encryption support and for populating things like the crypto cache with encryption keys of volumes  that you want to scan, you need to use the bscrypto tool. The bscrypto  tool has the following capabilities:

- Generate a new passphrase

  - to be used as a so called Key Encryption Key (KEK) for wrapping a passphrase using RFC3394 key wrapping with aes-wrap

    \- or -

  - for usage as a clear text encryption key loaded into the tape drive.

- Base64-encode a key if requested

- Generate a wrapped passphrase which performs the following steps:

  - generate a semi random clear text passphrase
  - wrap the passphrase using the Key Encryption Key using RFC3394
  - base64-encode the wrapped key (as the wrapped key is binary, we  always need to base64-encode it in order to be able to pass the data as  part of the director to storage daemon protocol

- show the content of a wrapped or unwrapped keyfile.

  This can be used to reveal the content of the  passphrase when a passphrase is stored in the database and you have the  urge to change the Key Encryption Key. Normally it is unwise to change  the Key Encryption Key, as this means that you have to redo all your  stored encryption keys, as they are stored in the database wrapped using the Key Encryption Key available in the config during the label phase  of the volume.

- Clear the crypto cache on the machine running the Bareos Storage  Daemon, which keeps a cache of used encryption keys, which can be used  when the Bareos Storage Daemon is restarted without the need to connect  to the Bareos Director to retrieve the encryption keys.

- Set the encryption key of the drive

- Clear the encryption key of the drive

- Show the encryption status of the drive

- Show the encryption status of the next block (e.g. volume)

- Populate the crypto cache with data

## Other Programs[](https://docs.bareos.org/Appendix/BareosPrograms.html#other-programs)

The following programs are general utility programs and in general do not need a configuration file nor a device name.



### bsmtp[](https://docs.bareos.org/Appendix/BareosPrograms.html#bsmtp)

**bsmtp** is a simple mail transport program that permits more flexibility than the standard mail  programs typically found on Unix systems. It can even be used on Windows machines.

It is called:

```
Usage: bsmtp [OPTIONS] recipients...

Positionals:
    recipients TEXT ...
        REQUIRED
        List of recipients. 


Options:
    --version
        Display program version information and exit 

    -?,--help
        Print this help message and exit. 

    -4,--ipv4-protocol
        Forces bsmtp to use IPv4 addresses only. 

    -6,--ipv6-protocol
        Forces bsmtp to use IPv6 addresses only. 

    -8,--utf8
        set charset to UTF-8. 

    -a,--any-protocol
        Use any ip protocol for address resolution. 

    -c,--copy-to TEXT
        Set the Cc: field. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -f,--from TEXT
        REQUIRED
        Set the From: field. 

    -h,--mailhost <mailhost/IPv4_address:port>,<[mailhost/IPv6_address]:port>
        Use mailhost:port as the SMTP server. 

    -s,--subject TEXT
        REQUIRED
        Set the Subject: field. 

    -r,--reply-to TEXT
        Set the Reply-To: field. 

    -l,--max-lines UINT
        Set the maximum number of lines to send. 
```

If the -f option is not specified, **bsmtp** will use your userid. If the option -h is not specified **bsmtp** will use the value in the environment variable SMTPSERVER or if there is none localhost. By default port 25 is used.

If a line count limit is set with the -l option, **bsmtp** will not send an email with a body text exceeding that number of lines. This is especially useful for large restore job reports where the list  of files restored might produce very long mails your mail-server would  refuse or crash. However, be aware that you will probably suppress the  job report and any error messages unless you check the log file written  by the Director (see the messages resource in this manual for details).

recipients is a space separated list of email recipients.

The body of the email message is read from standard input.

An example of the use of **bsmtp** would be to put the following statement in the [Messages resource](https://docs.bareos.org/Configuration/Messages.html#messageschapter) of your Bareos Director configuration.

bsmtp in Message resource[](https://docs.bareos.org/Appendix/BareosPrograms.html#id24)

```
Mail Command     = "bsmtp -h mail.example.com -f \"\(Bareos\) %r\" -s \"Bareos: %t %e of %c %l\" %r"
Operator Command = "bsmtp -h mail.example.com -f \"\(Bareos\) %r\" -s \"Bareos: Intervention needed for %j\" %r"
```

You have to replace  mail.example.com with the fully qualified name of your SMTP (email)  server, which normally listens on port 25. For more details on the  substitution characters (e.g. %r) used in the above line, please see the documentation of the [MailCommand in the Messages Resource](https://docs.bareos.org/Configuration/Messages.html#mailcommand) chapter of this manual.

It is HIGHLY recommended that you test one or two cases by hand to make sure that the mailhost that you specified is correct and that it will accept your email requests. Since command:bsmtp always uses a TCP connection rather than writing in the spool file, you may find that your from address is being rejected because it does not contain a valid domain, or  because your message is caught in your spam filtering rules. Generally,  you should specify a fully qualified domain name in the from field, and  depending on whether your bsmtp gateway is Exim or Sendmail, you may need to modify the syntax of the from part of the message. Please test.

When running **bsmtp** by hand, you will need to terminate the message by entering a ctrl-d in column 1 of the last line.

If you are getting incorrect dates (e.g. 1970) and you are running with a non-English language setting, you might try adding a **LANG=C** immediately before the **bsmtp** call.

In general, **bsmtp** attempts to cleanup email addresses that you specify in the from, copy, mailhost, and recipient fields, by adding the necessary < and > characters  around the address part. However, if you include a display-name (see RFC 5332), some SMTP servers such as Exchange may not accept the message if the display-name is also included in < and >. As mentioned above, you must test, and if you run into this situation, you may manually add the < and > to the Bareos [`Mail Command (Dir->Messages)`](https://docs.bareos.org/Configuration/Messages.html#config-Dir_Messages_MailCommand) or [`Operator Command (Dir->Messages)`](https://docs.bareos.org/Configuration/Messages.html#config-Dir_Messages_OperatorCommand) and when **bsmtp** is formatting an address if it already contains a < or > character, it will leave the address unchanged.



### bareos-dbcheck[](https://docs.bareos.org/Appendix/BareosPrograms.html#bareos-dbcheck)

**bareos-dbcheck** is a  simple program that will search for logical inconsistencies in the  Bareos tables in your database, and optionally fix them. It is a  database maintenance routine, in the sense that it can detect and remove unused rows, but it is not a database repair routine. To repair a  database, see the tools furnished by the database vendor. Normally **bareos-dbcheck** should never need to be run, but if Bareos has crashed or you have a  lot of Clients, Pools, or Jobs that you have removed, it could be  useful.

**bareos-dbcheck** is best started as the same user, as the Bareos Director is running, normally **bareos**. If you are **root** on Linux, use the following command to switch to user **bareos**:

Substitute user to bareos[](https://docs.bareos.org/Appendix/BareosPrograms.html#id25)

```
su -s /bin/bash - bareos
```

If not, problems of reading the Bareos configuration or accessing the database can arise.

**bareos-dbcheck** supports following command line options:

```
Usage: bareos-dbcheck [OPTIONS]

Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -c,--config <path>:PATH(existing)
        Use <path> as Director configuration filename or configuration 
        directory. 

    -B,--print-catalog
        Print catalog configuration and exit. 

    -b,--batch
        Batch mode. 

    -C,--catalog <catalog>
        Catalog name in the director configuration file. 

    -D,--driver TEXT
        Exists for backwards compatibility and is ignored. 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -f,--fix
        Fix inconsistencies. 

    -v,--verbose
        Default: 0
        Verbose user messages. 

[Option Group: Manual credentials]
  Setting database credentials manually. Can only be used when no configuration is given.
  Positionals:
      working_directory TEXT
          Path to working directory. 
      database_name TEXT
          Database name. 
      user TEXT
          Database user name. 
      password TEXT
          Database password. 
      host TEXT
          Database host. 
      port INT:POSITIVE
          Database port 
```

When using the default configuration paths, it is  not necessary to specify any options. Optionally, as Bareos supports  loading its database backend dynamically you may specify the right  database driver to use using the **-D** option.

If the **-B** option is specified, **bareos-dbcheck** will print out catalog information in a simple text based format:

```
bareos-dbcheck -B
catalog=MyCatalog
db_type=postgresql
db_name=bareos
db_driver=
db_user=bareos
db_password=
db_address=
db_port=0
db_socket=
```

If the **-c** option is given with the Bareos  Director configuration, there is no need to enter any of the command  line arguments, in particular the working directory as **bareos-dbcheck** will read them from the file.

If the **-f** option is specified, **bareos-dbcheck** will repair (fix) the inconsistencies it finds. Otherwise, it will report only.

If the **-b** option is specified, **bareos-dbcheck** will run in batch mode, and it will proceed to examine and fix (if **-f** is set) all programmed inconsistency checks. If the **-b** option is not specified, **bareos-dbcheck** will enter interactive mode and prompt with the following:

```
Hello, this is the Bareos database check/correct program.
Modify database is off. Verbose is off.
Please select the function you want to perform.
     0) Quit
     1) Toggle modify database flag
     2) Toggle verbose flag
     3) Check for bad Filename records
     4) Check for bad Path records
     5) Check for duplicate Path records
     6) Check for orphaned Jobmedia records
     7) Check for orphaned File records
     8) Check for orphaned Path records
     9) Check for orphaned FileSet records
    10) Check for orphaned Client records
    11) Check for orphaned Job records
    12) Check for orphaned storage records
    13) Check for all Admin records
    14) Check for all Restore records
    15) Run ALL checks
Select function number:
```

By entering 1 or 2, you can toggle the modify database flag (**-f** option) and the verbose flag (**-v**). It can be helpful and reassuring to turn off the modify database flag,  then select one or more of the consistency checks (items 3 through 13)  to see what will be done, then toggle the modify flag on and re-run the  check.

Since Bareos *Version >= 16.2.5*, when running **bareos-dbcheck** with **-b** and **-v**, it will not interactively ask if results should be printed or not. Instead, it does not print any detail results.

The inconsistencies examined are the following:

- Duplicate Filename records. This can happen if you accidentally  run two copies of Bareos at the same time, and they are both adding  filenames simultaneously. It is a rare occurrence, but will create an  inconsistent database. If this is the case, you will receive error  messages during Jobs warning of duplicate database records. If you are  not getting these error messages, there is no reason to run this check.

- Repair bad Filename records. This checks and corrects filenames that have a trailing slash. They should not.

- Repair bad Path records. This checks and corrects path names that do not have a trailing slash. They should.

- Duplicate Path records. This can happen if you accidentally run  two copies of Bareos at the same time, and they are both adding  filenames simultaneously. It is a rare occurrence, but will create an  inconsistent database. See the item above for why this occurs and how  you know it is happening.

- Orphaned JobMedia records. This happens when a Job record is  deleted (perhaps by a user issued SQL statement), but the corresponding  JobMedia record (one for each Volume used in the Job) was not deleted.  Normally, this should not happen, and even if it does, these records  generally do not take much space in your database. However, by running  this check, you can eliminate any such orphans.

- Orphaned File records. This happens when a Job record is deleted  (perhaps by a user issued SQL statement), but the corresponding File  record (one for each Volume used in the Job) was not deleted. Note,  searching for these records can be very time consuming (i.e. it may take hours) for a large database. Normally this should not happen as Bareos  takes care to prevent it. Just the same, this check can remove any  orphaned File records. It is recommended that you run this once a year  since orphaned File records can take a large amount of space in your database. You might want to ensure that you have indexes on JobId, FilenameId,  and PathId for the File table in your catalog before running this  command.

- Orphaned Path records. This condition happens any time a  directory is deleted from your system and all associated Job records  have been purged. During standard purging (or pruning) of Job records,  Bareos does not check for orphaned Path records. As a consequence, over a period of time, old unused Path records will tend to accumulate and use space in your database. This check will eliminate them. It is  recommended that you run this check at least once a year.

- Orphaned Filename records. This condition happens any time a file is deleted from your system and all associated Job records have been  purged. This can happen quite frequently as there are quite a large  number of files that are created and then deleted. In addition, if you  do a system update or delete an entire directory, there can be a very  large number of Filename records that remain in the catalog but are no  longer used.

  During standard purging (or pruning) of Job records, Bareos does not  check for orphaned Filename records. As a consequence, over a period of  time, old unused Filename records will accumulate and use space in your  database. This check will eliminate them. It is strongly recommended  that you run this check at least once a year, and for large database  (more than 200 Megabytes), it is probably better to run this once every 6 months.

- Orphaned Client records. These records can remain in the database long after you have removed a client.

- Orphaned Job records. If no client is defined for a job or you do not run a job for a long time, you can accumulate old job records. This option allow you to remove jobs that are not attached to any client  (and thus useless).

- Orphaned storage records. If you delete a storage configuration  file from the bareos configurations folder, you end up with unused  storages in the database that can cause certain visual inconsistencies.  This option allows you to delete these orphaned storages, but you have  to make sure first that they are not used by any Media or Device.

- All Admin records. This command will remove all Admin records, regardless of their age.

- All Restore records. This command will remove all Restore records, regardless of their age.

If you are using bvfs (e.g. used by [bareos-webui](https://docs.bareos.org/IntroductionAndTutorial/BareosWebui.html#section-webui)), don’t eliminate orphaned path, else you will have to rebuild `brestore_pathvisibility` and `brestore_pathhierarchy` indexes.

Normally you should never need to run **bareos-dbcheck** in spite of the recommendations given above, which are given so that users don’t waste their time running **bareos-dbcheck** too often.



### bregex[](https://docs.bareos.org/Appendix/BareosPrograms.html#bregex)

**bregex** is a simple  program that will allow you to test regular expressions against a file  of data. This can be useful because the regex libraries on most systems  differ, and in addition, regex expressions can be complicated.

To run it, use:

```
Usage: bregex [OPTIONS]

Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -f,--filename TEXT
        REQUIRED
        Specify file or data to be matched. 

    -l,--suppress-linenumbers
        Suppress line numbers. 

    -n,--not-match
        Print line that do not match. 
```

The  <data-file> is a filename that contains lines of data to be  matched (or not) against one or more patterns. When the program is run,  it will prompt you for a regular expression pattern, then apply it one  line at a time against the data in the file. Each line that matches will be printed preceded by its line number. You will then be prompted again for another pattern.

Enter an empty line for a pattern to terminate the program. You can  print only lines that do not match by using the -n option, and you can  suppress printing of line numbers with the -l option.

This program can be useful for testing regex expressions to be applied against a list of filenames.



### bwild[](https://docs.bareos.org/Appendix/BareosPrograms.html#bwild)

**bwild** is a simple program that will allow you to test wild-card expressions against a file of data.

To run it, use:

```
Usage: bwild [OPTIONS]

Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -d,--debug-level <level>
        Set debug level to <level>. 

    --dt,--debug-timestamps
        Print timestamps in debug output. 

    -f,--filename TEXT
        REQUIRED
        Specify file or data to be matched. 

    -i,--ignore-case
        Use case insensitive match. 

    -l,--suppress-linenumbers
        Suppress line numbers. 

    -n,--not-match
        Print line that do not match. 
```

The <data-file> is a filename that contains lines of data to be matched (or not)  against one or more patterns. When the program is run, it will prompt  you for a wild-card pattern, then apply it one line at a time against  the data in the file. Each line that matches will be printed preceded by its line number. You will then be prompted again for another pattern.

Enter an empty line for a pattern to terminate the program. You can  print only lines that do not match by using the -n option, and you can  suppress printing of line numbers with the -l option.

This program can be useful for testing wild expressions to be applied against a list of filenames.



### bpluginfo[](https://docs.bareos.org/Appendix/BareosPrograms.html#bpluginfo)

The main purpose of bpluginfo is to display different  information about Bareos plugin. You can use it to check a plugin name,  author, license and short description. You can use -f option to display  API implemented by the plugin. Some plugins may require additional ’-a’  option for val- idating a Bareos Daemons API. In most cases it is not  required.

To run it, use:

```
Usage: bpluginfo [OPTIONS] plugin_file.so

Positionals:
    plugin_file.so TEXT
        REQUIRED
        Plugin file. 


Options:
    -h,-?,--help
        Print this help message and exit. 

    --version
        Display program version information and exit 

    -a,--api <api>:NONNEGATIVE
        bareos api version (default :1). 

    -f,--list-functions
        list plugin functions information only. 

    -i,--list-headers
        list plugin header information only. 

    -v,--verbose
        Verbose. 
```

​        

# The Bootstrap File[](https://docs.bareos.org/Appendix/TheBootstrapFile.html#the-bootstrap-file)

 

The information in this chapter is provided so that you may either  create your own bootstrap files, or so that you can edit a bootstrap  file produced by Bareos. However, normally the bootstrap file will be  automatically created for you during the **restore** in the Console program, or by using a [`Write Bootstrap (Dir->Job)`](https://docs.bareos.org/Configuration/Director.html#config-Dir_Job_WriteBootstrap) record in your Backup Jobs, and thus you will never need to know the details of this file.

The bootstrap file contains ASCII information that permits precise  specification of what files should be restored, what volume they are on, and where they are on the volume. It is a relatively compact form of  specifying the information, is human readable, and can be edited with  any text editor.

## Bootstrap File Format[](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bootstrap-file-format)



The general format of a bootstrap file is:

<keyword>= <value>

Where each keyword and the value specify which files to restore. More precisely the keyword and their values serve to limit which files will  be restored and thus act as a filter. The absence of a keyword means  that all records will be accepted.

Blank lines and lines beginning with a pound sign (#) in the bootstrap file are ignored.

There are keywords which permit filtering by Volume, Client, Job, FileIndex, Session Id, Session Time, …

The more keywords that are specified, the more selective the  specification of which files to restore will be. In fact, each keyword  is ANDed with other keywords that may be present.

For example,

```
Volume = Test-001
VolSessionId = 1
VolSessionTime = 108927638
```

directs the Storage daemon (or the  bextract program) to restore only those files on Volume Test-001 AND  having VolumeSessionId equal to one AND having VolumeSession time equal  to 108927638.

The full set of permitted keywords presented in the order in which they are matched against the Volume records are:

- Volume

   The  value field specifies what Volume the following commands apply to. Each  Volume specification becomes the current Volume, to which all the  following commands apply until a new current Volume (if any) is  specified. If the Volume name contains spaces, it should be enclosed in  quotes. At lease one Volume specification is required.

- Count

   The value is the total number of files that will be restored for this Volume.  This allows the Storage daemon to know when to stop reading the Volume.  This value is optional.

- VolFile

   The  value is a file number, a list of file numbers, or a range of file  numbers to match on the current Volume. The file number represents the  physical file on the Volume where the data is stored. For a tape volume, this record is used to position to the correct starting file, and once  the tape is past the last specified file, reading will stop.

- VolBlock

   The  value is a block number, a list of block numbers, or a range of block  numbers to match on the current Volume. The block number represents the  physical block within the file on the Volume where the data is stored.

- VolSessionTime

   The value specifies a Volume Session Time to be matched from the current volume.

- VolSessionId

    The value specifies a VolSessionId, a list of volume session ids, or a  range of volume session ids to be matched from the current Volume. Each  VolSessionId and VolSessionTime pair corresponds to a unique Job that is backed up on the Volume.

- JobId

   The  value specifies a JobId, list of JobIds, or range of JobIds to be  selected from the current Volume. Note, the JobId may not be unique if  you have multiple Directors, or if you have reinitialized your database. The JobId filter works only if you do not run multiple simultaneous  jobs. This value is optional and not used by Bareos to restore files.

- Job

   The value  specifies a Job name or list of Job names to be matched on the current  Volume. The Job corresponds to a unique VolSessionId and VolSessionTime  pair. However, the Job is perhaps a bit more readable by humans.  Standard regular expressions (wildcards) may be used to match Job names. The Job filter works only if you do not run multiple simultaneous jobs. This value is optional and not used by Bareos to restore files.

- Client

   The  value specifies a Client name or list of Clients to will be matched on  the current Volume. Standard regular expressions (wildcards) may be used to match Client names. The Client filter works only if you do not run  multiple simultaneous jobs. This value is optional and not used by  Bareos to restore files.

- FileIndex

   The  value specifies a FileIndex, list of FileIndexes, or range of  FileIndexes to be selected from the current Volume. Each file (data)  stored on a Volume within a Session has a unique FileIndex. For each  Session, the first file written is assigned FileIndex equal to one and  incremented for each file backed up. This for a given Volume, the triple VolSessionId, VolSessionTime, and FileIndex uniquely identifies a file stored on the Volume. Multiple  copies of the same file may be stored on the same Volume, but for each  file, the triple VolSessionId, VolSessionTime, and FileIndex will be  unique. This triple is stored in the Catalog database for each file. To restore a particular file, this value (or a range of FileIndexes) is required.

- FileRegex

   The value is a regular expression. When specified, only matching filenames will be restored. `FileRegex=^/etc/passwd(.old)? `

- Slot

   The value specifies the autochanger slot. There may be only a single Slot specification for each Volume.

- Stream

   The  value specifies a Stream, a list of Streams, or a range of Streams to be selected from the current Volume. Unless you really know what you are  doing (the internals of Bareos), you should avoid this specification.  This value is optional and not used by Bareos to restore files.

The Volume record is a bit special in that it must be the first  record. The other keyword records may appear in any order and any number following a Volume record.

Multiple Volume records may be specified in the same bootstrap file,  but each one starts a new set of filter criteria for the Volume.

In processing the bootstrap file within the current Volume, each filter specified by a keyword is ANDed with the next. Thus,

```
Volume = Test-01
Client = "My machine"
FileIndex = 1
```

will match records on Volume Test-01 AND Client records for My machine AND FileIndex equal to one.

Multiple occurrences of the same record are ORed together. Thus,

```
Volume = Test-01
Client = "My machine"
Client = "Backup machine"
FileIndex = 1
```

will match records on Volume Test-01 AND (Client records for My machine OR Backup machine) AND FileIndex equal to one.

For integer values, you may supply a range or a list, and for all  other values except Volumes, you may specify a list. A list is  equivalent to multiple records of the same keyword. For example,

```
Volume = Test-01
Client = "My machine", "Backup machine"
FileIndex = 1-20, 35
```

will match records on Volume Test-01 AND (Client  records for My machine OR Backup machine) AND (FileIndex 1 OR 2 OR 3 …  OR 20 OR 35).

As previously mentioned above, there may be multiple Volume records  in the same bootstrap file. Each new Volume definition begins a new set  of filter conditions that apply to that Volume and will be ORed with any other Volume definitions.

As an example, suppose we query for the current set of tapes to  restore all files on Client Rufus using the query command in the console program:

```
Using default Catalog name=MyCatalog DB=bareos
*query
Available queries:
     1: List Job totals:
     2: List where a file is saved:
     3: List where the most recent copies of a file are saved:
     4: List total files/bytes by Job:
     5: List total files/bytes by Volume:
     6: List last 10 Full Backups for a Client:
     7: List Volumes used by selected JobId:
     8: List Volumes to Restore All Files:
Choose a query (1-8): 8
Enter Client Name: Rufus
+-------+------------------+------------+-----------+----------+------------+
| JobId | StartTime        | VolumeName | StartFile | VolSesId | VolSesTime |
+-------+------------------+------------+-----------+----------+------------+
| 154   | 2002-05-30 12:08 | test-02    | 0         | 1        | 1022753312 |
| 202   | 2002-06-15 10:16 | test-02    | 0         | 2        | 1024128917 |
| 203   | 2002-06-15 11:12 | test-02    | 3         | 1        | 1024132350 |
| 204   | 2002-06-18 08:11 | test-02    | 4         | 1        | 1024380678 |
+-------+------------------+------------+-----------+----------+------------+
```

The output shows us that there are four Jobs that  must be restored. The first one is a Full backup, and the following  three are all Incremental backups.

The following bootstrap file will restore those files:

```
Volume=test-02
VolSessionId=1
VolSessionTime=1022753312
Volume=test-02
VolSessionId=2
VolSessionTime=1024128917
Volume=test-02
VolSessionId=1
VolSessionTime=1024132350
Volume=test-02
VolSessionId=1
VolSessionTime=1024380678
```

As a final example, assume that the initial Full save spanned two Volumes. The output from query might look like:

```
+-------+------------------+------------+-----------+----------+------------+
| JobId | StartTime        | VolumeName | StartFile | VolSesId | VolSesTime |
+-------+------------------+------------+-----------+----------+------------+
| 242   | 2002-06-25 16:50 | File0003   | 0         | 1        | 1025016612 |
| 242   | 2002-06-25 16:50 | File0004   | 0         | 1        | 1025016612 |
| 243   | 2002-06-25 16:52 | File0005   | 0         | 2        | 1025016612 |
| 246   | 2002-06-25 19:19 | File0006   | 0         | 2        | 1025025494 |
+-------+------------------+------------+-----------+----------+------------+
```

and the following bootstrap file would restore those files:

```
Volume=File0003
VolSessionId=1
VolSessionTime=1025016612
Volume=File0004
VolSessionId=1
VolSessionTime=1025016612
Volume=File0005
VolSessionId=2
VolSessionTime=1025016612
Volume=File0006
VolSessionId=2
VolSessionTime=1025025494
```

## Automatic Generation of Bootstrap Files[](https://docs.bareos.org/Appendix/TheBootstrapFile.html#automatic-generation-of-bootstrap-files)

 

One thing that is probably worth knowing: the bootstrap files that  are generated automatically at the end of the job are not as optimized  as those generated by the restore command. This is because during  Incremental and Differential jobs, the records pertaining to the files  written for the Job are appended to the end of the bootstrap file. As  consequence, all the files saved to an Incremental or Differential job  will be restored first by the Full save, then by any Incremental or  Differential saves.

When the bootstrap file is generated for the restore command, only one copy (the most recent) of each file is restored.

So if you have spare cycles on your machine, you could optimize the bootstrap files by doing the following:

```
bconsole
restore client=xxx select all
done
no
quit
Backup bootstrap file.
```

The above will not work if you have multiple FileSets because that will be  an extra prompt. However, the restore client=xxx select all builds the  in-memory tree, selecting everything and creates the bootstrap file.

The no answers the Do you want to run this (yes/mod/no) question.

## Bootstrap for bscan[](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bootstrap-for-bscan)

   

If you have a very large number of Volumes to  scan with bscan, you may exceed the command line limit (511 characters). In that case, you can create a simple bootstrap file that consists of  only the volume names. An example might be:

```
Volume="Vol001"
Volume="Vol002"
Volume="Vol003"
Volume="Vol004"
Volume="Vol005"
```

## Bootstrap Example[](https://docs.bareos.org/Appendix/TheBootstrapFile.html#bootstrap-example)

 

If you want to extract or copy a single Job, you can do it by  selecting by JobId (code not tested) or better yet, if you know the  VolSessionTime and the VolSessionId (printed on Job report and in  Catalog), specifying this is by far the best. Using the VolSessionTime  and VolSessionId is the way Bareos does restores. A bsr file might look  like the following:

```
Volume="Vol001"
VolSessionId=10
VolSessionTime=1080847820
```

If you know how many files are backed up (on the  job report), you can enormously speed up the selection by adding (let’s  assume there are 157 files):

```
FileIndex=1-157
Count=157
```

Finally, if you know the File number where the Job  starts, you can also cause bcopy to forward space to the right file  without reading every record:

```
VolFile=20
```

There is nothing magic or complicated about a BSR  file. Parsing it and properly applying it within Bareos *is* magic, but  you don’t need to worry about that.

If you want to see a *real* bsr file, simply fire up the restore  command in the console program, select something, then answer no when it prompts to run the job. Then look at the file restore.bsr in your  working directory.

# Verify File Integrity with Bareos[](https://docs.bareos.org/Appendix/VerifyFileIntegrityWithBareos.html#verify-file-integrity-with-bareos)

 

Since Bareos maintains a catalog of files, their attributes, and  either SHA1 or MD5 signatures, it can be an ideal tool for improving  computer security. This is done by making a snapshot of your system  files with a Verify Job and then checking the current state of your  system against the snapshot, on a regular basis (e.g. nightly).

The first step is to set up a Verify Job and to run it with:

```
Level = InitCatalog
```

The InitCatalog level tells Bareos simply to get  the information on the specified files and to put it into the catalog.  That is your database is initialized and no comparison is done. The  InitCatalog is normally run one time manually.

Thereafter, you will run a Verify Job on a daily (or whatever) basis with:

```
Level = Catalog
```

The Level = Catalog level tells Bareos to compare  the current state of the files on the Client to the last InitCatalog  that is stored in the catalog and to report any differences. See the  example below for the format of the output.

You decide what files you want to form your “snapshot” by specifying  them in a FileSet resource, and normally, they will be system files that do not change, or that only certain features change.

Then you decide what attributes of each file you want compared by  specifying comparison options on the Include statements that you use in  the FileSet resource of your Catalog Jobs.

## The Details[](https://docs.bareos.org/Appendix/VerifyFileIntegrityWithBareos.html#the-details)



In the discussion that follows, we will make reference to the Verify  Configuration Example that is included below in the A Verify  Configuration Example section. You might want to look it over now to get an idea of what it does.

The main elements consist of adding a schedule, which will normally  be run daily, or perhaps more often. This is provided by the VerifyCycle Schedule, which runs at 5:05 in the morning every day.

Then you must define a Job, much as is done below. We recommend that  the Job name contain the name of your machine as well as the word Verify or Check. In our example, we named it MatouVerify. This will permit you to easily identify your job when running it from the Console.

You will notice that most records of the Job are quite standard, but  that the FileSet resource contains verify=pins1 option in addition to  the standard signature=SHA1 option. If you don’t want SHA1 signature  comparison, and we cannot imagine why not, you can drop the  signature=SHA1 and none will be computed nor stored in the catalog. Or  alternatively, you can use verify=pins5 and signature=MD5, which will  use the MD5 hash algorithm. The MD5 hash computes faster than SHA1, but  is cryptographically less secure.

The verify=pins1 is ignored during the InitCatalog Job, but is used  during the subsequent Catalog Jobs to specify what attributes of the  files should be compared to those found in the catalog. pins1 is a  reasonable set to begin with, but you may want to look at the details of these and other options. They can be found in the [FileSet Resource](https://docs.bareos.org/Configuration/Director.html#directorresourcefileset) section of this manual. Briefly, however, the p of the pins1 tells  Verify to compare the permissions bits, the i is to compare inodes, the n causes comparison of the number of links, the s  compares the file size, and the 1 compares the SHA1 checksums (this  requires the signature=SHA1 option to have been set also).

You must also specify the Client and the Catalog resources for your  Verify job, but you probably already have them created for your client  and do not need to recreate them, they are included in the example below for completeness.

As mentioned above, you will need to have a FileSet resource for the  Verify job, which will have the additional verify=pins1 option. You will want to take some care in defining the list of files to be included in  your FileSet. Basically, you will want to include all system (or other)  files that should not change on your system. If you select files, such  as log files or mail files, which are constantly changing, your  automatic Verify job will be constantly finding differences. The  objective in forming the FileSet is to choose all unchanging important system files.  Then if any of those files has changed, you will be notified, and you  can determine if it changed because you loaded a new package, or because someone has broken into your computer and modified your files. The  example below shows a list of files that I use on my Red Hat 7.3 system. Since I didn’t spend a lot of time working on it, it probably is  missing a few important files (if you find one, please send it to me).  On the other hand, as long as I don’t load any new packages, none of these  files change during normal operation of the system.

## Running the Verify[](https://docs.bareos.org/Appendix/VerifyFileIntegrityWithBareos.html#running-the-verify)



The first thing you will want to do is to run an InitCatalog level  Verify Job. This will initialize the catalog to contain the file  information that will later be used as a basis for comparisons with the  actual file system, thus allowing you to detect any changes (and  possible intrusions into your system).

The easiest way to run the InitCatalog is manually with the console  program by simply entering run. You will be presented with a list of  Jobs that can be run, and you will choose the one that corresponds to  your Verify Job, MatouVerify in this example.

```
The defined Job resources are:
     1: MatouVerify
     2: usersrestore
     3: Filetest
     4: usersave
Select Job resource (1-4): 1
```

Next, the console program will show you the basic parameters of the Job and ask you:

```
Run Verify job
JobName:  MatouVerify
FileSet:  Verify Set
Level:    Catalog
Client:   MatouVerify
Storage:  DLTDrive
Verify Job:
Verify List: /tmp/regress/working/MatouVerify.bsr
OK to run? (yes/mod/no): mod
```

Here, you want to respond mod to modify the  parameters because the Level is by default set to Catalog and we want to run an InitCatalog Job. After responding mod, the console will ask:

```
Parameters to modify:
     1: Level
     2: Storage
     3: Job
     4: FileSet
     5: Client
     6: When
     7: Priority
     8: Pool
     9: Verify Job
Select parameter to modify (1-5): 1
```

you should select number 2 to modify the Level, and it will display:

```
Levels:
     1: Initialize Catalog
     2: Verify Catalog
     3: Verify Volume to Catalog
     4: Verify Disk to Catalog
     5: Verify Volume Data (not yet implemented)
Select level (1-4): 1
```

Choose item 1, and you will see the final display:

```
Run Verify job
JobName:  MatouVerify
FileSet:  Verify Set
Level:    Initcatalog
Client:   MatouVerify
Storage:  DLTDrive
Verify Job:
Verify List: /tmp/regress/working/MatouVerify.bsr
OK to run? (yes/mod/no): yes
```

at which point you respond yes, and the Job will begin.

Thereafter the Job will automatically start according to the schedule you have defined. If you wish to immediately verify it, you can simply  run a Verify Catalog which will be the default. No differences should be found.

To use a previous job, you can add `jobid=xxx` option in run command line. It will run the Verify job against the specified job.

```
*run jobid=1 job=MatouVerify
Run Verify job
JobName:     MatouVerify
Level:       Catalog
Client:      127.0.0.1-fd
FileSet:     Full Set
Pool:        Default (From Job resource)
Storage:     File (From Job resource)
Verify Job:  MatouVerify.2010-09-08_15.33.33_03
Verify List: /tmp/regress/working/MatouVerify.bsr
When:        2010-09-08 15:35:32
Priority:    10
OK to run? (yes/mod/no):
```

## What To Do When Differences Are Found[](https://docs.bareos.org/Appendix/VerifyFileIntegrityWithBareos.html#what-to-do-when-differences-are-found)



If you have setup your messages correctly, you should be notified if  there are any differences and exactly what they are. For example, below  is the email received after doing an update of OpenSSH:

```
HeadMan: Start Verify JobId 83 Job=RufusVerify.2002-06-25.21:41:05
HeadMan: Verifying against Init JobId 70 run 2002-06-21 18:58:51
HeadMan: File: /etc/pam.d/sshd
HeadMan:       st_ino   differ. Cat: 4674b File: 46765
HeadMan: File: /etc/rc.d/init.d/sshd
HeadMan:       st_ino   differ. Cat: 56230 File: 56231
HeadMan: File: /etc/ssh/ssh_config
HeadMan:       st_ino   differ. Cat: 81317 File: 8131b
HeadMan:       st_size  differ. Cat: 1202 File: 1297
HeadMan:       SHA1 differs.
HeadMan: File: /etc/ssh/sshd_config
HeadMan:       st_ino   differ. Cat: 81398 File: 81325
HeadMan:       st_size  differ. Cat: 1182 File: 1579
HeadMan:       SHA1 differs.
HeadMan: File: /etc/ssh/ssh_config.rpmnew
HeadMan:       st_ino   differ. Cat: 812dd File: 812b3
HeadMan:       st_size  differ. Cat: 1167 File: 1114
HeadMan:       SHA1 differs.
HeadMan: File: /etc/ssh/sshd_config.rpmnew
HeadMan:       st_ino   differ. Cat: 81397 File: 812dd
HeadMan:       st_size  differ. Cat: 2528 File: 2407
HeadMan:       SHA1 differs.
HeadMan: File: /etc/ssh/moduli
HeadMan:       st_ino   differ. Cat: 812b3 File: 812ab
HeadMan: File: /usr/bin/scp
HeadMan:       st_ino   differ. Cat: 5e07e File: 5e343
HeadMan:       st_size  differ. Cat: 26728 File: 26952
HeadMan:       SHA1 differs.
HeadMan: File: /usr/bin/ssh-keygen
HeadMan:       st_ino   differ. Cat: 5df1d File: 5e07e
HeadMan:       st_size  differ. Cat: 80488 File: 84648
HeadMan:       SHA1 differs.
HeadMan: File: /usr/bin/sftp
HeadMan:       st_ino   differ. Cat: 5e2e8 File: 5df1d
HeadMan:       st_size  differ. Cat: 46952 File: 46984
HeadMan:       SHA1 differs.
HeadMan: File: /usr/bin/slogin
HeadMan:       st_ino   differ. Cat: 5e359 File: 5e2e8
HeadMan: File: /usr/bin/ssh
HeadMan:       st_mode  differ. Cat: 89ed File: 81ed
HeadMan:       st_ino   differ. Cat: 5e35a File: 5e359
HeadMan:       st_size  differ. Cat: 219932 File: 234440
HeadMan:       SHA1 differs.
HeadMan: File: /usr/bin/ssh-add
HeadMan:       st_ino   differ. Cat: 5e35b File: 5e35a
HeadMan:       st_size  differ. Cat: 76328 File: 81448
HeadMan:       SHA1 differs.
HeadMan: File: /usr/bin/ssh-agent
HeadMan:       st_ino   differ. Cat: 5e35c File: 5e35b
HeadMan:       st_size  differ. Cat: 43208 File: 47368
HeadMan:       SHA1 differs.
HeadMan: File: /usr/bin/ssh-keyscan
HeadMan:       st_ino   differ. Cat: 5e35d File: 5e96a
HeadMan:       st_size  differ. Cat: 139272 File: 151560
HeadMan:       SHA1 differs.
HeadMan: 25-Jun-2002 21:41
JobId:                  83
Job:                    RufusVerify.2002-06-25.21:41:05
FileSet:                Verify Set
Verify Level:           Catalog
Client:                 RufusVerify
Start time:             25-Jun-2002 21:41
End time:               25-Jun-2002 21:41
Files Examined:         4,258
Termination:            Verify Differences
```

At this point, it was obvious that these files were modified during  installation of the RPMs. If you want to be super safe, you should run a Verify Level=Catalog immediately before installing new software to  verify that there are no differences, then run a Verify  Level=InitCatalog immediately after the installation.

To keep the above email from being sent every night when the Verify  Job runs, we simply re-run the Verify Job setting the level to  InitCatalog (as we did above in the very beginning). This will  re-establish the current state of the system as your new basis for  future comparisons. Take care that you don’t do an InitCatalog after  someone has placed a Trojan horse on your system!

If you have included in your FileSet a file that is changed by the  normal operation of your system, you will get false matches, and you  will need to modify the FileSet to exclude that file (or not to Include  it), and then re-run the InitCatalog.

The FileSet that is shown below is what I use on my Red Hat 7.3  system. With a bit more thought, you can probably add quite a number of  additional files that should be monitored.

## A Verify Configuration Example[](https://docs.bareos.org/Appendix/VerifyFileIntegrityWithBareos.html#a-verify-configuration-example)



```
Schedule {
  Name = "VerifyCycle"
  Run = Level=Catalog sun-sat at 5:05
}
Job {
  Name = "MatouVerify"
  Type = Verify
  Level = Catalog                     # default level
  Client = MatouVerify
  FileSet = "Verify Set"
  Messages = Standard
  Storage = DLTDrive
  Pool = Default
  Schedule = "VerifyCycle"
}
#
# The list of files in this FileSet should be carefully
# chosen. This is a good starting point.
#
FileSet {
  Name = "Verify Set"
  Include {
    Options {
      verify=pins1
      signature=SHA1
    }
    File = /boot
    File = /bin
    File = /sbin
    File = /usr/bin
    File = /lib
    File = /root/.ssh
    File = /home/user/.ssh
    File = /var/named
    File = /etc/sysconfig
    File = /etc/ssh
    File = /etc/security
    File = /etc/exports
    File = /etc/rc.d/init.d
    File = /etc/sendmail.cf
    File = /etc/sysctl.conf
    File = /etc/services
    File = /etc/xinetd.d
    File = /etc/hosts.allow
    File = /etc/hosts.deny
    File = /etc/hosts
    File = /etc/modules.conf
    File = /etc/named.conf
    File = /etc/pam.d
    File = /etc/resolv.conf
  }
  Exclude = { }
}
Client {
  Name = MatouVerify
  Address = lmatou
  Catalog = Bareos
  Password = ""
  File Retention = 80d                # 80 days
  Job Retention = 1y                  # one year
  AutoPrune = yes                     # Prune expired Jobs/Files
}
Catalog {
  Name = Bareos
  dbname = verify; user = bareos; password = ""
}
```

# Catalog Tables[](https://docs.bareos.org/Appendix/CatalogTables.html#catalog-tables)



Bareos stores its information in a database, named Catalog. It is configured by [Catalog Resource](https://docs.bareos.org/Configuration/Director.html#directorresourcecatalog).

## Job[](https://docs.bareos.org/Appendix/CatalogTables.html#job)

 

### JobStatus[](https://docs.bareos.org/Appendix/CatalogTables.html#jobstatus)

 

The status of a Bareos job is stored as abbreviation in the Catalog  database table Job. It is also displayed by some bconsole commands, eg. **list jobs**.

This table lists the abbreviations together with its description and  weight. The weight is used, when multiple states are applicable for a  job. In this case, only the status with the highest weight/priority is  applied.

| **Abbr.** | **Description**                 | **Weight** |
| --------- | ------------------------------- | ---------- |
| C         | Created, not yet running        | 15         |
| R         | Running                         | 15         |
| B         | Blocked                         | 15         |
| T         | Completed successfully          | 10         |
| E         | Terminated with errors          | 25         |
| e         | Non-fatal error                 | 20         |
| f         | Fatal error                     | 100        |
| D         | Verify found differences        | 15         |
| A         | Canceled by user                | 90         |
| I         | Incomplete job                  | 15         |
| L         | Committing data                 | 15         |
| W         | Terminated with warnings        | 20         |
| l         | Doing data despooling           | 15         |
| q         | Queued waiting for device       | 15         |
| F         | Waiting for Client              | 15         |
| S         | Waiting for Storage daemon      | 15         |
| m         | Waiting for new media           | 15         |
| M         | Waiting for media mount         | 15         |
| s         | Waiting for storage resource    | 15         |
| j         | Waiting for job resource        | 15         |
| c         | Waiting for client resource     | 15         |
| d         | Waiting on maximum jobs         | 15         |
| t         | Waiting on start time           | 15         |
| p         | Waiting on higher priority jobs | 15         |
| i         | Doing batch insert file records | 15         |
| a         | SD despooling attributes        | 15         |

# Checkpoints[](https://docs.bareos.org/Appendix/Checkpoints.html#checkpoints)

Usually, the information about files backed up by a job are stored into the database at the end of a **successful** job. This results in failed or cancelled jobs not having any file  information. You cannot recover the data from these jobs via the usual restore  procedure. Especially for very long running jobs with many files, this  fact is unsatisfactory. To avoid this problem, we introduced the Checkpoints feature.

Checkpoints are a way to save the progress of a backup while it is running.

When a checkpoint is executed, the files that were successfully  stored in the media at that point in time will be updated in the catalog database.

Checkpoints happen after a certain amount of time set by the user using the [`Checkpoint Interval (Sd->Storage)`](https://docs.bareos.org/Configuration/StorageDaemon.html#config-Sd_Storage_CheckpointInterval) directive. When the interval is too high and the backup job fails, the files that  have been backed up since the last Checkpoint will be missing in the  catalog. On the other hand, updating the catalog too often will create a higher  load on the system and might reduce the backup performance and clutter  debug messages. For that reason, we suggest to start with a value of 15 minutes. A  reasonable range is between 1 and 30 minutes.

Checkpoints also happen on volume changes. This means that when a  volume is full, or the backup has to switch to writing to another volume for some other reason, a checkpoint is triggered saving what has been  written to that volume.

Based on the Checkpoints Feature, a resume of cancelled or broken Backupjobs is conceivable in the future.

The checkpoints feature is **disabled by default**.

Enabling/disabling the timed checkpoints means enabling/disabling the checkpoints on volume changes too.

Warning

As the functionality of Checkpoints does not make sense with how  spooling works, checkpoints are not executed on jobs using spooling,  even if the checkpoints are enabled.