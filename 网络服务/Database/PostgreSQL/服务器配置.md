## 服务器配置

**目录**

- [20.1. 设置参数](http://www.postgres.cn/docs/14/config-setting.html)

  [20.1.1. 参数名称和值](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-SETTING-NAMES-VALUES)[20.1.2. 通过配置文件影响参数](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-SETTING-CONFIGURATION-FILE)[20.1.3. 通过SQL影响参数](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-SETTING-SQL-COMMAND-INTERACTION)[20.1.4. 通过 Shell 影响参数](http://www.postgres.cn/docs/14/config-setting.html#id-1.6.7.4.5)[20.1.5. 管理配置文件内容](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-INCLUDES)

- [20.2. 文件位置](http://www.postgres.cn/docs/14/runtime-config-file-locations.html)

- [20.3. 连接和认证](http://www.postgres.cn/docs/14/runtime-config-connection.html)

  [20.3.1. 连接设置](http://www.postgres.cn/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-SETTINGS)[20.3.2. 安全和认证](http://www.postgres.cn/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-AUTHENTICATION)[20.3.3. SSL](http://www.postgres.cn/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-SSL)

- [20.4. 资源消耗](http://www.postgres.cn/docs/14/runtime-config-resource.html)

  [20.4.1. 内存](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-MEMORY)[20.4.2. 磁盘](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-DISK)[20.4.3. 内核资源使用](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-KERNEL)[20.4.4. 基于代价的清理延迟](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST)[20.4.5. 后台写入器](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER)[20.4.6. 异步行为](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR)

- [20.5. 预写式日志](http://www.postgres.cn/docs/14/runtime-config-wal.html)

  [20.5.1. 设置](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS)[20.5.2. 检查点](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-CHECKPOINTS)[20.5.3. 归档](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING)[20.5.4. 归档恢复](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY)[20.5.5. 恢复目标](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET)

- [20.6. 复制](http://www.postgres.cn/docs/14/runtime-config-replication.html)

  [20.6.1. 发送服务器](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SENDER)[20.6.2. 主服务器](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-PRIMARY)[20.6.3. 后备服务器](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-STANDBY)[20.6.4. 订阅者](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SUBSCRIBER)

- [20.7. 查询规划](http://www.postgres.cn/docs/14/runtime-config-query.html)

  [20.7.1. 规划器方法配制](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE)[20.7.2. 规划器代价常量](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS)[20.7.3. 遗传查询优化](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO)[20.7.4. 其他规划器选项](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-OTHER)

- [20.8. 错误报告和日志](http://www.postgres.cn/docs/14/runtime-config-logging.html)

  [20.8.1. 在哪里做日志](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHERE)[20.8.2. 什么时候记录日志](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHEN)[20.8.3. 记录什么到日志](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHAT)[20.8.4. 使用 CSV 格式的日志输出](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-CSVLOG)[20.8.5. 进程标题](http://www.postgres.cn/docs/14/runtime-config-logging.html#id-1.6.7.11.7)

- [20.9. 运行时统计数据](http://www.postgres.cn/docs/14/runtime-config-statistics.html)

  [20.9.1. 查询和索引统计收集器](http://www.postgres.cn/docs/14/runtime-config-statistics.html#RUNTIME-CONFIG-STATISTICS-COLLECTOR)[20.9.2. 统计监控](http://www.postgres.cn/docs/14/runtime-config-statistics.html#RUNTIME-CONFIG-STATISTICS-MONITOR)

- [20.10. 自动清理](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html)

- [20.11. 客户端连接默认值](http://www.postgres.cn/docs/14/runtime-config-client.html)

  [20.11.1. 语句行为](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-STATEMENT)[20.11.2. 区域和格式化](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-FORMAT)[20.11.3. 共享库预载入](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-PRELOAD)[20.11.4. 其他默认值](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-OTHER)

- [20.12. 锁管理](http://www.postgres.cn/docs/14/runtime-config-locks.html)

- [20.13. 版本和平台兼容性](http://www.postgres.cn/docs/14/runtime-config-compatible.html)

  [20.13.1. 以前的 PostgreSQL 版本](http://www.postgres.cn/docs/14/runtime-config-compatible.html#RUNTIME-CONFIG-COMPATIBLE-VERSION)[20.13.2. 平台和客户端兼容性](http://www.postgres.cn/docs/14/runtime-config-compatible.html#RUNTIME-CONFIG-COMPATIBLE-CLIENTS)

- [20.14. 错误处理](http://www.postgres.cn/docs/14/runtime-config-error-handling.html)

- [20.15. 预置选项](http://www.postgres.cn/docs/14/runtime-config-preset.html)

- [20.16. 自定义选项](http://www.postgres.cn/docs/14/runtime-config-custom.html)

- [20.17. 开发者选项](http://www.postgres.cn/docs/14/runtime-config-developer.html)

- [20.18. 短选项](http://www.postgres.cn/docs/14/runtime-config-short.html)



   有很多配置参数可以影响数据库系统的行为。本章的第一节中我们将描述一下如何与配置参数交互。   后续的小节将详细地讨论每一个参数。  

## 设置参数

- [20.1.1. 参数名称和值](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-SETTING-NAMES-VALUES)
- [20.1.2. 通过配置文件影响参数](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-SETTING-CONFIGURATION-FILE)
- [20.1.3. 通过SQL影响参数](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-SETTING-SQL-COMMAND-INTERACTION)
- [20.1.4. 通过 Shell 影响参数](http://www.postgres.cn/docs/14/config-setting.html#id-1.6.7.4.5)
- [20.1.5. 管理配置文件内容](http://www.postgres.cn/docs/14/config-setting.html#CONFIG-INCLUDES)

### 20.1.1. 参数名称和值

​     所有参数名都是大小写不敏感的。每个参数都可以接受五种类型之一的值： 布尔、字符串、整数、     浮点数或枚举。该类型决定了设置该参数的语法：    

- ​       *布尔:*       值可以被写成       `on`,       `off`,       `true`,       `false`,       `yes`,       `no`,       `1`,       `0`       （都是大小写不敏感的）或者这些值的任何无歧义前缀。      

- ​       *字符串:*       通常值被包括在单引号内，值内部的任何单引号都需要被双写。不过，如果值是一个简单数字或者       标识符，引号通常可以被省略。       (与 SQL 关键字匹配的值需要在某些上下文中引用。)	        

- ​       *数字（整数和浮点）:*       数字参数可以规定为惯用的整数和浮点格式；如果参数为整数类型，则小数值四舍五入到最接近的整数。       证书参数还接受十六进制输入(以`0x`开头)和十进制输入(以`0`开头)，但是这些格式不能有小数。       不能使用千位分隔符。引号是不是必需的，除了十六进制输入。        

- ​       *带单位的数字:*       一些数字参数具有隐含单位，因为它们描述内存或时间量。单位可能是字节、千字节、块（通常是 8KB）、 毫秒、秒或分钟。这些设置之一的一个未修饰的数字值将使用该设置的默认单位，默认单位可以通       过引用`pg_settings`.`unit`来找到。为了方便，也可以       显式地指定一个不同的单位，例如时间值可以是`'120 ms'`，并且它们将被转换到参数的实际单位。要使用这个特性，注意值必须被写成一个字符       串（带有引号）。单位名称是大小写敏感的，并且在数字值和单位之间可以有空白。        

  - ​          可用的内存单位是`B`（字节）、`kB`（千字节）、`MB`（兆字节）和`GB`（吉字节）。内存单位的乘数是 1024 而不是 1000。         
  - ​          可用的时间单位是          `us` (微秒),          `ms` (毫秒),          `s`（秒）、`min`（分钟）、          `h`（小时）和`d`（天）。         

  ​       如果一个单位指定了小数值，如果有下一个较小的单元，它将四舍五入为下一个较小单位的倍数。       例如，`30.1 GB`将被转换为`30822 MB`而不是`32319628902 B`。       如果参数为整数类型，则在进行任何单位转换之后，最后四舍五入到整数。      

- ​       *枚举:*       枚举类型的参数以与字符串参数相同的方式指定，但被限制到一组有限的值。 这样一个参数可用的值可以在`pg_settings`.`enumvals`       中找到。枚举参数值是大小写无关的。      

### 20.1.2. 通过配置文件影响参数

​     设置这些参数最基本的方法是编辑`postgresql.conf`文件， 它通常被保存在数据目录中（当数据库集簇目录被初始化时，一个默认的拷贝将会被安装在那里）。一个该文件的例子看起来是：

```
# This is a comment
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB
```

​     每一行指定一个参数。名称和值之间的等号是可选的。空白是无意义的（除了在一个引号引用的参数值内）并且空行被忽略。井号（`#`）指示该行的剩余部分是一个注释。非简单标识符或者数字的参数值必须用单引号包围。要在参数值里嵌入单引号， 要么写两个单引号（首选）或者在引号前放反斜线。     如果文件包含相同参数的多个条目，则忽略除最后一个之外的所有条目。    

​     以这种方式设定的参数为集簇提供了默认值。除非这些设置被覆盖，活动会话看到的就是这些设置。     下面的小节描述了管理员或用户覆盖这些默认值的方法。    

​          主服务器进程每次收到SIGHUP信号（最简单的方法是从命令行运行`pg_ctl reload`或调用 SQL 函数`pg_reload_conf()`来发送这个信号）后都会重新读取这个配置     文件。主服务器进程还会把这个信号传播给所有正在运行的服务器进程，这样现有的会话也能采用新     值（要等待它们完成当前正在执行的客户端命令之后才会发生）。另外，你可以直接向一个单一服务     器进程发送该信号。有些参数只能在服务器启动时设置，在配置文件中对这些条目的修改将被忽略，     直到下次服务器重启。配置文件中的非法参数设置也会在SIGHUP处理过程中被     忽略（但是会记录日志）。    

​     除`postgresql.conf`之外，PostgreSQL     数据目录还包含一个文件`postgresql.auto.conf`，     它具有和`postgresql.conf`相同的格式但是原自动编辑，而不是手工编辑。     这个文件保存了通过[`ALTER SYSTEM`](http://www.postgres.cn/docs/14/sql-altersystem.html)命令提供的设置。     每当`postgresql.conf`被读取时这个文件会被自动读取，并且它的设置会以同样的方式生效。     `postgresql.auto.conf`中的设置会覆盖`postgresql.conf`中的设置。    

​     外部工具也可以修改 `postgresql.auto.conf`.     不建议在服务器运行时执行此操作，因为并发的 `ALTER SYSTEM` 可能会覆盖这些更改。     这些工具可能只是简单地在末尾附加新的设置，或者它们可能删除重复的设置和/或注释(就像 `ALTER SYSTEM` )。    

​     系统视图[`pg_file_settings`](http://www.postgres.cn/docs/14/view-pg-file-settings.html)     可以有助于对配置文件中的更改进行提前测试，或者在SIGHUP     信号没有达到预期效果时用来诊断问题。    

### 20.1.3. 通过SQL影响参数

​      PostgreSQL提供了三个SQL命令来建立配置默认值。      已经提到过的`ALTER SYSTEM`命令提供了一种改变全局默认值的从SQL可      访问的方法；它在功效上等效于编辑`postgresql.conf`。此外，还有两个命令      可以针对每个数据库或者每个角色设置默认值：     

- ​       [`ALTER DATABASE`](http://www.postgres.cn/docs/14/sql-alterdatabase.html)命令允许针对一个数据库覆盖其全局设置。      
- ​       [`ALTER ROLE`](http://www.postgres.cn/docs/14/sql-alterrole.html)命令允许用用户指定的值来覆盖全局设置和数据库设置。      

​      只有当开始一个新的数据库会话时，用`ALTER DATABASE`和      `ALTER ROLE`设置的值才会被应用。它们会覆盖从配置文件或服务器命令行      获得的值，并且作为该会话后续的默认值。注意某些设置在服务器启动后不能被更改，并且因此      不能被这些命令（或者下文列举的命令）设置。    

​      一旦一个客户端连接到数据库，PostgreSQL会提供两个额外的SQL命令（      以及等效的函数）用以影响会话本地的配置设置：    

- ​      [`SHOW`](http://www.postgres.cn/docs/14/sql-show.html)命令允许察看任何参数的当前值。对应的SQL函数是      `current_setting(setting_name text)` (参见 [第 9.27.1 节](http://www.postgres.cn/docs/14/functions-admin.html#FUNCTIONS-ADMIN-SET))。     
- ​       [`SET`](http://www.postgres.cn/docs/14/sql-set.html)命令允许修改对于一个会话可以本地设置的参数的当前值，它对其他会话没有影响。       对应的SQL函数是 `set_config(setting_name, new_value, is_local)` (参见 [第 9.27.1 节](http://www.postgres.cn/docs/14/functions-admin.html#FUNCTIONS-ADMIN-SET))。      

​     此外，系统视图[`pg_settings`](http://www.postgres.cn/docs/14/view-pg-settings.html)可以被用来查看和改变     会话本地的值：    

- ​       查询这个视图与使用`SHOW ALL`相似，但是可以提供更多细节。它也更加灵活，       因为可以为它指定过滤条件或者把它与其他关系进行连接。      

- ​       在这个视图上使用`UPDATE`并且指定更新`setting`       列，其效果等同于发出`SET`命令。例如，下面的命令

  ```
  SET configuration_parameter TO DEFAULT;
  ```

  ​       等效于：

  ```
  UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';
  ```

  ​      

### 20.1.4. 通过 Shell 影响参数

​      除了在数据库或者角色层面上设置全局默认值或者进行覆盖，你还可以通过 shell 工具把设置      传递给PostgreSQL。服务器和libpq      客户端库都能通过 shell 接受参数值。     

- ​       在服务器启动期间，可以通过`-c`命令行参数把参数设置传递给       `postgres`命令。例如：

  ```
  postgres -c log_connections=yes -c log_destination='syslog'
  ```

  ​       这种方式提供的设置会覆盖通过`postgresql.conf`或者       `ALTER SYSTEM`提供的设置，因此除了重启服务器之外无法从全局上改变它们。     

- ​      当通过libpq启动一个客户端会话时，可以使用`PGOPTIONS`      环境变量指定参数设置。这种方式建立的设置构成了会话生存期间的默认值，但是不会影响      其他的会话。由于历史原因，`PGOPTIONS`的格式和启动      `postgres`命令时用到的相似，特别是`-c`标志必须被指定。      例如：

  ```
  env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql
  ```

  ​     

  ​      通过 shell 或者其他方式，其他客户端和库可能提供它们自己的机制，以便允许用户在不直接      使用SQL命令的前提下修改会话设置。     

### 20.1.5. 管理配置文件内容

​      PostgreSQL提供了一些特性用于把复杂的      `postgresql.conf`文件分解成子文件。在管理多个具有相关但不完全相同      配置的服务器时，这些特性特别有用。     

​            除了单个参数设置，`postgresql.conf`文件可以包含*包括指令*，它指定要读入和处理的另一个文件，就好像该文件被插入到配置文件的这个点。这个特性允许一个配置文件被划分成物理上独立的部分。包括指令看起来像：

```
include 'filename'
```

​      如果文件名不是一个绝对路径，它将作为包含引用配置文件的目录的相对位置。包括可以被嵌套。     

​            也有一个`include_if_exists`指令，它的作用和`include`指令一样，不过当被引用的文件不存在或者无法被读取时其行为不同。一个通常的`include`将认为这是一个错误情况，而`include_if_exists`仅仅记录一个消息并且继续处理引用配置文件。     

​              `postgresql.conf`文件也可以包含`include_dir`指令，它指定要被包含的配置文件的一整个目录。它的用法类似： 

```
 include_dir 'directory'
 
```

​        非绝对目录名被当做包含引用配置文件的目录的相对路径。在该指定目录中，只有以后缀名        `.conf`结尾的非目录文件才会被包括。以`.`        字符开头的文件名也会被忽略，因为在某些平台上它们是隐藏文件。一个包括目录中的多个文件        被以文件名顺序处理（根据 C 区域规则排序，即数字在字母之前并且大写字母在小写字母        之前）。     

​      包括文件或目录可以被用来在逻辑上分隔数据库配置的各个部分，而不是用一个很大的`postgresql.conf`文件。      考虑一个有两台数据库服务器的公司，每一个都有不同的内存量。      很可能配置的元素都会被共享，例如用于日志的参数。但是两者关于内存的参数将会不同。      并且还可能会有服务器相关的自定义。      一种管理这类情况的方法是将你的站点的自定义配置修改分成三个文件。      你可以把下面的内容加入到你的`postgresql.conf`文件末尾来包括它们：

```
include 'shared.conf'
include 'memory.conf'
include 'server.conf'
```

​      所有的系统将会有相同的`shared.conf`。      每个有特定内存量的服务器可以共享相同的`memory.conf`。      你可能对所有 8GB 内存的服务器有一个，而对那些 16GB 内存的服务器有另一个。      并且最后`server.conf`可以装有真正服务器相关的配置信息。     

​      另一中可能性是创建一个配置文件目录并把这个信息放到其中的文件里。      例如，一个`conf.d`目录可以在`postgresql.conf`的末尾被引用：

```
include_dir 'conf.d'
```

​      然后你可以这样命名`conf.d`目录中的文件：

```
00shared.conf
01memory.conf
02server.conf
```

​      这种命名习惯建立了这些文件将被载入的清晰顺序。这是很重要的，因为在服务器读取配置      文件时，对于一个特定的参数只有最后碰到的一个设置才会被使用。在这个例子中，      `conf.d/02server.conf`设置的东西将会覆盖在      `conf.d/01memory.conf`中相同参数的值。     

​       你还可以使用这种配置目录方法，在命名文件时更有描述性：

```
00shared.conf
01memory-8GB.conf
02server-foo.conf
```

​       这种形式的安排为每个配置文件变体给定了一个唯一的名称。当多个服务器把它们的配置全部存储在一个位置（例如在一个版本控制仓库中）时，这可以帮助消除歧义（在版本控制下存储数据库配置文件是另一个值得考虑的好方法）。     

## 文件位置

​      除了已经提到过的`postgresql.conf`文件之外，PostgreSQL还使用另外两个手工编辑的配置文件，它们控制客户端认证（其使用在[第 21 章](http://www.postgres.cn/docs/14/client-authentication.html)中讨论）。默认情况下，所有三个配置文件都存放在数据库集簇的数据目录中。 本节描述的参数允许配置文件放在别的地方（这么做可以简化管理，特别是如果配置文件被独立放置，可以很容易保证它得到恰当的备份）。     

- `data_directory` (`string`)            

  ​         指定用于数据存储的目录。这个选项只能在服务器启动时设置。       

- `config_file` (`string`)            

  ​         指定主服务器配置文件（通常叫`postgresql.conf`）。这个参数只能在`postgres`命令行上设置。       

- `hba_file` (`string`)            

  ​         指定基于主机认证配置文件（通常叫`pg_hba.conf`）。这个参数只能在服务器启动的时候设置。       

- `ident_file` (`string`)            

  ​         指定用于用户名称映射的配置文件（通常叫`pg_ident.conf`）。这个参数只能在服务器启动的时候设置。另见[第 21.2 节](http://www.postgres.cn/docs/14/auth-username-maps.html)。       

- `external_pid_file` (`string`)            

  ​        指定可被服务器创建的用于管理程序的额外进程 ID（PID）文件。这个参数只能在服务器启动的时候设置。       

​      在默认安装中不会显式设置以上参数。相反，命令行参数`-D`或者环境变量`PGDATA`指定数据目录，并且上述配置文件都能在数据目录中找到。     

​      如果你想把配置文件放在别的地方而不是数据目录中，那么`postgres` `-D`命令行选项或者环境变量`PGDATA`必须指向包含配置文件的目录，并且`postgresql.conf`中（或者命令行上）的`data_directory`参数必须显示数据目录实际存放的地方。请注意，`data_directory`将覆盖`-D`和`PGDATA`指定的数据目录位置，但是不覆盖配置文件的位置。     

​      如果你愿意，可以使用选项`config_file`、`hba_file`和/或`ident_file`单独指定配置文件名称和位置。`config_file`只能在`postgres`命令行上指定，但是其他文件可以在主配置文件中设置。如果所有三个参数外加`data_directory`被显式地设置，则不必指定`-D`或`PGDATA`。     

​      在设置任何这些参数时，相对路径将被解释为相对于`postgres`启动路径的路径。     

##  连接和认证

- [20.3.1. 连接设置](http://www.postgres.cn/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-SETTINGS)
- [20.3.2. 安全和认证](http://www.postgres.cn/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-AUTHENTICATION)
- [20.3.3. SSL](http://www.postgres.cn/docs/14/runtime-config-connection.html#RUNTIME-CONFIG-CONNECTION-SSL)

### 20.3.1. 连接设置

- `listen_addresses` (`string`)            

  ​         指定服务器在哪些 TCP/IP 地址上监听客户端连接。值的形式是一个逗号分隔的主机名和/或数字 IP 地址列表。特殊项`*`对应所有可用 IP 接口。项`0.0.0.0`允许监听所有 IPv4 地址并且`::`允许监听所有 IPv6 地址。如果列表为空，服务器将根本不会监听任何 IP 接口，在这种情况中只能使用 Unix 域套接字来连接它。默认值是localhost，它只允许建立本地 TCP/IP “环回”连接。虽然客户端认证（[第 21 章](http://www.postgres.cn/docs/14/client-authentication.html)）允许细粒度地控制谁能访问服务器，`listen_addresses`控制哪些接口接受连接尝试，这能帮助在不安全网络接口上阻止重复的恶意连接请求。这个参数只能在服务器启动时设置。       

- `port` (`integer`)            

  ​        服务器监听的 TCP 端口；默认是 5432 。请注意服务器会同一个端口号监听所有的 IP 地址。这个参数只能在服务器启动时设置。       

- `max_connections` (`integer`)            

  ​        决定数据库的最大并发连接数。默认值通常是 100 个连接，但是如果内核设置不支持（initdb时决定），可能会比这个 数少。这个参数只能在服务器启动时设置。               当运行一个后备服务器时，你必须设置这个参数等于或大于主服务器上的参数。        否则，后备服务器上可能无法允许查询。       

- `superuser_reserved_connections`      (`integer`)            

  ​        决定为PostgreSQL超级用户连接而保留的连接“槽”数。 同时活跃的并发连接最多[max_connections](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-MAX-CONNECTIONS)个。任何时候，活跃的并发连接数最多为`max_connections`减去 `superuser_reserved_connections`，新连接就只能由超级用户发起了，并且不会有新的复制连接被接受。               默认值是 3 连接 。这个值必须小于`max_connections`。 这个参数只能在服务器启动时设置。       

- `unix_socket_directories` (`string`)            

  ​        指定服务器用于监听来自客户端应用的连接的 Unix 域套接字目录。通过列出用逗号分隔的多个目录可以建立多个套接字。        项之间的空白被忽略，如果你需要在名字中包括空白或逗号，在目录名周围放上双引号。        一个空值指定在任何 Unix 域套接字上都不监听，在这种情况中只能使用 TCP/IP 套接字来连接到服务器。               以`@`开头的值指定将要在抽象命名空间中创建Unix-domain套接字(当前在Linux和Windows上支持)。        在这种情况下，该值不指定“directory”，而是指定一个前缀，实际的套接字名称以与文件系统名称空间相同的方式从该前缀计算。        虽然抽象套接字名称前缀可以自由选择，由于它不是一个文件系统位置，但惯例上仍然使用类似文件系统的值，例如`@/tmp`。               默认值通常是`/tmp`，但是在编译时可以被改变。        在windows上，默认值为空，意味着默认不建立UNIX-域嵌套。这个参数只能在服务器启动时设置。               除了套接字文件本身（名为`.s.PGSQL.*`nnnn`*`，其中*`nnnn`*是服务器的端口号），一个名为`.s.PGSQL.*`nnnn`*.lock`的普通文件会在每一个`unix_socket_directories`目录中被创建。        任何一个都不应该被手工移除。        对于抽象命名空间，没有锁文件被建立。       

- `unix_socket_group` (`string`)            

  ​        设置 Unix 域套接字的所属组（套接字的所属用户总是启动服务器的用户）。可以与选项`unix_socket_permissions`一起用于对 Unix域连接进行访问控制。默认是一个空字符串，表示服务器用户的默认组。这个参数只能在服务器启动时设置。               Windows 上不支持这个参数。        所有设置会被忽略。        同样，抽象命名空间中的套接字没有文件属主，所以在这种情况下，这个设置也会被忽略。       

- `unix_socket_permissions` (`integer`)            

  ​        设置 Unix 域套接字的访问权限。Unix 域套接字使用普通的 Unix 文件系统权限集。这个参数值应该是数字的形式，也就是系统调用`chmod`和`umask`接受的 形式（如果使用自定义的八进制格式，数字必须以一个`0`（零）开头）。               默认的权限是`0777`，意思是任何人都可以连接。合理的候选是`0770`（只有用户和同组的人可以访问， 又见`unix_socket_group`）和`0700`（只有用户自己可以访问）（请注意，对于 Unix 域套接字，只有写权限有麻烦，因此没有对读取和执行权限的设置和收回）。               这个访问控制机制与[第 21 章](http://www.postgres.cn/docs/14/client-authentication.html)中的用户认证没有关系。               这个参数只能在服务器启动时设置。               这个参数与完全忽略套接字权限的系统无关，尤其是自版本10以上的Solaris。        在那些系统上，可以通过把`unix_socket_directories`指向一个把搜索权限        限制给指定用户的目录来实现相似的效果。               抽象命名空间中的套接字没有文件权限，所以这种情况下这个设置也会被忽略。       

- `bonjour` (`boolean`)            

  ​        通过Bonjour广告服务器的存在。默认值是关闭。        这个参数只能在服务器启动时设置。       

- `bonjour_name` (`string`)            

  ​        指定Bonjour服务名称。空字符串`''`（默认值）表示使用计算机名。 如果编译时没有打开Bonjour支持那么将忽略这个参数。这个参数只能在服务器启动时设置。       

- `tcp_keepalives_idle` (`integer`)            

  ​        规定在操作系统向客户端发送一个TCP keepalive消息后无网络活动的时间总量。        如果指定值时没有单位，则以秒为单位。值0(默认值)表示选择操作系统默认值。        指定不活动多少秒之后通过 TCP 向客户端发送一个 keepalive 消息。 0 值表示使用默认值。        这个参数只有在支持`TCP_KEEPIDLE`或等效套接字选项的系统或 Windows 上才可以使用。在其他系统上，它必须为零。在通过 Unix 域套接字连接的会话中，这个参数被忽略并且总是读作零。       注意         在 Windows 上，设定值为0将设置这个参数为 2 小时，因为 Windows 不支持读取系统默认值。        

- `tcp_keepalives_interval` (`integer`)            

  ​        规定未被客户端确认收到的TCP keepalive消息应重新传输的时间长度。        如果指定值时没有单位，则以秒为单位。值0(默认值)表示选择操作系统默认值。 	这个参数只有在支持`TCP_KEEPINTVL`或等效套接字选项的系统或 Windows 上才可以使用。在其他系统上，必须为零。在通过 Unix域套接字连接的会话中，这个参数被忽略并总被读作零。       注意         在 Windows 上，设定值为0将设置这个参数为 1 秒，因为 Windows 不支持读取系统默认值。        

- `tcp_keepalives_count` (`integer`)            

  ​        指定服务器到客户端的连接被认为中断之前可以丢失的TCP keepalive消息的数量。值0(默认值)表示选择操作系统默认值。        这个参数只有在支持`TCP_KEEPCNT`或等效套接字选项的系统上才可以使用。在其他系统上，必须为零。在通过 Unix 域套接字连接的会话中，这个参数被忽略并总被读作零。       注意         Windows 不支持该参数，且必须为零。        

- `tcp_user_timeout` (`integer`)            

  ​        指定传输的数据在TCP连接被强制关闭之前可以保持未确认状态的时间量。        如果指定值时没有单位，则以毫秒为单位。值0(默认值)表示选择操作系统默认值。        这个参数只有在支持`TCP_USER_TIMEOUT`的系统上才被支持；在其他系统上，它必须为零。        在通过Unix-domain 套接字连接的会话中，此参数将被忽略并且始终读取为零。       注意         在Windows上不支持该参数，并且必须为零。        

- `client_connection_check_interval` (`integer`)            

  ​        在运行查询时，设置检查客户端是否保持连接的可选检查的时间间隔。        这个检查通过轮询套接字来执行，并且在内核报告该连接关闭时，允许长时间运行的查询可以尽快中止。               这个选项当前仅在支持非标的`POLLRDHUP`扩展到`poll`系统调用的系统上有效，包括Linux.               如果指定的值没有单位，则以毫秒为单位。        默认值为`0`，代表禁用连接检查。        没有连接检查，服务器将只在与套接字的下一次交互时检测连接的丢失，当它等待、接收或发送数据时。               为了让内核本身能够在包括网络故障在内的所有场景中，在已知的时间范围内可靠地检测丢失的TCP连接，它可能还需要调整操作系统的TCP保持连接设置，        或者PostgreSQL的[tcp_keepalives_idle](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-TCP-KEEPALIVES-IDLE),  [tcp_keepalives_interval](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-TCP-KEEPALIVES-INTERVAL) 和 [tcp_keepalives_count](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-TCP-KEEPALIVES-COUNT) 设置。       

### 20.3.2. 安全和认证

- `authentication_timeout` (`integer`)                        

  ​        允许完成客户端认证的最长时间。如果一个客户端没有在这段时间里完成认证协议，服务器将关闭连接。        这样就避免了出问题的客户端无限制地占有一个连接。如果指定值时没有单位，则以秒为单位。        默认值是 1分钟（`1m`）。这个参数只能在服务器命令行上或者在`postgresql.conf`文件中设置。       

- `password_encryption` (`enum`)            

  ​        当在[CREATE ROLE](http://www.postgres.cn/docs/14/sql-createrole.html)或者[ALTER ROLE](http://www.postgres.cn/docs/14/sql-alterrole.html)中指定了口令时，这个参数决定用于加密该口令的算法。        可能的值是 `scram-sha-256`, 可以用SCRAM-SHA-256, 和 `md5`加密密码，以MD5 哈希的方式存储密码。         默认为 `scram-sha-256`。               注意老的客户端可能缺少对SCRAM认证机制的支持，因此无法使用用SCRAM-SHA-256加密的口令。详情请参考[第 21.5 节](http://www.postgres.cn/docs/14/auth-password.html)。       

- `krb_server_keyfile` (`string`)            

  ​        设置服务器的Kerberos密钥文件的位置。        默认为`FILE:/usr/local/pgsql/etc/krb5.keytab`（其中目录部分是在构建时由`sysconfdir`指定的；用`pg_config --sysconfdir`来决定）。        如果这个参数被设为空字符串，它将被忽略，并且系统依赖的默认值被应用。        这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。        详情请参考[第 21.6 节](http://www.postgres.cn/docs/14/gssapi-auth.html)。       

- `krb_caseins_users` (`boolean`)            

  ​        设置是否应该以大小写不敏感的方式对待GSSAPI用户名。默认值是`off`（大小写敏感）。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

- `db_user_namespace` (`boolean`)            

  ​        这个参数启用针对每个数据库的用户名。这个参数默认是关掉的。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。               如果这个参数为打开，应该把用户创建成*`username@dbname`*的形式。当一个连接客户端传来*`username`*时，`@`和数据库名会被追加到用户名并且服务器会查找这个与数据库相关的用户名。注意在SQL环境中用含有`@`的名称创建用户时，需要把用户名放在引号内。               在这个参数被启用时，仍然可以创建平常的全局用户。而在客户端中指定这种用户时只需要简单地追加`@`，例如`joe@`。在服务器查找该用户名之前，`@`会被剥离掉。               `db_user_namespace`会导致客户端和服务器的用户名表达形式不同。认证检查总是会以服务器的用户名表达形式来完成，因此认证方法必须针对服务器用户名而不是客户端用户名来配置。由于`md5`方法在客户端和服务器两端都使用用户名作为salt，`md5`不能与`db_user_namespace`同时使用。       注意         这种特性的目的是在找到完整的解决方案之前提供一种临时的措施。在找到完整解决方案时，这个选项将被去除。        

### 20.3.3. SSL

​      有关设置SSL的更多信息请参考[第 19.9 节](http://www.postgres.cn/docs/14/ssl-tcp.html)。     

- `ssl` (`boolean`)            

  ​        启用SSL连接。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。默认值是`off`。       

- `ssl_ca_file` (`string`)            

  ​        指定包含 SSL 服务器证书颁发机构（CA）的文件名。相对路径是相对于数据目录的。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。默认值为空，表示没有载入CA文件，并且客户端证书验证没有被执行。       

- `ssl_cert_file` (`string`)            

  ​        指定包含 SSL 服务器证书的文件名。相对路径是相对于数据目录的。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。默认值是`server.crt`。       

- `ssl_crl_file` (`string`)            

  ​        指定包含 SSL 服务器证书撤销列表（CRL）的文件名。其中的相对路径是相对于数据目录的。        这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。        默认值是空，表示没有载入CRL文件(除非设定了 [ssl_crl_dir](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-SSL-CRL-DIR) is set)。       

- `ssl_crl_dir` (`string`)            

  ​        指定包含SSD服务器证书吊销列表(CRL)的目录的名称。        相对路径与数据目录相关。        这个参数只能在`postgresql.conf`文件中设置或者通过服务器命令行。        默认值为空，意味着没有使用CRLs(除非设定了[ssl_crl_file](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-SSL-CRL-FILE))。               这个目录需要用OpenSSL 命令 `openssl rehash` 或 `c_rehash`来准备。        详请参阅相应文档               当使用此设置时，在连接时会按需加载指定目录下的CRLs。        新的CRLs可以添加到该目录中，并可以立即使用。        这与[ssl_crl_file](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-SSL-CRL-FILE)不同，那个会导致文件中的CRL在服务器启动时间或重新加载配置时加载。        两个设置可以一起使用。       

- `ssl_key_file` (`string`)            

  ​        指定包含 SSL 服务器私钥的文件名。相对路径是相对于数据目录。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。默认值是`server.key`。       

- `ssl_ciphers` (`string`)            

  ​        指定一个允许用于SSL连接的SSL密码套件列表。        这个设置的语法和所支持的值列表可以参见OpenSSL包中的ciphers手册页。        仅在使用 TLS 版本 1.2 及更低版本的连接才受影响。目前没有控制 TLS 版本 1.3 连接使用的密码选择的设置。         默认值是`HIGH:MEDIUM:+3DES:!aNULL`。默认值通常是一种合理的选择，除非用户有特定的安全性需求。               这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。               默认值的解释：        `HIGH`            使用来自`HIGH`组的密码的密码组（例如 AES, Camellia, 3DES）           `MEDIUM`            使用来自`MEDIUM`组的密码的密码组（例如 RC4, SEED）           `+3DES`            OpenSSL 对`HIGH`的默认排序是有问题的，因为它认为 3DES 比AES128 更高。            这是错误的，因为 3DES 提供的安全性比 AES128 低，并且它也更加慢。            `+3DES`把它重新排序在所有其他`HIGH`和 `MEDIUM`密码之后。           `!aNULL`            禁用不做认证的匿名密码组。这类密码组容易收到MITM攻击，因此不应被使用。                          可用的密码组细节可能会随着OpenSSL 版本变化。        可使用命令 `openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'`来查看当前安装的OpenSSL版本的实际细节。        注意这个列表是根据服务器密钥类型在运行时过滤过的。       

- `ssl_prefer_server_ciphers` (`boolean`)            

  ​        指定是否使用服务器的 SSL 密码首选项，而不是用客户端的。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。        默认值是 `on`。               老的PostgreSQL版本没有这个设置并且总是使用客户端的首选项。这个设置主要用于与那些版本        的向后兼容性。使用服务器的首选项通常会更好，因为服务器更可能会被合适地配置。       

- `ssl_ecdh_curve` (`string`)            

  ​        指定用在ECDH密钥交换中的曲线名称。它需要被所有连接的客户端支持。        它不需要与服务器椭圆曲线密钥使用的曲线相同。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。默认值是`prime256v1`。               OpenSSL最常见的曲线名称是：        `prime256v1` (NIST P-256)、        `secp384r1` (NIST P-384)、        `secp521r1` (NIST P-521)。        `openssl ecparam -list_curves`命令可以显示可用曲线的完整列表。        不过并不是所有的都在TLS中可用。       

- `ssl_min_protocol_version` (`enum`)            

  ​        设置要使用的最小SSL/TLS协议版本。当前的可用版本包括： `TLSv1`, `TLSv1.1`, `TLSv1.2`, `TLSv1.3`.        旧版本的 OpenSSL 库不支持所有值;如果选择了不支持的设置将会引发错误。        TLS 1.0之前的协议版本，也就是SSL 版本 2 and 3，总是禁用的。               默认为`TLSv1.2`, 在本文撰写时的行业最佳实践。               这个参数只能在`postgresql.conf`文件中或通过服务器命令行进行设置。       

- `ssl_max_protocol_version` (`enum`)            

  ​        设定要使用的最大SSL/TLS协议版本。        有效的版本为 [ssl_min_protocol_version](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-SSL-MIN-PROTOCOL-VERSION), 添加一个空字符串，允许任何协议版本。        默认为允许任何版本。设置最大协议版本主要用于测试，或者某个组件在与较新的协议配合工作时出现了问题。               此参数只能在`postgresql.conf`文件或服务器命令行中设置。       

- `ssl_dh_params_file` (`string`)            

  ​        指定含有用于SSL密码的所谓临时DH家族的Diffie-Hellman参数的文件名。默认值为空，这种情况下将使用内置的默认DH参数。使用自定义的DH参数可以降低攻击者破解众所周知的内置DH参数的风险。可以用命令`openssl dhparam -out dhparams.pem 2048`创建自己的DH参数文件。               这个参数只能在 `postgresql.conf`文件中或服务器命令行上进行设置。       

- `ssl_passphrase_command` (`string`)            

  ​        设置当需要一个密码（例如一个私钥）来解密SSL文件时会调用的一个外部命令。默认情况下，这个参数为空，表示使用内建的提示机制。               该命令必须将密码打印到标准输出并且以代码0退出。在该参数值中，`%p`被替换为一个提示字符串（要得到文字`%`，应该写成`%%`）。注意该提示字符串将可能含有空格，因此要确保加上适当的引号。如果输出的末尾有单一的新行，它会被剥离掉。               该命令实际上并不一定要提示用户输入一个密码。它可以从文件中读取密码、从钥匙链得到密码等等。确保选中的机制足够安全是用户的责任。               这个参数只能在 `postgresql.conf`文件中或服务器命令行上进行设置。       

- `ssl_passphrase_command_supports_reload` (`boolean`)            

  ​        这个参数决定在配置重载期间如果一个密钥文件需要口令时，是否也调用`ssl_passphrase_command`设置的密码命令。        如果这个参数为off（默认），那么在重载期间将忽略`ssl_passphrase_command`，如果在此期间需要密码则SSL配置将不会被重载。        对于要求一个TTY（当服务器正在运行时可能是不可用的）来进行提示的命令，这种设置是合适的。        例如，如果密码是从一个文件中得到的，将这个参数设置为on可能是合适的。               这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

## 资源消耗

- [20.4.1. 内存](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-MEMORY)
- [20.4.2. 磁盘](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-DISK)
- [20.4.3. 内核资源使用](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-KERNEL)
- [20.4.4. 基于代价的清理延迟](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST)
- [20.4.5. 后台写入器](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER)
- [20.4.6. 异步行为](http://www.postgres.cn/docs/14/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR)

### 20.4.1. 内存

- `shared_buffers` (`integer`)            

  ​        设置数据库服务器将使用的共享内存缓冲区量。默认通常是 128 兆字节（`128MB`），但是如果你的内核设置不支持（在initdb时决定），那么可以会更少。        这个设置必须至少为 128 千字节。不过为了更好的性能，通常会使用明显高于最小值的设置。        如果指定值时没有单位，则以块为单位，即`BLCKSZ`字节，通常为8kB.(`BLCKSZ` 的非默认值改变最小值。)        此参数只能在服务器启动时设置。               如果有一个专用的 1GB 或更多内存的数据库服务器，一个合理的`shared_buffers`开始值是系统内存的 25%。即使更大的`shared_buffers`有效，也会造成一些工作负载， 但因为PostgreSQL同样依赖操作系统的高速缓冲区，将`shared_buffers`设置为超过 40% 的RAM不太可能比一个小点值工作得更好。为了能把对写大量新的或改变的数据的处理分布在一个较长的时间段内，`shared_buffers`更大的设置通常要求对`max_wal_size`也做相应增加。               如果系统内存小于 1GB，一个较小的 RAM 百分数是合适的，这样可以为操作系统留下足够的空间。       

- `huge_pages` (`enum`)            

  ​        控制是否为主共享内存区域请求巨型页。有效值是`try`（默认）、`on`以及`off`。如果`huge_pages`被设置为`try`，则服务器将尝试请求巨型页，但是如果失败会退回到默认的方式。如果为`on`，请求巨型页失败将使得服务器无法启动。如果为`off`，则不会请求巨型页。               当前，只有Linux和Windows上支持这个设置。在其他系统上这个参数被设置为`try`时，它会被忽略。        在Linux中，它只在`shared_memory_type`设置为`mmap`（默认）的时候被支持。               巨型页面的使用会导致更小的页面表以及花费在内存管理上的 CPU 时间更少，从而提高性能。更多有关Linux上使用巨型页面的细节请见[第 19.4.5 节](http://www.postgres.cn/docs/14/kernel-resources.html#LINUX-HUGE-PAGES)。               巨型页在Windows上被称为大页面。        要使用大页面，需要为运行PostgreSQL的Windows用户账号分配“Lock pages in memory”的用户权限。        可以使用Windows的组策略工具（gpedit.msc）来分配用户权限“Lock pages in memory”。        为了在命令窗口以单进程（而不是Windows服务）的方式启动数据库服务器，命令窗口必须以管理员身份运行或者禁用用户访问控制（UAC）。        当UAC被启用时，普通的命令窗口会在启动时收回用户权限“Lock pages in memory”。               注意这种设置仅影响主共享内存区域。Linux、FreeBSD以及Illumos之类的操作系统也能为普通内存分配自动使用巨型页（也被称为“超级”页或者“大”页面），而不需要来自PostgreSQL的显式请求。在Linux上，这被称为“transparent huge pages”（THP，透明巨型页）。已知这种特性对某些Linux版本上的某些用户会导致PostgreSQL的性能退化，因此当前并不鼓励使用它（与`huge_pages`的显式使用不同）。       

- `huge_page_size` (`integer`)            

  ​        控制巨型页的大小，当他们通过[huge_pages](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-HUGE-PAGES)时。        默认为零 (`0`)。        当设置为`0`时，将使用系统默认的巨型页大小。        这个参数只能在服务器启动时设置。               一些现代64位服务器体系结构上常用的有效页尺寸包括：        `2MB` 和 `1GB` (Intel and AMD),         `16MB` 和 `16GB` (IBM POWER),         还有 `64kB`, `2MB`,`32MB` 和 `1GB` (ARM).         关于使用和支持的更多信息，参见[第 19.4.5 节](http://www.postgres.cn/docs/14/kernel-resources.html#LINUX-HUGE-PAGES)。               非默认设置当前仅在Linux上支持。       

- `temp_buffers` (`integer`)            

  ​        为每个数据库会话设置用于临时缓冲区的最大内存.这些是仅用于访问临时表的会话本地缓冲。        如果指定值时没有单位，则以块为单位，即`BLCKSZ`字节，通常为8kB。        默认为8兆字节 (`8MB`)。(如果`BLCKSZ`不是8kB,则默认值按比例缩放。)        这个设置可以在独立的会话内部被改变，但是只有在会话第一次使用临时表之前才能改变； 在会话中随后企图改变该值是无效的。               一个会话将按照`temp_buffers`给出的限制根据需要分配临时缓冲区。如果在一个并不需要大量临时缓冲区的会话里设置一个大的数值， 其开销只是一个缓冲区描述符，或者说`temp_buffers`每增加一则增加大概 64 字节。不过，如果一个缓冲区被实际使用，那么它就会额外消耗 8192 字节（或者`BLCKSZ`字节）。       

- `max_prepared_transactions` (`integer`)            

  ​        设置可以同时处于“prepared”状态的事务的最大数目（见[PREPARE TRANSACTION](http://www.postgres.cn/docs/14/sql-prepare-transaction.html)）。把这个参数设置 为零（这是默认设置）将禁用预备事务特性。这个参数只能在服务器启动时设置。               如果你不打算使用预备事务，可以把这个参数设置为零来防止意外创建预备事务。如果你正在使用预备事务，你将希望把`max_prepared_transactions`至少设置为[max_connections](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-MAX-CONNECTIONS)一样大，因此每一个会话可以有一个预备事务待处理。               当运行一个后备服务器时，这个参数必须至少与主服务器上的一样大。否则，后备服务器上将不会执行查询。       

- `work_mem` (`integer`)            

  ​        设置在写入临时磁盘文件之前查询操作(例如排序或哈希表)可使用的基础最大内存容量。        如果指定值时没有单位，则以千字节为单位。默认值是4兆字节 (`4MB`)。        注意对于一个复杂查询， 可能会并行运行好几个排序或者哈希操作；每个操作通常都会被允许使用这个参数指定的内存量，然后才会开始写数据到临时文件。        同样，几个正在运行的会话可能并发进行这样的操作。因此被使用的总内存可能是`work_mem`值的好几倍，在选择这个值时一定要记住这一点。        `ORDER BY`、`DISTINCT`和归并连接都要用到排序操作。        哈希连接、基于哈希的聚集，结果缓存节点以及基于哈希的`IN`子查询处理中都要用到哈希表。               与等效的基于排序的操作相比，基于哈希的操作通常对内存可用性更敏感。         可用于哈希表的内存通过将`work_mem`乘`hash_mem_multiplier`来计算。         这使得基于哈希的操作可以使用超出通常`work_mem`基本量的内存。       

- `hash_mem_multiplier` (`浮点`)            

  ​        用于计算基于哈希的操作可以使用的最大内存量。        最终限制通过将`work_mem`乘以`hash_mem_multiplier`来决定。        默认值为 1.0，这使得基于hash的操作与基于排序的操作一样，都取决于简单的`work_mem`最大值。。               考虑在经常发生溢出的环境中增加`hash_mem_multiplier`，尤其是在简单增加 `work_mem` 会导致内存压力（内存压力通常以间歇性的内存退出错误的形式出现）。         设置为 1.5 或 2.0 对混合工作负载有效。在 2.0 - 8.0 或更多范围内的较高设置在已`work_mem`已经达到40MB 或更多的环境中可能有效。       

- `maintenance_work_mem` (`integer`)            

  ​        指定在维护性操作（例如`VACUUM`、`CREATE INDEX`和`ALTER TABLE ADD FOREIGN KEY`）中使用的 最大的内存量。        如果指定值时没有单位，则以千字节为单位，其默认值是 64 兆字节（`64MB`）。因为在一个数据库会话中，一个时刻只有一个这样的操作可以被执行，并且一个数据库安装通常不会有太多这样的操作并发执行， 把这个数值设置得比`work_mem`大很多是安全的。 更大的设置可以改进清理和恢复数据库转储的性能。               注意当自动清理运行时，可能会分配最多达这个内存的[autovacuum_max_workers](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS)倍，因此要小心不要把该默认值设置得太高。        通过独立地设置[autovacuum_work_mem](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM)可能会对控制这种情况        有所帮助。               注意，对于死亡元组标识的集合，`VACUUM`最多只能使用`1GB`的内存。       

- `autovacuum_work_mem` (`integer`)            

  ​        指定每个自动清理工作者进程能使用的最大内存量。        如果指定值时没有单位，则以千字节为单位。        其默认值为 -1，表示转而使用 [maintenance_work_mem](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM)的值。        当运行在其他上下文环境中时，这个设置对`VACUUM`的行为没有影响。        这个参数只能在`postgresql.conf`中或者服务器命令行上设置。               对于死亡元组标识的集合，autovacuum最大只能使用`1GB`内存，所以设置`autovacuum_work_mem`到一个更高的值，对于autovacuum在扫描表时所能收集的死亡元组数量是无效的。       

- `logical_decoding_work_mem` (`integer`)            

  ​        指定逻辑解码要使用的最大内存量，在将某些解码的更改写入本地磁盘之前。        这将限制逻辑流复制连接使用的内存量。它默认为 64 兆字节（`64MB`）。        由于每个复制连接仅使用此大小的单个缓冲区，并且安装通常不会同时具有多个此类连接（受 `max_wal_senders` 的限制），因此将此值设置得明显高于 `work_mem`是安全的，从而减少写入磁盘的解码更改数量。       

- `max_stack_depth` (`integer`)            

  ​        指定服务器的执行堆栈的最大安全深度。这个参数的理想设置是由内核强制的实际栈尺寸限制（`ulimit -s`所设置的或者本地等价物），减去大约一兆字节的安全边缘。        需要这个安全边缘是因为在服务器中并非所有例程都检查栈深度，只是在关键的可能递规的例程中才进行检查。如果指定值时没有单位，则以千字节为单位。默认设置是两兆字节（`2MB`），这个值相对比较小并且不可能导致崩溃。但是，这个值可能太小了，以至于无法执行复杂的函数。只有超级用户可以修改这个设置。               把`max_stack_depth`参数设置得高于实际的内核限制将意味着一个失控的递归函数可能会导致一个独立的后端进程崩溃。 在PostgreSQL能够检测内核限制的平台上， 服务器将不允许把这个参数设置为一个不安全的值。不过，并非所有平台都能提供该信息，所以我们还是建议你在选择值时要小心。       

- `shared_memory_type` (`enum`)            

  ​        指定服务器应用于主共享内存区域的共享内存实现，包括 PostgreSQL 的共享缓冲区和其他共享数据。        可能的值为 `mmap` (对使用 `mmap` 分配的匿名共享内存)，`sysv` (通过 `shmget` 分配的系统V 共享内存)，和`windows` (Windows共享内存)。        并非在所有平台上都支持全部值;第一个被支持的选项是该平台的默认选项。        `sysv` 选项不是任何平台的默认选项，通常不建议使用，因为它通常需要非默认的内核设置来允许大量的地址分配(参见 [第 19.4.1 节](http://www.postgres.cn/docs/14/kernel-resources.html#SYSVIPC))。       

- `dynamic_shared_memory_type` (`enum`)            

  ​        指定服务器应该使用的动态共享内存实现。可能的值是`posix`（用于使用        `shm_open`分配的 POSIX 共享内存）、`sysv`        （用于通过`shmget`分配的 System V 共享内存）、        `windows`（用于 Windows 共享内存）、和`mmap`        （使用存储在数据目录中的内存映射文件模拟共享内存）。并非所有平台上都支持所有值，平台上第一个支持的选项就是其默认值。        在任何平台上`mmap`选项都不是默认值，通常不鼓励使用它，因为操作系统会        反复地把修改过的页面写回到磁盘上，从而增加了系统的I/O负载。不过当        `pg_dynshmem`目录被存储在一个 RAM 盘时或者没有其他共享内存功能可用时，        它还是有用的。       

- `min_dynamic_shared_memory` (`integer`)            

  ​        指定在服务器启动时将要分配给并行查询使用的内存容量。        当此内存区域不够用或被并发查询耗尽时，新的并行查询尝试使用`dynamic_shared_memory_type`配置的方法从操作系统临时分配额外的共享内存，由于内存管理开销该方法可能慢一些。        在启动时由`min_dynamic_shared_memory`分配的内存受到操作系统上所支持的`huge_pages`设置的影响，并且在自动管理的操作系统上更可能从较大的页面中受益。        默认值是`0`(无)。        该参数只能在服务器启动时设置。       

### 20.4.2. 磁盘

- `temp_file_limit` (`integer`)            

  ​        指定一个进程能用于临时文件（如排序和哈希临时文件，或者用于保持游标的存储文件）的最大磁盘空间量。一个试图超过这个限制的事务将被取消。        如果指定值时没有单位，则以千字节为单位。`-1`（默认值）意味着没有限制。只有超级用户能够修改这个设置。               这个设置约束着一个给定PostgreSQL进程在任何瞬间所使用的所有临时文件的总空间。应该注意的是，与在查询执行中在幕后使用的临时文件相反，显式临时表所用的磁盘空间*不*被这个设置所限制。       

### 20.4.3. 内核资源使用

- `max_files_per_process` (`integer`)            

  ​        设置每个服务器子进程允许同时打开的最大文件数目。默认是 1000  个文件。如果内核强制一个安全的针对每个进程的限制，那么你不用操心这个设置。但是在 一些平台上（特别是大多数 BSD  系统），如果很多进程都尝试打开很多文件，内核将允许独立进程打开比个系统真正可以支持的数目大得多得文件数。如果你发现自己看到了“Too many open files”这样的失败，可尝试减小这个设置。这个参数只能在服务器启动时设置。       

### 20.4.4. 基于代价的清理延迟

​      在[VACUUM](http://www.postgres.cn/docs/14/sql-vacuum.html)和[ANALYZE](http://www.postgres.cn/docs/14/sql-analyze.html)命令的执行过程中，系统维持着一个内部计数器来跟踪各种被执行的I/O操作的估算开销。当累计的代价达到一个限制（由`vacuum_cost_limit`指定），执行这些操作的进程将按照`vacuum_cost_delay`所指定的休眠一小段时间。然后它将重置计数器并继续执行。     

​      这个特性的出发点是允许管理员降低这些命令对并发的数据库活动产生的I/O影响。在很多情况下，`VACUUM`和`ANALYZE`等维护命令能否快速完成并不重要，而非常重要的是这些命令不会对系统执行其他数据库操作的能力产生显著的影响。基于代价的清理延迟提供了一种方式让管理员能够保证这一点。     

​      对于手动发出的`VACUUM`命令，该特性默认被禁用。要启用它，只要把`vacuum_cost_delay`变量设为一个非零值。     

- `vacuum_cost_delay` (`floating point`)              

  ​         当超出开销限制时进程将要休眠的时间量。如果指定值时没有单位，则以毫秒为单位。         其默认值为0，这将禁用基于代价的清理延迟特性。正值将启用基于代价的清理。                 在使用基于代价的清理时，`vacuum_cost_delay`的合适值通常很小，也许是小于1毫秒。         虽然`vacuum_cost_delay`可以被设置为毫秒级别的值，但是在较老的平台上可能无法准确地测量这种延迟。         在这样的平台上，增加 `VACUUM`的节流资源消耗在1ms以上，需要改变其他的清理开销参数。         尽管如此，你应该保持 `vacuum_cost_delay` 在平台能持续测量的情况下尽可能小；大延迟没有帮助。        

- `vacuum_cost_page_hit` (`integer`)              

  ​         清理一个在共享缓存中找到的缓冲区的估计代价。它表示锁住缓冲池、查找共享哈希表和扫描页内容的代价。默认值为1。        

- `vacuum_cost_page_miss` (`integer`)              

  ​         清理一个必须从磁盘上读取的缓冲区的代价。         它表示锁住缓冲池、查找共享哈希表、从磁盘读取需要的块以及扫描其内容的代价。         默认值为2。        

- `vacuum_cost_page_dirty` (`integer`)              

  ​         当清理修改一个之前干净的块时需要花费的估计代价。它表示再次把脏块刷出到磁盘所需要的额外I/O。默认值为20。        

- `vacuum_cost_limit` (`integer`)              

  ​         将导致清理进程休眠的累计代价。默认值为200。        

### 注意

​       有些操作会保持关键性的锁，这样可以尽快完成。基于代价的清理延迟在这类操作期间不会发生。因此有可能代价会累计至大大超过指定的限制。为了防止在这种情况下的无意义的长时间延迟，实际延迟的计算方式是`vacuum_cost_delay` *       `accumulated_balance` /       `vacuum_cost_limit`，且最大值是`vacuum_cost_delay` * 4。      

### 20.4.5. 后台写入器

​      有一个独立的服务器进程，叫做*后台写入器*，它的功能就是发出写“脏”（新的或修改过的）共享缓冲区的命令。      当干净的共享缓存数量出现不足时，后台写入器写入一些脏缓存到文件系统，并标记为干净。      不过，后台写入器确实会增加 I/O 的总负荷，因为虽然在每个检查点间隔中一个重复弄脏的页面可能只会写出一次，但在同一个间隔中后台写入器可能会把它写出好几次。      在这一小节讨论的参数可以被用于调节本地需求的行为。     

- `bgwriter_delay` (`integer`)              

  ​         指定后台写入器活动轮次之间的延迟。在每个轮次中，写入器都会为一定数量的脏缓冲区发出写操作（可以用下面的参数控制）。         然后它就休眠 `bgwriter_delay`的时长， 然后重复动作。当缓冲池中没有脏缓冲区时，不管 `bgwriter_delay`，它都会进入更长的休眠。如果指定值时没有单位，则以毫秒为单位。默认值是 200 毫秒（`200ms`）。         注意在许多系统上，休眠延迟的有效解析度是 10 毫秒；因此，为`bgwriter_delay`设置一个 不是 10 的倍数的值与把它设置为下一个更高的 10 的倍数是一样的效果。这个选项只能在服务器命令行上或者在`postgresql.conf`文件中设置。        

- `bgwriter_lru_maxpages` (`integer`)              

  ​         在每个轮次中，不超过这么多个缓冲区将被后台写入器写出。把这个参数设置为零可禁用后台写出（注意被一个独立、专用辅助进程管理的检查点不受影响）。默认值是 100 个缓冲区。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。        

- `bgwriter_lru_multiplier` (`floating point`)              

  ​         每一轮次要写的脏缓冲区的数目基于最近几个轮次中服务器进程需要的新缓冲区的数目。 最近所需的平均值乘以`bgwriter_lru_multiplier`可以估算下一轮次中将会需要的缓冲区数目。脏缓冲区将被写出直到有很多干净可重用的缓冲区（然而，每一轮次中写出的缓冲区数不超过`bgwriter_lru_maxpages`）。 因此，设置为 1.0 表示一种“刚刚好的”策略，这种策略会写出正好符合预测值的数目的缓冲区。 更大大的值可以为需求高峰提供某种缓冲，而更小的值则需要服务进程来处理一些写出操作。默认值是 2.0。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。        

- `bgwriter_flush_after` (`integer`)              

  ​         只要后台写入的数据超过这个数量，尝试强制 OS 把这些写发送到底层存储上。这样做将限制内核页缓存中脏数据的量，降低了在检查点末尾发出一个 fsync 时或者 OS 在后台大批量写回数据时卡住的可能性。 	 那常常会导致大幅度压缩的事务延迟，但是也有一些情况（特别是负载超过[shared_buffers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-SHARED-BUFFERS)但小于 OS 页面高速缓存）的性能会降低。这种设置可能会在某些平台上没有效果。         如果指定值时没有单位，则以块为单位，即为`BLCKSZ` 字节，通常为8kB.合法的范围在`0`（禁用受控写回）和`2MB`之间。Linux 上的默认值是`512kB`，其他平台上是`0`（如果`BLCKSZ`不是8kB，则默认值和最大值会按比例缩放至这个值）。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。        

​      较小的`bgwriter_lru_maxpages`和`bgwriter_lru_multiplier`可以降低由后台写入器造成的额外 I/O 开销。但更可能的是，服务器进程将必须自己发出写入操作，这会延迟交互式查询。     

### 20.4.6. 异步行为

- `backend_flush_after` (`integer`)              

  ​         当单个后端写入数据的量超过这个数量时，尝试强制操作系统发送这些写入到底层存储。         这样做将限制内核的页面缓存中的脏数据量，降低在检查点末尾发出`fsync`时暂停的可能性，或者当操作系统在后台大批量的写回数据时。         通常的结果会大大减少事务延迟，但也有一些情况，特别是当工作负载大于[shared_buffers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-SHARED-BUFFERS)，但小于操作系统的页面缓存时，性能可能会下降。         此设置在某些平台上可能无效。         如果指定此值时没有单位，则将其作为块，即`BLCKSZ`字节，通常为8kB。         有效范围在`0`，禁止强制回写，和`2MB`之间。         默认值是`0`，即没有强制回写。         (如果`BLCKSZ`不是8kB，则最大值按其比例缩放。)        

- `effective_io_concurrency` (`integer`)              

  ​         设置PostgreSQL可以同时被执行的并发磁盘 I/O 操作的数量。调高这个值，可以增加任何单个PostgreSQL会话试图并行发起的 I/O 操作的数目。 允许的范围是 1 到 1000，或 0 表示禁用异步 I/O 请求。当前这个设置仅影响位图堆扫描。                 对于磁盘驱动器，这个设置的一个很好的出发点是组成一个被用于该数据库的 RAID 0 条带或 RAID 1  镜像的独立驱动器数量（对 RAID 5 而言，校验驱动器不计入）。但是，  如果数据库经常忙于在并发会话中发出的多个查询，较低的值可能足以使磁盘阵列繁忙。比保持磁盘繁忙所需的值更高的值只会造成额外的 CPU 开销。SSD 以及其他基于内存的存储常常能处理很多并发请求，因此它们的最佳值可能是数百。                 异步 I/O 依赖于一个有效的`posix_fadvise`函数（一些操作系统可能没有）。 如果不存在这个函数，将这个参数设置为除 0 之外的任何东西将导致错误。在一些操作系统上（如Solaris）虽然提供了这个函数，但它不会做任何事情。                 在支持的系统上默认值为 1，否则为 0。对于一个特定表空间中的表，可以通过设定该表空间的同名参数（见[ALTER TABLESPACE](http://www.postgres.cn/docs/14/sql-altertablespace.html)）可以覆盖这个值。        

- `maintenance_io_concurrency` (`integer`)              

  ​         与`effective_io_concurrency`相似，但用于支持许多客户端会话完成的维护工作。                 在支持的系统上的默认值为 10，否则为 0。          对于特定表空间中的表，这个值可以被覆盖，通过设置同名的表空间参数（参见 [ALTER TABLESPACE](http://www.postgres.cn/docs/14/sql-altertablespace.html)）。        

- `max_worker_processes` (`integer`)              

  ​         设置系统能够支持的后台进程的最大数量。这个参数只能在服务器启动时设置。默认值为 8。                 在运行一个后备服务器时，你必须把这个参数设置为等于或者高于主控服务器上的值。         否则，后备服务器上可能不会允许查询。                 在更改这个值时，考虑也对[max_parallel_workers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS)、[max_parallel_maintenance_workers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS)以及[max_parallel_workers_per_gather](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER)进行调整。        

- `max_parallel_workers_per_gather` (`integer`)              

  ​         设置单个`Gather`或者`Gather Merge`节点能够开始的工作者的最大数量。并行工作者会从[max_worker_processes](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES)建立的进程池中取得，数量由[max_parallel_workers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS)限制。注意所要求的工作者数量在运行时可能实际无法被满足。如果这种事情发生，该计划将会以比预期更少的工作者运行，这可能会不太高效。默认值是2。把这个值设置为0将会禁用并行查询执行。                 注意并行查询可能消耗比非并行查询更多的资源，因为每一个工作者进程时一个完全独立的进程，它对系统产生的影响大致和一个额外的用户会话相同。在为这个设置选择值时，以及配置其他控制资源利用的设置（例如[work_mem](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-WORK-MEM)）时，应该把这个因素考虑在内。`work_mem`之类的资源限制会被独立地应用于每一个工作者，这意味着所有进程的总资源利用可能会比单个进程时高得多。例如，一个使用 4 个工作者的并行查询使用的 CPU 时间、内存、I/O 带宽可能是不使用工作者时的 5 倍之多。                 并行查询的更多信息请见[第 15 章](http://www.postgres.cn/docs/14/parallel-query.html)。        

- `max_parallel_maintenance_workers` (`integer`)              

  ​         设置单一工具性命令能够启动的并行工作者的最大数目。         当前，支持使用并行工作者的工具性命令是`CREATE INDEX`，并且只有在构建B-树索引时才能并行，并且 `VACUUM` 没有 `FULL`选项。         并行工作者从由[max_worker_processes](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES)创建的进程池中取出，数量由[max_parallel_workers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS)控制。         注意实际在运行时所请求数量的工作者可能不可用。如果发生这种情况，工具性操作将使用比预期数量少的工作者运行。默认值为2。将这个值设置为0可以禁用工具性命令对并行工作者的使用。                 注意并行工具性命令不应该消耗比同等数量非并行操作更多的内存。这种策略与并行查询不同，并行查询的资源限制通常是应用在每个工作者进程上。并行工具性命令把资源限制`maintenance_work_mem`当作对整个工具性命令的限制，而不管其中用到了多少个并行工作者进程。不过，并行工具性命令实际上可能仍会消耗更多的CPU资源和I/O带宽。        

- `max_parallel_workers` (`integer`)              

  ​         设置系统为并行操作所支持的工作者的最大数量。默认值为8。         在增加或者减小这个值时，也要考虑对[max_parallel_maintenance_workers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS)以及[max_parallel_workers_per_gather](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER)进行调整。         此外，要注意将这个值设置得大于[max_worker_processes](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES)将不会产生效果，因为并行工作者进程都是从[max_worker_processes](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES)所建立的工作者进程池中取出来的。        

- ​       `parallel_leader_participation` (`boolean`)              

  ​         允许leader进程在`Gather` 和 `Gather Merge`节点下执行查询计划，而不是等待worker进程。         默认值是`on`。         设置该值为`off`可以降低workers因为leader读取元组的速度不够快而被阻塞的可能性，但在第一个元组生成之前需要leader进程等待worker进程启动。         leader能帮助或阻碍性能的程度取决于计划类型，workers的数量和查询持续时间。        

- `old_snapshot_threshold` (`integer`)              

  ​         设置在使用快照时，一个快照可以被使用而没有发生“snapshot too old” 错误的风险的最小时间。超过此阈值时间的死数据将允许被清除。          这可以有助于阻止长时间使用的快照造成的快照膨胀。为了阻止由于本来对该快照可见的数据被清理导致的不正确结果，当快照比这个阈值更旧并且该快照被用来读取一个该快照建立以来被修改过的页面时，将会产生一个错误。                 如果指定值时没有单位，则以分钟为单位。         值 `-1` (默认值) 禁用此功能,实际上将快照的时限设置为无穷大。         这个参数只能在服务器启动时设置。                 对于生产工作有用的值的范围可能从几个小时到几天不等。只允许小的值（例如`0`或者`1min`）是因为它们有时可能对测试有用。         虽然允许高达`60d`的设置，但是请注意很多负载情况下，很短的时间帧里就可能发生极大的膨胀或者事务 ID 回卷。                 当这个特性被启用时，关系末尾的被清出的空间不能被释放给操作系统，因为那可能会移除用于检测“snapshot too old”情况所需的信息。所有分配给关系的空间还将与该关系关联在一起便于重用，除非它们被显式地释放（例如，用`VACUUM FULL`）。                  这个设置不会尝试保证在任何特殊情况下都会生成错误。事实上，如果（例如）可以从一个已经物化了一个结果集的游标中生成正确的结果，即便被引用表中的底层行已经被清理掉也不会生成错误。某些表不能被过早地安全清除，并且因此将不受这个设置的影响，例如系统目录。对于这些表，这个设置将不能降低膨胀，也不能降低在扫描时产生“snapshot too old”错误的可能性。        

## 预写式日志

- [20.5.1. 设置](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS)
- [20.5.2. 检查点](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-CHECKPOINTS)
- [20.5.3. 归档](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING)
- [20.5.4. 归档恢复](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY)
- [20.5.5. 恢复目标](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET)

​    参阅[第 30.5 节](http://www.postgres.cn/docs/14/wal-configuration.html)获取调节这些设置的额外信息。   

### 20.5.1. 设置

- `wal_level` (`enum`)            

  ​        `wal_level`决定多少信息写入到 WAL 中。默认值是`replica`，它会写入足够的数据以支持WAL归档和复制，包括在后备服务器上运行只读查询。`minimal`会去掉除从崩溃或者立即关机中进行恢复所需的信息之外的所有记录。最后，`logical`会增加支持逻辑解码所需的信息。每个层次包括所有更低层次记录的信息。这个参数只能在服务器启动时设置。               在`minimal`级别中，对于创建或重写永久关系的事务的其余部分，不会记录任何信息。        这可以使那些操作更快（参见[第 14.4.7 节](http://www.postgres.cn/docs/14/populate.html#POPULATE-PITR)）。初始化这种优化的操作包括：        `ALTER ... SET TABLESPACE``CLUSTER``CREATE TABLE``REFRESH MATERIALIZED VIEW`         (without `CONCURRENTLY`)`REINDEX``TRUNCATE`        但最少的 WAL 不会包括足够的信息来从基础备份和 WAL 日志中重建数据，因此，要启用 WAL 归档（[archive_mode](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-ARCHIVE-MODE)）和流复制，必须使用`replica`或更高级别。        注意改变`wal_level`为`minimal`导致归档恢复和备用服务器之前的基本备份失效，也可能会导致数据丢失。               在`logical`层，与`replica`相同的信息会被记录，外加上        允许从 WAL 抽取逻辑修改集所需的信息。使用级别        `logical`将增加 WAL 容量，特别是如果为了`REPLICA IDENTITY FULL`配置了很多表并且执行了很多`UPDATE`和`DELETE`        语句时。               在 9.6 之前的版本中，这个参数也允许值`archive`和`hot_standby`。现在仍然接受这些值，但是它们会被映射到`replica`。       

- `fsync` (`boolean`)            

  ​        如果打开这个参数，PostgreSQL服务器将尝试确保更新被物理地写入到磁盘，做法是发出`fsync()`系统调用或者使用多种等价的方法（见[wal_sync_method](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-WAL-SYNC-METHOD)）。这保证了数据库集簇在一次操作系统或者硬件崩溃后能恢复到一个一致的状态。               虽然关闭`fsync`常常可以得到性能上的收益，但当发生断电或系统崩溃时可能造成不可恢复的数据损坏。因此，只有在能很容易地从外部数据中重建整个数据库时才建议关闭`fsync`。               能安全关闭`fsync`的环境的例子包括从一个备份文件中初始加载一个新数据库集簇、使用一个数据库集簇来在数据库被删掉并重建之后处理一批数据，或者一个被经常重建并却不用于失效备援的只读数据库克隆。单独的高质量硬件不足以成为关闭`fsync`的理由。               当把`fsync`从关闭改成打开时，为了可靠的恢复，需要强制在内核中的所有被修改的缓冲区进入持久化存储。这可以在多个时机来完成：在集簇被关闭时或在 fsync 因为运行`initdb --sync-only`而打开时、运行`sync`时、卸载文件系统时或者重启服务器时。               在很多情况下，为不重要的事务关闭[synchronous_commit](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT)可以提供很多关闭`fsync`的潜在性能收益，并不会有的同时， 关闭fsync可以提供很多潜在的性能优势，而不会有伴随着的数据损坏风险。               `fsync`只能在`postgresql.conf`文件中或在服务器命令行上设置。如果你关闭这个参数，请也考虑关闭[full_page_writes](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-FULL-PAGE-WRITES)。       

- `synchronous_commit` (`enum`)            

  ​        指定数据库服务器返回“success”指示给客户端之前，必须要完成多少WAL处理。        合法的值为`remote_apply`, `on`(默认值), `remote_write`,`local`, 和 `off`。               如果`synchronous_standby_names`为空，则唯一有意义的设置为`on` 和 `off` ；        `remote_apply`，`remote_write` 和 `local`都提供与`on`相同的本地同步级别。         所有非`off`模式的本地行为都是等待WAL的本地刷新到磁盘。         在 `off`模式，无需等待，因此在向客户端报告成功和以后保证事务安全防止服务器崩溃之间可能会出现延迟。        当设置为`off`时，在向客户端报告成功和真正保证事务不会被服务器崩溃威胁之间会有延迟（最大的延迟是[wal_writer_delay](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-WAL-WRITER-DELAY)的三倍）。        不同于[fsync](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-FSYNC)，将这个参数设置为`off`不会产生数据库不一致性的风险：一个操作系统或数据库崩溃可能会造成一些最近据说已提交的事务丢失，但数据库状态是一致的，就像这些事务已经被干净地中止。        因此，当性能比完全确保事务的持久性更重要时，关闭`synchronous_commit`可以作为一个有效的代替手段。更多讨论见[第 30.4 节](http://www.postgres.cn/docs/14/wal-async-commit.html)。               如果[synchronous_standby_names](http://www.postgres.cn/docs/14/runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES)为非空，`synchronous_commit`也控制是否事务提交将等待它们的 WAL 记录在后备服务器上被处理。               当设置为 `remote_apply` 时，提交将等待，直到来自当前同步备用服务器的答复显示他们已收到事务的提交记录并应用了它，以便它变得对备用服务器上的查询可见，并写入备用服务器上的持久存储。         这将导致比以前的设置更大的提交延迟，因为它等待 WAL 重放(replay)。         当设置为`on`时，提交将等待，直到来自于当前同步的后备服务器的回复显示它们已经收到了事务的提交记录并将其刷入了磁盘。        这保证事务将不会被丢失，除非主服务器和所有同步后备都遭受到了数据库存储损坏的问题。        当这个参数被设置为`remote_write`时，提交将等待，直到来自当前的同步后备的回复指示它们已经收到了该事务的提交记录并且已经把该记录写到它们的文件系统，这种设置保证数据得以保存，在PostgreSQL的后备服务器实例崩溃时，但是不能保证后备服务器遭受操作系统级别崩溃时数据能被保持，因为数据不一定必须要在后备机上达到持久存储。        设置`local`会导致提交等待本地刷写到磁盘，而不是复制。在使用同步复制时这通常是不可取的，但是为了完整性提供了这个选项。               这个参数可以随时被修改；任何一个事务的行为由其提交时生效的设置决定。因此，可以同步提交一些事务，同时异步提交其他事务。例如，当默认是相反时，实现一个单一多语句事务的异步提交，在事务中发出`SET LOCAL synchronous_commit TO OFF`。               [表 20.1](http://www.postgres.cn/docs/14/runtime-config-wal.html#SYNCHRONOUS-COMMIT-MATRIX) 概括了 `synchronous_commit` 设置的能力.       **表 20.1. synchronous_commit Modes**synchronous_commit settinglocal durable commitstandby durable commit after PG crashstandby durable commit after OS crashstandby query consistencyremote_apply••••on••• remote_write•• local•  off   

- `wal_sync_method` (`enum`)            

  ​        用来向强制 WAL 更新到磁盘的方法。如果`fsync`是关闭的，那么这个设置就不相关，因为 WAL 文件更新将根本不会被强制。可能的值是：                `open_datasync`（用`open()`选项`O_DSYNC`写 WAL 文件）                 `fdatasync`（在每次提交时调用`fdatasync()`）                 `fsync`（在每次提交时调用`fsync()`）                 `fsync_writethrough`（在每次提交时调用`fsync()`，强制任何磁盘写高速缓存的直通写）                 `open_sync`（用`open()`选项`O_SYNC`写 WAL 文件）                `open_`* 选项也可以使用`O_DIRECT`（如果可用）。        不是在所有平台上都能使用所有这些选择。        默认值是列表中第一个被平台支持的那个， 不过`fdatasync`是 Linux和FreeBSD中的默认值。        默认值不一定是最理想的；有可能需要修改这个设置或系统配置的其他方面来创建一个崩溃-安全的配置，或达到最佳性能。        这些方面在[第 30.1 节](http://www.postgres.cn/docs/14/wal-reliability.html)中讨论。        这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `full_page_writes` (`boolean`)            

  ​        当这个参数为打开时，PostgreSQL服务器在一个检查点之后的页面的第一次修改期间将每个页面的全部内容写到  WAL  中。这么做是因为在操作系统崩溃期间正在处理的一次页写入可能只有部分完成，从而导致在一个磁盘页面中混合有新旧数据。在崩溃后的恢复期间，通常存储在  WAL 中的行级改变数据不足以完全恢复这样一个页面。存储完整的页面映像可以保证页面被正确存储，但代价是增加了必须被写入 WAL 的数据量（因为  WAL 重放总是从一个检查点开始，所以在检查点后每个页面的第一次改变时这样做就够了。因此，一种减小全页面写开销的方法是增加检查点间隔参数值）。               把这个参数关闭会加快正常操作，但是在系统失败后可能导致不可恢复的数据损坏，或者静默的数据损坏。其风险类似于关闭`fsync`， 但是风险较小。并且只有在可关闭`fsync`的情况下才应该关闭它。               关闭这个选项并不影响用于时间点恢复（PITR）的 WAL 归档使用（见[第 26.3 节](http://www.postgres.cn/docs/14/continuous-archiving.html)）。               这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。默认值是`on`。       

- `wal_log_hints` (`boolean`)            

  ​        当这个参数为`on`时，PostgreSQL服务器一个检查点之后页面被第一次修改期间把该磁盘页面的整个内容都写入 WAL，即使对所谓的提示位做非关键修改也会这样做。               如果启用了数据校验和，提示位更新总是会被 WAL 记录并且这个设置会被忽略。你可以使用这个        设置测试如果你的数据库启用了数据校验和，会有多少额外的 WAL 记录发生。               这个参数只能在服务器启动时设置。默认值是`off`。       

- `wal_compression` (`boolean`)            

  ​        当这个参数为`on`时，如果[full_page_writes](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-FULL-PAGE-WRITES)        为打开或者处于基础备份期间，PostgreSQL服务器        会压缩写入到 WAL 中的完整页面镜像。压缩页面镜像将在 WAL 重放时        被解压。默认值为`off`。只有超级用户可以更改这个设置。               打开这个参数可以减小 WAL 所占的空间且无需承受不可恢复的数据损坏风险，        但是代价是需要额外的 CPU 开销以便在 WAL 记录期间进行压缩以及在 WAL         重放时解压。       

- `wal_init_zero` (`boolean`)            

  ​        如果设置为`on`（默认值），此选项会导致新的 WAL 文件被零填充。         在某些文件系统上，这可确保在我们需要写入 WAL 记录之前分配空间。         但是，*Copy-On-Write*（COW）文件系统可能不会从此技术中受益，因此可以选择跳过不必要的工作。         如果设置为`off`，则在创建文件时仅写入最终字节，以便其具有预期大小。       

- `wal_recycle` (`boolean`)            

  ​        如果设置为 `on` （默认值），此选项通过重命名来回收 WAL 文件，从而避免创建新文件。         在 COW 文件系统上，创建新文件系统可能更快，因此提供了禁用此行为的选项。       

- `wal_buffers` (`integer`)            

  ​        用于还未写入磁盘的 WAL 数据的共享内存量。默认值 -1 选择等于[shared_buffers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-SHARED-BUFFERS)的 1/32 的尺寸（大约3%），但是不小于`64kB`也不大于 WAL 段的尺寸（通常为）。如果自动的选择太大或太小可以手工设置该值，但是任何小于`32kB`的正值都将被当作`32kB`。        如果指定值时没有单位，则以WAL块作为单位，即为 `XLOG_BLCKSZ` 字节，通常为8kB。这个参数只能在服务器启动时设置。               在每次事务提交时，WAL  缓冲区的内容被写出到磁盘，因此极大的值不可能提供显著的收益。不过，把这个值设置为几个兆字节可以在一个繁忙的服务器（其中很多客户端会在同一时间提交）上提高写性能。由默认设置 -1 选择的自动调节将在大部分情况下得到合理的结果。       

- `wal_writer_delay` (`integer`)            

  ​        指定 WAL 写入器刷写 WAL 的频繁程度，以时间为单位。        在刷写WAL之后，写入器将根据`wal_writer_delay`所给出的时间长度进行睡眠，除非被一个异步提交的事务提前唤醒。        如果最近的刷写发生在 `wal_writer_delay` 之前，并且小于 `wal_writer_flush_after` WAL的值产生之后，那么WAL只会被写入操作系统，而不会被刷写到磁盘。        如果指定值时没有单位，则以毫秒作为单位。 	默认值是 200 毫秒（`200ms`）。注意在很多系统上，有效的睡眠延迟粒度是 10 毫秒，把`wal_writer_delay`设置为一个不是 10 的倍数的值，其效果和把它设置为大于该值的下一个 10 的倍数产生的效果相同。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

- `wal_writer_flush_after` (`integer`)            

  ​        指定 WAL 写入器刷写 WAL 的频繁程度，以卷为单位。        如果最近的刷写发生在 `wal_writer_delay` 之前，并且小于 `wal_writer_flush_after` WAL的值产生之后，那么WAL只会被写入操作系统，而不会被刷写到磁盘。        如果`wal_writer_flush_after`被设置为`0`，则WAL数据总是会被立即刷写。        如果指定值时没有单位，则以WAL块作为单位，即为`XLOG_BLCKSZ`字节，通常为8kB。        默认是`1MB`。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

- `wal_skip_threshold` (`integer`)            

  ​        当`wal_level`为`minimal`，并且在创建或重写永久关系之后提交事务时，此设置将确定如何保留新数据。         如果数据小于此设置，将其写入 WAL 日志;否则，使用受影响文件的 fsync。         根据存储的属性，如果此类提交减慢了并发事务，提高或降低此值可能会有所帮助。         如果指定此值时没有单位，则视为千字节。默认为两兆字节（`2MB`）。       

- `commit_delay` (`integer`)            

  ​        在一次 WAL 刷写被发起之前，`commit_delay`增加一个时间延迟。        如果系统负载足够高，使得在一个给定间隔内有额外的事务准备好提交，那么通过允许更多事务通过一个单次 WAL 刷写来提交能够提高组提交的吞吐量。        但是，它也把每次 WAL 刷写的潜伏期增加到了最多`commit_delay`。        因为如果没有其他事务准备好提交，就会浪费一次延迟，只有在当一次刷写将要被发起时有至少`commit_siblings`个其他活动事务时，才会执行一次延迟。        另外，如果`fsync`被禁用，则将不会执行任何延迟。        如果指定值时没有单位，则以微秒作为单位。        默认的`commit_delay`是零（无延迟）。只有超级用户才能修改这个设置。               在PostgreSQL的 9.3 发布之前，`commit_delay`的行为不同并且效果更差：它只影响提交，而不是所有 WAL 刷写，并且即使在 WAL 刷写马上就要完成时也会等待一整个配置的延迟。从PostgreSQL 9.3 中开始，第一个准备好刷写的进程会等待配置的间隔，而后续的进程只等到领先者完成刷写操作。       

- `commit_siblings` (`integer`)            

  ​        在执行`commit_delay`延迟时，要求的并发活动事务的最小数目。大一些的值会导致在延迟间隔期间更可能有至少另外一个事务准备好提交。默认值是五个事务。       

### 20.5.2. 检查点

- `checkpoint_timeout` (`integer`)            

  ​        自动 WAL 检查点之间的最长时间。如果指定值时没有单位，则以秒为单位。        合理的范围在 30 秒到 1 天之间。默认是 5 分钟（`5min`）。增加这个参数的值会增加崩溃恢复所需的时间。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `checkpoint_completion_target` (`floating point`)            

  ​        指定检查点完成的目标，作为检查点之间总时间的一部分。        默认是 0.9，这将把检查点分布在几乎所有可用的时间间隔上，提供公平一致的I/O负载，同时也为检查点完成开销留下了一些时间。        减少此参数是不被推荐的，因为这会导致检查点完成得更快。        这个造成处于在检查点和下一个计划检查点之间较少IO之后的检查点会有更高的IO比例。        这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `checkpoint_flush_after` (`integer`)            

  ​        当执行检查点时写入的数据量超过此数量时，就尝试强制 OS 把这些写发送到底层存储。        这样做将会限制内核页面高速缓存中的脏数据数量，降低在检查点末尾发出`fsync`或者 OS 在后台大批量写回数据时被卡住的可能性。        那常常会导致大幅度压缩的事务延迟，但是也有一些情况（特别是负载超过[shared_buffers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-SHARED-BUFFERS)但小于 OS 页面高速缓存）的性能会降低。        这种设置可能会在某些平台上没有效果。        如果指定值时没有单位，则以块为单位，即为`BLCKSZ` 字节，通常为8kB。        合法的范围在`0`（禁用强制写回）和`2MB`之间。Linux 上的默认值是`256kB`，其他平台上是`0`（如果`BLCKSZ`不是8kB，则默认值和最大值会按比例缩放到它）。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

- `checkpoint_warning` (`integer`)            

  ​        如果由于填充WAL段文件导致的检查点之间的间隔低于这个参数表示的时间量，那么就向服务器日志写一个消息（它建议增加`max_wal_size`的值）。        如果指定值时没有单位，则以秒为单位。默认值是 30 秒（`30s`）。零则关闭警告。如果`checkpoint_timeout`低于`checkpoint_warning`，则不会有警告产生。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `max_wal_size` (`integer`)            

  ​        在自动 WAL 检查点之间允许 WAL 增长到的最大尺寸。这是一个软限制，在特殊的情况下 WAL 尺寸可能会超过`max_wal_size`，        例如在重度负荷下、`archive_command`失败或者高的 `wal_keep_size`设置。        如果指定值时没有单位，则以兆字节为单位。默认为 1 GB。增加这个参数可能导致崩溃恢复所需的时间。        这个参数只能在`postgresql.conf` 或者服务器命令行中设置。       

- `min_wal_size` (`integer`)            

  ​        只要 WAL 磁盘用量保持在这个设置之下，在检查点时旧的 WAL 文件总是        被回收以便未来使用，而不是直接被删除。这可以被用来确保有足够的        WAL 空间被保留来应付 WAL 使用的高峰，例如运行大型的批处理任务。        如果指定值时没有单位，则以兆字节为单位。默认是 80 MB。这个参数只能在`postgresql.conf`        或者服务器命令行中设置。       

### 20.5.3. 归档

- `archive_mode` (`enum`)            

  ​        当启用`archive_mode`时，可以通过设置        [archive_command](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-ARCHIVE-COMMAND)命令将完成的 WAL 段发送到        归档存储。除用于禁用的`off`之外，还有两种模式：        `on`和`always`。在普通操作期间，这两种模式之间        没有区别，但是当设置为`always`时，WAL 归档器在归档恢复        或者后备模式下也会被启用。在`always`模式下，所有从归档恢复        的或者用流复制传来的文件将被（再次）归档。详见        [第 27.2.9 节](http://www.postgres.cn/docs/14/warm-standby.html#CONTINUOUS-ARCHIVING-IN-STANDBY)。               `archive_mode`和`archive_command`是独立的变量，这样可以在不影响归档模式的前提下修改`archive_command`。这个参数只能在服务器启动时设置。当`wal_level`被设置为`minimal`时，`archive_mode`不能被启用。       

- `archive_command` (`string`)            

  ​        本地 shell 命令被执行来归档一个完成的 WAL 文件段。字符串中的任何`%p`被替换成要被归档的文件的路径名， 而`%f`只被文件名替换（路径名是相对于服务器的工作目录， 即集簇的数据目录）。如果要在命令里嵌入一个真正的`%`字符，可以使用`%%`。有一点很重要，该命令只在成功时返回一个零作为退出状态。更多信息请见[第 26.3.1 节](http://www.postgres.cn/docs/14/continuous-archiving.html#BACKUP-ARCHIVING-WAL)。               这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。除非服务器启动时启用了`archive_mode`，否则它会被忽略。如果`archive_mode`被启用时，`archive_command`是一个空字符串（默认），WAL 归档会被临时禁用，但服务器仍会继续累计 WAL 段文件，期待着一个命令被提供。将`archive_command`设置为一个只返回真但不做任何事的命令（例如`/bin/true`或 Windows 上的`REM`）实际上会禁用归档，也会打破归档恢复所需的 WAL 文件链，因此只有在极少数情况下才能用。       

- `archive_timeout` (`integer`)            

  ​        [archive_command](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-ARCHIVE-COMMAND)仅在已完成的 WAL 段上调用。因此，如果你的服务器只产生很少的 WAL 流量（或产生流量的周期很长），那么在事务完成和它被安全地记录到归档存储之间将有一个很长的延迟。为了限制未归档数据存在的时间，你可以设置`archive_timeout`来强制服务器来周期性地切换到一个新的 WAL 段文件。        当这个参数被设置为大于零时，只要从上次段文件切换后过了参数所设置的时间量，并且已经有过任何数据库活动（包括一个单一检查点），服务器将切换到一个新的段文件（如果没有数据库活动则会跳过检查点）。        注意，由于强制切换而提早关闭的被归档文件仍然与完整的归档文件长度相同。因此，使用非常短的`archive_timeout`是不明智的 — 它将占用巨大的归档存储。一分钟左右的`archive_timeout`设置通常比较合理。如果你希望数据能被更快地从主服务器上复制下来，你应该考虑使用流复制而不是归档。如果指定值时没有单位，则以秒为单位。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

### 20.5.4. 归档恢复



​     本节描述了仅在恢复期间适用的设置。如果您希望执行任何后续恢复，则必须重置它们。    

​     “Recovery” 涵盖使用服务器作为备用服务器或用于执行目标恢复。     通常情况，备用模式用于提供高可用性和/或读可扩展性，而目标恢复用于从数据丢失中恢复。    

​     若要在备用模式下启动服务器，在数据目录中建立名为`standby.signal`的文件。     服务器将会进入恢复状态并且在到达归档WAL末尾时不会停止恢复，但将保持尝试继续恢复，通过连接到`primary_conninfo`设置指定的发送服务器和/或用`restore_command`获取新的WAL分段。     对于这种模式，来自本节的参数和[第 20.6.3 节](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-STANDBY) 是值得关注的。     [第 20.5.5 节](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET) 中的参数也会被应用，但通常在这种模式下没用。    

​     要启动服务器为目标恢复模式，需在数据目录中建立名为`recovery.signal`的文件。     如果同时创建了`standby.signal` 和 `recovery.signal` 文件，则优先使用备用模式。     目标恢复模式在归档的WAL全部回放或到达`recovery_target`时结束。     在这种模式下，将使用来自本节和 [第 20.5.5 节](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET) 的参数。    

- `restore_command` (`string`)            

  ​        用于获取 WAL 文件系列的一个已归档段的本地 shell 命令。这个参数是归档恢复所必需的，但是对于流复制是可选的。        在该字符串中的任何`%f`会被替换为从归档中获得的文件的名字，并且任何`%p`会被在服务器上的复制目标路径名替换（该路径名是相对于当前工作目录的，即集簇的数据目录）。        任何`%r`会被包含上一个可用重启点的文件的名字所替换。        在那些必须被保留用于使得一次恢复变成可重启的文件中，这个文件是其中最早的一个，因此这个信息可以被用来把归档截断为支持从当前恢复重启所需的最小值。        `%r`通常只被温备配置（见[第 27.2 节](http://www.postgres.cn/docs/14/warm-standby.html)）所使用。要嵌入一个真正的`%`字符，需要写成`%%`。               很重要的一点是，该命令只有在成功时才返回一个为零的退出状态。        该命令*将*会被询问不存在于归档中的文件名，当这样被询问时它必须返回非零。例子： `restore_command = 'cp /mnt/server/archivedir/%f "%p"' restore_command = 'copy "C:\\server\\archivedir\\%f" "%p"'  # Windows `        一个例外是如果该命令被一个信号（不是SIGTERM，它是数据库服务器关闭的一部分）或者一个 shell 错误（例如命令未找到）终止，则恢复将会中止并且服务器将不会启动。               这个参数只能在`postgresql.conf`文件中或通过服务器命令行进行设置。       

- `archive_cleanup_command` (`string`)            

  ​        这个可选参数指定了一个 shell 命令，它将在每一个重启点被执行。        `archive_cleanup_command`的目的是提供一种清除不再被后备服务器需要的旧的已归档 WAL 文件的机制。        任何`%r`会被替换为包含最后一个可用重启点的文件的名称。        那是使一次恢复变成可重启的所必须被*保留*的最早的文件，并且因此比`%r`更早的所有文件可以被安全地移除。        这个信息可以被用来把归档截断为支持从当前恢复重启所需的最小值。        对于单一后备配置，[pg_archivecleanup](http://www.postgres.cn/docs/14/pgarchivecleanup.html)模块常常被用在`archive_cleanup_command`中，例如： `archive_cleanup_command = 'pg_archivecleanup /mnt/server/archivedir %r'`        但是注意，如果多个后备服务器正在从同一个归档目录中恢复，你将需要保证只有当任意服务器都不再需要 WAL 文件时才会删除它们。        `archive_cleanup_command`通常被用于一种温后备配置（见[第 27.2 节](http://www.postgres.cn/docs/14/warm-standby.html)）中。        要在该命令中嵌入一个真正的`%`字符，需要写成`%%`。               如果该命令返回一个非零退出状态，则将会写出一个警告日志消息。        一个例外是如果该命令被一个信号或者一个 shell 错误（例如命令未找到）终止，则会抛出一个致命错误。               这个参数只能在 `postgresql.conf` 文件中设置或通过服务器命令行的方式。       

- `recovery_end_command` (`string`)            

  ​        这个参数指定了一个将只在恢复末尾被执行一次的 shell 命令。这个参数是可选的。        `recovery_end_command`的目的是为复制或恢复之后的清除提供一种机制。        与[archive_cleanup_command](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-ARCHIVE-CLEANUP-COMMAND)中相似，任何`%r`会被替换为包含最后一个可用重启点的文件的名称。               如果该命令返回一个非零退出状态，则一个警告日志消息将被写出并且不管怎样该数据库将继续启动。        一个例外是如果该命令被一个信号或者 shell 错误（例如命令未找到）中止，该数据库将不会继续启动。               这个参数只能在 `postgresql.conf` 文件中设置或通过服务器命令行的方式。       

### 20.5.5. 恢复目标

​      默认情况下，恢复将会一直恢复到 WAL 日志的末尾。下面的参数可以被用来指定一个更早的停止点。      在`recovery_target`、`recovery_target_lsn`、`recovery_target_name`、`recovery_target_time`和`recovery_target_xid`中，      最多只能使用一个，如果在配置文件中使用了多个，将会产生一个错误。这个参数只能在服务器启动时设置。	       

- `recovery_target`` = 'immediate'`            

  ​        这个参数指定恢复应该在达到一个一致状态后尽快结束，即尽早结束。在从一个在线备份中恢复时，这意味着备份结束的那个点。               在技术上，这是一个字符串参数，但是`'immediate'`是目前唯一允许的值。       

- `recovery_target_name` (`string`)            

  ​        这个参数指定（`pg_create_restore_point()`所创建）的已命名的恢复点，恢复将进入该恢复点。       

- `recovery_target_time` (`timestamp`)            

  ​        此参数指定恢复将执行的时间戳。精确的停止点还受到[recovery_target_inclusive](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE)得影响。               此参数的值是一个被`timestamp with time zone`数据类型接受的相同格式的时间戳，只不过你不能使用时区缩写（除非[timezone_abbreviations](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-TIMEZONE-ABBREVIATIONS)变量在配置文件中已提前设置）。         首选样式是使用 UTC 的数字偏移量，或者你可以写一个完整时区名称，例如 `Europe/Helsinki` 而不是 `EEST`。       

- `recovery_target_xid` (`string`)            

  ​        这个参数指定恢复将进入的事务 ID。记住虽然事务 ID 是在事务开始时顺序分配的，但是事务可能以不同的数字顺序完成。        那些在指定事务之前（也可以包括该事务）提交的事务将被恢复。精确的停止点也受到[recovery_target_inclusive](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE)的影响。       

- `recovery_target_lsn` (`pg_lsn`)            

  ​        此参数指定恢复将继续进行的预写日志位置的LSN。精确的停靠点也受 [recovery_target_inclusive](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE)的影响。        使用系统数据类型[`pg_lsn`](http://www.postgres.cn/docs/14/datatype-pg-lsn.html)解析此参数。       

​       下列选项进一步指定恢复目标，并且影响到达目标时会发生什么：     

- `recovery_target_inclusive` (`boolean`)            

  ​        指定我们是否仅在指定的恢复目标之后停止（`on`），或者仅在恢复目标之前停止（`off`）。        适用于[recovery_target_lsn](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-RECOVERY-TARGET-LSN)、[recovery_target_time](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-RECOVERY-TARGET-TIME)或者[recovery_target_xid](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-RECOVERY-TARGET-XID)被指定的情况。        这个设置分别控制事务是否有准确的目标WAL位置(LSN)、提交时间或事务ID将被包括在该恢复中。默认值为`on`。       

- `recovery_target_timeline` (`string`)            

  ​        指定恢复到一个特定的时间线中。该值可以是数字时间线 ID 或特殊值。        值`current`沿着与执行基本备份时相同的时间线恢复。        值`latest`将恢复到归档中能找到的最新的时间线，这在一个备用服务器中有用。`latest`是默认的。               你通常只需要在复杂的重恢复情况下设置这个参数，在这种情况下你需要返回到一个状态，该状态本身是在一次时间点恢复之后到达的。        相关讨论见[第 26.3.5 节](http://www.postgres.cn/docs/14/continuous-archiving.html#BACKUP-TIMELINES)。       

- `recovery_target_action` (`enum`)            

  ​        指定在达到恢复目标时服务器应该立刻采取的动作。默认动作是`pause`，这表示恢复将会被暂停。        `promote`表示恢复处理将会结束并且服务器将开始接受连接。        最后，`shutdown`将在达到恢复目标之后停止服务器。               使用`pause`设置的目的是：如果这个恢复目标就是恢复最想要的位置，就允许对数据库执行查询。        暂停的状态可以使用`pg_wal_replay_resume()`（见[表 9.89](http://www.postgres.cn/docs/14/functions-admin.html#FUNCTIONS-RECOVERY-CONTROL-TABLE)）继续，这会让恢复终结。        如果这个恢复目标不是想要的停止点，那么关闭服务器，将恢复目标设置改为一个稍后的目标并且重启以继续恢复。               要让实例在想要的重放点那里准备好，`shutdown`设置可以派上用场。        该实例将仍能重放更多 WAL 记录（并且事实上将不得不重放从下一次它被启动后最后一个检查点以来的 WAL 记录）。               注意由于在`recovery_target_action`被设置为`shutdown`时，`recovery.signal`将不会被移除，        任何后续的启动都将会以立刻关闭为终结，除非该配置被改变或者`recovery.signal`文件被手工移除。               如果没有设置恢复目标，这个设置没有效果。        如果没有启用[hot_standby](http://www.postgres.cn/docs/14/runtime-config-replication.html#GUC-HOT-STANDBY)，`pause`设置的动作将和`shutdown`一样。        如果在升级期间达到恢复目标，`pause` 的设置将与 `promote`的行为相同。               在任何情况下，如果已配置了恢复目标，但归档恢复在达到目标之前结束，则服务器将关闭，并出现致命错误。       

##  复制

- [20.6.1. 发送服务器](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SENDER)
- [20.6.2. 主服务器](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-PRIMARY)
- [20.6.3. 后备服务器](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-STANDBY)
- [20.6.4. 订阅者](http://www.postgres.cn/docs/14/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SUBSCRIBER)

​     这些设置控制内建*流复制*特性（见[第 27.2.5 节](http://www.postgres.cn/docs/14/warm-standby.html#STREAMING-REPLICATION)）的行为。服务器将可以是主控服务器或后备服务器。主控机能发送数据，而后备机总是被复制数据的接收者。当使用级联复制（见[第 27.2.7 节](http://www.postgres.cn/docs/14/warm-standby.html#CASCADING-REPLICATION)）时，后备服务器也可以是发送者，同时也是接收者。这些参数主要用于发送服务器和后备服务器，尽管某些只在主服务器上有意义。如果有必要，设置可以在集群中变化而不出问题。    

### 20.6.1. 发送服务器

​      这些参数可以在任何发送复制数据给一个或多个后备服务器的服务器上设置。主控机总是一个发送服务器，因此这些参数总是要在主控机上设置。这些参数的角色和含义不会在一个后备机变成主控机后改变。     

- `max_wal_senders` (`integer`)              

  ​        指定来自后备服务器或流式基础备份客户端的并发连接的最大数量（即同时运行 WAL 发送进程的最大数）。        默认值是`10`。值`0`意味着禁用复制。        突然的流客户端断开连接可能留下一个孤立连接槽（知道达到超时），因此这个参数应该设置得略高于最大客户端连接数，这样断开连接的客户端可以立刻重新连接。        这个参数只能在服务器启动时被设置。此外，`wal_level`必须设置为`replica`或更高级别以允许来自后备服务器的连接。                当运行备用服务器时，你必须将此参数设置为与主服务器上相同的或更高的值。否则，备用服务器中将不允许查询。        

- `max_replication_slots` (`integer`)              

  ​         指定服务器可以支持的复制槽（见[第 27.2.6 节](http://www.postgres.cn/docs/14/warm-standby.html#STREAMING-REPLICATION-SLOTS)）         最大数量。默认值为10。这个参数只能在服务器启动时设置。将它设置为一个比当前已有复制槽要少的值会阻碍服务器启动。此外，要允许使用复制槽，         `wal_level`必须被设置为`replica`或         更高。                 在订阅端，指定多少复制源头 (参见 [第 50 章](http://www.postgres.cn/docs/14/replication-origins.html)) 可以被同时跟踪，有效的限制了服务器上可以建立多少逻辑复制订阅。         设置它到一个低与当前跟踪复制源(体现在[pg_replication_origin_status](http://www.postgres.cn/docs/14/view-pg-replication-origin-status.html),不是 [pg_replication_origin](http://www.postgres.cn/docs/14/catalog-pg-replication-origin.html))的值将阻止服务器启动。        

- `wal_keep_size` (`integer`)              

  ​        指定在后备服务器需要为流复制获取日志段文件的情况下，`pg_wal`目录下所能保留的过去日志文件段的最小尺寸。        如果一个连接到发送服务器的后备服务器落后了超过`wal_keep_size`兆字节，发送服务器可以移除一个后备机仍然需要的 WAL 段，在这种情况下复制连接将被中断。        最终结果是下行连接也将最终失败（不过，如果在使用 WAL 归档，后备服务器可以通过从归档获取段来恢复）。               只设置`pg_wal`中保留的文件段的最小尺寸；系统可能需要为 WAL 归档或从一个检查点恢复保留更多段。        如果`wal_keep_size`为零（默认值）， 更多的空间来 存放WAL归档或从一个检查点恢复。        如果wal_keep_segments是零（缺省）， 系统不会为后备目的保留任何多余的段，因此后备服务器可用的旧 WAL 段的数量是一个上个检查点位置和 WAL 归档状态的函数。        如果此值被指定时没有单位，则视为兆字节。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `max_slot_wal_keep_size` (`integer`)              

  ​        指定[replication slots](http://www.postgres.cn/docs/14/warm-standby.html#STREAMING-REPLICATION-SLOTS) 所允许的在检查点时保留在 `pg_wal` 目录中的 WAL 文件的最大尺寸。        如果`max_slot_wal_keep_size` 为 -1（默认值），复制槽可能会保留无限数量的 WAL 文件。         否则，如果复制槽的restart_lsn比当前LSN滞后超过给定的大小，由于删除了所需的WAL文件，使用插槽的备用服务器可能无法继续复制。        你可以在[pg_replication_slots](http://www.postgres.cn/docs/14/view-pg-replication-slots.html)中查看复制槽有效的WAL。       

- `wal_sender_timeout` (`integer`)            

  ​        中断那些停止活动超过这个时间量的复制连接。这对发送服务器检测一个费用服务器崩溃或网络中断有用。        如果指定值时没有单位，则以毫秒为单位。默认值是 60 秒。值0将禁用超时机制。               对于跨越多个地理位置分布的集群，每个位置使用不同的值可以为集群管理带来更大的灵活性。        对于具有低延迟网络连接的备用服务器，较小的值有助于更快的故障检测;        对于位于远端位置的具有高延迟网络连接的备用服务器，较大的值有助于更好地判断备用服务器的健康状况。       

- `track_commit_timestamp` (`boolean`)            

  ​        记录事务的提交时间。这个参数只能在`postgresql.conf`        文件中或在服务器命令行上设置。默认值是`off`。       

### 20.6.2. 主服务器

​      这些参数可以在发送复制数据给一个或多个后备服务器的主控/主要服务器上设置。注意除了这些参数之外，在主控服务器上必须设置合适的[wal_level](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-WAL-LEVEL)，并且也启用可选的 WAL 归档（见[第 20.5.3 节](http://www.postgres.cn/docs/14/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING)）。这些参数值与后备服务器无关，尽管你可能希望为了准备好一个后备机转变成主控机来设置这些参数。     

- `synchronous_standby_names` (`string`)            

  ​        如[第 27.2.8 节](http://www.postgres.cn/docs/14/warm-standby.html#SYNCHRONOUS-REPLICATION)所述，这个参数指定一个支持*同步复制*的后备服务器的列表。        可能会有一个或者多个活动的同步后备服务器，在这些后备服务器确认收到它们的数据之后，等待提交的事务将被允许继续下去。        同步后备服务器是那些名字出现在这个列表前面，并且当前已连接并且正在实时流传输数据（如[`pg_stat_replication`](http://www.postgres.cn/docs/14/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW)视图中`streaming`的状态所示）的服务器。        指定多于一台同步后备可以得到非常高的可用性并且能防止数据丢失。               用于这一目的的后备服务器的名称是其`application_name`设置，它在后备服务器的连接信息中设置。        在物理复制后备的情况下，这应该被设置在`primary_conninfo`设置中，如果设置了，默认是[cluster_name](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-CLUSTER-NAME)的设置，否则为 `walreceiver`。        对于逻辑复制，可以在订阅的连接信息中设置。对于其他复制流消费者，请参考其文档。               这个参数使用下面的语法之一来指定一个后备服务器列表： `[FIRST] *`num_sync`* ( *`standby_name`* [, ...] ) ANY *`num_sync`* ( *`standby_name`* [, ...] ) *`standby_name`* [, ...] `        其中*`num_sync`*是事务需要等待其回复的同步后备服务器的数量，*`standby_name`*是一个后备服务器的名称。`FIRST`以及`ANY`指定从所列服务器中选取同步后备的方法。                关键词`FIRST`加上*`num_sync`*指定一种基于优先的同步复制，并且会让事务提交等待，直到它们的WAL记录被复制到基于优先级选择的*`num_sync`*台同步后备上为止。例如，设置`FIRST 3 (s1, s2, s3, s4)`将导致每次提交都等待来自三台较高优先级的后备机的答复，这三台后备机将从后备服务器`s1`、`s2`、`s3`以及`s4`中选出。在该列表中出现较早的后备服务器将被给予较高的优先级，并且将被考虑为同步后备。列表中出现的其他后备服务器表示潜在的同步后备。如果当前的任何同步后备因为某种原因断开连接，它将立刻被下一个最高优先级的后备服务器替代。关键词`FIRST`是可选的。               关键词`ANY`加上*`num_sync`*指定一种基于规定数量的同步复制，并且会让事务提交等待，直到它们的WAL记录被复制到所列出后备服务器中的*至少**`num_sync`*台上为止。例如，设置`ANY 3 (s1, s2, s3, s4)`将导致每次提交会在收到`s1`、`s2`、`s3`以及`s4`中任意三台后备服务器的回答后立刻继续下去。               `FIRST`和`ANY`是大小写不敏感的。如果这些关键词被用作后备服务器的名字，其*`standby_name`*必须被放在双引号内。               PostgreSQL版本 9.6 之前使用过第三种语法，目前也仍然支持。它和`FIRST`和*`num_sync`*等于1的第一种语法相同。例如，`FIRST 1 (s1, s2)`和`s1, s2`具有相同的含义：`s1`或者`s2`会被选中作为同步后备服务器。               特殊项`*`匹配任意后备名称。               没有机制强制后备服务器名称的唯一性。在出现重复的情况下，匹配的后备之一将被认为是较高优先级，不过无法弄清到底是哪一个。       注意         每一个*`standby_name`*都应该具有合法 SQL 标识符的形式，除非它是`*`。如果必要你可以使用双引号。但是注意在比较*`standby_name`*和后备机应用程序名称时是大小写不敏感的（不管有没有双引号）。                如果这里没有指定同步后备机名称，那么同步复制不能被启用并且事务提交将不会等待复制。这是默认的配置。即便当同步复制被启用时，个体事务也可以被配置为不等待复制，做法是将[synchronous_commit](http://www.postgres.cn/docs/14/runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT)参数设置为`local`或`off`。               这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `vacuum_defer_cleanup_age` (`integer`)            

  ​        指定`VACUUM`和HOT更新在清除死亡行版本之前，应该推迟多久（以事务数量计）。默认值是零个事务，表示死亡行版本将被尽可能快地清除，即当它们不再对任何打开的事务可见时尽快清除。在一个支持热后备服务器的主服务器上，你可能希望把这个参数设置为一个非零值，如[第 27.4 节](http://www.postgres.cn/docs/14/hot-standby.html)中所述。这允许后备机上的查询有更多时间来完成而不会由于先前的行清除产生冲突。但是，由于该值是用在主服务器上发生的写事务的数目衡量的，很难预测对后备机查询可用的附加时间到底是多少。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。               你也可以考虑设置后备服务器上的`hot_standby_feedback`作为使用这个参数的一种替代方案。               这无法阻止已经达到`old_snapshot_threshold`所指定年龄的死亡行被清除。       

### 20.6.3. 后备服务器

​      这些设置控制一个[standby server](http://www.postgres.cn/docs/14/warm-standby.html#STANDBY-SERVER-OPERATION)接收复制数据的行为。      它们在主服务器的值是无关的。     

- `primary_conninfo` (`string`)                

  ​          指定备用服务器用来连接发送服务器的连接字符串。这个字符串的格式在[第 34.1.1 节](http://www.postgres.cn/docs/14/libpq-connect.html#LIBPQ-CONNSTRING)中描述。          如果在这个字符串中有任何选项未被指定，那么将检查相应的环境变量（见[第 34.15 节](http://www.postgres.cn/docs/14/libpq-envars.html)）。          如果环境变量也没有被设置，则使用默认值。                   连接字符串应当指定发送服务器的主机名（或地址），以及端口号（如果它和备用服务器的默认端口不同）。          还要指定对应于发送服务器上合适权限角色的用户名（见[第 27.2.5.1 节](http://www.postgres.cn/docs/14/warm-standby.html#STREAMING-REPLICATION-AUTHENTICATION)）。          如果发送服务器要求口令认证，还需要提供一个口令。它可以在`primary_conninfo`字符串中提供，或者在后备服务器（使用`replication`作为数据库名）的一个单独`~/.pgpass`文件中提供。          不要在`primary_conninfo`字符串中指定一个数据库名。                   这个参数只能在 `postgresql.conf`文件或服务器命令行上设置。          如果在 WAL 接收器进程运行时更改此参数，则该进程将发出关机信号，并预期使用新设置重新启动（除非`primary_conninfo`为空字符串）。          如果服务器没有处于备用模式，则此设置无效。         

- `primary_slot_name` (`string`)                

  ​          有选择地指定通过流复制连接到发送服务器时使用一个现有的复制槽来控制上游节点上的资源移除（见[第 27.2.6 节](http://www.postgres.cn/docs/14/warm-standby.html#STREAMING-REPLICATION-SLOTS)）。          这个参数只能在 `postgresql.conf`文件或服务器命令行上设置。          如果在 WAL 接收器进程运行时更改此参数，则该进程将发出关机信号，并预期使用新设置重新启动（除非`primary_conninfo`为空字符串）。          如果没有设置`primary_conninfo`或服务器没有处于备用模式，则此设置无效。         

- `promote_trigger_file` (`string`)                

  ​          指定一个触发器文件，该文件的存在会结束后备机中的恢复。即使这个值没有被设置，你也能够使用`pg_ctl promote`或调用`pg_promote()`.来提升后备机。          这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。         

- `hot_standby` (`boolean`)            

  ​        指定在恢复期间，你是否能够连接并运行查询，如[第 27.4 节](http://www.postgres.cn/docs/14/hot-standby.html)中所述。默认值是`on`。这个参数只能在服务器启动时设置。它只在归档恢复期间或后备机模式下才有效。       

- `max_standby_archive_delay` (`integer`)            

  ​        当热后备机处于活动状态时，这个参数决定取消那些与即将应用的 WAL 项冲突的后备机查询之前，后备服务器应该等待多久，如[第 27.4.2 节](http://www.postgres.cn/docs/14/hot-standby.html#HOT-STANDBY-CONFLICT)中所述。        当 WAL 数据被从 WAL 归档（并且因此不是当前的 WAL）时，`max_standby_archive_delay`可以应用。        如果指定值时没有单位，则以毫秒为单位。默认值是 30 秒。值 -1 允许后备机一直等到冲突查询结束。        这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。               注意，`max_standby_archive_delay`与取消之前一个查询能够运行的最长时间不同；它表示应用任何一个 WAL 段数据能够被允许的最长总时间。因此，如果一个查询早于 WAL 段导致了显著的延迟，后续冲突查询将只有更少的时间。       

- `max_standby_streaming_delay` (`integer`)            

  ​        当热后备机处于活动状态时，这个参数决定取消那些与即将应用的 WAL 项冲突的后备机查询之前，后备服务器应该等待多久，如[第 27.4.2 节](http://www.postgres.cn/docs/14/hot-standby.html#HOT-STANDBY-CONFLICT)中所述。        当 WAL 数据正在通过流复制被接收时，`max_standby_streaming_delay`可以应用。        如果指定值时没有单位，则以毫秒为单位。默认值是 30 秒。值 -1 允许后备机一直等到冲突查询结束。        这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。               注意，`max_standby_streaming_delay`与取消之前一个查询能够运行的最长时间不同；它表示在从主服务器接收到 WAL 数据并立刻应用它能够被允许的最长总时间。因此，如果一个查询导致了显著的延迟，后续冲突查询将只有更少的时间，直到后备服务器再次赶上进度。       

- `wal_receiver_create_temp_slot` (`boolean`)            

  ​        指定在未配置永久复制槽时，WAL 接收器进程是否应在远程实例上创建临时复制槽（使用 [primary_slot_name](http://www.postgres.cn/docs/14/runtime-config-replication.html#GUC-PRIMARY-SLOT-NAME)）。        默认为"关闭"。 此参数只能在`postgresql.conf`文件或服务器命令行中设置。        如果在 WAL 接收器进程运行时更改此参数，则该进程将发出关机的信号，并预期使用新设置重新启动。       

- `wal_receiver_status_interval` (`integer`)            

  ​       指定在后备机上的 WAL 接收者进程向主服务器或上游后备机发送有关复制进度的信息的最小频度，它可以使用[`pg_stat_replication`](http://www.postgres.cn/docs/14/monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW)视图看到。       后备机将报告它已经写入的上一个预写式日志位置、它已经刷到磁盘的上一个位置以及它已经应用的最后一个位置。       这个参数的值是报告之间的最大时间量。       每次写入或刷出位置改变时会发送状态更新，或者按这个参数的指定的频度发送，如果设置为非零值。        在其他情况下发送更新时忽略此参数；例如，当现有的WAL处理完成或当`synchronous_commit`设置为`remote_apply`时。       因此，应用位置可能比真实位置略微滞后。       如果指定值时没有单位，则以秒为单位。       默认值是 10 秒。       这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。      

- `hot_standby_feedback` (`boolean`)            

  ​        指定一个热后备机是否将会向主服务器或上游后备机发送有关于后备机上当前正被执行的查询的反馈。这个参数可以被用来排除由于记录清除导致的查询取消，但是可能导致在主服务器上用于某些负载的数据库膨胀。反馈消息的发送频度不会高于每个`wal_receiver_status_interval`周期发送一次。默认值是`off`。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。               如果使用级联复制，反馈将被向上游传递直到它最后到达主服务器。后备机在接收到反馈之后除了传递给上游不会做任何其他操作。               这个设置不会覆盖主服务器上的`old_snapshot_threshold`的行为，后备服务器上一个超过了主服务器年龄阈值的快照可能会变得不可用，导致后备服务器上事务的取消。这是因为`old_snapshot_threshold`是为了对死亡行能够存在的时间给出一个绝对限制，不然就会因为一个后备服务器的配置而被违背。       

- `wal_receiver_timeout` (`integer`)            

  ​        中止处于非活动状态超过这个时间量的复制链接。这对于正在接收的后备服务器检测主服务器崩溃或网络断开有用。        如果指定值时没有单位，则以毫秒为单位。默认值是 60 秒。        这个参数只能在`postgresql.conf`文件中或者服务器命令行中设置。       

- `wal_retrieve_retry_interval` (`integer`)            

  ​        指定当从任何来源（流复制、本地`pg_wal`或者 WAL 归档）都得不到 WAL 数据时，后备服务器应该等待多久才去重新尝试获取 WAL 数据。        如果指定值时没有单位，则以毫秒为单位。默认值是 5 秒。        这个参数只能在`postgresql.conf`文件或者服务器命令行中设置。               这个参数对恢复中的节点需要为新 WAL 数据可用等待多少时间的配置有用。        例如，在归档恢复中，通过减小这个参数的值可以让恢复更积极地检测新的        WAL 日志文件。在一个 WAL 活动较低的系统上，增加这个参数的值可以减        少访问 WAL 归档所必需的请求数量，这对于例如云环境是有用的，在其中        对于基础设施的访问时间也是被考虑的。       

- `recovery_min_apply_delay` (`integer`)            

  ​        默认情况下，后备服务器会尽快恢复来自于发送服务器的 WAL 记录。有一份数据的延时拷贝是有用的，它能提供机会纠正数据丢失错误。        这个参数允许你将恢复延迟一段指定的时间量。        例如，如果你设置这个参数为`5min`，对于一个事务提交，只有当后备机上的系统时钟超过主服务器报告的提交时间至少 5分钟时，后备机才会重放该事务。        如果指定值时没有单位，则以毫秒为单位。默认为0，不增加延迟。               有可能服务器之间的复制延迟会超过这个参数的值，在这种情况下则不会增加延迟。        注意延迟是根据主服务器上写 WAL 的时间戳以及后备机上的当前时间来计算。        由于网络延迟或者级联复制配置导致的传输延迟可能会显著地减少实际等待时间。        如果主服务器和后备机上的系统时钟不同步，这会导致恢复比预期的更早应用记录。        但这不是一个主要问题，因为这个参数有用的设置比服务器之间的典型事件偏差要大得多。               只有在事务提交的 WAL 记录上才会发生延迟。其他记录还是会被尽可能快地重放，这不会成为问题，因为 MVCC 可见性规则确保了在对应的提交记录被应用之前它们的效果不会被看到。               一旦恢复中的数据库已经达到一致状态，延迟就会产生，直到后备机被提升或者触发。在那之后，后备机将会结束恢复并且不再等待。               这个参数的目的是和流复制部署一起使用，但是，如果指定了该参数，除了崩溃恢复之外所有的情况下都会遵守它。        使用这个特性也会让`hot_standby_feedback`被延迟，这可能导致主服务器的膨胀，两者一起使用时要小心。                警告          当`synchronous_commit`被设置为`remote_apply`时，同步复制会受到这个设置的影响，每一个`COMMIT`都需要等待被应用。                        这个参数只能在`postgresql.conf`文件中或在服务器命令行中设置。       

### 20.6.4. 订阅者

​      这些设置控制逻辑复制订阅者的行为。它们在发布者上的值与此无关。     

​      注意，配置参数`wal_receiver_timeout`、`wal_receiver_status_interval`以及`wal_retrieve_retry_interval`也影响逻辑复制工作者。     

- `max_logical_replication_workers` (`int`)            

  ​        指定逻辑复制工作者的最大数目。这同时包括应用工作者和表同步工作者。               逻辑复制工作者是从`max_worker_processes`定义的池中取出的。               默认值是4。        这个参数只能在服务器启动时被设置。       

- `max_sync_workers_per_subscription` (`integer`)            

  ​        每个订阅的同步工作者的最大数目。这个参数控制订阅初始化期间或者新表增加时的初始数据拷贝的并行度。               当前，每个表只能有一个同步工作者。               同步工作者是从`max_logical_replication_workers`定义的池中取出的。               默认值为2。        这个参数只能在`postgresql.conf`文件中或服务器命令行上设置。       

## 查询规划

- [20.7.1. 规划器方法配制](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE)
- [20.7.2. 规划器代价常量](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS)
- [20.7.3. 遗传查询优化](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO)
- [20.7.4. 其他规划器选项](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-OTHER)

### 20.7.1. 规划器方法配制

​       这些配置参数提供了影响查询优化器选择查询规划的原始方法。       如果优化器 为特定的查询选择的缺省规划并不是最优，那么我们就可以通过使用这些  配置参数强制优化器选择一个更好的规划来temporary解决这个问题。       不过，永久地关闭这些设置几乎从不是个好主意。       更好的改善优化器 选择规划的方法包括调节Section 18.6.2、 更频繁运行ANALYZE、增大配置参数  default_statistics_target的值、使用 ALTER TABLE SET STATISTICS为某个字段增加收集的统计信息。       这些配置参数影响查询优化器选择查询计划的暴力方法。       如果优化器为一个特定查询选择的默认计划不是最优的，一种*临时*解决方案是使用这些配置参数之一来强制优化器选择一个不同的计划。       提高优化器选择的计划质量的更好的方式包括调整规划器的代价常数（见[第 20.7.2 节](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS)）、手工运行[`ANALYZE`](http://www.postgres.cn/docs/14/sql-analyze.html) 、增加[default_statistics_target](http://www.postgres.cn/docs/14/runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET)配置参数的值以及使用`ALTER TABLE SET STATISTICS`增加为特定列收集的统计信息量。      

- `enable_async_append` (`boolean`)            

  ​        激活或禁用查询计划的关于异步感知附加计划类型的使用。        默认为`on`。       

- `enable_bitmapscan` (`boolean`)                  

  ​        允许或禁止查询规划器使用位图扫描计划类型。默认值是`on`。       

- `enable_gathermerge` (`boolean`)            

  ​        启用或者禁用查询规划器对收集归并计划类型的使用。默认值是`on`。       

- `enable_hashagg` (`boolean`)            

  ​        允许或禁用查询规划器使用哈希聚集计划类型。默认值是`on`。       

- `enable_hashjoin` (`boolean`)            

  ​        允许或禁止查询规划器使用哈希连接计划类型。默认值是`on`。       

- `enable_incremental_sort` (`boolean`)            

  ​        启用或禁用查询规划器对增量排序步骤的使用。默认为`on`。       

- `enable_indexscan` (`boolean`)                  

  ​        允许或禁止查询规划器使用索引扫描计划类型。默认值是`on`。       

- `enable_indexonlyscan` (`boolean`)            

  ​        允许或禁止查询规划器使用只用索引扫描计划类型（见[第 11.9 节](http://www.postgres.cn/docs/14/indexes-index-only-scans.html)）。默认值是`on`。       

- `enable_material` (`boolean`)            

  ​        允许或者禁止查询规划器使用物化。它不可能完全禁用物化，但是关闭这个变量将阻止规划器插入物化节点，除非为了保证正确性。默认值是`on`。       

- `enable_memoize` (`boolean`)            

  ​        启用或禁用查询计划器对memoize计划的使用，以便缓存在嵌套循环连接中参数化扫描的结果。        在当前参数的结果已经在缓存中时，此计划类型允许跳过对底层计划的扫描。        当新条目需要更多空间时，不太常用的查询结果可能会从缓存中去除。        默认值是`on`。       

- `enable_mergejoin` (`boolean`)            

  ​        允许或禁止查询规划器使用归并连接计划类型。默认值是`on`。       

- `enable_nestloop` (`boolean`)            

  ​        允许或禁止查询规划器使用嵌套循环连接计划。它不可能完全禁止嵌套循环连接，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是`on`。       

- `enable_parallel_append` (`boolean`)            

  ​        允许或禁止查询规划器使用并行追加计划类型。默认值是`on`。       

- `enable_parallel_hash` (`boolean`)             

  ​        允许或禁止查询规划器对并行哈希使用哈希连接计划类型。如果哈希连接计划也没有启用，这个参数没有效果。默认值是`on`。       

- `enable_partition_pruning` (`boolean`)             

  ​        允许或者禁止查询规划器从查询计划中消除一个分区表的分区。这也控制着规划器产生允许执行器在查询执行期间移除（忽略）分区的查询计划的能力。默认值是`on`。详情请参考[第 5.11.4 节](http://www.postgres.cn/docs/14/ddl-partitioning.html#DDL-PARTITION-PRUNING)。       

- `enable_partitionwise_join` (`boolean`)            

  ​        允许或者禁止查询规划器使用面向分区的连接，这使得分区表之间的连接以连接匹配的分区的方式来执行。        面向分区的连接当前只适用于连接条件包括所有分区键的情况，连接条件必须是相同的数据类型并且子分区集合要1对1匹配。        由于面向分区的连接规划在规划期间会使用可观的CPU时间和内存，所以默认值为`off`。       

- `enable_partitionwise_aggregate` (`boolean`)            

  ​        允许或者禁止查询规划器使用面向分区的分组或聚集，这使得在分区表上的分组或聚集可以在每个分区上分别执行。如果`GROUP BY`子句不包括分区键，只有部分聚集能够以基于每个分区的方式执行，并且finalization必须最后执行。由于面向分区的分组或聚集在规划期间会使用可观的CPU时间和内存，所以默认值为`off`。       

- `enable_seqscan` (`boolean`)                  

  ​        允许或禁止查询规划器使用顺序扫描计划类型。它不可能完全禁止顺序扫描，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是`on`。       

- `enable_sort` (`boolean`)            

  ​        允许或禁止查询规划器使用显式排序步骤。它不可能完全禁止显式排序，但是关闭这个变量将使得规划器尽可能优先使用其他方法。默认值是`on`。       

- `enable_tidscan` (`boolean`)            

  ​        允许或禁止查询规划器使用TID扫描计划类型。默认值是`on`。       

### 20.7.2. 规划器代价常量

​     这一节中描述的*代价*变量可以按照任意尺度衡量。我们只关心它们的相对值，将它们以相同的因子缩放不会影响规划器的选择。默认情况下，这些代价变量是基于顺序页面获取的代价的，即`seq_page_cost`被设置为`1.0`并且其他代价变量都参考它来设置。不过你可以使用你喜欢的不同尺度，例如在一个特定机器上的真实执行时间。    

### 注意

​     不幸的是，没有一种良定义的方法来决定代价变量的理想值。它们最好被作为一个特定安装将接收到的查询的平均值来对待。这意味着基于少量的实验来改变它们是有风险的。    

- `seq_page_cost` (`floating point`)            

  ​        设置规划器计算一次顺序磁盘页面抓取的开销。默认值是1.0。 通过设置同名的表空间参数，这个值可以重写为一个特定的表空间。 参阅ALTER TABLESPACE。        设置规划器对一系列顺序磁盘页面获取中的一次的代价估计。默认值是 1.0。通过把表和索引放在一个特殊的表空间（要设置该表空间的同名参数）中可以覆盖这个值（见[ALTER TABLESPACE](http://www.postgres.cn/docs/14/sql-altertablespace.html)）。       

- `random_page_cost` (`floating point`)            

  ​        设置规划器对一次非顺序获取磁盘页面的代价估计。默认值是 4.0。通过把表和索引放在一个特殊的表空间（要设置该表空间的同名参数）中可以覆盖这个值（见[ALTER TABLESPACE](http://www.postgres.cn/docs/14/sql-altertablespace.html)）。               减少这个值（相对于`seq_page_cost`）将导致系统更倾向于索引扫描；提高它将让索引扫描看起来相对更昂贵。你可以一起提高或降低两个值来改变磁盘 I/O 代价相对于 CPU 代价的重要性，后者由下列参数描述。                对磁盘存储的随机访问通常比顺序访问要贵不止四倍。但是，由于对磁盘的大部分随机访问（例如被索引的读取）都被假定在高速缓冲中进行，所以使用了一个较低的默认值（4.0）。默认值可以被想成把随机访问建模为比顺序访问慢 40 倍，而期望 90% 的随机读取会被缓存。               如果你相信 90% 的缓冲率对你的负载是一个不正确的假设，你可以增加 random_page_cost 来更好的反映随机存储读取的真正代价。        相应地，如果你的数据可以完全放在高速缓存中（例如当数据库小于服务器总内存时），降低 random_page_cost 可能是合适的。        为具有很低的随机读取代价的存储（例如固态驱动器）采用较低的 random_page_cost 值可能更好，例如`1.1`。       提示         虽然允许你将random_page_cost设置的比 seq_page_cost小，但是物理上的实际情况并不受此影响。  然而当所有数据库都位于内存中时，两者设置为相等是非常合理的，因为 在此情况下，乱序抓取并不比顺序抓取开销更大。同样，在缓冲率很高的  数据库上，你应当相对于 CPU 开销同时降低这两个值，因为获取内存中 的页比通常情况下的开销小许多。         尽管系统可以是你把`random_page_cost`设置得小于`seq_page_cost`，但是实际上没有意义。不过，如果数据库被整个缓存在 RAM 中，将它们设置为相等是有意义的，因为在那种情况中不按顺序访问页面是没有惩罚值的。同样，在一个高度缓存化的数据库中，你应该相对于 CPU 参数降低这两个值，因为获取一个已经在 RAM 中的页面的代价要远小于通常情况下的代价。        

- `cpu_tuple_cost` (`floating point`)            

  ​        设置规划器对一次查询中处理每一行的代价估计。默认值是 0.01。       

- `cpu_index_tuple_cost` (`floating point`)            

  ​        设置规划器对一次索引扫描中处理每一个索引项的代价估计。默认值是 0.005。       

- `cpu_operator_cost` (`floating point`)            

  ​        设置规划器对于一次查询中处理每个操作符或函数的代价估计。默认值是 0.0025。       

- `parallel_setup_cost` (`floating point`)            

  ​        设置规划器对启动并行工作者进程的代价估计。默认是 1000。       

- `parallel_tuple_cost` (`floating point`)            

  ​        设置规划器对于从一个并行工作者进程传递一个元组给另一个进程的代价估计。默认是 0.1。       

- `min_parallel_table_scan_size` (`integer`)            

  ​        为必须扫描的表数据量设置一个最小值，扫描的表数据量超过这一个值才会考虑使用并行扫描。        对于并行顺序扫描，被扫描的表数据量总是等于表的尺寸，但是在使用索引时，被扫描的表数据量通常会更小。        如果指定值时没有单位，则以块为单位，即`BLCKSZ`字节，通常为8kB。默认值是8兆字节（`8MB`）。       

- `min_parallel_index_scan_size` (`integer`)            

  ​        为必须扫描的索引数据量设置一个最小值，扫描的索引数据量超过这一个值时才会考虑使用并行扫描。        注意并行索引扫描通常并不会触及整个索引，它是规划器认为该扫描会实际用到的相关页面的数量。        这个参数还用于决定特定的索引是否参与并行vacuum。参见[VACUUM](http://www.postgres.cn/docs/14/sql-vacuum.html)。        如果指定值时没有单位，则以块为单位，即`BLCKSZ`字节，通常为8kB。默认值是512千字节（`512kB`）。       

- `effective_cache_size` (`integer`)            

  ​        设置规划器对一个单一查询可用的有效磁盘缓冲区尺寸的假设。        这个参数会被考虑在使用一个索引的代价估计中，更高的数值会使得索引扫描更可能被使用，更低的数值会使得顺序扫描更可能被使用。        在设置这个参数时，你还应该考虑PostgreSQL的共享缓冲区以及将被用于PostgreSQL数据文件的内核磁盘缓冲区，尽管有些数据可能在两个地方都存在。        另外，还要考虑预计在不同表上的并发查询数目，因为它们必须共享可用的空间。        这个参数对PostgreSQL分配的共享内存尺寸没有影响，它也不会保留内核磁盘缓冲，它只用于估计的目的。系统也不会假设在查询之间数据会保留在磁盘缓冲中。        如果指定值时没有单位，则以块为单位，即`BLCKSZ`字节，通常为8kB。        默认值是 4吉字节（`4GB`）。(如果`BLCKSZ`不是8kB，默认值会按比例缩放它。)       

- `jit_above_cost` (`floating point`)            

  ​        设置激活JIT编译的查询代价，如果查询代价超过这个值就会激活JIT编译（如果启用了JIT，见[第 32 章](http://www.postgres.cn/docs/14/jit.html)）。执行JIT会消耗一些规划时间，但是能够加速查询执行。将这个值设置为`-1`会禁用JIT编译。默认值是`100000`。       

- `jit_inline_above_cost` (`floating point`)            

  ​        设置JIT编译尝试内联函数和操作符的查询代价阈值，如果查询代价超过这个值，JIT编译就会尝试内联。内联会增加规划时间，但是可以提高执行速度。将这个参数设置成小于`jit_above_cost`是没有意义的。将这个参数设置为`-1`会禁用内联。默认值是`500000`。       

- `jit_optimize_above_cost` (`floating point`)            

  ​        设置JIT编译应用优化的查询代价阈值，如果查询代价超过这个值，JIT编译就会应用开销较大的优化。这类优化会增加规划时间，但是更能够改进执行速度。将这个参数设置成小于`jit_above_cost`是没有意义的，并且将它设置成大于`jit_inline_above_cost`也未必有益。将这个参数设置为`-1`会禁用开销较大的优化。默认值是`500000`。       

### 20.7.3. 遗传查询优化

​      GEQO是一个使用探索式搜索来执行查询规划的算法。它可以降低负载查询的规划时间。 同时，GEQO的检索是随机的，因此它的规划可能会不可确定。 更多信息参阅Chapter 50。      遗传查询规划器（GEQO）是一种使用启发式搜索来进行查询规划的算法。它可以降低对于复杂查询（连接很多表的查询）的规划时间，但是代价是它产生的计划有时候要差于使用穷举搜索算法找到的计划。详见[第 60 章](http://www.postgres.cn/docs/14/geqo.html)。     

- `geqo` (`boolean`)                        

  ​        允许或禁止遗传查询优化。默认是启用。在生产环境中通常最好不要关闭它。`geqo_threshold`变量提供了对 GEQO 更细粒度的空值。       

- `geqo_threshold` (`integer`)            

  ​        只有当涉及的`FROM`项数量至少有这么多个的时候，才使用遗传查询优化（注意一个`FULL OUTER JOIN`只被计为一个`FROM`项）。默认值是 12。对于更简单的查询，通常会使用普通的穷举搜索规划器，但是对于有很多表的查询穷举搜索会花很长时间，通常比执行一个次优的计划带来的惩罚值还要长。因此，在查询尺寸上的一个阈值是管理 GEQO 使用的一种方便的方法。       

- `geqo_effort` (`integer`)            

  ​        控制 GEQO 里规划时间和查询规划的有效性之间的平衡。这个变量必须是 一个范围从 1 到 10 的整数。缺省值是 5 。大的数值增加花在进行查询 规划上面的时间，但是也很可能会提高选中更有效的查询规划的几率。        控制 GEQO 中规划时间和查询计划质量之间的折中。这个变量必须是位于 1 到 10 之间的一个整数。默认值是 5。更大的值会增加花在查询规划上的时间，但是同时也增加了选择一个高效查询计划的可能性。               `geqo_effort`实际并不直接做任何事情；它只是被用来计算其他影响 GEQO 行为的变量（如下所述）的默认值。如果你愿意，你可以手工设置其他参数。       

- `geqo_pool_size` (`integer`)            

  ​        控制 GEQO 使用的池尺寸，它就是遗传种群中的个体数目。它必须至少为 2，且有用的值通常在 100 到 1000 之间。如果它被设置为零（默认设置）则会基于`geqo_effort`和查询中表的数量选择一个合适的值。       

- `geqo_generations` (`integer`)            

  ​        控制 GEQO 使用的子代数目。子代的意思是算法的迭代次数。它必须至少 是 1 ，有用的值范围和池大小相同。如果设置为零(缺省)，那么将基于 geqo_pool_size选取合适的值。        控制 GEQO 使用的代数，也是算法的迭代次数。它必须至少为 1，并且有用值的范围和池尺寸相同。如果它被设置为零（默认设置）则会基于`geqo_pool_size`选择一个合适的值。       

- `geqo_selection_bias` (`floating point`)            

  ​        控制 GEQO 使用的选择偏好。选择偏好是种群中的选择压力。值可以是 1.5 到 2.0 之间，后者是默认值。       

- `geqo_seed` (`floating point`)            

  ​        控制 GEQO 使用的随机数生成器的初始值，随机数生成器用于在连接顺序搜索空间中选择随机路径。该值可以从 0 （默认值）到 1。变化该值会改变被探索的连接路径集合，并且可能导致找到一个更好或更差的路径。       

### 20.7.4. 其他规划器选项

- `default_statistics_target` (`integer`)            

  ​        为没有通过`ALTER TABLE SET STATISTICS`设置列相关目标的表列设置默认统计目标。更大的值增加了需要做`ANALYZE`的时间，但是可能会改善规划器的估计质量。默认值是 100。有关PostgreSQL查询规划器使用的统计信息的更多内容， 请参考[第 14.2 节](http://www.postgres.cn/docs/14/planner-stats.html)。       

- `constraint_exclusion` (`enum`)                  

  ​        控制查询规划器对表约束的使用，以优化查询。        `constraint_exclusion`的允许值是`on`（对所有表检查约束）、`off`（从不检查约束）和`partition`（只对继承的子表和`UNION ALL`子查询检查约束）。        `partition`是默认设置。它通常与传统的继承树一起使用来提高性能。              当对一个特定表允许这个参数，规划器比较查询条件和表的`CHECK`约束，并且忽略那些条件违反约束的表扫描。例如： `CREATE TABLE parent(key integer, ...); CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent); CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent); ... SELECT * FROM parent WHERE key = 2400; `         在启用约束排除时，这个`SELECT`将完全不会扫描`child1000`，从而提高性能。               目前，约束排除只在通过继承树实现表分区的情况中被默认启用。为所有表启用它会增加额外的规划开销，特别是在简单查询上并且不会产生任何好处。        如果没有用传统继承树分区的表时，最好是完全关闭它。(注意分区表的等效特性是由单独的参数控制的，[enable_partition_pruning](http://www.postgres.cn/docs/14/runtime-config-query.html#GUC-ENABLE-PARTITION-PRUNING).)               更多关于使用约束排除实现分区的信息请参阅[第 5.11.5 节](http://www.postgres.cn/docs/14/ddl-partitioning.html#DDL-PARTITIONING-CONSTRAINT-EXCLUSION)。       

- `cursor_tuple_fraction` (`floating point`)            

  ​        设置规划器对将被检索的一个游标的行的比例的估计。默认值是 0.1。更小的值使得规划器偏向为游标使用“快速开始”计划，它将很快地检索前几行但是可能需要很长时间来获取所有行。更大的值强调总的估计时间。最大设置为 1.0，游标将和普通查询完全一样地被规划，只考虑总估计时间并且不考虑前几行会被多快地返回。       

- `from_collapse_limit` (`integer`)            

  ​        如果生成的`FROM`列表不超过这么多项，规划器将把子查询融合到上层查询。较小的值可以减少规划时间，但是可能 会生成较差的查询计划。默认值是 8。详见[第 14.3 节](http://www.postgres.cn/docs/14/explicit-joins.html)。               将这个值设置为[geqo_threshold](http://www.postgres.cn/docs/14/runtime-config-query.html#GUC-GEQO-THRESHOLD)或更大，可能触发使用 GEQO 规划器，从而产生非最优计划。见[第 20.7.3 节](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO)。       

- `jit` (`boolean`)            

  ​        决定如果可用（见[第 32 章](http://www.postgres.cn/docs/14/jit.html)），PostgreSQL是否可以使用JIT编译。默认值是`on`。       

- `join_collapse_limit` (`integer`)            

  ​        如果得出的列表中不超过这么多项，那么规划器将把显式`JOIN`（除了`FULL JOIN`）结构重写到 `FROM`项列表中。较小的值可减少规划时间，但是可能会生成差些的查询计划。               默认情况下，这个变量被设置成和`from_collapse_limit`相同， 这样适合大多数使用。把它设置为 1 可避免任何显式`JOIN`的重排序。因此查询中指定的显式连接顺序就是关系被连接的实际顺序。因为查询规划器并不是总能 选取最优的连接顺序，高级用户可以选择暂时把这个变量设置为 1，然后显式地指定他们想要的连接顺序。更多信息请见[第 14.3 节](http://www.postgres.cn/docs/14/explicit-joins.html)。               将这个值设置为[geqo_threshold](http://www.postgres.cn/docs/14/runtime-config-query.html#GUC-GEQO-THRESHOLD)或更大，可能触发使用 GEQO 规划器，从而产生非最优计划。见[第 20.7.3 节](http://www.postgres.cn/docs/14/runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO)。       

- `plan_cache_mode` (`enum`)            

  ​        准备语句（显式准备或隐式生成的，例如 PL/pgSQL）可以使用自定义或通用计划执行。         使用其特定的参数值集为每个执行重新生成自定义计划，而通用计划不依赖于参数值，并且可以在执行中重复使用。         因此，使用通用计划可以节省计划时间，但如果理想计划严重依赖参数值，则通用计划可能效率低下。        这些选项之间的选择通常是自动进行的，但可以通过`plan_cache_mode`覆盖它。        允许的值为 `auto` (默认的),`force_custom_plan` 和 `force_generic_plan`。        这个设置是在执行缓存计划时考虑，而不是在准备计划时考虑。        更多信息请参阅 [PREPARE](http://www.postgres.cn/docs/14/sql-prepare.html).       

## 错误报告和日志

- [20.8.1. 在哪里做日志](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHERE)
- [20.8.2. 什么时候记录日志](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHEN)
- [20.8.3. 记录什么到日志](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHAT)
- [20.8.4. 使用 CSV 格式的日志输出](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-CSVLOG)
- [20.8.5. 进程标题](http://www.postgres.cn/docs/14/runtime-config-logging.html#id-1.6.7.11.7)



### 20.8.1. 在哪里做日志



- `log_destination` (`string`)            

  ​        PostgreSQL支持多种方法来记录服务器消息，包括stderr、csvlog和syslog。在 Windows 上还支持eventlog。设置这个参数为一个由想要的日志目的地的列表，之间用逗号分隔。默认值是只记录到stderr。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。               如果csvlog被包括在`log_destination`中，日志项会以“逗号分隔值” （CSV）格式被输出，这样可以很方便地把日志载入到程序中。详见[第 20.8.4 节](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-CSVLOG)。要产生 CSV 格式的日志输出，必须启用[logging_collector](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOGGING-COLLECTOR)。               当包括有stderr或csvlog时，会创建文件`current_logfiles`来记录当前正在被日志收集器使用的日志文件的位置以及相关的日志目的地。这提供了一种查找实例当前使用的日志的便利手段。这里是该文件内容的一个例子： `stderr log/postgresql.log csvlog log/postgresql.csv `         当由于轮转效应创建一个新的日志文件时以及`log_destination`被重载时，`current_logfiles`文件会被重建。当`log_destination`中不包括stderr和csvlog时以及当日志收集器被禁用时，这个文件会被删除。       注意         在大多数 Unix 系统上，你将需要修改系统的syslog守护进程的配置来使用`log_destination`的syslog选项。PostgreSQL可以在syslog设备`LOCAL0`到`LOCAL7`中记录（见[syslog_facility](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-SYSLOG-FACILITY)），但是大部分平台上的默认syslog配置会丢弃所有这种消息。你将需要增加这样的内容： `local0.*    /var/log/postgresql `         到syslog守护进程的配置文件来让它工作。                 在 Windows 上，当你使用`log_destination`的`eventlog`选项时，你应该在操作系统中注册一个事件源极其库，这样 Windows 事件查看器能够清楚地显示事件日志消息。详见[第 19.12 节](http://www.postgres.cn/docs/14/event-log-registration.html)。        

- `logging_collector` (`boolean`)            

  ​         这个参数启用*日志收集器*，它是一个捕捉被发送到stderr的日志消息的后台进程，并且它会将这些消息重定向到日志文件中。这种方法比记录到syslog通常更有用，因为某些类型的消息不会在syslog输出中出现（一个常见的例子是动态链接器错误消息；另一个例子是由`archive_command`等脚本产生的错误消息）。这个参数只能在服务器启动时设置。       注意         也可以不使用日志收集器而把日志记录到stderr，日志消息将只会去到服务器的stderr被定向到的位置。不过，那种方法只适合于低日志量，因为它没有提供方法来轮转日志文件。还有，在某些不使用日志收集器的平台上可能会导致丢失或者混淆日志输出，因为多个进程并发写入同一个日志文件时会覆盖彼此的输出。        注意          日志收集器被设计成从来不会丢失消息。这意味着在极高的负载下，如果服务器进程试图在收集器已经落后时发送更多的日志消息，那么它会被阻塞。相反，syslog倾向于在无法写入消息时丢掉消息，这意味着在这样的情况下它可能会无法记录某些消息，但是它不会阻塞系统的其他部分。        

- `log_directory` (`string`)            

  ​        当`logging_collector`被启用时，这个参数决定日志文件将被在哪个目录下创建。它可以被指定为一个绝对路径，也可以被指定为一个相对于集簇数据目录的相对路径。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。        默认是`log`。       

- `log_filename` (`string`)            

  ​        当`logging_collector`被启用时，这个参数设置被创建的日志文件的文件名。        该值被视为一种`strftime`模式，因此`%`转义可以被用来指定根据时间变化的文件名（注意如果有任何时区独立的`%`转义，计算将在由[log_timezone](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-TIMEZONE)指定的时区中完成）。        被支持的`%`转义和开放组织的[strftime](https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html)说明中列举的类似。        注意系统的`strftime`不会被直接使用，因此平台相关（非标准）的扩展无法工作。        默认是`postgresql-%Y-%m-%d_%H%M%S.log`。               如果你不使用转义来指定一个文件名，你应该计划使用一个日志轮转工具来避免最终填满整个磁盘。在 8.4 发行之前，如果不存在`%`转义，PostgreSQL将追加新日志文件创建时间的纪元，但是现在已经不再这样做了。               如果在`log_destination`中启用了 CSV 格式输出，`.csv`将会被追加到时间戳日志文件名中来创建 CSV 格式输出（如果`log_filename`以`.log`结尾，该后缀会被替换）。               这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `log_file_mode` (`integer`)            

  ​        在 Unix 系统上，当`logging_collector`被启用时，这个参数设置日志文件的权限（在微软 Windows 上这个参数将被忽略）。这个参数值应当是一个数字形式的模式，它可以被`chmod`和`umask`系统调用接受（要使用通常的十进制格式，该数字必须以一个`0`（零）开始）。               默认的权限是`0600`，表示只有服务器拥有者才能读取或写入日志文件。其他常用的设置是`0640`，它允许拥有者的组成员读取文件。不过要注意你需要修改[log_directory](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-DIRECTORY)为将文件存储在集簇数据目录之外的某个位置，才能利用这个设置。在任何情况下，让日志文件变成任何人都可读是不明智的，因为日志文件中可能包含敏感数据。               这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `log_rotation_age` (`integer`)            

  ​        当`logging_collector`被启用时，这个参数决定使用一个单个日志文件的最大时间量，之后将创立一个新的日志文件。        如果指定值时没有单位，则以分钟为单位。默认为24小时。        将这个参数设置为零将禁用基于时间的新日志文件创建。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `log_rotation_size` (`integer`)            

  ​        当`logging_collector`被启用时，这个参数决定一个个体日志文件的最大尺寸。        当这些数据量被发送到一个日志文件后，将创建一个新的日志文件。        如果指定值的时候没有单位，则以千字节为单位。默认值是10兆字节。设置为零时将禁用基于大小创建新的日志文件。        这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `log_truncate_on_rotation` (`boolean`)            

  ​        当`logging_collector`被启用时，这个参数将导致PostgreSQL截断（覆盖而不是追加）任何已有的同名日志文件。不过，截断只在一个新文件由于基于时间的轮转被打开时发生，在服务器启动或基于尺寸的轮转时不会发生。如果被关闭，在所有情况下以前存在的文件将被追加。例如，使用这个设置和一个类似`postgresql-%H.log`的`log_filename`将导致产生 24 个每小时的日志文件，并且循环地覆盖它们。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。               例子：要保留 7 天的日志，每天的一个日志文件被命令为`server_log.Mon`、`server_log.Tue`等等，并且自动用本周的日志覆盖上一周的日志。可以这样做：将`log_filename`设置为`server_log.%a`、将`log_truncate_on_rotation`设置为`on`并且将`log_rotation_age`设置为`1440`。               例子：要保留 24 小时的日志，每个小时一个日志文件，但是在日志文件尺寸超过 1GB 时轮转。可以这样做：将`log_filename`设置为`server_log.%H%M`、        将`log_truncate_on_rotation`设置为`on`、        将`log_rotation_age`设置为`60`并且        将`log_rotation_size`设置为`1000000`。        在`log_filename`中包括`%M`允许发生任何尺寸驱动的轮转来选择一个不同于每个小时的初始文件名的新文件名。       

- `syslog_facility` (`enum`)            

  ​        当启用了向syslog记录时，这个参数决定要使用的syslog“设备”。你可以在`LOCAL0`、`LOCAL1`、`LOCAL2`、`LOCAL3`、`LOCAL4`、        `LOCAL5`、`LOCAL6`、`LOCAL7`中选择，默认值是`LOCAL0`。还请参阅系统的syslog守护进程的文档。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `syslog_ident` (`string`)            

  ​         当启用了向syslog记录时，这个参数决定用来标识syslog中的PostgreSQL消息的程序名。默认值是`postgres`。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。        

- `syslog_sequence_numbers` (`boolean`)               

  ​         当日志被记录到syslog并且这个设置为 on （默认）时，每一个消息会被加上一个增长的序号作为前缀（例如`[2]`）。这种行为避开了很多 syslog 实现默认采用的“--- 上一个消息重复 N 次 ---”形式。在现代 syslog 实现中，抑制重复消息是可以配置的（例如rsyslog中的`$RepeatedMsgReduction`），因此这个参数可能不是必需的。此外，如果你真的想抑制重复消息，你可以把这个参数设置为 off。                 这个参数只能在`postgresql.conf`文件或者服务器命令行上设置。        

- `syslog_split_messages` (`boolean`)            

  ​        当启用把日志记录到syslog时，这个参数决定消息如何送达  syslog。当设置为 on（默认）时，消息会被分成行，并且长的行也会被划分以便能够放到 1024 字节中，这是传统 syslog  实现一种典型的尺寸限制。当设置为 off 时，PostgreSQL 服务器日志消息会被原样送达 syslog  服务，而处理可能的大体量消息的任务由 syslog 服务负责。               如果 syslog 最终被记录到一个文本文件中，那么两种设置的效果是一样的，但最好设置为 on，因为大部分 syslog  实现要么不能处理大型消息，要么需要做特殊的配置以处理大型消息。但是如果 syslog  最终写入到某种其他媒介，有必要让消息保持逻辑上的整体性（也更加有用）。               这个参数只能在`postgresql.conf`文件或者服务器命令行上设置。       

- `event_source` (`string`)            

  ​        当启用了向事件日志记录时，这个参数决定用来标识日志中PostgreSQL消息的程序名。默认值是`PostgreSQL`。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

### 20.8.2. 什么时候记录日志

- `log_min_messages` (`enum`)            

  ​        控制哪些[消息级别](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS)        被写入到服务器日志。有效值是`DEBUG5`、`DEBUG4`、        `DEBUG3`、`DEBUG2`、`DEBUG1`、        `INFO`、`NOTICE`、`WARNING`、        `ERROR`、`LOG`、`FATAL`和        `PANIC`。每个级别都包括以后的所有级别。级别越靠后，被发送的消息越少。默认值是`WARNING`。注意`LOG`在这里有与[client_min_messages](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-CLIENT-MIN-MESSAGES)中不同的排名。只有超级用户可以改变这个设置。       

- `log_min_error_statement` (`enum`)            

  ​        控制哪些导致一个错误情况的 SQL 语句被记录在服务器日志中。任何指定        [严重级别](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS)        或更高级别的消息的当前 SQL 语句将被包括在日志项中。有效值是`DEBUG5`、        `DEBUG4`、`DEBUG3`、        `DEBUG2`、`DEBUG1`、        `INFO`、`NOTICE`、        `WARNING`、`ERROR`、        `LOG`、        `FATAL`和`PANIC`。默认值是`ERROR`，它表示导致错误、日志消息、致命错误或恐慌错误的语句将被记录在日志中。要有效地关闭记录失败语句，将这个参数设置为`PANIC`。只有超级用户可以改变这个设置。       

- `log_min_duration_statement` (`integer`)            

  ​         如果语句运行至少指定的时间量，将导致记录每一个这种完成的语句的持续时间。         例如，如果你设置它为`250ms`，那么所有运行 250ms 或更久的 SQL 语句将被记录。         启用这个参数可以有助于追踪应用中未优化的查询。如果指定值时没有单位，则以毫秒为单位。将这个参数设置为零将打印所有语句的执行时间。         设置为 `-1`（默认值）将停止记录语句持续时间。只有超级用户可以改变这个设置。                 这会覆盖[log_min_duration_sample](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-DURATION-SAMPLE)，意味着持续时间超过此设置的查询不进行抽样，并且始终被记录。                 对于使用扩展查询协议的客户端，解析、绑定和执行步骤的持续时间将被独立记录。        注意         当把这个选项和[log_statement](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-STATEMENT)一起使用时，已经被`log_statement`记录的语句文本不会在持续时间日志消息中重复。如果你没有使用syslog，我们推荐你使用[log_line_prefix](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-LINE-PREFIX)记录 PID 或会话 ID，这样你可以使用进程 ID 或会话 ID 把语句消息链接到后来的持续时间消息。        

- `log_min_duration_sample` (`integer`)            

  ​         允许对最少运行了指定时间的已完成语句的持续时间进行抽样。         这将生成与[log_min_duration_statement](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-DURATION-STATEMENT) 相同的日志条目，但仅适用于已执行语句的子集，采样率由 [log_statement_sample_rate](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-STATEMENT-SAMPLE-RATE) 控制。         例如，如果将它设置为 `100ms`则所有运行 100ms 或更长的 SQL 语句都将被采样。          当流量过高而无法记录所有查询时，启用此参数会很有帮助。如果指定此值时没有单位，则以毫秒为单位。         设置为零将采样所有语句持续时间。`-1`（默认值）禁用采样语句持续时间。只有超级用户可以更改此设置。                 此设置的优先级低于 `log_min_duration_statement`，意味着持续时间超过 `log_min_duration_statement` 的语句不被采样，并且始终被记录。                 `log_min_duration_statement`的其他注释也适用于此设置。        

- `log_statement_sample_rate` (`floating point`)            

  ​         确定持续时间超过 [log_min_duration_sample](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-DURATION-SAMPLE)的语句的部分。         采样是随机的，例如`0.5`意味着从统计学上讲，任何给定语句都有1/2的概率将被记录。         默认值为 `1.0`，意味着要记录所有采样语句。         设置为零将禁用采样语句持续时间日志，与将`log_min_duration_sample`设为 `-1` 相同。         只有超级用户可以更改此设置。        

- `log_transaction_sample_rate` (`floating point`)            

  ​         设置所有语句都被记录的交易的部分，以及由于其他原因而记录的语句。它适用于每个新事务，而不考虑其语句的持续时间。         采样是随机的，例如 `0.1`意味着从统计学上讲，任何给定事务都有十分之一的机会将被记录。         `log_transaction_sample_rate` 有助于构建一个事务示例.         默认值为 `0`，表示不记录任何额外事务的语句。         设置这个为`1`将记录所有交易的所有语句。只有超级用户可以更改此设置。        注意         就像所有的语句-日志选项一样，这个选项可能会增加大量开销。        

​     [表 20.2](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS)解释了PostgreSQL所使用的消息严重级别。如果日志输出被发送到syslog或 Windows 的eventlog，严重级别会按照表中所示进行转换。    

**表 20.2. 消息严重级别**

| 严重性             | 用法                                                     | syslog    | eventlog      |
| ------------------ | -------------------------------------------------------- | --------- | ------------- |
| `DEBUG1 .. DEBUG5` | 为开发者提供连续的更详细的信息。                         | `DEBUG`   | `INFORMATION` |
| `INFO`             | 提供用户隐式要求的信息，例如来自`VACUUM VERBOSE`的输出。 | `INFO`    | `INFORMATION` |
| `NOTICE`           | 提供可能对用户有用的信息，例如长标识符截断提示。         | `NOTICE`  | `INFORMATION` |
| `WARNING`          | 提供可能出现的问题的警告，例如在一个事务块外`COMMIT`。   | `NOTICE`  | `WARNING`     |
| `ERROR`            | 报告一个导致当前命令中断的错误。                         | `WARNING` | `ERROR`       |
| `LOG`              | 报告管理员可能感兴趣的信息，例如检查点活动。             | `INFO`    | `INFORMATION` |
| `FATAL`            | 报告一个导致当前会话中断的错误。                         | `ERR`     | `ERROR`       |
| `PANIC`            | 报告一个导致所有数据库会话中断的错误。                   | `CRIT`    | `ERROR`       |

### 20.8.3. 记录什么到日志

- `application_name` (`string`)            

  ​        `application_name`可以是任意小于`NAMEDATALEN`个字符（标准编译中是 64 个字符）的字符串。这通常由一个应用通过到服务器的连接设置。该名称将被显示在`pg_stat_activity`视图中并被包括在 CSV 日志项中。它也会被通过[log_line_prefix](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-LINE-PREFIX)包括在普通日志项中。只有可打印 ASCII 字符能被使用在`application_name`之中。其他字符将被替换为问号（`?`）。       

- `debug_print_parse` (`boolean`)             `debug_print_rewritten` (`boolean`)             `debug_print_plan` (`boolean`)            

  ​        这个参数启用发出各种调试输出。当设置时，会打印生成的解析树， 查询重写输出，或执行的每个查询的执行计划。这些信息是在LOG  信息级别发出，因此默认的，它们会出现在服务器日志中，但不会发送给客户端。 可以通过  client_min_messages和/或log_min_messages 来设置。这些参数缺省是off。        这些参数将会让多种调试输出被发出。当被设置时，它们为每一个被执行的查询打印结果分析树、查询重写器输出或执行计划。这些消息在`LOG`消息级别上被发出，因此默认情况下它们将出现在服务器日志中但不会被发送到客户端。你可以通过调整[client_min_messages](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-CLIENT-MIN-MESSAGES)和/或[log_min_messages](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-MESSAGES)来改变这种情况。这些参数默认是关闭的。       

- `debug_pretty_print` (`boolean`)            

  ​        当被设置时，`debug_pretty_print`会缩进由`debug_print_parse`、        `debug_print_rewritten`或        `debug_print_plan`产生的输出。这将导致比关闭参数时使用的“紧凑”模式可读性更强但是更长的输出。它默认是打开的。       

- `log_autovacuum_min_duration` (`integer`)            

  ​        如果autovacuum执行的每个操作至少运行了指定的时间，该操作会被记录。        设置这个为零记录所有autovacuum操作。        `-1`(默认的)禁用日志记录autovacuum操作。        如果指定此值时不带单位，则以毫秒为单位。        例如，如果将其设置为`250ms`，那么所有运行250毫秒或更长时间的自动vacuums和分析都将被记录。        此外，当此参数设置为`-1`以外的任何值时，如果由于锁冲突或并发删除关系而跳过autovacuum操作，则会记录一条消息。        启用此参数有助于跟踪autovacuum活动。        该参数只能在`postgresql.conf`文件或在服务器命令行中设置;但是可以通过更改表存储参数来覆盖单独表的设置。       

- `log_checkpoints` (`boolean`)            

  ​        导致检查点和重启点被记录在服务器日志中。一些统计信息也被包括在日志消息中，包括写入缓冲区的数据和写它们所花的时间。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。默认值是关闭。       

- `log_connections` (`boolean`)            

  ​        导致每一次尝试对服务器的连接被记录，客户端认证(如需要)和认证的成功完成也会被记录。        只有超级用户能在会话开始时更改这个参数，在会话中它不能被更改。默认        为`off`。       注意         某些客户端程序（例如psql）在要求密码时会尝试连接两次，因此重复的“收到连接”消息并不一定表示一个错误。        

- `log_disconnections` (`boolean`)            

  ​        导致会话终止被记录。日志输出提供的信息类似于        `log_connections`，不过还外加会话的持续时间。        只有超级用户能在会话开始时更改这个参数，在会话中它不能被更改。默认        为`off`。       

- `log_duration` (`boolean`)            

  ​        导致每一个完成的语句的持续时间被记录。默认值是`off`。只有超级用户可以改变这个设置。               对于使用扩展查询协议的客户端，解析、绑定和执行步骤的持续时间将被独立记录。       注意         启用`log_duration`和设置[log_min_duration_statement](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-DURATION-STATEMENT)为零之间的区别是，超过`log_min_duration_statement`强制查询的文本被记录，但这个选项不会。因此，如果`log_duration`为`on`并且`log_min_duration_statement`为正值，所有持续时间都将被记录，但是只有超过阈值的语句才会被记录查询文本。这种行为有助于在高负载安装中收集统计信息。        

- `log_error_verbosity` (`enum`)            

  ​        控制为每一个被记录的消息要写入到服务器日志的细节量。有效值是`TERSE`、`DEFAULT`和`VERBOSE`，每一个都为显示的消息增加更多域。`TERSE`排除记录`DETAIL`、`HINT`、`QUERY`和`CONTEXT`错误信息。`VERBOSE`输出包括`SQLSTATE`错误码（见[附录 A](http://www.postgres.cn/docs/14/errcodes-appendix.html)）以及产生错误的源代码文件名、函数名和行号。只有超级用户能够更改这个设置。       

- `log_hostname` (`boolean`)            

  ​        默认情况下，连接日志消息只显示连接主机的 IP 地址。打开这个参数将导致也记录主机名。注意根据你的主机名解析设置，这可能会导致很微小的性能损失。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `log_line_prefix` (`string`)            

  ​         这是一个`printf`风格的字符串，它在每个日志行的开头输出。         `%`字符开始“转义序列”，它将被按照下文描述的替换成状态信息。         未识别的转义被忽略。其他字符被直接复制到日志行。某些转义只被会话进程识别并且被主服务器进程等后台进程当作空。         通过指定一个在%之后和该选项之前的数字可以让状态信息左对齐或右对齐。         负值将导致在右边用空格填充状态信息已达到最小宽度，而正值则在左边填充。填充对于日志文件的人类可读性大有帮助。                这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。默认值是`'%m [%p] '`，它记录时间戳和进程ID。       转义效果只限会话`%a`应用名是`%u`用户名是`%d`数据库名是`%r`远程主机名或 IP 地址，以及远程端口是`%h`远程主机名或 IP 地址是`%b`后端类型否`%p`进程 ID否`%P`并行组leader的进程ID，如果该进程是一个并行查询workerno`%t`无毫秒的时间戳否`%m`带毫秒的时间戳否`%n`带毫秒的时间戳（作为 Unix 时代）no`%i`命令标签：会话当前命令的类型是`%e`SQLSTATE 错误代码否`%c`会话 ID：见下文否`%l`对每个会话或进程的日志行号，从 1 开始否`%s`进程开始的时间戳否`%v`虚拟事务 ID (backendID/localXID)否`%x`事务 ID （如果未分配则为 0）否`%q`不产生输出，但是告诉非会话进程在字符串的这一点停止；会话进程忽略否`%Q`当前查询的查询标识符。             查询标识符默认是不计算的，所以这个部分将是零，除非[compute_query_id](http://www.postgres.cn/docs/14/runtime-config-statistics.html#GUC-COMPUTE-QUERY-ID) 参数被激活或者配置了计算查询标识符的第三方模块yes`%%`纯文字 `%`否          后端类型对应视图[ `pg_stat_activity`](http://www.postgres.cn/docs/14/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW)中的`backend_type`列。          但是其他类型可能会出现在日志中而不显示在该视图中。                  `%c`转义打印一个准唯一的会话标识符，它由两个 4 字节的十六进制数（不带先导零）组成，以点号分隔。         这些数字是进程启动时间和进程 ID，因此`%c`也可以被用作保存打印这些项的方式的空间。         例如，要从`pg_stat_activity`生成会话标识符，使用这个查询： `SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || '.' ||       to_hex(pid) FROM pg_stat_activity; `        提示         如果你为`log_line_prefix`设置了非空值，你通常应该让它的最后一个字符为空格，这样用以提供和日志行的剩余部分的视觉区别。也可以使用标点符号。        提示         Syslog产生自己的时间戳和进程 ID 信息，因此如果你记录到syslog你可能不希望包括哪些转义。        提示         在包括仅在会话（后端）上下文中可用的信息（如用户名或者数据库名）时，`%q`转义很有用。例如： `log_line_prefix = '%m [%p] %q%u@%d/%a ' `        注意         对于[log_statement](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-STATEMENT)输出的行，`%Q` 总是报告零标识符， 	 因为`log_statement`在标识符能被计算之前生成输出，包括无效标识符不能计算的无效语句。        

- `log_lock_waits` (`boolean`)            

  ​        控制当一个会话为获得一个锁等到超过[deadlock_timeout](http://www.postgres.cn/docs/14/runtime-config-locks.html#GUC-DEADLOCK-TIMEOUT)时，是否要产生一个日志消息。这有助于决定是否所等待造成了性能低下。默认值是`off`。只有超级用户可以更改这个设置。       

- `log_recovery_conflict_waits` (`boolean`)            

  ​        控制启动过程等待时间超过针对恢复冲突的`deadlock_timeout`的时候是否产生日志消息。        这对于决定恢复冲突是否会阻止恢复应用WAL有所帮助。               默认为`off`。        这个参数只能在`postgresql.conf`文件中或服务器命令行中设置。       

- `log_parameter_max_length` (`integer`)            

  ​        如果大于零，则使用非错误语句日志消息记录的每个绑定参数值都被裁剪为这么多字节。        零禁用非错误语句日志的绑定参数日志。`-1`（默认值）允许绑定参数被完整登录。        如果指定此值时没有单位，则将其作为字节。只有超级用户可以更改此设置。               此设置仅影响作为结果打印的日志消息[log_statement](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-STATEMENT),[log_duration](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-DURATION), 和相关的设置。        该设置的非零值会增加一些开销，特别是当参数以二进制形式发送时，因为需要转换为文本。       

- `log_parameter_max_length_on_error` (`integer`)            

  ​        如果大于零，则错误消息中报告的每个绑定参数值都将裁剪为这么多字节。        零(默认值)禁止在错误消息中包含绑定参数。`-1`允许打印完整绑定参数。        如果指定此值时没有单位，则将其作为字节。               该设置的非零值会增加开销，由于PostgreSQL需要在每条语句的开始处将参数值的文本表示存储在内存中，无论最终是否会发生错误。        当绑定参数以二进制形式发送时，开销比以文本形式发送时更大，因为前者需要数据转换，而后者只需要复制字符串。       

- `log_statement` (`enum`)            

  ​        控制哪些 SQL 语句被记录。有效值是        `none` (off)、`ddl`、`mod`和        `all`（所有语句）。`ddl`记录所有数据定义语句，例如`CREATE`、`ALTER`和        `DROP`语句。`mod`记录所有`ddl`语句，外加数据修改语句例如`INSERT`,        `UPDATE`、`DELETE`、`TRUNCATE`,        和`COPY FROM`。        如果`PREPARE`、`EXECUTE`和        `EXPLAIN ANALYZE`包含合适类型的命令，它们也会被记录。对于使用扩展查询协议的客户端，当收到一个执行消息时会产生日志并且会包括绑定参数的值（任何内嵌的单引号会被双写）。               默认值是`none`。只有超级用户可以改变这个设置。       注意         即使使用`log_statement` = `all`设置，包含简单语法错误的语句也不会被记录。这是因为只有在完成基本语法解析并确定了语句类型之后才会发出日志消息。在扩展查询协议的情况下，在执行阶段之前（即在解析分析或规划期间）出错的语句也不会被记录。将`log_min_error_statement`设置为`ERROR`（或更低）来记录这种语句。        

- `log_replication_commands` (`boolean`)            

  ​        导致每一个复制命令都被记录在服务器日志中。关于复制命令的详细信息请见        [第 53.4 节](http://www.postgres.cn/docs/14/protocol-replication.html)。默认值是`off`。只有        超级用户可以更改这个设置。       

- `log_temp_files` (`integer`)            

  ​        控制记录临时文件名和尺寸。临时文件可以被创建用来排序、哈希和存储临时查询结果。        如果启用这个设置，当每一个临时文件被删除时都会产生一个日志项。        一个零值记录所有临时文件信息，而正值只记录尺寸大于或等于指定数据量的文件。如果指定值时没有单位，则以千字节为单位。默认设置为 -1，它禁用这种记录。只有超级用户可以更改这个设置。       

- `log_timezone` (`string`)            

  ​        设置在服务器日志中写入的时间戳的时区。和[TimeZone](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-TIMEZONE)不同，这个值是集簇范围的，因此所有会话将报告一致的时间戳。内建默认值是`GMT`，但是通常会被在`postgresql.conf`中覆盖。initdb将安装一个对应于其系统环境的设置。详见[第 8.5.3 节](http://www.postgres.cn/docs/14/datatype-datetime.html#DATATYPE-TIMEZONES)。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

### 20.8.4. 使用 CSV 格式的日志输出

​        在`log_destination`列表中包括`csvlog`提供了一种便捷方式将日志文件导入到一个数据库表。这个选项发出逗号分隔值（CSV）格式的日志行，包括这些列：        带毫秒的时间戳、        用户名、        数据库名、        进程 ID、        客户端主机:端口号、        会话 ID、        每个会话的行号、        命令标签、        会话开始时间、        虚拟事务 ID、        普通事务 ID、        错误严重性、        SQLSTATE 代码、        错误消息、        错误消息详情、        提示、        导致错误的内部查询（如果有）、        错误位置所在的字符计数、        错误上下文、        导致错误的用户查询（如果有且被`log_min_error_statement`启用）、        错误位置所在的字符计数、        在 PostgreSQL 源代码中错误的位置（如果`log_error_verbosity`被设置为`verbose`）以及应用名，后端类型，并行组leader的进程ID和查询ID。        下面是一个定义用来存储 CSV 格式日志输出的样表：

```
CREATE TABLE postgres_log
(
  log_time timestamp(3) with time zone,
  user_name text,
  database_name text,
  process_id integer,
  connection_from text,
  session_id text,
  session_line_num bigint,
  command_tag text,
  session_start_time timestamp with time zone,
  virtual_transaction_id text,
  transaction_id bigint,
  error_severity text,
  sql_state_code text,
  message text,
  detail text,
  hint text,
  internal_query text,
  internal_query_pos integer,
  context text,
  query text,
  query_pos integer,
  location text,
  application_name text,
  backend_type text,
  leader_pid integer,
  query_id bigint,
  PRIMARY KEY (session_id, session_line_num)
);
```

​        It is also possible to access the file as a foreign table, using        the supplied [file_fdw](http://www.postgres.cn/docs/14/file-fdw.html) module.       

​        使用`COPY FROM`命令将一个日志文件导入到这个表中：

```
COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;
```

​		也可以作为外部表访问该文件，使用提供的 [file_fdw](http://www.postgres.cn/docs/14/file-fdw.html) 模块。       

​       你可以做一些事情来简化导入 CSV 日志文件：        

1. ​            设置`log_filename`和`log_rotation_age`为你的日志文件提供一种一致的、可预测的命名空间。这让你预测文件名会是怎样以及知道什么时候一个个体日志文件完成并且因此准备好被导入。         
2. ​            将`log_rotation_size`设置为 0 来禁用基于尺寸的日志轮转，因为它使得日志文件名难以预测。           
3. ​           将`log_truncate_on_rotation`设置为`on`，这样在同一个文件中旧日志数据不会与新数据混杂。          
4. ​           上述表定义包括一个主键声明。这有助于避免意外地两次导入相同的信息。`COPY`命令一次提交所有它导入的数据，因此任何错误将导致整个导入失败。如果你导入一个部分完成的日志文件并且稍后当它完全完成后再次导入，主键违背将导致导入失败。请等到日志完成且被关闭之后再导入。这个过程也可以避免意外地导入部分完成的行，这种行也将导致`COPY`失败。          

​      

### 20.8.5. 进程标题

​     这些设置控制服务器进程的进程标题如何被修改。进程标题通常可以用ps或者 Windows 上的进程浏览器等程序来查看。详见[第 28.1 节](http://www.postgres.cn/docs/14/monitoring-ps.html)。    

- `cluster_name` (`string`)            

  ​        为不同目的设置标识这个数据库集群(实例)的名称。此集群名称出现在该集群中所有服务器进程的进程标题中。        此外，它还是备用连接的默认应用名称。(参见 [synchronous_standby_names](http://www.postgres.cn/docs/14/runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES).)               这个名称可以是任何长度不超过`NAMEDATALEN`个字符（在标准编译中是 64字符）的任何字符串。只有可打印的 ASCII 字符能被用在`cluster_name`值中。其他字符将被替换为问号（`?`）。如果这个参数被设置为空字符串`''`（也是默认值），将不会显示名称。这个参数只能在服务器启动时设置。       

- `update_process_title` (`boolean`)            

  ​        启用进程标题更新，每次服务器接收到一个新的 SQL 命令时都更新进程标题。在大部分平台上这个设置默认为`on`，但是由于 Windows 上更新进程标题的开销更大，所以在 Windows 这个设置默认为`off`。只有超级用户能更改这个设置。       

##  运行时统计数据

- [20.9.1. 查询和索引统计收集器](http://www.postgres.cn/docs/14/runtime-config-statistics.html#RUNTIME-CONFIG-STATISTICS-COLLECTOR)
- [20.9.2. 统计监控](http://www.postgres.cn/docs/14/runtime-config-statistics.html#RUNTIME-CONFIG-STATISTICS-MONITOR)

### 20.9.1. 查询和索引统计收集器

​      这些参数控制服务器范围的统计数据收集特性。当统计收集被启用时，被产生的数据可以通过`pg_stat`和`pg_statio`系统视图族访问。详见[第 28 章](http://www.postgres.cn/docs/14/monitoring.html)。     

- `track_activities` (`boolean`)            

  ​        启用对每个会话的当前执行命令的信息收集，还有它的标识符和命令开始执行的时间。        这个参数默认为打开。注意即使被启用，这些信息也不是对所有用户可见，只有超级用户和拥有报告信息的会话的用户可见，因此它不会表现为一个安全风险。        只有超级用户可以更改这个设置。       

- `track_activity_query_size` (`integer`)            

  ​       为每个活动会话指定存储当前执行命令的文本所保留的内存量，它们被用于`pg_stat_activity`.`query`域。       如果指定值时没有单位，则以字节为单位。默认值是 1024字节。这个参数只能在服务器启动时被设置。         

- `track_counts` (`boolean`)            

  ​        启用在数据库活动上的统计收集。这个参数默认为打开，因为自动清理守护进程需要被收集的信息。只有超级用户可以更改这个设置。       

- `track_io_timing` (`boolean`)            

  ​        启用对系统 I/O 调用的计时。这个参数默认为关闭，因为它将重复地向操作系统查询当前时间，这会在某些平台上导致显著的负荷。        你可以使用[pg_test_timing](http://www.postgres.cn/docs/14/pgtesttiming.html)工具来度量你的系统中计时的开销。        I/O 计时信息被显示在[ `pg_stat_database`](http://www.postgres.cn/docs/14/monitoring-stats.html#MONITORING-PG-STAT-DATABASE-VIEW)中，        当`BUFFERS`选项被使用时的[EXPLAIN](http://www.postgres.cn/docs/14/sql-explain.html)输出中，通过autovacuum对auto-vacuums 和 auto-analyzes，当 [log_autovacuum_min_duration](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-AUTOVACUUM-MIN-DURATION) 被[pg_stat_statements](http://www.postgres.cn/docs/14/pgstatstatements.html)设置时。        只有超级用户可以更改这个设置。       

- `track_wal_io_timing` (`boolean`)            

  ​        激活WAL I/O调用的计时。        该参数默认为关闭，因为它将重复查询操作系统当前时间，这可能在某些平台上造成显著的开销。        您可以使用pg_test_timing工具来评估系统上的定时开销。        I/O计时信息在[`pg_stat_wal`](http://www.postgres.cn/docs/14/monitoring-stats.html#MONITORING-PG-STAT-WAL-VIEW).中显示。        只有超级用户才能改变此设置。       

- `track_functions` (`enum`)            

  ​        启用跟踪函数调用计数和用时。指定`pl`只跟踪过程语言函数，指定`all`还会跟踪 SQL 和 C 语言函数。默认值是`none`，它禁用函数统计跟踪。只有超级用户可以更改这个设置。       注意         简单到足以被“内联”到调用查询中的 SQL 语言函数不会被跟踪， 而不管这个设置。        

- `stats_temp_directory` (`string`)            

  ​        设置存储临时统计数据的目录。这可以是一个相对于数据目录的路径或一个绝对路径。默认值是`pg_stat_tmp`。在一个基于 RAM 的文件系统上指明这个参数将降低物理 I/O 需求，并且提高性能。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

### 20.9.2. 统计监控

- `compute_query_id` (`enum`)            

  ​        启用查询标识符的内核中计算。        查询标识符可以显示在[`pg_stat_activity`](http://www.postgres.cn/docs/14/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW)视图中，使用`EXPLAIN`，或者在日志中发出，如果通过[log_line_prefix](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-LINE-PREFIX)参数配置，。        [pg_stat_statements](http://www.postgres.cn/docs/14/pgstatstatements.html)扩展还需要一个查询标识符以计算。        注意，如果内核中查询标识符计算方法不可接受，也可以使用外部模块。        在这种情况下，必须始终禁用核内计算。        有效的值为`off`(总是禁用)，`on`(总是启用)和`auto`，这让像[pg_stat_statements](http://www.postgres.cn/docs/14/pgstatstatements.html)的模块自动启用它。        默认为`auto`。       注意         确认只有一个查询标识符被计算和显示，如果一个查询标识符已经被计算，扩展计算标识符将抛出一个错误。        

- `log_statement_stats` (`boolean`)             `log_parser_stats` (`boolean`)             `log_planner_stats` (`boolean`)             `log_executor_stats` (`boolean`)            

  ​        对每个查询，向服务器日志里输出相应模块的性能统计。这是一种粗糙的分析工具。类似于 Unix 的`getrusage()`系统功能。`log_statement_stats`报告总的语句统计，而其它的报告针每个模块的统计。`log_statement_stats`不能和 其它任何针对每个模块统计的选项一起启用。所有这些选项都是默认禁用的。只有超级用户可以更改这个设置。       

## 自动清理



​      这些设置控制*autovacuum*特性的行为。详情请参考      [第 25.1.6 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#AUTOVACUUM)。注意很多这些设置可以被针对每个表      的设置所覆盖，参见[Storage Parameters](http://www.postgres.cn/docs/14/sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS)。     

- `autovacuum` (`boolean`)            

  ​        控制服务器是否运行自动清理启动器后台进程。默认为开启，        不过要自动清理正常工作还需要启用[track_counts](http://www.postgres.cn/docs/14/runtime-config-statistics.html#GUC-TRACK-COUNTS)。        该参数只能在`postgresql.conf`文件或服务器命令行中设置，        不过，通过更改表存储参数可以为表禁用自动清理。               注意即使该参数被禁用，系统也会在需要防止事务ID回卷时发起清理进程。详情请见[第 25.1.5 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND)。       

- `autovacuum_max_workers` (`integer`)            

  ​        指定能同时运行的自动清理进程（除了自动清理启动器之外）的最大数量。默认值为3。该参数只能在服务器启动时设置。       

- `autovacuum_naptime` (`integer`)            

  ​        指定自动清理在任意给定数据库上运行的最小延迟。在每一轮中后台进程检查数据库并根据需要为数据库中的表发出`VACUUM`和`ANALYZE`命令。        如果指定值时没有单位，则以秒为单位。默认值为1分钟（`1min`）。该参数只能在`postgresql.conf`文件或在服务器命令行上设置。       

- `autovacuum_vacuum_threshold` (`integer`)            

  ​        指定能在一个表上触发`VACUUM`的被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在`postgresql.conf`文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。       

- `autovacuum_vacuum_insert_threshold` (`integer`)            

  ​        指定在任何一个表中触发 `VACUUM`所需要插入的元组数。默认值为 1000 个元组。         如果指定了 -1，则autovacuum不会根据插入数量在任何表上触发 `VACUUM`操作。        此参数只能在`postgresql.conf`文件或服务器命令行中设置;但可以通过更改表存储参数来覆盖单个表的设置。       

- `autovacuum_analyze_threshold` (`integer`)            

  ​        指定能在一个表上触发`ANALYZE`的被插入、被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在`postgresql.conf`文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。       

- `autovacuum_vacuum_scale_factor` (`floating point`)            

  ​        指定一个表尺寸的分数，在决定是否触发`VACUUM`时将它加到`autovacuum_vacuum_threshold`上。默认值为0.2（表尺寸的20%）。该参数只能在`postgresql.conf`文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。       

- `autovacuum_vacuum_insert_scale_factor` (`floating point`)            

  ​        指定一个要添加到`autovacuum_vacuum_insert_threshold` 中的表的大小的比例，在决定是否触发`VACUUM`时。        默认值为 0.2（表大小的 20%）。此参数只能在`postgresql.conf`文件或服务器命令行中设置;但可以通过更改表存储参数来覆盖单个表的设置。       

- `autovacuum_analyze_scale_factor` (`floating point`)            

  ​        指定一个表尺寸的分数，在决定是否触发`ANALYZE`时将它加到`autovacuum_analyze_threshold`上。默认值为0.1（表尺寸的10%）。该参数只能在`postgresql.conf`文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。       

- `autovacuum_freeze_max_age` (`integer`)            

  ​        指定在一个`VACUUM`操作被强制执行来防止表中事务ID回卷之前，一个表的`pg_class`.`relfrozenxid`域能保持的最大年龄（事务的）。注意即便自动清理被禁用，系统也将发起自动清理进程来阻止回卷。               清理也允许从`pg_xact`子目录中移除旧文件，这也是为什么默认值被设置为较低的2亿事务。该参数只能在服务器启动时设置，但是对于个别表可以通过修改表存储参数来降低该设置。详见[第 25.1.5 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND)。       

- `autovacuum_multixact_freeze_max_age` (`integer`)            

  ​        指定在一个`VACUUM`操作被强制执行来防止表中多事务ID回卷之前，一个表的`pg_class`.`relminmxid`域能保持的最大年龄（多事务的）。注意即便自动清理被禁用，系统也将发起自动清理进程来阻止回卷。               清理多事务也允许从`pg_multixact/members`和`pg_multixact/offsets`子目录中移除旧文件，这也是为什么默认值被设置为较低的4亿事务。该参数只能在服务器启动时设置，但是对于个别表可以通过修改表存储参数来降低该设置。详见[第 25.1.5.1 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-MULTIXACT-WRAPAROUND)。       

- `autovacuum_vacuum_cost_delay` (`floating point`)            

  ​        指定用于自动`VACUUM`操作中的代价延迟值。如果指定-1，则使用[vacuum_cost_delay](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-VACUUM-COST-DELAY)值。        如果指定值时没有单位，则以毫秒为单位。默认值为2毫秒。该参数只能在`postgresql.conf`文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。       

- `autovacuum_vacuum_cost_limit` (`integer`)            

  ​        指定用于自动`VACUUM`操作中的代价限制值。如果指定-1（默认值），则使用[vacuum_cost_limit](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-VACUUM-COST-LIMIT)值。注意该值被按比例地分配到运行中的自动清理工作者上（如果有多个），因此每一个工作者的限制值之和不会超过这个变量中的值。该参数只能在`postgresql.conf`文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。       

## 客户端连接默认值

- [20.11.1. 语句行为](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-STATEMENT)
- [20.11.2. 区域和格式化](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-FORMAT)
- [20.11.3. 共享库预载入](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-PRELOAD)
- [20.11.4. 其他默认值](http://www.postgres.cn/docs/14/runtime-config-client.html#RUNTIME-CONFIG-CLIENT-OTHER)

### 20.11.1. 语句行为

- `client_min_messages` (`enum`)            

  ​        控制被发送给客户端的[消息级别](http://www.postgres.cn/docs/14/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS)。有效值是`DEBUG5`、        `DEBUG4`、`DEBUG3`、`DEBUG2`、        `DEBUG1`、`LOG`、`NOTICE`、        `WARNING`、`ERROR`。        每个级别都包括其后的所有级别。级别越靠后，被发送的消息越少。默认值是`NOTICE`。        注意`LOG`在这里有与[log_min_messages](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-MESSAGES)中不同的排名。               `INFO` 级别的消息总是被发送到客户端。       

- `search_path` (`string`)                  

  ​         这个变量指定当一个对象（表、数据类型、函数等）被用一个无模式限定的简单名称引用时，用于进行搜索该对象的模式顺序。当在不同模式中有同名对象时，将使用第一个在搜索路径中被找到的对象。一个不属于搜索路径中任何一个模式的对象只能通过用限定名（带点号）指定包含它的模式来引用。               `search_path`的值必需是一个逗号分隔的模式名列表。任何不是一个已有模式的名称，或者是一个用户不具有`USAGE`权限的模式，将被安静地忽略。               如果列表项之一是特殊名`$user`，则具有`SESSION_USER`返回的名字的模式将取代它（如果有这样一个模式并且该用户有该模式的`USAGE`权限；如果没有，`$user`会被忽略）。               系统目录模式`pg_catalog`总是被搜索，不管它是否在搜索路径中被提及。如果它在路径中被提及，那么它将被按照路径指定的顺序搜索。如果`pg_catalog`不在路径中，则它将在任何路径项*之前*被搜索。               同样，当前会话的临时表模式`pg_temp_*`nnn`*`也总是被搜索（如果存在）。它可以在路径中通过使用别名`pg_temp`显式列出。如果在路径中没有列出，那么会首先对它进行搜索（甚至是在`pg_catalog`之前）。然而，临时模式只被用来搜索关系（表、视图、序列等）和数据类型名。它从不用于搜索函数或操作符名。               当对象创建时没有指定一个特定目标模式，它们将被放置在`search_path`中第一个合法模式中。如果搜索路径为空将报告一个错误。               这个参数的缺省值是`"$user", public`。这种设置支持一个数据库（其中没有用户拥有私有模式，并且所有人共享使用`public`）、每个用户私有模式及其组合的共享使用。其它效果可以通过全局或者针对每个用户修改默认搜索路径设置获得。               更多有关方案处理的信息，请参考[第 5.9 节](http://www.postgres.cn/docs/14/ddl-schemas.html)。特别地，只有当数据库只有一个用户或者有少数的相互信任的用户时，默认配置是合适的。               搜索路径的当前有效值可以通过SQL函数`current_schemas`检查（见[第 9.26 节](http://www.postgres.cn/docs/14/functions-info.html)）。它和检查`search_path`的值不太一样，因为`current_schemas`显示出现在`search_path`中的项如何被解析。       

- `row_security` (`boolean`)            

  ​        这个变量控制是否以抛出一个错误来代替应用一条行安全性策略。在设置为`on`时，策略正常应用。在设置为`off`时，只要有至少一条策略被应用则查询就会失败。默认为`on`。受限的行可见性会导致不正确的结果时，可将其改成`off`。例如，pg_dump默认会做这种更改。这个变量对能绕过每一条行安全性策略的角色（即超级用户和具有`BYPASSRLS`）属性的角色没有效果。               更多关于行安全性策略的信息请见[CREATE POLICY](http://www.postgres.cn/docs/14/sql-createpolicy.html)。       

- `default_table_access_method` (`string`)            

  ​        如果 `CREATE`命令没有显式指定访问方法，则此参数指定在创建表或物化视图时使用的默认表访问方法，        或者在使用`SELECT ... INTO` 时，不允许指定表访问方法。默认为`heap`。       

- `default_tablespace` (`string`)                  

  ​        这个变量指定当一个`CREATE`命令没有显式指定一个表空间时，创建对象（表和索引）的默认表空间。               该值要么是一个表空间的名字，要么是一个指定使用当前数据库默认表空间的空字符串。如果该值和任何现有表空间的名字都不匹配，PostgreSQL将自动使用当前数据库的默认表空间。如果指定了一个非默认的表空间，用户必须对它有`CREATE`权限，否则创建企图将失败。               这个变量不被用于临时表，对临时表会使用[temp_tablespaces](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-TEMP-TABLESPACES)。               当创建数据库时也会使用这个变量。默认情况下，一个新数据库会从它的模板数据库继承其表空间设置。               当一个分区表建立时如果这个参数被设置为空字符串以外的值，分区表的表空间将被设置为该值，将被用做未来建立分区的默认表空间，        即使`default_tablespace`已经改变。               有关表空间的更多的信息，请见[第 23.6 节](http://www.postgres.cn/docs/14/manage-ag-tablespaces.html)。       

- `default_toast_compression` (`enum`)            

  ​        这个变量设置针对可压缩列的值的默认的[TOAST](http://www.postgres.cn/docs/14/storage-toast.html)压缩方法。        （这个可以通过设置`COMPRESSION`列选项跨越不同的列，通过`CREATE TABLE` 或 `ALTER TABLE`）        支持的压法方法有`pglz` 和(如果PostgreSQL 编译时包括 `--with-lz4`) `lz4`.        默认为 `pglz`       

- `temp_tablespaces` (`string`)                  

  ​        这个变量指定当一个`CREATE`命令没有显式指定一个表空间时，创建临时对象（临时表和临时表上的索引）的默认表空间。用于排序大型数据集的临时文件也被创建在这些表空间中。               该值是一个表空间名字的列表。当列表中有多于一个名称时，每次一个临时对象被创建时PostgreSQL随机选择列表中的一个成员。例外是在一个事务中，连续创建的临时对象被放置在里表中的连续表空间中。如果列表被选中元素是一个空字符串，PostgreSQL将自动使用当前数据库的默认表空间。               当`temp_tablespaces`被交互式地设置时，指定一个不存在的表空间是一种错误，类似于为用户指定一个不具有`CREATE`权限的表空间。不过，当使用一个之前设置的值时，不存在的表空间会被忽略，就像用户缺少`CREATE`权限的表空间一样。特殊地，使用一个在`postgresql.conf`中设置的值时，这条规则起效。               默认值是一个空字符串，它使得所有临时对象被创建在当前数据库的默认表空间中。               参阅[default_tablespace](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-DEFAULT-TABLESPACE)。       

- `check_function_bodies` (`boolean`)            

  ​        这个参数通常为打开。        当设置为`off`时，它禁用[CREATE FUNCTION](http://www.postgres.cn/docs/14/sql-createfunction.html)和[CREATE PROCEDURE](http://www.postgres.cn/docs/14/sql-createprocedure.html)期间对例程体字符串的验证。        禁用验证避免了验证处理的副作用，特别避免了如向前引用导致的伪肯定。        在代表其他用户载入函数之前设置这个参数为`off`；pg_dump会自动这样做。       

- `default_transaction_isolation` (`enum`)                  

  ​        每个 SQL 事务都有一个隔离级别，可以是“读未提交”、“读已提交”、“可重复读”或者“可序列化”。这个参数控制每个新事务的默认隔离级别。默认是“读已提交”。               更多信息请参阅[第 13 章](http://www.postgres.cn/docs/14/mvcc.html)和[SET TRANSACTION](http://www.postgres.cn/docs/14/sql-set-transaction.html)。       

- `default_transaction_read_only` (`boolean`)                  

  ​        一个只读的 SQL 事务不能修改非临时表。这个参数控制每个新事务的默认只读状态 。默认是`off`（读/写）。               更多信息请参考[SET TRANSACTION](http://www.postgres.cn/docs/14/sql-set-transaction.html)。       

- `default_transaction_deferrable` (`boolean`)                  

  ​        当运行在`可序列化`隔离级别时，一个可延迟只读 SQL 事务可以在它被允许继续之前延迟一段时间。但是，一旦它开始执行就不会产生任何用来保证可序列化性的负荷；因此序列化代码将没有任何理由因为并发更新而强制它中断，使得这个选项适合于长时间运行的只读事务。                这个参数控制每个新事务的默认可延迟状态。目前它对读写事务或者那些操作在低于`可序列化`隔离级别上的事务无效。默认值是`off`。               详情请参阅[SET TRANSACTION](http://www.postgres.cn/docs/14/sql-set-transaction.html)。       

- `transaction_isolation` (`enum`)                  

  ​        此参数反映当前事务的隔离级别。在每个事务开始时，它被设置为        [default_transaction_isolation](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-ISOLATION)的当前值。        任何后续更改它的尝试都相当于[SET TRANSACTION](http://www.postgres.cn/docs/14/sql-set-transaction.html)命令。       

- `transaction_read_only` (`boolean`)                  

  ​        此参数反映当前事务的只读状态。        在每个事务的开始，它被设置为[default_transaction_read_only](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-READ-ONLY)的当前值。        任何后续尝试更改它的都等同于[SET TRANSACTION](http://www.postgres.cn/docs/14/sql-set-transaction.html)命令。       

- `transaction_deferrable` (`boolean`)                  

  ​        此参数反映当前事务的可延迟性状态。        在每个事务的开始，它被设置为[default_transaction_deferrable](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-DEFERRABLE)的当前值。        任何后续尝试更改它的都等同于[SET TRANSACTION](http://www.postgres.cn/docs/14/sql-set-transaction.html)命令。       

- `session_replication_role` (`enum`)            

  ​        为当前会话控制复制相关的触发器和规则的触发。需要超级用户权限才能设置这个变量，并且会导致丢弃任何之前缓存下来的查询计划。可能的值有`origin`（默认）、`replica`和`local`。               这个设置的预期用途是由逻辑复制系统在应用所复制的更改时将它设置为`replica`。 	其效果将是触发器和规则（没有对其默认配置做修改）在复制机上将不会被触发。 	更多信息请参考[`ALTER TABLE`](http://www.postgres.cn/docs/14/sql-altertable.html)的子句`ENABLE TRIGGER`以及`ENABLE RULE`。               PostgreSQL在内部会把设置`origin`和`local`同样对待。第三方复制系统可能会把这两个值用于其内部目的，例如把`local`用来标出一个不应复制其更改的会话。               因为外键被实现为触发器，将这个参数设置为`replica`还会禁用所有的外键检查，如果使用不当可能会让数据处于一种不一致的状态。       

- `statement_timeout` (`integer`)            

  ​        中止任何使用了超过指定时间量的语句。        如果`log_min_error_statement`被设置为`ERROR`或更低，语句如果超时也会被记录。        如果指定值时没有单位，则以毫秒为单位。一个零值（默认）将禁用超时。               超时从命令到达服务器的时间开始计算，一直到它被服务器完成为止。        如果单个简单查询消息中出现多个 SQL 语句，超时将分别应用于每个语句。（PostgreSQL 13 之前的版本通常将超时应用于整个查询字符串。        在扩展查询协议中，当任何与查询相关的消息(解析、绑定、执行、描述)到达时，超时就开始运行，并且可以通过执行完成或同步消息来取消超时。               我们不推荐在`postgresql.conf`中设置`statement_timeout`，因为它会影响所有会话。       

- `lock_timeout` (`integer`)            

  ​        如果任何语句在试图获取表、索引、行或其他数据库对象上的锁时等到超过指定的时间量，该语句将被中止。        该时间限制独立地应用于每一次锁获取尝试。该限制会应用到显式锁定请求（如`LOCK TABLE`或不带`NOWAIT`的`SELECT FOR UPDATE`）和隐式获得的锁。        如果指定值时没有单位，则以毫秒为单位。一个零值（默认）将禁用超时。               与`statement_timeout`不同，这个超时只在等待锁时发生。注意如果`statement_timeout`为非零，设置`lock_timeout`为相同或更大的值没有意义，因为事务超时将总是第一个被触发。        如果`log_min_error_statement` 被设置为`ERROR` 或更低，超时的语句将被记录。               我们不推荐在`postgresql.conf`中设置`lock_timeout`，因为它会影响所有会话。       

- `idle_in_transaction_session_timeout` (`integer`)            

  ​        终止任何已经闲置(这是指，等待客户端查询)超过这个参数所指定时间量的打开事务的会话。        如果这个值指定时没有单位，它被设为毫秒。        零值(默认)禁用超时。               此选项可以用于确保空闲会话不会在不合理的时间内持有锁。        即使没有持有重要的锁的时候，打开的事务也会防止清理最近死亡的可能只对这个事务可见的元组;所以长时间保持空闲会导致表膨胀。        详见[第 25.1 节](http://www.postgres.cn/docs/14/routine-vacuuming.html)。       

- `idle_session_timeout` (`integer`)            

  ​        终止任何空闲的会话(也就是，等待客户端查询)，但不在打开的事务中，且超过指定的时间量。        如果指定值时不带单位，其单位采用毫秒。        零值时(默认)禁用超时。               不像打开事务的情况，没有事务的空闲会话不会给服务器带来很大的开销，因此启用此超时的需要比`idle_in_transaction_session_timeout`更少。               注意不要对通过连接池软件或其他中间件建立的连接强制执行此超时，因为这样的层可能不会很好地响应意外的连接关闭。        只对交互会话启用此超时可能是帮助的，也许只对特定用户应用它。       

- `vacuum_freeze_table_age` (`integer`)            

  ​        当表的`pg_class`.`relfrozenxid`域达到该设置指定的年龄时，`VACUUM`会执行一次激进的扫描。激进的扫描与常规`VACUUM`的不同在于它会访问每一个可能包含未冻结 XID 或者 MXID 的页面，而不只是那些可能包含死亡元组的页面。默认值是 1.5 亿个事务。尽管用户可以把这个值设置为从 0 到 20 亿，`VACUUM`会悄悄地将有效值设置为[autovacuum_freeze_max_age](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE)值的95%，因此在表上启动一次反回卷自动清理之前有机会进行一次定期手动`VACUUM`。更多信息请见[第 25.1.5 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND)。       

- `vacuum_freeze_min_age` (`integer`)            

  ​        指定`VACUUM`在扫描表时用来决定是否冻结行版本的切断年龄（以事务计）。默认值是 5 千万个事务。尽管用户可以将这个值设置为从 0 到 10 亿，`VACUUM`会悄悄地将有效值设置为[autovacuum_freeze_max_age](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE)值的一半，这样在强制执行的自动清理之间不会有过短的时间间隔。更多信息请见[第 25.1.5 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND)。       

- `vacuum_failsafe_age` (`integer`)            

  ​        指定表的`pg_class`.`relfrozenxid`字段在`VACUUM`采取特别措施以避免系统级事务ID封装失败之前的最大年龄(在事务中)。        这是`VACUUM`最后手段的策略。        失效保护通常在防止事务ID换行的autovacuum已经运行了一段时间时触发，不过失效保护也有可能在任何`VACUUM`期间触发。               当失效保护被触发时，任何有效的基于成本的延迟都将不再被应用，并且进一步的非必要的维护任务(例如索引vacuuming)被绕过。               默认为16亿事务。        虽然用户可以把这个值设置为零到21亿之间的任何地方。        `VACUUM`将静默调整有效值到不小于[autovacuum_freeze_max_age](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE)的105%。       

- `vacuum_multixact_freeze_table_age` (`integer`)            

  ​        如果表的`pg_class`.`relminmxid`域超过了这个设置指定的年龄，`VACUUM`会执行一次激进的扫描。激进的扫描与常规`VACUUM`的区别在于它会访问每一个可能包含未冻结 XID 或者 MXID 的页面，而不是只扫描那些可能包含死亡元组的页面。默认值是 1.5 亿个组合事务。尽管用户可以把这个值设置为从 0 到 20 亿，`VACUUM`会悄悄地将有效值设置为[autovacuum_multixact_freeze_max_age](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE)值的95%，因此在表上启动一次反回卷自动清理之前有机会进行一次定期手动`VACUUM`。更多信息请见[第 25.1.5.1 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-MULTIXACT-WRAPAROUND)。       

- `vacuum_multixact_freeze_min_age` (`integer`)            

  ​        指定`VACUUM`在扫描表时用来决定是否把组合事务 ID 替换为一个更新的事务 ID 或组合事务 ID 的切断年龄（以组合事务计）。默认值是 5 千万个组合事务。尽管用户可以将这个值设置为从 0 到 10 亿，`VACUUM`会悄悄地将有效值设置为[autovacuum_multixact_freeze_max_age](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE)值的一半，这样在强制执行的自动清理之间不会有过短的时间间隔。更多信息请见[第 25.1.5.1 节](http://www.postgres.cn/docs/14/routine-vacuuming.html#VACUUM-FOR-MULTIXACT-WRAPAROUND)。       

- `vacuum_multixact_failsafe_age` (`integer`)            

  ​        指定最大寿命(in multixacts)，以便表的`pg_class`.`relminmxid`字段可以在`VACUUM`采取特别措施之前获得，以避免系统范围的multixact ID 回卷失败。        这是`VACUUM`的最后手段的策略。        失效保护通常在防止事务ID回卷的autovacuum已经运行了一段时间时触发，不过失效保护也有可能在任何`VACUUM`期间被触发。               当失效保护被触发时，任何进行中的基于成本的延迟将不再应用，而且非必要的维护任务(如索引vacuuming)会被旁路。               默认为16亿multixacts。        但是用户可以设置这个值为零至21亿之间的任意值。        `VACUUM`将静默调整有效值到不小于[autovacuum_multixact_freeze_max_age](http://www.postgres.cn/docs/14/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE)的105%。       

- `bytea_output` (`enum`)            

  ​        设置`bytea`类型值的输出格式。有效值是`hex`（默认）和 `escape`（传统的 PostgreSQL 格式）。详见[第 8.4 节](http://www.postgres.cn/docs/14/datatype-binary.html)。不管这个设置的值如何，`bytea`类型总是接受这两种格式的输入。       

- `xmlbinary` (`enum`)            

  ​        设置二进制值如何被编码为 XML。例如，这适用于通过`xmlelement`函数或`xmlforest`函数将`bytea`值转换到 XML 值。可能的值有`base64`和`hex`，它们都是用 XML 模式标准定义的。默认值是`base64`。更多关于 XML 相关函数的信息可参阅[第 9.15 节](http://www.postgres.cn/docs/14/functions-xml.html)。               这里的实际选择都是根据爱好做出的，只受客户端应用中可能存在的限制的约束。两种方法都支持所有可能的值，尽管十六进制编码将比 base64 编码更大。       

- `xmloption` (`enum`)                        

  ​        当在XML和字符串值之间进行转换时，无论设置DOCUMENT或 CONTENT都是隐式的。可参阅Section 8.13。 有效值是DOCUMENT和CONTENT。 缺省值是CONTENT。当在 XML 和字符串值之间进行转换时，设置`DOCUMENT`或`CONTENT`都是隐式的。详见[第 8.13 节](http://www.postgres.cn/docs/14/datatype-xml.html)。有效值是`DOCUMENT`和`CONTENT`。默认值是`CONTENT`。               根据 SQL 标准，设置这个选项的命令是： `SET XML OPTION { DOCUMENT | CONTENT }; `        这种语法在 PostgreSQL 也可用。       

- `gin_pending_list_limit` (`integer`)            

  ​        设置`fastupdate`被启用时可以使用的 GIN索引的待处理列表的最大尺寸。        如果该列表增长到超过这个最大尺寸，会通过批量将其中的项移入索引的主 GIN 数据结构来清理列表。        如果指定值时没有单位，则以千字节为单位。默认值是四兆字节（`4MB`）。        可以通过更改索引的存储参数来为个别 GIN 索引覆盖这个设置。更多信息请见[第 67.4.1 节](http://www.postgres.cn/docs/14/gin-implementation.html#GIN-FAST-UPDATE)和[第 67.5 节](http://www.postgres.cn/docs/14/gin-tips.html)。       

### 20.11.2. 区域和格式化

- `DateStyle` (`string`)            

  ​        设置日期和时间值的显示格式，以及解释有歧义的日期输入值的规则。由于历史原因， 这个变量包含两个独立的部分：输出格式声明（`ISO`、`Postgres`、`SQL`或`German`）、 输入/输出的年/月/日顺序（`DMY`、`MDY`或`YMD`）。这些可以被独立设置或者一起设置。关键字`Euro`和`European`是`DMY`的同义词；关键字`US`、`NonEuro`和`NonEuropean`是`MDY`的同义词。详见[第 8.5 节](http://www.postgres.cn/docs/14/datatype-datetime.html)。内建默认值是`ISO, MDY`，但是initdb将用对应于选中的`lc_time`区域行为的设置初始化配置文件。       

- `IntervalStyle` (`enum`)            

  ​        设置间隔值的显示格式。值`sql_standard`将产生匹配 SQL 标准间隔文本的输出。当[DateStyle](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-DATESTYLE)参数被设置为`ISO`时，值`postgres`（默认）将产生匹配PostgreSQL发行 8.4 之前的输出。当`DateStyle`参数被设置为非`ISO`输出时，值`postgres_verbose`会产生匹配PostgreSQL发行 8.4 之前的输出。值`iso_8601`会产生匹配在 ISO 8601 的 4.4.3.2 节中定义的“带标志符格式”的时间间隔的输出。               `IntervalStyle`参数也可以影响对有歧义的间隔输入的解释。详见[第 8.5.4 节](http://www.postgres.cn/docs/14/datatype-datetime.html#DATATYPE-INTERVAL-INPUT)。       

- `TimeZone` (`string`)                  

  ​        设置用于显示和解释时间戳的时区。内建默认值是`GMT`，但是它通常会在`postgresql.conf`中被覆盖；initdb将安装一个对应于其系统环境的设置。详见[第 8.5.3 节](http://www.postgres.cn/docs/14/datatype-datetime.html#DATATYPE-TIMEZONES)。       

- `timezone_abbreviations` (`string`)                  

  ​        设置服务器接受的日期时间输入中使用的时区缩写集合。默认值为`'Default'`， 这个集合在全世界大多数地方都能工作。也还有`'Australia'`和`'India'`，以及可能为一种特定安装定义的其他集合。详见[第 B.4 节](http://www.postgres.cn/docs/14/datetime-config-files.html)。       

- `extra_float_digits` (`integer`)                        

  ​        这个参数调整用于文本输出浮点值的位数，包括`float4`，`float8`以及几何数据类型。               如果值为1(默认值)或更高，浮点值被输出为最短-精度格式；参见[第 8.1.3 节](http://www.postgres.cn/docs/14/datatype-numeric.html#DATATYPE-FLOAT)。        实际生成的位数只取决于输出的值，而不取决于此参数的值。        ` float8` 值最多需要 17 位数字，`float4`值最多需要9位数字。        这种格式既快速又精确，在正确读取时精确地保留了原始的二进制浮点值。为了历史兼容性，允许的值最大为3。               如果值为零或负，则输出四舍五入为给定的十进制精度。        使用的精度是根据此参数的值减小的类型（(`FLT_DIG`或`DBL_DIG`，视情况而定）的标准位数。        （例如，指定 -1 将导致`float4` 值输出四舍五入为 5 位有效数字，而`float8`值四舍五入为 14 位。）        此格式较慢，不会保留二进制浮点值的所有位，但可能令人更易于阅读。       注意         此参数的含义，以及其默认值，在 PostgreSQL 12 中发生了变化;         参见 [第 8.1.3 节](http://www.postgres.cn/docs/14/datatype-numeric.html#DATATYPE-FLOAT) 以便进一步讨论。        

- `client_encoding` (`string`)                  

  ​        设置客户端编码（字符集）。默认使用数据库编码。PostgreSQL服务器所支持的字符集在[第 24.3.1 节](http://www.postgres.cn/docs/14/multibyte.html#MULTIBYTE-CHARSET-SUPPORTED)中描述。       

- `lc_messages` (`string`)            

  ​        设置消息显示的语言。可接受的值是系统相关的；详见[第 24.1 节](http://www.postgres.cn/docs/14/locale.html)。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。               在一些系统上，这个区域分类并不存在。仍然可以设置这个变量，只是不会有任何效果。同样，所期望语言的翻译消息也可能不存在。在这种情况下，你将仍然继续看到英文消息。               只有超级用户可以改变这个设置。因为它同时影响发送到服务器日志和客户端的消息。一个不正确的值可能会降低服务器日志的可读性。       

- `lc_monetary` (`string`)            

  ​        设置用于格式化货币量的区域，例如用`to_char`函数族。可接受的值是系统相关的；详见[第 24.1 节](http://www.postgres.cn/docs/14/locale.html)。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。       

- `lc_numeric` (`string`)            

  ​        设置用于格式化数字的区域，例如用`to_char`函数族。可接受的值是系统相关的；详见[第 24.1 节](http://www.postgres.cn/docs/14/locale.html)。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。       

- `lc_time` (`string`)            

  ​        设置用于格式化日期和时间的区域，例如用`to_char`函数族。可接受的值是系统相关的；详见[第 24.1 节](http://www.postgres.cn/docs/14/locale.html)。如果这个变量被设置为空字符串（默认），那么该值将以一种系统相关的方式从服务器的执行环境中继承。       

- `default_text_search_config` (`string`)            

  ​        选择被那些没有显式参数指定配置的文本搜索函数变体使用的文本搜索配置。详见[第 12 章](http://www.postgres.cn/docs/14/textsearch.html)。内建默认值是`pg_catalog.simple`，但是如果能够标识一个匹配区域的配置，initdb将用对应于选中的`lc_ctype`区域的设置初始化配置文件。       

### 20.11.3. 共享库预载入

​      为了载入附加的功能或者达到提高性能的目的，可用多个设置来预先载入共享库到服务器中。      例如`'$libdir/mylib'`设置可能会导致`mylib.so`（或者某些平台上的`mylib.sl`）从安装的标准库目录被预装载。这些设置之间的区别在于生效的时间以及改变它们所需的特权。     

​      可以用这个方法预装载PostgreSQL的过程语言库，通常是使用`'$libdir/plXXX'`语法，其中的`XXX`是`pgsql`、`perl`、`tcl`或`python`。     

​      只有特别为与PostgreSQL一起使用设计的共享库才能以这种方式载入。每一个PostgreSQL支持      的库都有一个“魔法块”，它会被检查以保证兼容性。由于这个原因，非PostgreSQL无法      以这种方式被载入。你可能可以使用操作系统的工具（如`LD_PRELOAD`）载入它。     

​      总之，请参考特定模块的文档来用推荐的方法载入它。     

- `local_preload_libraries` (`string`)                  

  ​        这个变量指定一个或者多个要在连接开始时预载入的共享库。        它包含一个由逗号分隔的库名列表，其中每个名称都会按[`LOAD`](http://www.postgres.cn/docs/14/sql-load.html)命令的方式解析。        项之间的空格会被忽略，如果需要在库名中包含空格或者逗号，请把库名放在双引号内。        这个参数值只在连接开始时生效。后续的更改不会有任何效果。        如果一个指定的库没有找到，连接尝试将会失败。               任何用户都能设置这个选项。正因为如此，能被这样载入的库被严格限制为出现于安装的标准库        目录中`plugins`子目录下的共享库（保证只有“安全的”库被安装到        这里是数据库管理员的责任）。`local_preload_libraries`中的项可以显式        指定这个目录，例如`$libdir/plugins/mylib`，或者只是指定库的        名称 — `mylib` 和        `$libdir/plugins/mylib`的效果是相同的。               这个特性的目的是允许非特权用户在特定的会话中载入正在调试的或者性能度量库，        而无需一个显式的`LOAD`命令。为了这个目的，通常通过使用客        户端的`PGOPTIONS`环境变量或者        `ALTER ROLE SET`来设置这个参数。               不过，除非一个模块被特别设计成由非超级用户以这种方式使用，通常不推荐使用这个设置。应该看看        [session_preload_libraries](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-SESSION-PRELOAD-LIBRARIES)。       

- `session_preload_libraries` (`string`)            

  ​        这个变量指定一个或者多个要在连接开始时预载入的共享库。        只有超级用户更够更改这个设置。        它包含一个由逗号分隔的库名列表，其中每个名称都会按[`LOAD`](http://www.postgres.cn/docs/14/sql-load.html)命令的方式解析。        项之间的空格会被忽略，如果需要在库名中包含空格或者逗号，请把库名放在双引号内。这个参数只在连接开始时起效。        后续的改变没有效果。如果指定的库没有找到，连接尝试将会失败。        只有超级用户能够更改这个设置。               这个特性的意图是允许在特定会话中载入调试用的或者测量性能的库，而不需要显式的给出一个        `LOAD`命令。例如，通过用`ALTER ROLE SET`设置这个参数可以        为一个给定用户名下的所有会话启用[auto_explain](http://www.postgres.cn/docs/14/auto-explain.html)。还有，无需重启        服务器就能更改这个参数（但是只有新会话启动时才会生效），这样可以以这种方式更容易地增        加新模块，即便它们会应用到所有会话。               和[shared_preload_libraries](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES)不同，相对于在库被第一次使用        时载入它，在会话开始时载入库并没有什么性能优势。不过，当使用连接池时这样做还是有一些        优势。       

- `shared_preload_libraries` (`string`)            

  ​        这个变量指定一个或者多个要在服务器启动时预载入的共享库。        它包含一个由逗号分隔的库名列表，其中每个名称都会按[`LOAD`](http://www.postgres.cn/docs/14/sql-load.html)命令的方式解析。        项之间的空格会被忽略，如果需要在库名中包含空格或者逗号，请把库名放在双引号内。        这个参数只能在服务器启动时设置。        如果指定的库没有找到，服务器将无法启动。               有些库需要执行只能在postmaster启动时发生的特定操作，例如分配共享内存、保留轻量级锁        或者启动后台工作者。这些库必须通过这个参数在服务器启动时载入。每个库的详情请见文档。               其他库也能被预载入。通过预载入一个共享库，当该库被第一次使用时就可以避免库的启动时间。        不过，启动每个新服务器进程的时间可能会略有增加，即使该进程从不使用该库。因此，推荐只        把这个参数用于那些要在大多数会话中使用的库上。还有，改变这个参数要求重启服务器，因此        对于短期的调试任务来说这不是好的选择，应该转用        [session_preload_libraries](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-SESSION-PRELOAD-LIBRARIES)。       注意        在 Windows 主机上，在服务器启动时预载入一个库并不会减少启动每个新服务器进程所需的        时间；每一个服务器进程将会重新载入预载入的库。不过，对于那些要在postmaster启动时        执行操作的库来说，Windows 主机上的        `shared_preload_libraries`任然有用。       

- `jit_provider` (`string`)             

  ​        这个变量是要被使用的JIT提供者库的名称（见[第 32.4.2 节](http://www.postgres.cn/docs/14/jit-extensibility.html#JIT-PLUGGABLE)）。默认是`llvmjit`。这个参数只能在服务器启动时设置。               如果这个变量被设置为一个不存在的库，JIT将不可用，但是也不会发生错误。这种特性允许在主PostgreSQL包之外单独安装JIT支持。       

### 20.11.4. 其他默认值

- `dynamic_library_path` (`string`)                  

  ​        如果需要打开一个可以动态装载的模块并且在`CREATE FUNCTION`或`LOAD`命令中指定的文件名没有目录部分（即名字中不包含斜线），那么系统将搜索这个路径以查找所需的文件。               `dynamic_library_path`的值必须是一个冒号分隔（或者在 Windows 上以分号分隔）的绝对目录路径的列表。如果一个列表元素以特殊字符串开始，`$libdir`会被替换为PostgreSQL包中已编译好的库目录。这里是PostgreSQL发布提供的模块被安装的位置（使用`pg_config --pkglibdir`来找到这个目录的名字）。例如： `dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir' `        或者在 Windows 环境中： `dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir' `               这个参数的默认值是`'$libdir'`。如果该值被设置为一个空字符串，则关闭自动路径搜索。               这个参数可以在运行时由超级用户修改，但是这样修改的设置只能保持到这个客户端连接的结尾，因此这个方法应该保留给开发目的。 我们建议在`postgresql.conf`配置文件中设置这个参数。       

- `gin_fuzzy_search_limit` (`integer`)            

  ​        GIN 索引返回的集合尺寸的软上限。详见[第 67.5 节](http://www.postgres.cn/docs/14/gin-tips.html)。       

##  锁管理

- `deadlock_timeout` (`integer`)                        

  ​        这是进行死锁检测之前在一个锁上等待的时间量。死锁检测相对昂贵，因此服务器不会在每次等待锁时都运行这个它。        我们乐观地假设在生产应用中死锁是不常出现的，并且只在开始检测死锁之前等待一会儿。增加这个值就减少了浪费在无用的死锁检测上的时间，但是减慢了报告真正死锁错误的速度。        如果指定值时没有单位，则以毫秒为单位。默认是 1 秒（`1s`），这可能是实际中你想要的最小值。        在一个高负载的服务器上，你可能需要增大它。这个值的理想设置应该超过你通常的事务时间，这样就可以减少在锁释放之前就开始死锁检查的机会。只有超级用户可以更改这个设置。               当[log_lock_waits](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-LOCK-WAITS)被设置时，这个参数还可以决定发出关于锁等待的日志之前等待的时间量。如果你想调查锁延迟，你可能希望设置一个比正常的`deadlock_timeout`小的值。       

- `max_locks_per_transaction` (`integer`)            

  ​        共享锁表跟踪在`max_locks_per_transaction` * ([max_connections](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-MAX-CONNECTIONS) + [max_prepared_transactions](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PREPARED-TRANSACTIONS)) 个对象（如表）上的锁。因此，在任何一个时刻，只有不超过这么多个可区分对象能够被锁住。这个参数控制为每个事务分配的对象锁的平均数量。个体事务可以锁住更多对象，数量可以和锁表中能容纳的所有事务的锁一样多。这*不*是能被锁住的行数，那个值是没有限制的。默认值 64 已经被历史证明是足够的，但是如果你有需要在一个事务中使用很多不同表的查询（例如查询一个有很多子表的父表），你可能需要提高这个值。这个参数只能在服务器启动时设置。               当运行一个后备服务器时，你必须设置这个参数为大于等于主服务器上的值。        否则，后备服务器上将不允许查询。       

- `max_pred_locks_per_transaction` (`integer`)            

  ​        共享谓词锁表跟踪在`max_pred_locks_per_transaction` * ([max_connections](http://www.postgres.cn/docs/14/runtime-config-connection.html#GUC-MAX-CONNECTIONS) + [max_prepared_transactions](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-MAX-PREPARED-TRANSACTIONS)) 个对象（如表）上的锁。因此，在任何一个时刻，只有不超过这么多个可区分对象能够被锁住。这个参数控制为每个事务分配的对象锁的平均数量。个体事务可以锁住更多对象，数量可以和锁表中能容纳的所有事务的锁一样多。这*不*是能被锁住的行数，那个值是没有限制的。默认值 64 已经在测试中被证明通常是足够的，但是如果你有需要在一个可序列化事务中使用很多不同表的查询（例如查询一个有很多子表的父表），你可能需要提高这个值。这个参数只能在服务器启动时设置。       

- `max_pred_locks_per_relation` (`integer`)            

  ​        这个参数控制在谓词锁被提升为覆盖整个关系之前，该谓词锁能够在单个关系上锁住多少页面或元组。大于等于零的值表示一种绝对限制，而负值表示用[max_pred_locks_per_transaction](http://www.postgres.cn/docs/14/runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION)除以这个设置的绝对值。默认值为-2，它将保持以往版本的PostgreSQL中的行为。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

- `max_pred_locks_per_page` (`integer`)            

  ​        这个参数控制在谓词锁被提升为覆盖整个页面之前，该谓词锁能在单一页面上锁住多少行。默认值是2。这个参数只能在`postgresql.conf`文件中或者服务器命令行上设置。       

## 版本和平台兼容性

- [20.13.1. 以前的 PostgreSQL 版本](http://www.postgres.cn/docs/14/runtime-config-compatible.html#RUNTIME-CONFIG-COMPATIBLE-VERSION)
- [20.13.2. 平台和客户端兼容性](http://www.postgres.cn/docs/14/runtime-config-compatible.html#RUNTIME-CONFIG-COMPATIBLE-CLIENTS)

### 20.13.1. 以前的 PostgreSQL 版本

- `array_nulls` (`boolean`)            

  ​        这个参数控制数组输入解析器是否把未用引号的`NULL`识别为一个空数组元素。默认为`on`，允许输入包含空值的数组值。但是PostgreSQL 8.2 之前的版本不支持数组中的空值，并且因此将把`NULL`当作指定一个值为字符串“NULL”的正常数组元素。对于那些要求旧行为的应用的向后兼容性，这个变量可以被设置为`off`。               注意即使这个变量为`off`也能够创建包含空值的数组值。       

- `backslash_quote` (`enum`)                  

  ​        这个参数控制字符串文本中的单引号是否能够用`\'`来表示。首选的 SQL 标准的方法是将其双写（`''`），但是PostgreSQL在历史上也接受`\'`。不过使用`\'`容易导致安全风险，因为在某些客户端字符集编码中，有多字节字符的最后一个字节在数值上等价于 ASCII 的`\'`。如果客户端代码没有做到正确转义，那么将会导致 SQL 注入攻击。如果服务器拒绝看起来带有被反斜线转义的单引号的查询，那么就可以避免这种风险。`backslash_quote`的可用值是`on`（总是允许`\'`）、`off`（总是拒绝）以及`safe_encoding`（只有客户端编码不允许在多字节字符中存在 ASCII `\`时允许）。`safe_encoding`是默认设置。               注意在符合标准的字符串文本中，`\`就表示`\`。这个参数只影响不符合标准的文本的处理，包括转义字符串语法（`E'...'`）。       

- `escape_string_warning` (`boolean`)                  

  ​        打开时，如果在普通字符串文本中（`'...'`语法）出现了 一个反斜线（`\`）并且`standard_conforming_strings`为关闭，那么就会发出一个警告。默认值是`on`。               希望使用反斜线作为转义符的应用应该被修改来使用转义字符串语法（`E'...'`），因为在 SQL 标准中普通字符串的默认行为是将反斜线视作一个普通字符。这个变量可以被启用来帮助定位需要被更改的代码。       

- `lo_compat_privileges` (`boolean`)            

  ​        在PostgreSQL 9.0 之前，大对象不具有访问特权并且因此总是所有用户可读可写的。为了和以前的版本兼容，把这个变量设置为`on`可以禁用这种新的特权检查。默认是`off`。只有超级用户可以更改这个设置。               设置这个参数不会禁用所有与大对象相关的安全检查 — 除了那些在PostgreSQL 9.0中已经修改了的默认行为。       

- `quote_all_identifiers` (`boolean`)            

  ​        当数据库产生 SQL 时，强制所有标识符被引号包围，即使它们（当前）不是关键字。这将影响`EXPLAIN`的输出以及`pg_get_viewdef`等函数的结果。另请参阅[pg_dump](http://www.postgres.cn/docs/14/app-pgdump.html)和[pg_dumpall](http://www.postgres.cn/docs/14/app-pg-dumpall.html)的`--quote-all-identifiers`选项。       

- `standard_conforming_strings` (`boolean`)                  

  ​        控制普通字符串文本（`'...'`）是否按照 SQL 标准把反斜线当普通文本。从PostgreSQL 9.1 开始，默认值为`on`（之前的发行中默认值为`off`）。应用可以检查这个参数来判断字符串文本如何被处理。这个参数的存在也可以被当做转义字符串语法（`E'...'`）被支持的标志。如果一个应用希望反斜线被当做转义字符，应该使用转义字符串语法（[第 4.1.2.2 节](http://www.postgres.cn/docs/14/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-ESCAPE)）。       

- `synchronize_seqscans` (`boolean`)            

  ​        它允许对大型表的顺序扫描与其他扫描同步，因此并发扫描可以在几乎相同的时刻读取相同的块，这样可以分担 I/O 负载。当启用这个参数时，一个扫描可能会从表的中间开始并且之后“绕回”到开头以覆盖所有的行，这样可以与已在进行中的扫描活动同步。对于没有`ORDER BY`子句的查询来，这样的扫描会在返回行的顺序中造成不可预料的改变。将这个参数设置为`off`以保证 8.3 之前的行为（顺序扫描总是从表的起始处开始）。默认值是`on`。       

### 20.13.2. 平台和客户端兼容性

- `transform_null_equals` (`boolean`)                  

  ​        当打开时，形为`*`expr`* = NULL`（或`NULL =  *`expr`*`）的表达式将被当做`*`expr`* IS NULL`， 也就是说，如果*`expr`*得出空值值则返回真，否则返回假。正确的 SQL 标准兼容的`*`expr`* = NULL`行为总是返回空（未知）。因此这个参数默认为`off`。               不过，在Microsoft Access里的过滤表单生成的查询似乎使用`*`expr`* = NULL`来测试空值，因此，如果你使用这个接口访问数据库，你可能想把这个选项打开。因为`*`expr`* = NULL`形式的表达式总是返回空值（使用 SQL 标准解释）。它们不是非常有用并且在普通应用中也不常见，在应用中也不常见，因此这个选项实际上没有什么危害。但是新用户常常对涉及 空值的表达式的语义上感到困惑，因此这个选项默认为关闭。               请注意这个选项只影响`= NULL`形式，而不影响其它比较操作符或者其它与一些涉及等值操作符的表达式在计算上等效的其他表达式（例如`IN`）。因此，这个选项不是劣质程序的一般修复。               相关信息请见[第 9.2 节](http://www.postgres.cn/docs/14/functions-comparison.html)。       

## 错误处理

- `exit_on_error` (`boolean`)            

  ​        如果为开(on)，任何错误将中止当前会话。默认情况下，这个值被设置为关(off)，这样只有 FATAL 错误（致命）将中止会话。       

- `restart_after_crash` (`boolean`)            

  ​        当被设置为开(on)，PostgreSQL将在一次后端崩溃后自动重新初始化。        让这个值设置为开(on)通常是将数据库可用性最大化的最佳方法。但是在某些环境中，例如PostgreSQL被集群软件调用时，禁用重启可能很有用，这样集群软件可以得到控制并且采取它认为适当的行动。               这个参数只能在`postgresql.conf`文件中或服务器命令行中设置。       

- `data_sync_retry` (`boolean`)            

  ​        如果设置为关（off），PostgreSQL在将修改的数据文件刷新到文件系统失败时，将引发PANIC级错误。        这样会导致数据库服务器崩溃。这个参数只能在服务器启动时被设置。               在某些操作系统上，回写失败后，内核页面缓存中的数据状态未知。  在某些情况下，它可能已被完全遗忘，因此重试不安全；第二次尝试可能报告为成功，而事实上数据已丢失。在此类情形下，避免数据丢失的唯一方法是在报告任何故障后从WAL中恢复，最好是在调查了故障的根本原因并更换了任何有故障的硬件之后。               如果设置为开(on)，PostgreSQL将报告错误，但会继续运行，以便可以在以后的检查点中重试数据刷新操作。        仅在调查操作系统假如回写失败时对缓冲数据的处理方式的情况下，才将其设置为开(on)。       

- `recovery_init_sync_method` (`enum`)             

  ​        当设置为`fsync`，也就是默认值，PostgreSQL将在崩溃恢复开始之前递归地打开并同步数据目录中的所有文件。        对文件的搜索将遵循WAL目录和每个配置表空间的符号链接(而不是任何其它符号链接)。        这是为了确保在重现更改之前，所有WAL和数据文件都持久地存储在硬盘上。        这适用于在启动没有完全关闭的数据库集群时，包括由pg_basebackup创建的副本。               在Linux上，可以用`syncfs`代替，请求操作系统来同步包含数据目录的整个文件系统，WAL文件和每个表空间(但不是通过符号链接可访问到的任何其他文件系统)。        这可能比`fsync`设置快得多，因为它不需要逐个打开每个文件。        另一方面，如果一个文件系统是被其他需要修改大量文件的应用程序共享的，它可能会慢一些，因为这些文件也将写入硬盘。        此外，在5.8之前的Linux版本中，向磁盘写入数据时遇到的I/O错误可能不会报告给PostgreSQL，相关的错误消息可能只出现在内核日志中。               这个参数只能在`postgresql.conf`文件中或者服务器命令行中设置。       

## 预置选项

​     下列“参数”是只读的。     同样，它们被排除在`postgresql.conf`文件例子之外。     这些选项报告特定应用可能感兴趣的多种PostgreSQL行为，特别是管理前端相关的行为。     所有这些都是在PostgreSQL被编译或者它被安装时决定的。    

- `block_size` (`integer`)            

  ​        报告一个磁盘块的大小。它由编译服务器时`BLCKSZ`的值确定。默认值是 8192 字节。有些配置变量的含义（例如[shared_buffers](http://www.postgres.cn/docs/14/runtime-config-resource.html#GUC-SHARED-BUFFERS)）会被`block_size`影响。详见[第 20.4 节](http://www.postgres.cn/docs/14/runtime-config-resource.html)。       

- `data_checksums` (`boolean`)            

  ​        报告对这个集簇是否启用了数据校验码。详见[data checksums](http://www.postgres.cn/docs/14/app-initdb.html#APP-INITDB-DATA-CHECKSUMS)。       

- `data_directory_mode` (`integer`)            

  ​        在Unix系统上，这个参数报告启动时的数据目录(由[data_directory](http://www.postgres.cn/docs/14/runtime-config-file-locations.html#GUC-DATA-DIRECTORY)定义)的权限。        （在Microsoft Windows上这个参数将总是显示`0700`。）        更多信息请参考[group access](http://www.postgres.cn/docs/14/app-initdb.html#APP-INITDB-ALLOW-GROUP-ACCESS)。       

- `debug_assertions` (`boolean`)            

  ​        报告编译PostgreSQL时是否启用了断言。        如果PostgreSQL被编译时定义了宏        `USE_ASSERT_CHECKING` is defined        when PostgreSQL（例如通过        `configure`选项        `--enable-cassert`定义），那么会报告已启用。默认情况下        PostgreSQL编译时没有用断言。       

- `integer_datetimes` (`boolean`)            

  ​        报告PostgreSQL是否在编译时打开了 64 位整数日期和时间。从PostgreSQL 10起，这个值总是`on`。       

- `in_hot_standby` (`boolean`)            

  ​        报告服务器当前是否处于热备模式。        当这个是`on`的时候，所有的事务强制为只读。        在会话中，这个只能在服务器提升为主服务器的时候变更。        更多信息参见[第 27.4 节](http://www.postgres.cn/docs/14/hot-standby.html)       

- `lc_collate` (`string`)            

  ​        报告文本数据排序使用的区域。详见[第 24.1 节](http://www.postgres.cn/docs/14/locale.html)。该值是在数据库被创建时确定的。       

- `lc_ctype` (`string`)            

  ​        报告决定字符分类的区域。详见[第 24.1 节](http://www.postgres.cn/docs/14/locale.html)。该值是在数据库被创建时决定的。通常它和`lc_collate`一样，但是可以为特殊应用设置成不同的值。       

- `max_function_args` (`integer`)            

  ​        报告函数参数的最大数量。它由编译服务器时的`FUNC_MAX_ARGS`值决定的。默认值是 100 个参数。       

- `max_identifier_length` (`integer`)            

  ​        报告标识符的最大长度。它由编译服务器时的`NAMEDATALEN`值减一决定。`NAMEDATALEN`的默认值是 64 ；因此`max_identifier_length`的默认值是 63，但是在使用多字节编码时可以少于 63 个字符。       

- `max_index_keys` (`integer`)            

  ​        报告索引键的最大数目。它由编译服务器时的`INDEX_MAX_KEYS`值决定。默认值是 32 个键。       

- `segment_size` (`integer`)            

  ​        报告一个文件段中可以存储的块（页）的数量。由编译服务器时的`RELSEG_SIZE`值决定。一个段文件的最大尺寸（以字节计）等于`segment_size`乘以`block_size`，默认是 1GB。       

- `server_encoding` (`string`)                  

  ​        报告数据库的编码（字符集）。这是在数据库被创建时决定的。通常，客户端只需要关心[client_encoding](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-CLIENT-ENCODING)的值。       

- `server_version` (`string`)            

  ​        报告服务器版本数值。它是由编译服务器时的`PG_VERSION`值决定的。       

- `server_version_num` (`integer`)            

  ​        报告服务器版本数值的整数值。它是由编译服务器时的`PG_VERSION_NUM`值决定的。       

- `ssl_library` (`string`)            

  ​        报告此PostgreSQL服务器已构建的 SSL 库的名称（即使此实例当前未配置或使用 SSL），        例如`OpenSSL`，或一个空字符串(如果没有)。       

- `wal_block_size` (`integer`)            

  ​        报告一个 WAL 磁盘块的尺寸。由编译服务器时的`XLOG_BLCKSZ`值决定。默认是 8192 字节。       

- `wal_segment_size` (`integer`)            

  ​        报告 WAL 段文件的大小。默认是 16MB。详见[第 30.5 节](http://www.postgres.cn/docs/14/wal-configuration.html)。       

## 自定义选项

​     这个特性被设计用来由附加模块向PostgreSQL添加通常不为系统知道的参数（例如过程语言）。这允许使用标准方法配制扩展模块。    

​     自定义选项有两部分名称：一个扩展名，然后是一个句点，再然后是正确的参数名，就像 SQL 中的合格名称。一个例子是`plpgsql.variable_conflict`。    

​     因为自定义选项可能需要在没有载入相关扩展模块的进程中设置，PostgreSQL将接收任意两部分参数名的设置。这种变量被认为是占位符并且在定义它们的模块被载入之前不会有实际功能。当一个扩展模块被载入，它将加入它的变量定义、根据那些定义转换任何占位符值并且对以其扩展名开始的任意未识别占位符发出警告。    

## 开发者选项

​     下面的参数目的是用在开发测试上， 并且永远不能用于生产数据库。     但是，它们中的一些能够用于帮助恢复严重损坏的数据库。     同样，它们被从例子`postgresql.conf`文件中排除。     请注意许多这些参数要求特殊的源代码编译标志才能工作。    

- `allow_system_table_mods` (`boolean`)            

  ​        允许对系统表结构的修改，以及对系统表的某些其他危险操作。这是不允许的，即使是对超级用户。        不理智地使用此设置可能导致无法恢复的数据丢失或严重损坏数据库系统。只有超级用户才能更改此设置       

- `backtrace_functions` (`string`)            

  ​        这个参数包含一个以逗号分隔的C函数名称列表。        如果出现错误，并且发生错误的内部C函数的名称与列表中的值相匹配，那么将向服务器日志中写入一个回溯跟踪信息和错误消息。        这可以用来调试源代码的特定区域。               回溯支持并非在所有平台上都可以使用，并且回溯的质量取决于编译选项。               该参数只能由超级用户设置。       

- `debug_discard_caches` (`integer`)            

  ​        当设置为`1`时，每个系统目录缓存条目在第一个可能的机会时失效，不管任何使之无效的事情是否真的发生。        作为结果，系统目录的缓存被有效地禁用，因此服务器将运行得非常缓慢。        较高的值递归地运行缓存失效，这样会更慢，而且只用于测试缓存逻辑自身。        默认值`0`选择正常的目录缓存行为。               当试图触发涉及并发目录更改的难以复现的错误时，此参数非常有用，但除此之外它不太被需要。        详请参见源码文件`inval.c` 和 `pg_config_manual.h`。               当 `DISCARD_CACHES_ENABLED`在编译时定义时，可支持此参数(当使用configure option `--enable-cassert`时自动发生)。        在生产建设中，它的值总是`0`，并且试图将它设置为另一个值将引发错误。       

- `force_parallel_mode` (`enum`)            

  ​        允许应用并行查询作为测试目的，即使在没有预期性能好处的情况下。        `force_parallel_mode` 的允许值为`off`(仅在期望提高性能时使用并行模式)，        `on`(对被认为是安全的所有查询强制并行查询)，        以及`regress`   (类似`on`，但是有额外的行为变化在下面说明)。               更具体地说，将该值设置为`on`的将在看起来安全的任何查询计划的顶部添加一个`Gather` 节点，以便查询在并行worker内部运行。        即使当并行worker不可用或不能使用时，例如启动子事务之类的操作将被禁止，在并行查询上下文中将被禁止，除非规划器认为这会导致查询失败。        如果设置此选项时发生失败或意外结果，查询使用的一些函数可能需要被标记为`PARALLEL UNSAFE`(或者，可能是`PARALLEL RESTRICTED`)。               设置该值为`regress`与设置为`on` 具有相同的所有效果，加上一些附加效果，为了便于自动回归测试。        通常，来自并行worker的消息包含一个上下文行表示之，        但是`regress`的设置会抑制这一行，因此输出与非并行执行时相同。        此外，通过此设置隐藏在`EXPLAIN`输出中，`Gather`节点添加到计划，以便输出匹配如果将此设置`off`将获得的结果。       

- `ignore_system_indexes` (`boolean`)            

  ​        读取系统表时忽略系统索引（但是修改系统表时依然同时更新索引）。这在从被破坏的系统索引中恢复数据的时有用。这个参数在会话开始之后不能被更改。       

- `post_auth_delay` (`integer`)            

  ​        执行身份验证过程后启动新服务器进程时延迟的时间量。这是为了给开发者们一个机会在一个服务器进程上附加一个调试器。        如果指定值时没有单位，则以秒为单位。0值(默认值)禁用延迟。这个参数在会话开始之后不能被更改。       

- `pre_auth_delay` (`integer`)            

  ​        在新服务器进程分叉后，在进行身份验证过程之前，延迟的时间量。这是为了给开发者们一个机会在一个服务器进程上附加一个调试器来跟踪认证过程中的不当行为。        如果指定值时没有单位，则以秒为单位。0值(默认值)禁用延迟。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `trace_notify` (`boolean`)            

  ​        为`LISTEN`和`NOTIFY`命令生成大量调试输出。[client_min_messages](http://www.postgres.cn/docs/14/runtime-config-client.html#GUC-CLIENT-MIN-MESSAGES)和[log_min_messages](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-MESSAGES)必须是`DEBUG1`或者更低才能把这种输出分别发送到客户端或者服务器日志。       

- `trace_recovery_messages` (`enum`)            

  ​        启用记录与恢复有关的调试输出，否则无法记录。这个参数允许用户覆盖[log_min_messages](http://www.postgres.cn/docs/14/runtime-config-logging.html#GUC-LOG-MIN-MESSAGES)的正常设置，但只用于指定的消息。这个参数的目的是用来调试热后备。有效值包括`DEBUG5`、`DEBUG4`、`DEBUG3`、`DEBUG2`、`DEBUG1`和`LOG`。默认值`LOG`完全不会影响日志决定。其他值会记录相关级别或更高级别的与恢复相关的调试消息，就好像它们具有`LOG`优先级一样；对于`log_min_messages`的通用设置，这会无条件的将消息发送给服务器日志。这个参数只能在`postgresql.conf`文件中或在服务器命令行上设置。       

- `trace_sort` (`boolean`)            

  ​        如果打开，发出在排序操作中的资源使用的相关信息。只有在编译PostgreSQL时定义了`TRACE_SORT`宏， 这个参数才可用（不过，当前在默认情况下就定义了`TRACE_SORT`）。       

- `trace_locks` (`boolean`)            

  ​        如果开启，发出锁使用情况的信息。被转储信息中包括锁操作的类型、锁的类型和  被锁或被解锁对象的唯一标识符。同样包括的还有已经授予这个对象的锁类型的位掩码和  等待这个对象的锁类型的位掩码。对每一种锁类型，已授权锁和等待锁的计数也会被一起转储。一个日志文件输出的例子如下： `LOG:  LockAcquire: new: lock(0xb7acd844) id(24688,24696,0,0,0,1)      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0      wait(0) type(AccessShareLock) LOG:  GrantLock: lock(0xb7acd844) id(24688,24696,0,0,0,1)      grantMask(2) req(1,0,0,0,0,0,0)=1 grant(1,0,0,0,0,0,0)=1      wait(0) type(AccessShareLock) LOG:  UnGrantLock: updated: lock(0xb7acd844) id(24688,24696,0,0,0,1)      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0      wait(0) type(AccessShareLock) LOG:  CleanUpLock: deleting: lock(0xb7acd844) id(24688,24696,0,0,0,1)      grantMask(0) req(0,0,0,0,0,0,0)=0 grant(0,0,0,0,0,0,0)=0      wait(0) type(INVALID) `        被转储结构的详细信息可以在`src/include/storage/lock.h`中找到。               只有在编译PostgreSQL时定义了`LOCK_DEBUG`宏， 这个参数才可用。       

- `trace_lwlocks` (`boolean`)            

  ​        如果开启，发出轻量级锁的使用信息。轻量级锁主要是为了提供对共享内存数据结构的互斥访问。               只有在编译PostgreSQL时定义了`LOCK_DEBUG`宏， 这个参数才可用。       

- `trace_userlocks` (`boolean`)            

  ​        如果开启，发出关于用户锁使用的信息。与`trace_locks`的输出一样，但只用于咨询锁。               只有在编译PostgreSQL时定义了`LOCK_DEBUG`宏， 这个参数才可用。       

- `trace_lock_oidmin` (`integer`)            

  ​        如果设置，不会跟踪小于这个 OID 的锁（用于避免在系统表上的输出）。               只有在编译PostgreSQL时定义了`LOCK_DEBUG`宏， 这个参数才可用。       

- `trace_lock_table` (`integer`)            

  ​        无条件地跟踪此表（OID）上的锁。               只有在编译PostgreSQL时定义了`LOCK_DEBUG`宏， 这个参数才可用。       

- `debug_deadlocks` (`boolean`)            

  ​        如果设置，当死锁超时发生时，转储所有当前锁的信息。               只有在编译PostgreSQL时定义了`LOCK_DEBUG`宏， 这个参数才可用。       

- `log_btree_build_stats` (`boolean`)            

  ​        如果设置，会记录 B 树操作上的系统资源使用情况统计（内存和 CPU）。               只有在编译PostgreSQL时定义了`BTREE_BUILD_STATS`宏， 这个参数才可用。       

- `wal_consistency_checking` (`string`)            

  ​         这个参数被设计用来检查WAL重做例程中的缺陷。当这个参数被启用时，被修改的任何缓冲区的全页映像及其WAL记录都被加入到记录中。如果该记录后来被重放，系统将首先应用每个记录然后测试该记录修改的缓冲区是否符合存储的映像。在某些情况下（例如提示位），小的变动是可以接受的，并且会被忽略。任何预期之外的差别都将导致致命错误，最后中止恢复。               这个设置的默认值是空字符串，它将禁用这一特性。它可以被设置为`all`以检查所有记录，或者被设置为一个逗号分隔的资源管理器列表用以检查那些资源管理器产生的记录。当前，支持的资源管理器是`heap`、`heap2`、`btree`、`hash`、`gin`、`gist`、`sequence`、`spgist`、`brin`以及`generic`。只有超级用户可以更改这一设置。       

- `wal_debug` (`boolean`)            

  ​        如果被打开，WAL 相关的调试输出将被发出。只有在编译PostgreSQL时定义了`WAL_DEBUG`宏的情况下，这个参数才可用。       

- `ignore_checksum_failure` (`boolean`)            

  ​        只有当[data checksums](http://www.postgres.cn/docs/14/app-initdb.html#APP-INITDB-DATA-CHECKSUMS)被启用时才有效。               在读取过程中检测到一次校验码失败通常会导致PostgreSQL报告一个错误。设置`ignore_checksum_failure`为打开会导致系统忽略失败（但是仍然报告一个警告），并且继续执行。这种行为可能*导致崩溃、传播或隐藏损坏或者其他严重的问题*。但是，它允许你绕过错误并且在块头部仍然健全的情况下从表中检索未损坏的元组。如果头部被损坏，即便这个选项被启用系统也将报告一个错误。默认设置是`off`，并且只能被超级用户改变。       

- `zero_damaged_pages` (`boolean`)            

  ​        检测到一个损坏的页面头部通常会导致PostgreSQL报告一个错误，并且中止当前事务。把`zero_damaged_pages`设置为打开会让系统报告一个警告、把损坏的页面填充零，然后继续处理。这种行为会*毁掉数据*，即被损坏页面上的所有行。但是它允许你绕开错误并且从可能存在表中的任何未损坏页面中检索行。如果由于一次硬件或软件错误而发生毁坏，这种方法可用于恢复数据。通常你不应该把它设置为打开，除非你已经彻底放弃从表的损坏页面中恢复数据。被填充零的页面不会被强制到磁盘上，因此我们推荐在再次关闭这个参数之前先重建表或索引。默认的设置是`off`，并且只有超级用户可以改变它。       

- `ignore_invalid_pages` (`boolean`)            

  ​        如果设置为 `off`（默认值），则在恢复期间检测到引用无效页面的 WAL 记录会导致 PostgreSQL 引发 PANIC 级别错误，中止恢复。        将`ignore_invalid_pages`设置为`on`会导致系统忽略 WAL 记录中的无效页面引用（但仍报告警告），并继续恢复。        此行为可能会*导致崩溃、数据丢失、传播或隐藏腐败，或其他严重问题*。        但是，它可能允许你通过 PANIC 级错误，完成恢复，并启动服务器。        参数只能在服务器启动时设置。它仅在恢复期间或待机模式下生效。       

- `jit_debugging_support` (`boolean`)            

  ​        如果LLVM有所需要的功能，用GDB注册所生成的函数。这会让调试更加容易。默认设置是`off`。这个参数只能在服务器启动时设置。       

- `jit_dump_bitcode` (`boolean`)            

  ​        把生成的LLVM IR写出到文件系统，写到[data_directory](http://www.postgres.cn/docs/14/runtime-config-file-locations.html#GUC-DATA-DIRECTORY)中。只有在做JIT内部实现工作时，这个参数才能派上用场。默认设置是`off`。这个参数只能由超级用户修改。       

- `jit_expressions` (`boolean`)            

  ​        当JIT编译被激活时（见[第 32.2 节](http://www.postgres.cn/docs/14/jit-decision.html)），确定表达式是否用JIT编译。默认值是`on`。       

- `jit_profiling_support` (`boolean`)            

  ​        如果LLVM有所需的功能，发出需要的数据以允许perf对JIT生成的函数画像。        这会写出文件到`~/.debug/jit/`中，如果需要，由用户负责对其执行清除。        默认设置是`off`。        这个参数只能在服务器启动时设置。       

- `jit_tuple_deforming` (`boolean`)            

  ​        当JIT编译被激活时（见[第 32.2 节](http://www.postgres.cn/docs/14/jit-decision.html)），确定元组拆解是否被JIT编译。默认值是`on`。       

- `remove_temp_files_after_crash` (`boolean`)            

  ​        当设置为`on`时，这是默认值，PostgreSQL将在后端崩溃后自动删除临时文件。        如果禁用，文件将被保留，并且也许可用于调试，例如。        重复的崩溃可能会导致无用文件的积累。        该参数只能在`postgresql.conf`文件中或服务器命令行中设置。       

##  短选项

​    为了方便起见，系统中还为一些参数提供了单字母的命令行选项开关。它们在[表 20.3](http://www.postgres.cn/docs/14/runtime-config-short.html#RUNTIME-CONFIG-SHORT-TABLE)中描述。其中一些选项是由于历史原因而存在，并且它们作为一个单字母选项存在并不表示它们会被大量使用。   

**表 20.3. 短选项键**

| 短选项                                                       | 等效于                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `-B *`x`*`                                                   | `shared_buffers = *`x`*`                                     |
| `-d *`x`*`                                                   | `log_min_messages = DEBUG*`x`*`                              |
| `-e`                                                         | `datestyle = euro`                                           |
| `-fb`, `-fh`, `-fi`,          `-fm`, `-fn`, `-fo`,          `-fs`, `-ft` | `enable_bitmapscan = off`,          `enable_hashjoin = off`,          `enable_indexscan = off`,          `enable_mergejoin = off`,          `enable_nestloop = off`,          `enable_indexonlyscan = off`,          `enable_seqscan = off`,          `enable_tidscan = off` |
| `-F`                                                         | `fsync = off`                                                |
| `-h *`x`*`                                                   | `listen_addresses = *`x`*`                                   |
| `-i`                                                         | `listen_addresses = '*'`                                     |
| `-k *`x`*`                                                   | `unix_socket_directories = *`x`*`                            |
| `-l`                                                         | `ssl = on`                                                   |
| `-N *`x`*`                                                   | `max_connections = *`x`*`                                    |
| `-O`                                                         | `allow_system_table_mods = on`                               |
| `-p *`x`*`                                                   | `port = *`x`*`                                               |
| `-P`                                                         | `ignore_system_indexes = on`                                 |
| `-s`                                                         | `log_statement_stats = on`                                   |
| `-S *`x`*`                                                   | `work_mem = *`x`*`                                           |
| `-tpa`, `-tpl`, `-te`                                        | `log_parser_stats = on`,        `log_planner_stats = on`,        `log_executor_stats = on` |
| `-W *`x`*`                                                   | `post_auth_delay = *`x`*`                                    |