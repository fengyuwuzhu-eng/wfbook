## 备份数据

使用以下方法： 		

- SQL dump			
- 文件系统级备份				
- 持续归档				

### SQL dump

SQL dump 方法基于使用 SQL 命令生成转储文件。

可使用以下客户端应用程序： 			

- **pg_dump**        转储单个数据库，而无需有关角色或表空间的集群范围的信息 					
- **pg_dumpall**   转储给定集群中的每个数据库，并保留集群范围的数据，如角色和表空间定义。 					

默认情况下，`pg_dump` 和 `pg_dumpall` 命令将它的们结果写入标准输出。要将转储保存到文件中，请将输出重定向到 SQL 文件。生成的 SQL 文件可以是文本格式，也可以是允许并行且可以更详细地控制对象恢复的其他格式。

可以在任何可访问数据库的远程主机中执行 SQL dump 。

#### 优点和缺陷

优点：

- SQL dump 是唯一的、不针对特定服务器版本的备份方法。pg_dump 工具的输出可以重新加载到 PostgreSQL 的后续版本中。 						
- SQL dump 是将数据库传输到不同计算机架构（比如从 32 位服务器传输到 64 位服务器）的唯一方法。 						
- SQL dump 提供内部一致的转储。转储表示在 pg_dump 开始运行时的数据库快照。
- pg_dump 程序不会阻止数据库中的其他操作。

缺点:

* 与文件系统级备份相比，它需要更长的时间。 				

#### 4.5.1.2. 使用 pg_dump 执行 SQL 转储

​						要转储一个没有集群范围信息的单个数据库，请使用 **pg_dump** 工具。 				

**先决条件**

- ​								您必须对要转储的所有表具有读的权限。若要转储整个数据库，您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

- ​								转储没有集群范围信息的数据库： 						

  ```none
  $ pg_dump dbname > dumpfile
  ```

​						要指定 **pg_dump** 会联系哪个数据库服务器，请使用以下命令行选项： 				

- ​								`-h` 选项用来定义主机 。 						

  ​								默认主机要么是本地主机，要么是 `PGHOST` 环境变量所指定的主机。 						

- ​								`-p` 选项用来定义端口 。 						

  ​								默认端口是由 `PGPORT` 环境变量或编译后的默认值指明的。 						

#### 4.5.1.3. 使用 pg_dumpall 执行 SQL 转储

​						要转储给定数据库集群中的每个数据库，并保留集群范围的数据，请使用 **pg_dumpall** 工具。 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

- ​								转储数据库集群中的所有数据库，并保留集群范围的数据： 						

  ```none
  $ pg_dumpall > dumpfile
  ```

​						要指定**pg_dumpall**与哪个数据库服务器联系，请使用以下命令行选项： 				

- ​								`-h` 选项用来定义主机 。 						

  ​								默认主机要么是本地主机，要么是 `PGHOST` 环境变量所指定的主机。 						

- ​								`-p` 选项用来定义端口 。 						

  ​								默认端口是由 `PGPORT` 环境变量或编译后的默认值指明的。 						

- ​								`-l` 选项用来定义默认数据库。 						

  ​								这个选项使您能够选择一个与初始化过程中自动创建的 `postgres` 数据库不同的默认数据库。 						

#### 4.5.1.4. 恢复使用 pg_dump 转储的数据库

​						要从使用 **pg_dump** 工具转储的 SQL 转储恢复数据库，请按照以下流程。 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

1. ​								创建新数据库： 						

   ```none
   $ createdb dbname
   ```

2. ​								确保所有拥有对象的用户或对转储数据库中的对象赋予了权限的用户都已存在。如果这样的用户不存在，恢复将无法重新创建具有原始所有权和权限的对象。 						

3. ​								运行 **psql** 工具来恢复 **pg_dump** 程序创建的文本文件转储： 						

   ```none
   $ psql dbname < dumpfile
   ```

   ​								其中 `dumpfile` 是 `pg_dump` 命令的输出。要恢复非文本文件转储，请使用 `pg_restore` 工具： 						

   ```none
   $ pg_restore non-plain-text-file
   ```

#### 4.5.1.5. 恢复使用 pg_dumpall 转储的数据库

​						要从使用 **pg_dumpall** 工具转储的数据库集群中恢复数据，请按照以下步骤。 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

1. ​								确保所有拥有对象的用户或对转储数据库中的对象赋予了权限的用户都已存在。如果这样的用户不存在，恢复将无法重新创建具有原始所有权和权限的对象。 						

2. ​								运行 **psql** 工具来恢复由 **pg_dumpall** 工具创建的文本文件转储： 						

   ```none
   $ psql < dumpfile
   ```

   ​								其中 `dumpfile` 是 `pg_dumpall` 命令的输出。 						

#### 4.5.1.6. 在另一服务器上执行数据库的 SQL 转储

​						将数据库从一台服务器直接转储到另一台服务器是可能的，因为 **pg_dump** 和 **psql** 可以写入管道并从管道读取。 				

**流程**

- ​								要从一个服务器到另一个服务器转储数据库，请运行： 						

  ```none
  $ pg_dump -h host1 dbname | psql -h host2 dbname
  ```

#### 4.5.1.7. 在恢复过程中处理 SQL 错误

​						默认情况下，如果出现 SQL 错误，**psql** 会继续执行，从而导致数据库只部分恢复。 				

​						要修改默认行为，在恢复转储时使用以下任一方法： 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

- ​								请设置 `ON_ERROR_STOP` 变量，使 **psql** 在发生 SQL 错误时退出，且有一个为 3 的退出状态码： 						

  ```none
  $ psql --set ON_ERROR_STOP=on dbname < dumpfile
  ```

- ​								指定整个转储作为一个事务来恢复，以便要么全部完成，要么全部取消。 						

  - ​										使用 `psql` 工具恢复文本文件转储时： 								

    ```none
    $ psql -1
    ```

  - ​										使用 `pg_restore` 工具恢复非文本文件转储时： 								

    ```none
    $ pg_restore -e
    ```

    ​										请注意，在使用这个方法时，即使一个小的错误也可以取消已经运行了很长时间的恢复操作。 								

1. ​								其他资源 						
   - ​										[PostgreSQL 文档 - SQL 转储](https://www.postgresql.org/docs/current/backup-dump.html)。 								

### 使用文件系统级别备份

​					要执行文件系统级备份，请将 **PostgreSQL** 数据库文件复制到其它位置。例如，您可以使用以下任一方法： 			

- ​							使用 **tar** 工具创建归档文件。 					
- ​							使用 **rsync** 工具将文件复制到其它位置。 					
- ​							创建数据目录的一致快照。 					

#### 4.5.2.1. 文件系统级别备份的优点和缺陷

​						文件系统级别备份与其他 **PostgreSQL** 备份方法相比有以下优点： 				

- ​								文件系统级的备份通常比 SQL 转储要快。 						

​						与其它 **PostgreSQL** 备份方法相比，文件系统级别备份有以下缺陷： 				

- ​								当您要从 RHEL 8 升级到 RHEL 9  时，这个备份方法不合适，并将您的数据迁移到升级的系统。文件系统级别备份是特定于架构的，特定于 RHEL 主版本。如果升级不成功，但无法在  RHEL 9 系统中恢复数据，则可以在 RHEL 8 系统中恢复数据。 						
- ​								数据库服务器必须在数据备份前和数据恢复前关闭。 						
- ​								无法备份和恢复某些独立文件或表。文件系统备份只能用于完整备份和恢复整个数据库集群。 						

#### 4.5.2.2. 执行文件系统级别备份

​						要执行文件系统级备份，请使用以下流程： 				

**流程**

1. ​								选择数据库集群的位置，并初始化该集群： 						

   ```none
   # postgresql-setup --initdb
   ```

2. ​								停止 postgresql 服务： 						

   ```none
   # systemctl stop postgresql.service
   ```

3. ​								使用任何方法来进行文件系统备份，例如 `tar` 归档： 						

   ```none
   $ tar -cf backup.tar /var/lib/pgsql/data
   ```

4. ​								启动 postgresql 服务： 						

   ```none
   # systemctl start postgresql.service
   ```

### 通过持续存档来备份

4.5.3.1. 持续归档介绍

​						**PostgreSQL** 将对数据库的数据文件所做的每项修改记录到预写日志(WAL)文件中，该文件位于集群数据目录的 `pg_wal/` 子目录中。此日志主要用于崩溃恢复。崩溃后，可用上次检查点以后所记录的日志条目将数据库恢复到一致。 				

​						持续归档方法也称为在线备份，以在运行的服务器上执行的基础备份或文件系统级备份的形式，将 WAL 文件与数据库集群的副本结合起来。 				

​						如果需要进行数据库恢复，您可以从数据库集群的副本恢复数据库，然后从备份的 WAL 文件中重新执行日志，使系统恢复到当前状态。 				

​						使用持续归档方法时，您必须保持所有归档的 WAL 文件的连续顺序，这些文件至少可扩展到上一次基础备份的开始时间。因此，基础备份的理想频率取决于： 				

- ​								归档 WAL 文件的存储卷。 						
- ​								需要恢复时数据恢复的最可能持续时间。如果自上次备份起已有较长时间，系统会重新执行更多的 WAL 段，因此恢复需要更长的时间。 						

注意

​							您不能将 **pg_dump** 和 **pg_dumpall** SQL 转储用作持续归档备份解决方案的一部分。SQL 转储生成逻辑备份，但所包含的信息不足以供WAL重新执行。 					

​						要使用持续归档方法执行数据库备份和恢复，请按照以下说明： 				

1. ​								设置并测试您归档 WAL 文件的步骤 - 请参阅 [第 4.5.3.3 节 “设置 WAL 归档”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#setting-wal-archiving)。 						
2. ​								执行基础备份 - 请参阅 [第 4.5.3.4 节 “进行基础备份”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#making-base-backup)。 						

​						要恢复您的数据，请按照 [第 4.5.3.5 节 “使用持续归档备份来恢复数据库”](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#restoring-database-with-continuous-archiving) 中的说明。 				

#### 4.5.3.2. 持续归档的优点和缺陷

​						与其它 **PostgreSQL** 备份方法相比，持续归档具有以下优势： 				

- ​								使用持续备份方法时，可以使用不完全一致的基础备份，因为备份中的任何内部不一致都可以被重新执行日志所修正。因此，您可以在正在运行的 **PostgreSQL** 服务器上执行基础备份。 						
- ​								不需要文件系统快照； `tar` 或类似的归档工具就足够了。 						
- ​								持续备份可以通过继续归档 WAL 文件来实现，因为日志重播的 WAL 文件序列可能会无限期地延长。这对大型数据库尤其重要。 						
- ​								持续备份支持点恢复。不需要将 WAL 条目重新显示到结尾。可在任何时间点停止重新执行，并且数据库可以恢复到执行基础备份以后的任何状态。 						
- ​								如果已经加载了相同的基础备份文件的另一台机器可以连续使用WAL文件系列，那么可以在任何时候用数据库几乎当前的副本来恢复其它机器。 						

​						与其他 **PostgreSQL** 备份方法相比，持续归档有以下缺点： 				

- ​								持续备份方法只支持恢复整个数据库集群，而不是子集。 						
- ​								持续备份需要广泛的归档存储。 						

#### 4.5.3.3. 设置 WAL 归档

​						运行的 **PostgreSQL** 服务器会生成一系列预写日志(WAL)记录。服务器物理上将该序列分成 WAL 段文件，这些文件被指定了数字名称，以反映它们在 WAL 序列中的位置。如果不进行 WAL 归档，段文件将被重新使用，并被重命名为更高的段号。 				

​						在归档 WAL 数据时，在重用段文件之前，都会捕获每一个段文件的内容，并将其保存在一个新的位置。您有多个保存内容的选项，例如其他机器上的 NFS 挂载目录、磁带驱动器或 CD。 				

​						请注意，WAL 记录不包括对配置文件的修改。 				

​						要启用 WAL 归档，请使用以下流程： 				

**流程**

1. ​								在 `/var/lib/pgsql/data/postgresql.conf` 文件中： 						

   1. ​										将 `wal_level` 配置参数设置为 `replica` 或更高的值。 								
   2. ​										将 `archive_mode` 参数设置为 `on`。 								
   3. ​										在 `archive_command` 配置参数中指定 shell 命令。您可以使用 `cp` 命令、其它命令或 shell 脚本。 								

2. ​								重启 `postgresql` 服务以使修改生效： 						

   ```none
   # systemctl restart postgresql.service
   ```

3. ​								测试您的归档命令，并确保它不会覆盖现有的文件，如果失败，它会返回一个非零的退出状态码。 						

4. ​								要保护您的数据，请确保将段文件归档到不具有组或全局读权限的目录中。 						

注意

​							归档命令只对已完成的 WAL 段执行。生成小 WAL 流量的服务器在交易完成和其归档存储中的安全记录之间可能会有很长时间的延迟。要限制未归档数据可保留多久，您可以： 					

- ​									设置 `archive_timeout` 参数，来强制服务器以给定频率切换到新的 WAL 段文件。 							
- ​									使用 `pg_switch_wal` 参数强制段切换，以确保交易在完成后立即归档。 							

**例 4.3. 用于归档 WAL 段的 shell 命令**

​							本例显示了您可以在 `archive_command` 配置参数中设置的简单 shell 命令。 					

​							以下命令将完成的段文件复制到所需位置： 					

```none
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
```

​							其中 `%p` 参数替换为归档文件的相对路径，`%f` 参数替换为文件名。 					

​							此命令将可归档的 WAL 段复制到 `/mnt/server/archivedir/` 目录中。替换 `%p` 和 `%f` 参数后，执行的命令如下所示： 					

```none
test ! -f /mnt/server/archivedir/00000001000000A900000065 && cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
```

​							对每个归档的新文件都会生成类似的命令。 					

**其他资源**

- ​								有关设置 WAL 存档的更多信息，请参阅 [PostgreSQL 13 文档](https://www.postgresql.org/docs/13/continuous-archiving.html#BACKUP-ARCHIVING-WAL) 						

#### 4.5.3.4. 进行基础备份

​						您可以通过多种方法创建基础备份：本节描述了在运行的 **PostgreSQL** 服务器上使用 **pg_basebackup** 工具执行基础备份的最简单的方法。 				

​						基础备份进程会创建一个备份历史记录文件，该文件存储在 WAL 归档区，并以基础备份所需的第一个 WAL 段文件来命名。 				

​						备份历史记录文件是一个小文本文件，其包含开始和结束时间，以及备份的 WAL 段。如果您使用标签字符串来标识关联的转储文件，那么您可以使用备份历史记录文件来确定要恢复哪个转储文件。 				

注意

​							请考虑保留多个备份集，以确保您可以恢复数据。 					

​						要执行基础备份，请使用以下流程： 				

**先决条件**

- ​								您必须以 `postgres` 超级用户身份、具有数据库管理员特权的用户身份或至少具有 `REPLICATION` 权限的其他用户身份来运行命令。 						
- ​								您必须保留在基础备份期间和之后生成的所有 WAL 段文件。 						

**流程**

1. ​								使用 `pg_basebackup` 工具执行基础备份。 						

   - ​										将基础备份创建为单个的文件（纯格式）： 								

     ```none
     $ pg_basebackup -D backup_directory -Fp
     ```

     ​										将 *backup_directory* 替换为您所希望的备份位置。 								

     ​										如果您在与服务器相同的主机上使用表空间并执行基础备份，那么也必须使用 `--tablespace-mapping` 选项，否则当试图将备份写入到同一位置时，备份将失败。 								

   - ​										将基础备份创建为一个 `tar` 归档（`tar` 和压缩格式）： 								

     ```none
     $ pg_basebackup -D backup_directory -Ft -z
     ```

     ​										将 *backup_directory* 替换为您所希望的备份位置。 								

     ​										要恢复此数据，您必须手动提取正确位置中的文件。 								

2. ​								基础备份进程完成后，将备份历史记录文件中指定的数据库集群副本和备份过程中使用的 WAL 段文件进行安全归档。 						

3. ​								删除比基础备份中使用的 WAL 段文件数值更低的WAL段，因为这些比基础备份旧，并且不再需要进行恢复。 						

​						要指定**serverpg_basebackup**将与哪个数据库联系，请使用以下命令行选项： 				

- ​								`-h` 选项用来定义主机的。 						

  ​								默认主机要么是本地主机，要么是 `PGHOST` 环境变量所指定的主机。 						

- ​								`-p` 选项用来定义端口。 						

  ​								默认端口是由 `PGPORT` 环境变量或编译后的默认值指明的。 						

**其他资源**

- ​								[PostgreSQL 文档 - 基础备份](https://www.postgresql.org/docs/current/continuous-archiving.html#BACKUP-BASE-BACKUP). 						
- ​								[PostgreSQL 文档 - **pg_basebackup** 工具](https://www.postgresql.org/docs/13/app-pgbasebackup.html)。 						

#### 4.5.3.5. 使用持续归档备份来恢复数据库

​						要使用持续备份来恢复数据库，请使用以下流程： 				

**流程**

1. ​								停止服务器： 						

   ```none
   # systemctl stop postgresql.service
   ```

2. ​								将必要的数据复制到临时位置。 						

   ​								最好复制整个集群数据目录和任何表空间。请注意，这需要系统上有足够的可用空间来保存现有数据库的两个副本。 						

   ​								如果您没有足够的空间，就保存集群的`pg_wal` 目录的内容，其中可能包含系统关闭前没有归档的日志。 						

3. ​								删除集群数据目录下的所有现有文件和子目录，并在您要使用的任何表空间的根目录下删除。 						

4. ​								从您的基础备份恢复数据库文件。 						

   ​								请确定： 						

   - ​										恢复的文件具有正确的所有权（数据库系统用户，而不是 `root`）。 								
   - ​										恢复的文件具有正确的权限。 								
   - ​										`pg_tblspc/` 子目录中的符号链接被正确恢复。 								

5. ​								删除 `pg_wal/` 子目录中的任何文件。 						

   ​								这些文件源自基础备份，因此已过时。如果您没有归档 `pg_wal/`，请重新创建它，并使其具有正确的权限。 						

6. ​								将你在步骤 2 中保存的任何未归档的 WAL 段文件复制到 `pg_wal/` 中。 						

7. ​								在集群数据目录中创建 `restore.conf` 恢复命令文件，并在 `restore_command` 配置参数中指定 shell 命令。您可以使用 `cp` 命令、其它命令或 shell 脚本。例如： 						

   ```none
   restore_command = 'cp /mnt/server/archivedir/%f "%p"'
   ```

8. ​								启动服务器： 						

   ```none
   # systemctl start postgresql.service
   ```

   ​								服务器将进入恢复模式，并继续读取所需的存档 WAL 文件。 						

   ​								如果恢复因为外部错误而终止，那么可以重启服务器，它将继续进行恢复。恢复过程完成后，服务器将 `restore.conf` 重命名为 `restore.done`。这可以防止服务器在启动正常的数据库操作后意外重新进入恢复模式。 						

9. ​								检查数据库的内容，确保数据库已恢复到所需的状态。 						

   ​								如果数据库尚未恢复到所需状态，请返回到第 1 步。如果数据库已恢复到所需的状态，那么通过恢复 `pg_hba.conf` 文件中的客户端身份验证配置来允许用户进行连接。 						

​						有关使用持续备份恢复的更多信息，请参阅 [PostgreSQL 文档](https://www.postgresql.org/docs/current/continuous-archiving.html#BACKUP-PITR-RECOVERY)。 				

**其他资源**

- ​								[PostgreSQL 文档 - 持续存档方法](https://www.postgresql.org/docs/current/continuous-archiving.html)。 						

## 4.6. 备份 PostgreSQL 数据

​				要备份 **PostgreSQL** 数据，请使用以下方法之一： 		

- SQL 转储

  ​							[请参阅使用 SQL 转储备份](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#backuping-postgresql-sql-dump_backing-up-postgresql-data)。 					

- 文件系统级别备份

  ​							请参阅 [文件系统级别备份](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#backuping-postgresql-system-level-backup_backing-up-postgresql-data)。 					

- 持续归档

  ​							请参阅 [持续归档](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#backuping-postgresql-continuous-archiving_backing-up-postgresql-data)。 					

### 4.6.1. 使用 SQL 转储备份 PostgreSQL 数据

​					SQL 转储方法基于使用 SQL 命令生成转储文件。当转储上传回数据库服务器时，它会按与转储时相同的状态重新创建数据库。 			

​					以下 **PostgreSQL** 客户端应用程序为 SQL 转储提供了保证： 			

- ​							**pg_dump** 转储单个数据库，而无需有关角色或表空间的集群范围的信息 					
- ​							**pg_dumpall** 转储给定集群中的每个数据库，并保留集群范围的数据，如角色和表空间定义。 					

​					默认情况下，`pg_dump` 和 `pg_dumpall` 命令将它的们结果写入标准输出。要将转储保存到文件中，请将输出重定向到 SQL 文件。生成的 SQL 文件可以是文本格式，也可以是允许并行且可以更详细地控制对象恢复的其他格式。 			

​					您可以在任何可访问数据库的远程主机中执行 SQL 转储。 			

#### 4.6.1.1. SQL 转储的优点和缺陷

​						与其它 **PostgreSQL** 备份方法相比，SQL 转储具有以下优点： 				

- ​								SQL 转储是唯一的、不针对特定服务器版本的 **PostgreSQL** 备份方法。**pg_dump** 工具的输出可以重新加载到 **PostgreSQL** 的后续版本中，这不适用于文件系统级备份或持续归档。 						
- ​								SQL 转储是将数据库传输到不同计算机架构（比如从 32 位服务器传输到 64 位服务器）的唯一方法。 						
- ​								SQL 转储提供内部一致的转储。转储表示在**pg_dump** 开始运行时的数据库快照。 						
- ​								**pg_dump** 程序不会阻止数据库中的其他操作。 						

​						SQL 转储的一个缺点是，与文件系统级备份相比，它需要更长的时间。 				

#### 4.6.1.2. 使用 pg_dump 执行 SQL 转储

​						要转储一个没有集群范围信息的单个数据库，请使用 **pg_dump** 工具。 				

**先决条件**

- ​								您必须对要转储的所有表具有读的权限。若要转储整个数据库，您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

- ​								转储没有集群范围信息的数据库： 						

  

  ```none
  $ pg_dump dbname > dumpfile
  ```

​						要指定 **pg_dump** 会联系哪个数据库服务器，请使用以下命令行选项： 				

- ​								`-h` 选项用来定义主机 。 						

  ​								默认主机要么是本地主机，要么是 `PGHOST` 环境变量所指定的主机。 						

- ​								`-p` 选项用来定义端口 。 						

  ​								默认端口是由 `PGPORT` 环境变量或编译后的默认值指明的。 						

#### 4.6.1.3. 使用 pg_dumpall 执行 SQL 转储

​						要转储给定数据库集群中的每个数据库，并保留集群范围的数据，请使用 **pg_dumpall** 工具。 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

- ​								转储数据库集群中的所有数据库，并保留集群范围的数据： 						

  ​								$ **pg_dumpall > dumpfile** 						

​						要指定**pg_dumpall**与哪个数据库服务器联系，请使用以下命令行选项： 				

- ​								`-h` 选项用来定义主机 。 						

  ​								默认主机要么是本地主机，要么是 `PGHOST` 环境变量所指定的主机。 						

- ​								`-p` 选项用来定义端口 。 						

  ​								默认端口是由 `PGPORT` 环境变量或编译后的默认值指明的。 						

- ​								`-l` 选项用来定义默认数据库。 						

  ​								这个选项使您能够选择一个与初始化过程中自动创建的 `postgres` 数据库不同的默认数据库。 						

#### 4.6.1.4. 恢复使用 pg_dump 转储的数据库

​						要从使用 **pg_dump** 工具转储的 SQL 转储恢复数据库，请按照以下流程。 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

1. ​								创建新数据库： 						

   

   ```none
   $ createdb dbname
   ```

2. ​								确保所有拥有对象的用户或对转储数据库中的对象赋予了权限的用户都已存在。如果这样的用户不存在，恢复将无法重新创建具有原始所有权和权限的对象。 						

3. ​								运行 **psql** 工具来恢复 **pg_dump** 程序创建的文本文件转储： 						

   

   ```none
   $ psql dbname < dumpfile
   ```

   ​								其中 `dumpfile` 是 `pg_dump` 命令的输出。要恢复非文本文件转储，请使用 `pg_restore` 工具： 						

   

   ```none
   $ pg_restore non-plain-text-file
   ```

#### 4.6.1.5. 恢复使用 pg_dumpall 转储的数据库

​						要从使用 **pg_dumpall** 工具转储的数据库集群中恢复数据，请按照以下步骤。 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

1. ​								确保所有拥有对象的用户或对转储数据库中的对象赋予了权限的用户都已存在。如果这样的用户不存在，恢复将无法重新创建具有原始所有权和权限的对象。 						

2. ​								运行 **psql** 工具来恢复由 **pg_dumpall** 工具创建的文本文件转储： 						

   

   ```none
   $ psql < dumpfile
   ```

   ​								其中 `dumpfile` 是 `pg_dumpall` 命令的输出。 						

#### 4.6.1.6. 在另一服务器上执行数据库的 SQL 转储

​						将数据库从一台服务器直接转储到另一台服务器是可能的，因为 **pg_dump** 和 **psql** 可以写入管道并从管道读取。 				

**流程**

- ​								要从一个服务器到另一个服务器转储数据库，请运行： 						

  

  ```none
  $ pg_dump -h host1 dbname | psql -h host2 dbname
  ```

#### 4.6.1.7. 在恢复过程中处理 SQL 错误

​						默认情况下，如果出现 SQL 错误，**psql** 会继续执行，从而导致数据库只部分恢复。 				

​						要修改默认行为，在恢复转储时使用以下任一方法： 				

**先决条件**

- ​								您必须以 `postgres` 超级用户或具有数据库管理员特权的用户身份运行命令。 						

**流程**

- ​								请设置 `ON_ERROR_STOP` 变量，使 **psql** 在发生 SQL 错误时退出，且有一个为 3 的退出状态码： 						

  ​								$ **psql --set ON_ERROR_STOP=on dbname < dumpfile** 						

- ​								指定整个转储作为一个事务来恢复，以便要么全部完成，要么全部取消。 						

  - ​										使用 `psql` 工具恢复文本文件转储时： 								

    

    ```none
    $ psql -1
    ```

  - ​										使用 `pg_restore` 工具恢复非文本文件转储时： 								

    

    ```none
    $ pg_restore -e
    ```

    ​										请注意，在使用这个方法时，即使一个小的错误也可以取消已经运行了很长时间的恢复操作。 								

#### 4.6.1.8. 其他资源

- ​								[PostgreSQL 文档 - SQL 转储](https://www.postgresql.org/docs/current/backup-dump.html) 						

### 4.6.2. 使用文件系统级别备份来备份 PostgreSQL 数据

​					要创建文件系统级别备份，请将 **PostgreSQL** 数据库文件复制到另一个位置。例如，您可以使用以下任一方法： 			

- ​							使用 **tar** 工具创建归档文件。 					
- ​							使用 **rsync** 工具将文件复制到其它位置。 					
- ​							创建数据目录的一致快照。 					

#### 4.6.2.1. 文件系统备份的优点和限制

​						文件系统级别备份与其他 **PostgreSQL** 备份方法相比有以下优点： 				

- ​								文件系统级的备份通常比 SQL 转储要快。 						

​						与其它 **PostgreSQL** 备份方法相比，文件系统级备份有以下限制： 				

- ​								当您要从 RHEL 8 升级到 RHEL 9 时，这个备份方法不合适，并将您的数据迁移到升级的系统。文件系统级别备份特定于架构和 RHEL 主版本。如果升级不成功，但无法在 RHEL 9 系统中恢复数据，则可以在 RHEL 8 系统中恢复数据。 						
- ​								在备份和恢复数据前，必须关闭数据库服务器。 						
- ​								无法备份和恢复某些独立文件或表。备份文件系统只适用于完全备份和恢复整个数据库集群。 						

#### 4.6.2.2. 执行文件系统级别备份

​						要执行文件系统级别备份，请使用以下步骤。 				

**流程**

1. ​								选择数据库集群的位置，并初始化该集群： 						

   

   ```none
   # postgresql-setup --initdb
   ```

2. ​								停止 postgresql 服务： 						

   

   ```none
   # systemctl stop postgresql.service
   ```

3. ​								使用任意方法创建文件系统备份，如 `tar` 归档： 						

   

   ```none
   $ tar -cf backup.tar /var/lib/pgsql/data
   ```

4. ​								启动 postgresql 服务： 						

   

   ```none
   # systemctl start postgresql.service
   ```

**其他资源**

- ​								[PostgreSQL 文档 - 文件系统级别备份](https://www.postgresql.org/docs/current/backup-file.html) 						

### 4.6.3. 通过持续存档来备份 PostgreSQL 数据

#### 4.6.3.1. 持续归档介绍

​						**PostgreSQL** 将对数据库的数据文件所做的每项修改记录到预写日志(WAL)文件中，该文件位于集群数据目录的 `pg_wal/` 子目录中。此日志主要用于崩溃恢复。崩溃后，可用上次检查点以后所记录的日志条目将数据库恢复到一致。 				

​						持续归档方法也称为在线备份，以在运行的服务器上执行的基础备份或文件系统级备份的形式，将 WAL 文件与数据库集群的副本结合起来。 				

​						如果需要进行数据库恢复，您可以从数据库集群的副本恢复数据库，然后从备份的 WAL 文件中重新执行日志，使系统恢复到当前状态。 				

​						使用持续归档方法时，您必须保持所有归档的 WAL 文件的连续顺序，这些文件至少可扩展到上一次基础备份的开始时间。因此，基本备份的理想频率取决于： 				

- ​								归档 WAL 文件的存储卷。 						
- ​								需要恢复时数据恢复的最可能持续时间。如果自上次备份起已有较长时间，系统会重新执行更多的 WAL 段，因此恢复需要更长的时间。 						

注意

​							您不能将 **pg_dump** 和 **pg_dumpall** SQL 转储用作持续归档备份解决方案的一部分。SQL 转储生成逻辑备份，但所包含的信息不足以供WAL重新执行。 					

​						要使用持续归档方法执行数据库备份和恢复，请按照以下说明： 				

1. ​								设置并测试归档 WAL 文件的步骤 - 请参阅 [WAL 归档](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#setting-wal-archiving)。 						
2. ​								执行基础备份 - 请参阅 [基础备份](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#making-base-backup)。 						

​						要恢复您的数据，请遵循 [使用持续归档恢复数据库](https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/configuring_and_using_database_servers/index#restoring-database-with-continuous-archiving) 中的说明。 				

#### 4.6.3.2. 持续归档的优点和缺陷

​						与其它 **PostgreSQL** 备份方法相比，持续归档具有以下优势： 				

- ​								使用持续备份方法时，可以使用不完全一致的基础备份，因为备份中的任何内部不一致都可以被重新执行日志所修正。因此，您可以在正在运行的 **PostgreSQL** 服务器上执行基础备份。 						
- ​								不需要文件系统快照； `tar` 或类似的归档工具就足够了。 						
- ​								持续备份可以通过继续归档 WAL 文件来实现，因为日志重播的 WAL 文件序列可能会无限期地延长。这对大型数据库尤其重要。 						
- ​								持续备份支持点恢复。不需要将 WAL 条目重新显示到结尾。可在任何时间点停止重新执行，并且数据库可以恢复到执行基础备份以后的任何状态。 						
- ​								如果已经加载了相同的基础备份文件的另一台机器可以连续使用WAL文件系列，那么可以在任何时候用数据库几乎当前的副本来恢复其它机器。 						

​						与其他 **PostgreSQL** 备份方法相比，持续归档有以下缺点： 				

- ​								持续备份方法只支持恢复整个数据库集群，而不是子集。 						
- ​								持续备份需要广泛的归档存储。 						

#### 4.6.3.3. 设置 WAL 归档

​						运行的 **PostgreSQL** 服务器会生成一系列预写日志(WAL)记录。服务器物理上将该序列分成 WAL 段文件，这些文件被指定了数字名称，以反映它们在 WAL 序列中的位置。如果不进行 WAL 归档，段文件将被重新使用，并被重命名为更高的段号。 				

​						在归档 WAL 数据时，在重用段文件之前，都会捕获每一个段文件的内容，并将其保存在一个新的位置。您有多个保存内容的选项，例如其他机器上的 NFS 挂载目录、磁带驱动器或 CD。 				

​						请注意，WAL 记录不包括对配置文件的修改。 				

​						要启用 WAL 归档，请使用以下流程： 				

**流程**

1. ​								在 `/var/lib/pgsql/data/postgresql.conf` 文件中： 						

   1. ​										将 `wal_level` 配置参数设置为 `replica` 或更高的值。 								
   2. ​										将 `archive_mode` 参数设置为 `on`。 								
   3. ​										在 `archive_command` 配置参数中指定 shell 命令。您可以使用 `cp` 命令、其它命令或 shell 脚本。 								

2. ​								重启 `postgresql` 服务以使修改生效： 						

   

   ```none
   # systemctl restart postgresql.service
   ```

3. ​								测试您的归档命令，并确保它不会覆盖现有的文件，如果失败，它会返回一个非零的退出状态码。 						

4. ​								要保护您的数据，请确保将段文件归档到不具有组或全局读权限的目录中。 						

注意

​							归档命令只对已完成的 WAL 段执行。生成小 WAL 流量的服务器在交易完成和其归档存储中的安全记录之间可能会有很长时间的延迟。要限制未归档数据可保留多久，您可以： 					

- ​									设置 `archive_timeout` 参数，来强制服务器以给定频率切换到新的 WAL 段文件。 							
- ​									使用 `pg_switch_wal` 参数强制段切换，以确保交易在完成后立即归档。 							

例 4.5. 用于归档 WAL 段的 shell 命令

​							本例显示了您可以在 `archive_command` 配置参数中设置的简单 shell 命令。 					

​							以下命令将完成的段文件复制到所需位置： 					



```none
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
```

​							其中 `%p` 参数替换为归档文件的相对路径，`%f` 参数替换为文件名。 					

​							此命令将可归档的 WAL 段复制到 `/mnt/server/archivedir/` 目录中。替换 `%p` 和 `%f` 参数后，执行的命令如下所示： 					



```none
test ! -f /mnt/server/archivedir/00000001000000A900000065 && cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
```

​							对每个归档的新文件都会生成类似的命令。 					

**其他资源**

- ​								[PostgreSQL 13 文档](https://www.postgresql.org/docs/13/continuous-archiving.html#BACKUP-ARCHIVING-WAL) 						

#### 4.6.3.4. 进行基础备份

​						您可以通过多种方法创建基础备份：本节描述了在运行的 **PostgreSQL** 服务器上使用 **pg_basebackup** 工具执行基础备份的最简单的方法。 				

​						基础备份进程会创建一个备份历史记录文件，该文件存储在 WAL 归档区，并以基础备份所需的第一个 WAL 段文件来命名。 				

​						备份历史记录文件是一个小文本文件，其包含开始和结束时间，以及备份的 WAL 段。如果您使用标签字符串来标识关联的转储文件，那么您可以使用备份历史记录文件来确定要恢复哪个转储文件。 				

注意

​							请考虑保留多个备份集，以确保您可以恢复数据。 					

​						要执行基础备份，请使用以下流程： 				

**先决条件**

- ​								您必须以 `postgres` 超级用户身份、具有数据库管理员特权的用户身份或至少具有 `REPLICATION` 权限的其他用户身份来运行命令。 						
- ​								您必须保留在基础备份期间和之后生成的所有 WAL 段文件。 						

**流程**

1. ​								使用 `pg_basebackup` 工具执行基础备份。 						

   - ​										将基础备份创建为单个的文件（纯格式）： 								

     

     ```none
     $ pg_basebackup -D backup_directory -Fp
     ```

     ​										将 *backup_directory* 替换为您所希望的备份位置。 								

     ​										如果您在与服务器相同的主机上使用表空间并执行基础备份，那么也必须使用 `--tablespace-mapping` 选项，否则当试图将备份写入到同一位置时，备份将失败。 								

   - ​										将基础备份创建为一个 `tar` 归档（`tar` 和压缩格式）： 								

     

     ```none
     $ pg_basebackup -D backup_directory -Ft -z
     ```

     ​										将 *backup_directory* 替换为您所希望的备份位置。 								

     ​										要恢复此数据，您必须手动提取正确位置中的文件。 								

2. ​								基础备份进程完成后，将备份历史记录文件中指定的数据库集群副本和备份过程中使用的 WAL 段文件进行安全归档。 						

3. ​								删除比基础备份中使用的 WAL 段文件数值更低的WAL段，因为这些比基础备份旧，并且不再需要进行恢复。 						

​						要指定**serverpg_basebackup**将与哪个数据库联系，请使用以下命令行选项： 				

- ​								`-h` 选项用来定义主机的。 						

  ​								默认主机要么是本地主机，要么是 `PGHOST` 环境变量所指定的主机。 						

- ​								`-p` 选项用来定义端口。 						

  ​								默认端口是由 `PGPORT` 环境变量或编译后的默认值指明的。 						

**其他资源**

- ​								[PostgreSQL 文档 - 基础备份](https://www.postgresql.org/docs/current/continuous-archiving.html#BACKUP-BASE-BACKUP) 						
- ​								[PostgreSQL 文档 - pg_basebackup 工具](https://www.postgresql.org/docs/13/app-pgbasebackup.html) 						

#### 4.6.3.5. 使用持续归档备份来恢复数据库

​						要使用持续备份来恢复数据库，请使用以下流程： 				

**流程**

1. ​								停止服务器： 						

   

   ```none
   # systemctl stop postgresql.service
   ```

2. ​								将必要的数据复制到临时位置。 						

   ​								最好复制整个集群数据目录和任何表空间。请注意，这需要系统上有足够的可用空间来保存现有数据库的两个副本。 						

   ​								如果您没有足够的空间，就保存集群的`pg_wal` 目录的内容，其中可能包含系统关闭前没有归档的日志。 						

3. ​								删除集群数据目录下的所有现有文件和子目录，并在您要使用的任何表空间的根目录下删除。 						

4. ​								从您的基础备份恢复数据库文件。 						

   ​								确保： 						

   - ​										恢复的文件具有正确的所有权（数据库系统用户，而不是 `root`）。 								
   - ​										恢复的文件具有正确的权限。 								
   - ​										`pg_tblspc/` 子目录中的符号链接被正确恢复。 								

5. ​								删除 `pg_wal/` 子目录中的任何文件。 						

   ​								这些文件源自基础备份，因此已过时。如果您没有归档 `pg_wal/`，请重新创建它，并使其具有正确的权限。 						

6. ​								将你在步骤 2 中保存的任何未归档的 WAL 段文件复制到 `pg_wal/` 中。 						

7. ​								在集群数据目录中创建 `restore.conf` 恢复命令文件，并在 `restore_command` 配置参数中指定 shell 命令。您可以使用 `cp` 命令、其它命令或 shell 脚本。例如： 						

   

   ```none
   restore_command = 'cp /mnt/server/archivedir/%f "%p"'
   ```

8. ​								启动服务器： 						

   

   ```none
   # systemctl start postgresql.service
   ```

   ​								服务器将进入恢复模式，并继续读取所需的存档 WAL 文件。 						

   ​								如果恢复因为外部错误而终止，那么可以重启服务器，它将继续进行恢复。恢复过程完成后，服务器将 `restore.conf` 重命名为 `restore.done`。这可以防止服务器在启动正常的数据库操作后意外重新进入恢复模式。 						

9. ​								检查数据库的内容，确保数据库已恢复到所需的状态。 						

   ​								如果数据库尚未恢复到所需状态，请返回到第 1 步。如果数据库已恢复到所需的状态，那么通过恢复 `pg_hba.conf` 文件中的客户端身份验证配置来允许用户进行连接。 						

​						有关使用持续备份恢复的更多信息，请参阅 [PostgreSQL 文档](https://www.postgresql.org/docs/current/continuous-archiving.html#BACKUP-PITR-RECOVERY)。 				

#### 4.6.3.6. 其他资源

- ​								[持续归档方法](https://www.postgresql.org/docs/current/continuous-archiving.html) 						