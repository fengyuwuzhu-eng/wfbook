## 表

### 创建

通过指定表的名字和所有列的名字及其类型来创建表∶

```sql
CREATE TABLE table_name(
   column1 datatype,
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
   PRIMARY KEY( 一个或多个列 )
);

CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- 最低温度
    temp_hi         int,           -- 最高温度
    prcp            real,          -- 湿度
    date            date
);
```

表名字必需在同一模式中的其它表、 序列、索引、视图或外部表名字中唯一。在当前数据库创建一个新的空白表，该表将由发出此命令的用户所拥有。

可以在 SQL 命令中自由使用空白（即空格、制表符和换行符）。

两个划线（“`--`”）引入注释。

SQL 是对关键字和标识符大小写不敏感的语言，只有在标识符用双引号包围时才能保留它们的大小写。

第二个例子将保存城市和它们相关的地理位置：

```sql
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
```

### 删除

使用 DROP TABLE 语句来删除表格，包含表格数据、规则、触发器等。删除表格要慎重，删除后所有信息就消失了。

```sql
DROP TABLE tablename;
```

### 查看表

```sql
# 使用 \d 命令来查看表格是否创建成功

mydb=# \d
           List of relations
 Schema |    Name    | Type  |  Owner   
--------+------------+-------+----------
 public | company    | table | postgres
 public | department | table | postgres
(2 rows)

# 使用 \d tablename 查看表格信息

mydb=# \d company
                  Table "public.company"
 Column  |     Type      | Collation | Nullable | Default 
---------+---------------+-----------+----------+---------
 id      | integer       |           | not null | 
 name    | text          |           | not null | 
 age     | integer       |           | not null | 
 address | character(50) |           |          | 
 salary  | real          |           |          | 
Indexes:
    "company_pkey" PRIMARY KEY, btree (id)
```

### 在表中增加行

INSERT INTO 语句用于向表中插入新记录。可以插入一行也可以同时插入多行。

```sql
INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN);
```

- column1, column2,...columnN 为表中字段名。
- value1, value2, value3,...valueN 为字段对应的值。

在使用 INSERT INTO 语句时，字段列必须和数据值数量相同，且顺序也要对应。

如果向表中的所有字段插入值，则可以不需要指定字段，只需要指定插入的值即可：

```sql
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
```

下表列出执行插入后返回结果的说明：

| 输出信息     | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| INSERT oid 1 | 只插入一行并且目标表具有 OID的返回信息， 那么 oid 是分配给被插入行的 OID。 |
| INSERT 0 #   | 插入多行返回的信息， # 为插入的行数。                        |

### 实例

在 mydb 数据库中创建 COMPANY 表：

```sql
mydb=# CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL,
   JOIN_DATE      DATE
);
```

在 COMPANY 表中插入以下数据：

```sql
mydb=# INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) VALUES (1, 'Paul', 32, 'California', 20000.00,'2001-07-13');
INSERT 0 1
```

以下插入语句忽略 SALARY 字段：

```sql
mydb=# INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,JOIN_DATE) VALUES (2, 'Allen', 25, 'Texas', '2007-12-13');
INSERT 0 1
```

以下插入语句 JOIN_DATE 字段使用 DEFAULT 子句来设置默认值，而不是指定值：

```sql
mydb=# INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) VALUES (3, 'Teddy', 23, 'Norway', 20000.00, DEFAULT );
INSERT 0 1
```

以下实例插入多行：

```sql
mydb=# INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00, '2007-12-13' ), (5, 'David', 27, 'Texas', 85000.00, '2007-12-13');
INSERT 0 2
```

使用 SELECT 语句查询表格数据：

```sql
mydb=# SELECT * FROM company;

ID        NAME        AGE        ADDRESS     SALARY   JOIN_DATE
----      ----------  -----      ----------  -------      --------
1         Paul        32         California  20000.0      2001-07-13
2         Allen       25         Texas                    2007-12-13
3         Teddy       23         Norway      20000.0
4         Mark        25         Rich-Mond   65000.0      2007-12-13
5         David       27         Texas       85000.0      2007-12-13
```

可以使用 `COPY` 从文本文件中装载大量数据。这种方式通常更快，因为 `COPY` 命令就是为这类应用优化的， 只是比 `INSERT` 少一些灵活性。比如：

```bash
COPY weather FROM '/home/user/weather.txt';
```

这里源文件的文件名必须在运行后端进程的机器上是可用的，而不是在客户端上，因为后端进程将直接读取该文件。   

### 查询一个表

SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。

要检索表 `weather` 的所有行，键入：

```sql
SELECT * FROM weather;
```

可以在选择列表中写任意表达式，而不仅仅是列的列表。

```sql
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;

-- AS子句是如何给输出列重新命名的（AS子句是可选的）。
```

一个查询可以使用 `WHERE` 子句“修饰”，它指定需要哪些行。`WHERE` 子句包含一个布尔（真值）表达式，只有那些使布尔表达式为真的行才会被返回。在条件中可以使用常用的布尔操作符（`AND`、`OR` 和 `NOT`）。

```sql
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp > 0.0;
```

可以要求返回的查询结果是排好序的：

```sql
SELECT * FROM weather
    ORDER BY city;
```

在这个例子里，排序的顺序并未完全被指定，因此你可能看到属于旧金山的行被随机地排序。但是如果你使用下面的语句，那么就总是会得到上面的结果：

```sql
SELECT * FROM weather
    ORDER BY city, temp_lo;
```

可以要求在查询的结果中消除重复的行：

```sql
SELECT DISTINCT city
    FROM weather;
```

结果行的顺序可能变化。可以组合使用`DISTINCT`和`ORDER BY`来保证获取一致的结果：

```sql
SELECT DISTINCT city
    FROM weather
    ORDER BY city;     
```

### 在表之间连接

一个同时访问同一个或者不同表的多个行的查询叫**连接查询**。 

```sql
SELECT *
    FROM weather, cities
    WHERE city = name;
    
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;
```

列的名字都不一样，规划器自动地找出它们属于哪个表。如果在两个表里有重名的列，需要**限定**列名来说明究竟想要哪一个：

```sql
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
```

广泛认为在一个连接查询中限定所有列名是一种好的风格，这样即使未来向其中一个表里添加重名列也不会导致查询失败。

到目前为止，这种类型的连接查询也可以用下面这样的形式写出来：

```sql
SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);
```

想让查询干的事是扫描 `weather`表， 并且对每一行都找出匹配的`cities`表行。如果我们没有找到匹配的行，那么我们需要一些“空值”代替cities表的列。 这种类型的查询叫**外连接** 。

```sql
SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);
```

这个查询是一个**左外连接**， 因为在连接操作符左部的表中的行在输出中至少要出现一次， 而在右部的表的行只有在能找到匹配的左部表行时才被输出。 如果输出的左部表的行没有对应匹配的右部表的行，那么右部表行的列将填充空值（null）。   

也可以把一个表和自己连接起来。这叫做**自连接**。 比如，假设我们想找出那些在其它天气记录的温度范围之外的天气记录。这样我们就需要拿 `weather`表里每行的`temp_lo`和`temp_hi`列与`weather`表里其它行的`temp_lo`和`temp_hi`列进行比较。我们可以用下面的查询实现这个目标：

```sql
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo < W2.temp_lo
    AND W1.temp_hi > W2.temp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
```

在这里我们把weather表重新标记为`W1`和`W2`以区分连接的左部和右部。你还可以用这样的别名在其它查询里节约一些敲键，比如：

```sql
SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;
```

### 聚集函数

一个聚集函数从多个输入行中计算出一个结果。 比如，我们有在一个行集合上计算`count`（计数）、`sum`（和）、`avg`（均值）、`max`（最大值）和`min`（最小值）的函数。   

比如，可以用下面的语句找出所有记录中最低温度中的最高温度：

```sql
SELECT max(temp_lo) FROM weather;

 max
-----
  46
(1 row)
```

如果我们想知道该读数发生在哪个城市，我们可以用：

```sql
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     -- 错误
```

聚集 `max` 不能被用于 `WHERE` 子句中（存在这个限制是因为 `WHERE` 子句决定哪些行可以被聚集计算包括；因此显然它必需在聚集函数之前被计算）。 不过，我们通常都可以用其它方法实现我们的目的；这里我们就可以使用**子查询**：

```sql
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
    
     city
---------------
 San Francisco
(1 row)
```

子查询是一次独立的计算，它独立于外层的查询计算出自己的聚集。   

聚集同样也常用于和`GROUP BY`子句组合。比如，我们可以获取每个城市观测到的最低温度的最高值：

```sql
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
    
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)
```

这样给我们每个城市一个输出。每个聚集结果都是在匹配该城市的表行上面计算的。我们可以用`HAVING` 过滤这些被分组的行：

```sql
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) < 40;
    
  city   | max
---------+-----
 Hayward |  37
(1 row)
```

这样就只给出那些所有`temp_lo`值曾都低于 40的城市。最后，如果我们只关心那些名字以“`S`”开头的城市，我们可以用：

```sql
SELECT city, max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'
    GROUP BY city
    HAVING max(temp_lo) < 40;
```

`WHERE` 和 `HAVING` 的基本区别如下：

`WHERE`在分组和聚集计算之前选取输入行（因此，它控制哪些行进入聚集计算）， 而`HAVING`在分组和聚集之后选取分组行。相反，`HAVING`子句总是包含聚集函数（严格说来，你可以写不使用聚集的`HAVING`子句， 但这样做很少有用。同样的条件用在`WHERE`阶段会更有效）。      

### 更新

`UPDATE` 命令更新现有的行。假设发现所有 11 月 28 日以后的温度读数都低了两度，那么就可以用下面的方式改正数据：

```sql
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date > '1994-11-28';
```

###  删除

```sql
DELETE FROM weather WHERE city = 'Hayward';
```

用下面形式的语句的时候一定要小心

```sql
DELETE FROM tablename;
```

如果没有一个限制，`DELETE`将从指定表中删除所有行，把它清空。

## 