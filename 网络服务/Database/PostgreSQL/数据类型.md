## 数据类型

数据类型是我们在创建表的时候为每个字段设置的。

### 数值类型

数值类型由 2 字节、4 字节或 8 字节的整数以及 4 字节或 8 字节的浮点数和可选精度的十进制数组成。

| 名字             | 存储长度 | 描述                 | 范围                                         |
| ---------------- | -------- | -------------------- | -------------------------------------------- |
| smallint         | 2 字节   | 小范围整数           | -32768 到 +32767                             |
| integer          | 4 字节   | 常用的整数           | -2147483648 到 +2147483647                   |
| bigint           | 8 字节   | 大范围整数           | -9223372036854775808 到 +9223372036854775807 |
| decimal          | 可变长   | 用户指定的精度，精确 | 小数点前 131072 位；小数点后 16383 位        |
| numeric          | 可变长   | 用户指定的精度，精确 | 小数点前 131072 位；小数点后 16383 位        |
| real             | 4 字节   | 可变精度，不精确     | 6 位十进制数字精度                           |
| double precision | 8 字节   | 可变精度，不精确     | 15 位十进制数字精度                          |
| smallserial      | 2 字节   | 自增的小范围整数     | 1 到 32767                                   |
| serial           | 4 字节   | 自增整数             | 1 到 2147483647                              |
| bigserial        | 8 字节   | 自增的大范围整数     | 1 到 9223372036854775807                     |

### 货币类型

money 类型存储带有固定小数精度的货币金额。

numeric、int 和 bigint 类型的值可以转换为 money，不建议使用浮点数来处理处理货币类型，因为存在舍入错误的可能性。

| 名字  | 存储容量 | 描述     | 范围                                           |
| ----- | -------- | -------- | ---------------------------------------------- |
| money | 8 字节   | 货币金额 | -92233720368547758.08 到 +92233720368547758.07 |

### 字符类型

| 名字                             | 描述              |
| -------------------------------- | ----------------- |
| character varying(n), varchar(n) | 变长，有长度限制  |
| character(n), char(n)            | f 定长,不足补空白 |
| text                             | 变长，无长度限制  |

### 日期/时间类型

| 名字                                      | 存储空间 | 描述                     | 最低值        | 最高值        | 分辨率         |
| ----------------------------------------- | -------- | ------------------------ | ------------- | ------------- | -------------- |
| timestamp [ (*p*) ] [ without time zone ] | 8 字节   | 日期和时间(无时区)       | 4713 BC       | 294276 AD     | 1 毫秒 / 14 位 |
| timestamp [ (*p*) ] with time zone        | 8 字节   | 日期和时间，有时区       | 4713 BC       | 294276 AD     | 1 毫秒 / 14 位 |
| date                                      | 4 字节   | 只用于日期               | 4713 BC       | 5874897 AD    | 1 天           |
| time [ (*p*) ] [ without time zone ]      | 8 字节   | 只用于一日内时间         | 00:00:00      | 24:00:00      | 1 毫秒 / 14 位 |
| time [ (*p*) ] with time zone             | 12 字节  | 只用于一日内时间，带时区 | 00:00:00+1459 | 24:00:00-1459 | 1 毫秒 / 14 位 |
| interval [ *fields* ] [ (*p*) ]           | 12 字节  | 时间间隔                 | -178000000 年 | 178000000 年  | 1 毫秒 / 14 位 |

### 布尔类型

boolean 有 "true"(真) 或 "false"(假) 两个状态， 第三种 "unknown"(未知) 状态，用 NULL 表示。

| 名称    | 存储格式 | 描述         |
| ------- | -------- | ------------ |
| boolean | 1 字节   | true / false |

### 枚举类型

枚举类型是一个包含静态和值的有序集合的数据类型。类似于 C 语言中的 enum 类型。

枚举类型需要使用 CREATE TYPE 命令创建。

```sql
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
```

创建一周中的几天，如下所示:

```sql
CREATE TYPE week AS ENUM ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');
```

就像其他类型一样，一旦创建，枚举类型可以用于表和函数定义。

```sql
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood 
------+--------------
 Moe  | happy
(1 row)
```

### 几何类型

表示二维的平面物体。最基本的类型：点。它是其它类型的基础。

| 名字    | 存储空间    | 说明                   | 表现形式               |
| ------- | ----------- | ---------------------- | ---------------------- |
| point   | 16 字节     | 平面中的点             | (x,y)                  |
| line    | 32 字节     | (无穷)直线(未完全实现) | ((x1,y1),(x2,y2))      |
| lseg    | 32 字节     | (有限)线段             | ((x1,y1),(x2,y2))      |
| box     | 32 字节     | 矩形                   | ((x1,y1),(x2,y2))      |
| path    | 16+16n 字节 | 闭合路径(与多边形类似) | ((x1,y1),...)          |
| path    | 16+16n 字节 | 开放路径               | [(x1,y1),...]          |
| polygon | 40+16n 字节 | 多边形(与闭合路径相似) | ((x1,y1),...)          |
| circle  | 24 字节     | 圆                     | <(x,y),r> (圆心和半径) |

### 网络地址类型

用于存储 IPv4 、IPv6 、MAC 地址的数据类型。

用这些数据类型存储网络地址比用纯文本类型好， 因为这些类型提供输入错误检查和特殊的操作和功能。

| 名字    | 存储空间     | 描述                    |
| ------- | ------------ | ----------------------- |
| cidr    | 7 或 19 字节 | IPv4 或 IPv6 网络       |
| inet    | 7 或 19 字节 | IPv4 或 IPv6 主机和网络 |
| macaddr | 6 字节       | MAC 地址                |

在对 inet 或 cidr 数据类型进行排序的时候， IPv4 地址总是排在 IPv6 地址前面，包括那些封装或者是映射在 IPv6 地址里的 IPv4 地址， 比如 `::10.2.3.4` 或 `::ffff:10.4.3.2` 。

### 位串类型

位串就是一串 1 和 0 的字符串。用于存储和直观化位掩码。 有两种 SQL 位类型：bit(n) 和bit varying(n)， n 是一个正整数。

bit 类型的数据必须准确匹配长度 n， 试图存储短些或者长一些的数据都是错误的。bit varying 类型数据是最长 n  的变长类型；更长的串会被拒绝。 写一个没有长度的bit 等效于 bit(1)， 没有长度的 bit varying 意思是没有长度限制。

### 文本搜索类型

全文检索即通过自然语言文档的集合来找到那些匹配一个查询的检索。

| 名字     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| tsvector | tsvector 的值是一个无重复值的 lexemes 排序列表， 即一些同一个词的不同变种的标准化。 |
| tsquery  | tsquery 存储用于检索的词汇，并且使用布尔操作符 &(AND)，\|(OR) 和 !(NOT) 来组合它们，括号用来强调操作符的分组。 |

### UUID 类型

uuid 数据类型用来存储 RFC 4122，ISO/IEF 9834-8:2005 以及相关标准定义的通用唯一标识符（UUID）。  （一些系统认为这个数据类型为全球唯一标识符，或 GUID ） 这个标识符是一个由算法产生的 128 位标识符，使它不可能在已知使用相同算法的模块中和其他方式产生的标识符相同。因此，对分布式系统而言，这种标识符比序列能更好的提供唯一性保证，因为序列只能在单一数据库中保证唯一。

UUID 被写成一个小写十六进制数字的序列，由分字符分成几组， 特别是一组8位数字+3组4位数字+一组12位数字，总共 32 个数字代表 128 位， 一个这种标准的 UUID 例子如下：

```bash
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
```

### XML 类型

xml 数据类型可以用于存储 XML 数据。 将 XML 数据存到 text 类型中的优势在于它能够为结构良好性来检查输入值， 且支持函数对其进行类型安全性检查。 使用这个数据类型，编译时必须使用 `configure --with-libxml` 。

xml 可以存储由 XML 标准定义的格式良好的"文档"， 以及由 XML 标准中的 **XMLDecl? content** 定义的"内容"片段， 大致上，这意味着内容片段可以有多个顶级元素或字符节点。 xmlvalue IS DOCUMENT 表达式可以用来判断一个特定的 xml 值是一个完整的文件还是内容片段。

#### 创建XML值

使用函数 xmlparse: 来从字符数据产生 xml 类型的值：

```sql
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
```

### JSON 类型

json 数据类型可以用来存储 JSON（JavaScript Object Notation）数据， 这样的数据也可以存储为 text，但是 json 数据类型更有利于检查每个存储的数值是可用的 JSON 值。

| 实例                                     | 实例结果            |
| ---------------------------------------- | ------------------- |
| array_to_json('{{1,5},{99,100}}'::int[]) | [[1,5],[99,100]]    |
| row_to_json(row(1,'foo'))                | {"f1":1,"f2":"foo"} |

### 数组类型

将字段定义成变长的多维数组。

数组类型可以是任何基本类型或用户定义类型，枚举类型或复合类型。 

#### 声明数组

创建表的时候，可以声明数组，方式如下：

```sql
CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);
```

pay_by_quarter 为一维整型数组、schedule 为二维文本类型数组。

也可以使用 "ARRAY" 关键字，如下所示：

```sql
CREATE TABLE sal_emp (
   name           text,
   pay_by_quarter integer ARRAY[4],
   schedule       text[][]
);
```

#### 插入值

插入值使用花括号 {}，元素在 {} 使用逗号隔开：

```sql
INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');
```

#### 访问数组

```sql
SELECT name FROM sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2];

 name
-------
 Carol
(1 row)
```

数组的下标数字是写在方括弧内的。

#### 修改数组

```sql
UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';
```

或者使用 ARRAY 构造器语法：

```sql
UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';
```

#### 数组中检索

要搜索一个数组中的数值，必须检查该数组的每一个值。

比如：

```sql
SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;
```

另外，你可以用下面的语句找出数组中所有元素值都等于 10000 的行：

```sql
SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);
```

或者，可以使用 generate_subscripts 函数。例如：

```sql
SELECT * FROM
   (SELECT pay_by_quarter,
           generate_subscripts(pay_by_quarter, 1) AS s
      FROM sal_emp) AS foo
 WHERE pay_by_quarter[s] = 10000;
```

### 复合类型

复合类型表示一行或者一条记录的结构； 它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL 允许像简单数据类型那样使用复合类型。比如，一个表的某个字段可以声明为一个复合类型。

#### 声明复合类型

下面是两个定义复合类型的简单例子：

```sql
CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);
```

语法类似于 CREATE TABLE，只是这里只可以声明字段名字和类型。

定义了类型，我们就可以用它创建表：

```sql
CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);
```

#### 复合类型值输入

要以文本常量书写复合类型值，在圆括弧里包围字段值并且用逗号分隔他们。 你可以在任何字段值周围放上双引号，如果值本身包含逗号或者圆括弧， 你必须用双引号括起。

复合类型常量的一般格式如下：

```sql
'( val1 , val2 , ... )'
```

一个例子是:

```sql
'("fuzzy dice",42,1.99)'
```

#### 访问复合类型

要访问复合类型字段的一个域，我们写出一个点以及域的名字， 非常类似从一个表名字里选出一个字段。实际上，因为实在太像从表名字中选取字段， 所以我们经常需要用圆括弧来避免分析器混淆。比如，你可能需要从on_hand 例子表中选取一些子域，像下面这样：

```sql
SELECT item.name FROM on_hand WHERE item.price > 9.99;
```

这样将不能工作，因为根据 SQL 语法，item是从一个表名字选取的， 而不是一个字段名字。你必须像下面这样写：

```sql
SELECT (item).name FROM on_hand WHERE (item).price > 9.99;
```

或者如果你也需要使用表名字(比如，在一个多表查询里)，那么这么写：

```sql
SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;
```

现在圆括弧对象正确地解析为一个指向item字段的引用，然后就可以从中选取子域。

### 范围类型

范围数据类型代表着某一元素类型在一定范围内的值。

例如，timestamp 范围可能被用于代表一间会议室被预定的时间范围。

PostgreSQL 内置的范围类型有：

- int4range — integer的范围      
- int8range —bigint的范围      
- numrange —numeric的范围      
- tsrange —timestamp without time zone的范围      
- tstzrange —timestamp with time zone的范围      
- daterange —date的范围      

此外，你可以定义你自己的范围类型。

```sql
CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');

-- 包含
SELECT int4range(10, 20) @> 3;

-- 重叠
SELECT numrange(11.1, 22.2) && numrange(20.0, 30.0);

-- 提取上边界
SELECT upper(int8range(15, 25));

-- 计算交叉
SELECT int4range(10, 20) * int4range(15, 25);

-- 范围是否为空
SELECT isempty(numrange(1, 5));
```

范围值的输入必须遵循下面的格式：

```sql
(下边界,上边界)
(下边界,上边界]
[下边界,上边界)
[下边界,上边界]
空
```

圆括号或者方括号显示下边界和上边界是不包含的还是包含的。注意最后的格式是 空，代表着一个空的范围（一个不含有值的范围）。

```sql
-- 包括3，不包括7，并且包括二者之间的所有点
SELECT '[3,7)'::int4range;

-- 不包括3和7，但是包括二者之间所有点
SELECT '(3,7)'::int4range;

-- 只包括单一值4
SELECT '[4,4]'::int4range;

-- 不包括点（被标准化为‘空’）
SELECT '[4,4)'::int4range;
```

### 对象标识符类型

PostgreSQL 在内部使用对象标识符(OID)作为各种系统表的主键。

同时，系统不会给用户创建的表增加一个 OID 系统字段(除非在建表时声明了WITH OIDS  或者配置参数default_with_oids设置为开启)。oid 类型代表一个对象标识符。除此以外 oid 还有几个别名：regproc,  regprocedure, regoper, regoperator, regclass, regtype, regconfig,  和 regdictionary。

| 名字          | 引用         | 描述               | 数值例子                              |
| ------------- | ------------ | ------------------ | ------------------------------------- |
| oid           | 任意         | 数字化的对象标识符 | 564182                                |
| regproc       | pg_proc      | 函数名字           | sum                                   |
| regprocedure  | pg_proc      | 带参数类型的函数   | sum(int4)                             |
| regoper       | pg_operator  | 操作符名           | +                                     |
| regoperator   | pg_operator  | 带参数类型的操作符 | *(integer,integer) 或 -(NONE,integer) |
| regclass      | pg_class     | 关系名             | pg_type                               |
| regtype       | pg_type      | 数据类型名         | integer                               |
| regconfig     | pg_ts_config | 文本搜索配置       | english                               |
| regdictionary | pg_ts_dict   | 文本搜索字典       | simple                                |

### 伪类型

PostgreSQL类型系统包含一系列特殊用途的条目， 它们按照类别来说叫做伪类型。伪类型不能作为字段的数据类型， 但是它可以用于声明一个函数的参数或者结果类型。 伪类型在一个函数不只是简单地接受并返回某种SQL 数据类型的情况下很有用。

| 名字             | 描述                                               |
| ---------------- | -------------------------------------------------- |
| any              | 表示一个函数接受任何输入数据类型。                 |
| anyelement       | 表示一个函数接受任何数据类型。                     |
| anyarray         | 表示一个函数接受任意数组数据类型。                 |
| anynonarray      | 表示一个函数接受任意非数组数据类型。               |
| anyenum          | 表示一个函数接受任意枚举数据类型。                 |
| anyrange         | 表示一个函数接受任意范围数据类型。                 |
| cstring          | 表示一个函数接受或者返回一个空结尾的 C 字符串。    |
| internal         | 表示一个函数接受或者返回一种服务器内部的数据类型。 |
| language_handler | 一个过程语言调用处理器声明为返回language_handler。 |
| fdw_handler      | 一个外部数据封装器声明为返回fdw_handler。          |
| record           | 标识一个函数返回一个未声明的行类型。               |
| trigger          | 一个触发器函数声明为返回trigger。                  |
| void             | 表示一个函数不返回数值。                           |
| opaque           | 一个已经过时的类型，以前用于所有上面这些用途。     |

## 第 8 章 数据类型

**目录**

- [8.1. 数字类型](http://www.postgres.cn/docs/13/datatype-numeric.html)

  [8.1.1. 整数类型](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-INT)[8.1.2. 任意精度数字](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL)[8.1.3. 浮点类型](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-FLOAT)[8.1.4. 序数类型](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-SERIAL)

- [8.2. 货币类型](http://www.postgres.cn/docs/13/datatype-money.html)

- [8.3. 字符类型](http://www.postgres.cn/docs/13/datatype-character.html)

- [8.4. 二进制数据类型](http://www.postgres.cn/docs/13/datatype-binary.html)

  [8.4.1. `bytea`的十六进制格式](http://www.postgres.cn/docs/13/datatype-binary.html#id-1.5.7.12.9)[8.4.2. `bytea`的转义格式](http://www.postgres.cn/docs/13/datatype-binary.html#id-1.5.7.12.10)

- [8.5. 日期/时间类型](http://www.postgres.cn/docs/13/datatype-datetime.html)

  [8.5.1.  日期/时间输入](http://www.postgres.cn/docs/13/datatype-datetime.html#DATATYPE-DATETIME-INPUT)[8.5.2. 日期/时间输出](http://www.postgres.cn/docs/13/datatype-datetime.html#DATATYPE-DATETIME-OUTPUT)[8.5.3.  时区](http://www.postgres.cn/docs/13/datatype-datetime.html#DATATYPE-TIMEZONES)[8.5.4. 间隔输入](http://www.postgres.cn/docs/13/datatype-datetime.html#DATATYPE-INTERVAL-INPUT)[8.5.5. 间隔输出](http://www.postgres.cn/docs/13/datatype-datetime.html#DATATYPE-INTERVAL-OUTPUT)

- [8.6. 布尔类型](http://www.postgres.cn/docs/13/datatype-boolean.html)

- [8.7. 枚举类型](http://www.postgres.cn/docs/13/datatype-enum.html)

  [8.7.1. 枚举类型的声明](http://www.postgres.cn/docs/13/datatype-enum.html#id-1.5.7.15.5)[8.7.2. 排序](http://www.postgres.cn/docs/13/datatype-enum.html#id-1.5.7.15.6)[8.7.3. 类型安全性](http://www.postgres.cn/docs/13/datatype-enum.html#id-1.5.7.15.7)[8.7.4. 实现细节](http://www.postgres.cn/docs/13/datatype-enum.html#id-1.5.7.15.8)

- [8.8. 几何类型](http://www.postgres.cn/docs/13/datatype-geometric.html)

  [8.8.1. 点](http://www.postgres.cn/docs/13/datatype-geometric.html#id-1.5.7.16.5)[8.8.2. 线](http://www.postgres.cn/docs/13/datatype-geometric.html#DATATYPE-LINE)[8.8.3. 线段](http://www.postgres.cn/docs/13/datatype-geometric.html#DATATYPE-LSEG)[8.8.4. 方框](http://www.postgres.cn/docs/13/datatype-geometric.html#id-1.5.7.16.8)[8.8.5. 路径](http://www.postgres.cn/docs/13/datatype-geometric.html#id-1.5.7.16.9)[8.8.6. 多边形](http://www.postgres.cn/docs/13/datatype-geometric.html#DATATYPE-POLYGON)[8.8.7. 圆](http://www.postgres.cn/docs/13/datatype-geometric.html#DATATYPE-CIRCLE)

- [8.9. 网络地址类型](http://www.postgres.cn/docs/13/datatype-net-types.html)

  [8.9.1. `inet`](http://www.postgres.cn/docs/13/datatype-net-types.html#DATATYPE-INET)[8.9.2. `cidr`](http://www.postgres.cn/docs/13/datatype-net-types.html#DATATYPE-CIDR)[8.9.3. `inet` vs. `cidr`](http://www.postgres.cn/docs/13/datatype-net-types.html#DATATYPE-INET-VS-CIDR)[8.9.4. `macaddr`](http://www.postgres.cn/docs/13/datatype-net-types.html#DATATYPE-MACADDR)[8.9.5. `macaddr8`](http://www.postgres.cn/docs/13/datatype-net-types.html#DATATYPE-MACADDR8)

- [8.10. 位串类型](http://www.postgres.cn/docs/13/datatype-bit.html)

- [8.11. 文本搜索类型](http://www.postgres.cn/docs/13/datatype-textsearch.html)

  [8.11.1. `tsvector`](http://www.postgres.cn/docs/13/datatype-textsearch.html#DATATYPE-TSVECTOR)[8.11.2. `tsquery`](http://www.postgres.cn/docs/13/datatype-textsearch.html#DATATYPE-TSQUERY)

- [8.12. UUID类型](http://www.postgres.cn/docs/13/datatype-uuid.html)

- [8.13. XML类型](http://www.postgres.cn/docs/13/datatype-xml.html)

  [8.13.1. 创建XML值](http://www.postgres.cn/docs/13/datatype-xml.html#id-1.5.7.21.6)[8.13.2. 编码处理](http://www.postgres.cn/docs/13/datatype-xml.html#id-1.5.7.21.7)[8.13.3. 访问XML值](http://www.postgres.cn/docs/13/datatype-xml.html#id-1.5.7.21.8)

- [8.14. JSON 类型](http://www.postgres.cn/docs/13/datatype-json.html)

  [8.14.1. JSON 输入和输出语法](http://www.postgres.cn/docs/13/datatype-json.html#JSON-KEYS-ELEMENTS)[8.14.2. 设计 JSON 文档](http://www.postgres.cn/docs/13/datatype-json.html#JSON-DOC-DESIGN)[8.14.3. `jsonb` 包含和存在](http://www.postgres.cn/docs/13/datatype-json.html#JSON-CONTAINMENT)[8.14.4. `jsonb` 索引](http://www.postgres.cn/docs/13/datatype-json.html#JSON-INDEXING)[8.14.5. 转换](http://www.postgres.cn/docs/13/datatype-json.html#id-1.5.7.22.19)[8.14.6. jsonpath Type](http://www.postgres.cn/docs/13/datatype-json.html#DATATYPE-JSONPATH)

- [8.15. 数组](http://www.postgres.cn/docs/13/arrays.html)

  [8.15.1. 数组类型的定义](http://www.postgres.cn/docs/13/arrays.html#ARRAYS-DECLARATION)[8.15.2. 数组值输入](http://www.postgres.cn/docs/13/arrays.html#ARRAYS-INPUT)[8.15.3. 访问数组](http://www.postgres.cn/docs/13/arrays.html#ARRAYS-ACCESSING)[8.15.4. 修改数组](http://www.postgres.cn/docs/13/arrays.html#ARRAYS-MODIFYING)[8.15.5. 在数组中搜索](http://www.postgres.cn/docs/13/arrays.html#ARRAYS-SEARCHING)[8.15.6. 数组输入和输出语法](http://www.postgres.cn/docs/13/arrays.html#ARRAYS-IO)

- [8.16. 组合类型](http://www.postgres.cn/docs/13/rowtypes.html)

  [8.16.1. 组合类型的声明](http://www.postgres.cn/docs/13/rowtypes.html#ROWTYPES-DECLARING)[8.16.2. 构造组合值](http://www.postgres.cn/docs/13/rowtypes.html#id-1.5.7.24.6)[8.16.3. 访问组合类型](http://www.postgres.cn/docs/13/rowtypes.html#ROWTYPES-ACCESSING)[8.16.4. 修改组合类型](http://www.postgres.cn/docs/13/rowtypes.html#id-1.5.7.24.8)[8.16.5. 在查询中使用组合类型](http://www.postgres.cn/docs/13/rowtypes.html#ROWTYPES-USAGE)[8.16.6. 组合类型输入和输出语法](http://www.postgres.cn/docs/13/rowtypes.html#ROWTYPES-IO-SYNTAX)

- [8.17. 范围类型](http://www.postgres.cn/docs/13/rangetypes.html)

  [8.17.1. 内建范围类型](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-BUILTIN)[8.17.2. 例子](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-EXAMPLES)[8.17.3. 包含和排除边界](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-INCLUSIVITY)[8.17.4. 无限（无界）范围](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-INFINITE)[8.17.5. 范围输入/输出](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-IO)[8.17.6. 构造范围](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-CONSTRUCT)[8.17.7. 离散范围类型](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-DISCRETE)[8.17.8. 定义新的范围类型](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-DEFINING)[8.17.9. 索引](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-INDEXING)[8.17.10. 范围上的约束](http://www.postgres.cn/docs/13/rangetypes.html#RANGETYPES-CONSTRAINT)

- [8.18. 域类型](http://www.postgres.cn/docs/13/domains.html)

- [8.19. 对象标识符类型](http://www.postgres.cn/docs/13/datatype-oid.html)

- [8.20. pg_lsn 类型](http://www.postgres.cn/docs/13/datatype-pg-lsn.html)

- [8.21. 伪类型](http://www.postgres.cn/docs/13/datatype-pseudo.html)



   PostgreSQL有着丰富的本地数据类型可用。用户可以使用[CREATE TYPE](http://www.postgres.cn/docs/13/sql-createtype.html)命令为 PostgreSQL增加新的数据类型。  

   [表 8.1](http://www.postgres.cn/docs/13/datatype.html#DATATYPE-TABLE)显示了所有内建的普通数据类型。大部分在“别名”列里列出的可选名字都是因历史原因 被PostgreSQL在内部使用的名字。另外，还有一些内部使用的或者废弃的类型也可以用，但没有在这里列出。  

**表 8.1. 数据类型**

| 名字                                          | 别名                                 | 描述                                          |
| --------------------------------------------- | ------------------------------------ | --------------------------------------------- |
| `bigint`                                      | `int8`                               | 有符号的8字节整数                             |
| `bigserial`                                   | `serial8`                            | 自动增长的8字节整数                           |
| `bit [ (*`n`*) ]`                             |                                      | 定长位串                                      |
| `bit varying [ (*`n`*) ]`                     | `varbit [ (*`n`*) ]`                 | 变长位串                                      |
| `boolean`                                     | `bool`                               | 逻辑布尔值（真/假）                           |
| `box`                                         |                                      | 平面上的普通方框                              |
| `bytea`                                       |                                      | 二进制数据（“字节数组”）                      |
| `character [ (*`n`*) ]`                       | `char [ (*`n`*) ]`                   | 定长字符串                                    |
| `character varying [ (*`n`*) ]`               | `varchar [ (*`n`*) ]`                | 变长字符串                                    |
| `cidr`                                        |                                      | IPv4或IPv6网络地址                            |
| `circle`                                      |                                      | 平面上的圆                                    |
| `date`                                        |                                      | 日历日期（年、月、日）                        |
| `double precision`                            | `float8`                             | 双精度浮点数（8字节）                         |
| `inet`                                        |                                      | IPv4或IPv6主机地址                            |
| `integer`                                     | `int`, `int4`                        | 有符号4字节整数                               |
| `interval [ *`fields`* ] [ (*`p`*) ]`         |                                      | 时间段                                        |
| `json`                                        |                                      | 文本 JSON 数据                                |
| `jsonb`                                       |                                      | 二进制 JSON 数据，已分解                      |
| `line`                                        |                                      | 平面上的无限长的线                            |
| `lseg`                                        |                                      | 平面上的线段                                  |
| `macaddr`                                     |                                      | MAC（Media Access Control）地址               |
| `macaddr8`                                    |                                      | MAC（Media Access Control）地址（EUI-64格式） |
| `money`                                       |                                      | 货币数量                                      |
| `numeric [ (*`p`*,         *`s`*) ]`          | `decimal [ (*`p`*,         *`s`*) ]` | 可选择精度的精确数字                          |
| `path`                                        |                                      | 平面上的几何路径                              |
| `pg_lsn`                                      |                                      | PostgreSQL日志序列号                          |
| `point`                                       |                                      | 平面上的几何点                                |
| `polygon`                                     |                                      | 平面上的封闭几何路径                          |
| `real`                                        | `float4`                             | 单精度浮点数（4字节）                         |
| `smallint`                                    | `int2`                               | 有符号2字节整数                               |
| `smallserial`                                 | `serial2`                            | 自动增长的2字节整数                           |
| `serial`                                      | `serial4`                            | 自动增长的4字节整数                           |
| `text`                                        |                                      | 变长字符串                                    |
| `time [ (*`p`*) ] [ without time zone ]`      |                                      | 一天中的时间（无时区）                        |
| `time [ (*`p`*) ] with time zone`             | `timetz`                             | 一天中的时间，包括时区                        |
| `timestamp [ (*`p`*) ] [ without time zone ]` |                                      | 日期和时间（无时区）                          |
| `timestamp [ (*`p`*) ] with time zone`        | `timestamptz`                        | 日期和时间，包括时区                          |
| `tsquery`                                     |                                      | 文本搜索查询                                  |
| `tsvector`                                    |                                      | 文本搜索文档                                  |
| `txid_snapshot`                               |                                      | 用户级别事务ID快照                            |
| `uuid`                                        |                                      | 通用唯一标识码                                |
| `xml`                                         |                                      | XML数据                                       |



### 兼容性

​    下列类型（或者及其拼写）是SQL指定的：`bigint`、`bit`、`bit varying`、`boolean`、`char`、`character varying`、`character`、`varchar`、`date`、`double precision`、`integer`、`interval`、`numeric`、`decimal`、`real`、`smallint`、`time`（有时区或无时区）、`timestamp`（有时区或无时区）、`xml`。   

   每种数据类型都有一个由其输入和输出函数决定的外部表现形式。许多内建的类型有明显的格式。不过，许多类型要么是PostgreSQL所特有的（例如几何路径），要么可能是有几种不同的格式（例如日期和时间类型）。 有些输入和输出函数是不可逆的，即输出函数的结果和原始输入比较时可能丢失精度。  

## 8.1. 数字类型

- [8.1.1. 整数类型](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-INT)
- [8.1.2. 任意精度数字](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL)
- [8.1.3. 浮点类型](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-FLOAT)
- [8.1.4. 序数类型](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-SERIAL)



​    数字类型由2、4或8字节的整数以及4或8字节的浮点数和可选精度小数组成。[表 8.2](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-NUMERIC-TABLE)列出了所有可用类型。   

**表 8.2. 数字类型**

| 名字               | 存储尺寸 | 描述               | 范围                                         |
| ------------------ | -------- | ------------------ | -------------------------------------------- |
| `smallint`         | 2字节    | 小范围整数         | -32768 to +32767                             |
| `integer`          | 4字节    | 整数的典型选择     | -2147483648 to +2147483647                   |
| `bigint`           | 8字节    | 大范围整数         | -9223372036854775808 to +9223372036854775807 |
| `decimal`          | 可变     | 用户指定精度，精确 | 最高小数点前131072位，以及小数点后16383位    |
| `numeric`          | 可变     | 用户指定精度，精确 | 最高小数点前131072位，以及小数点后16383位    |
| `real`             | 4字节    | 可变精度，不精确   | 6位十进制精度                                |
| `double precision` | 8字节    | 可变精度，不精确   | 15位十进制精度                               |
| `smallserial`      | 2字节    | 自动增加的小整数   | 1到32767                                     |
| `serial`           | 4字节    | 自动增加的整数     | 1到2147483647                                |
| `bigserial`        | 8字节    | 自动增长的大整数   | 1到9223372036854775807                       |



​    数字类型常量的语法在[第 4.1.2 节](http://www.postgres.cn/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS)里描述。数字类型有一整套对应的数学操作符和函数。相关信息请参考 [第 9 章](http://www.postgres.cn/docs/13/functions.html)。下面的几节详细描述这些类型。   

### 8.1.1. 整数类型



​     类型`smallint`、`integer`和`bigint`存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。    

​     常用的类型是`integer`，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 `smallint`类型。而只有在`integer`的范围不够的时候才使用`bigint`。    

​     SQL只声明了整数类型`integer`（或`int`）、`smallint`和`bigint`。类型`int2`、`int4`和`int8`都是扩展，也在许多其它SQL数据库系统中使用。    

### 8.1.2. 任意精度数字



​     类型`numeric`可以存储非常多位的数字。我们特别建议将它用于货币金额和其它要求计算准确的数量。`numeric`值的计算在可能的情况下会得到准确的结果，例如加法、减法、乘法。不过，`numeric`类型上的算术运算比整数类型或者下一节描述的浮点数类型要慢很多。    

​     在随后的内容里，我们使用了下述术语：一个`numeric`的*precision*（精度）是整个数中有效位的总数，也就是小数点两边的位数。`numeric`的*scale*（刻度）是小数部分的数字位数，也就是小数点右边的部分。因此数字 23.5141 的精度为6而刻度为4。可以认为整数的刻度为零。    

​     `numeric`列的最大精度和最大比例都是可以配置的。要声明一个类型为`numeric`的列，你可以用下面的语法：

```
NUMERIC(precision, scale)
```

​     精度必须为正数，比例可以为零或者正数。另外：

```
NUMERIC(precision)
```

​     选择比例为 0 。如果使用

```
NUMERIC
```

​     创建一个列时不使用精度或比例，则该列可以存储任何精度和比例的数字值，并且值的范围最多可以到实现精度的上限。一个这种列将不会把输入值转化成任何特定的比例，而带有比例声明的`numeric`列将把输入值转化为该比例（SQL标准要求缺省的比例是 0，即转化成整数精度。我们觉得这样做有点没用。如果你关心移植性，那你最好总是显式声明精度和比例）。    

### 注意

​      显式指定类型精度时的最大允许精度为 1000，没有指定精度的`NUMERIC`受到[表 8.2](http://www.postgres.cn/docs/13/datatype-numeric.html#DATATYPE-NUMERIC-TABLE)中描述的限制所控制。     

​     如果一个要存储的值的比例比列声明的比例高，那么系统将尝试圆整（四舍五入）该值到指定的分数位数。 然后，如果小数点左边的位数超过了声明的精度减去声明的比例，那么抛出一个错误。    

​     数字值在物理上是以不带任何前导或者后缀零的形式存储。 因此，列上声明的精度和比例都是最大值，而不是固定分配的 （在这个方面，`numeric`类型更类似于`varchar(*`n`*)`， 而不像`char(*`n`*)`）。 实际存储要求是每四个十进制位组用两个字节，再加上三到八个字节的开销。    



​     除了普通的数字值之外，`numeric`类型允许特殊值`NaN`， 表示“不是一个数字”。任何在 `NaN`上面的操作都生成另外一个`NaN`。 如果在 SQL 命令里把这些值当作一个常量写，你必须在其周围放上单引号，例如`UPDATE table SET x = 'NaN'`。在输入时，字串`NaN`被识别为大小写无关。    

### 注意

​      在“不是一个数字”概念的大部分实现中，`NaN`被认为不等于任何其他数字值（包括`NaN`）。为了允许`numeric`值可以被排序和使用基于树的索引，PostgreSQL把`NaN`值视为相等，并且比所有非`NaN`值都要大。     

​     类型`decimal`和`numeric`是等效的。两种类型都是SQL标准的一部分。    

​     在对值进行圆整时，`numeric`类型会圆到远离零的整数，而（在大部分机器上）`real`和`double precision`类型会圆到最近的偶数上。例如：

```
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
```

​    

### 8.1.3. 浮点类型



​     数据类型`real`和`double precision`是不精确的、变精度的数字类型。     在所有当前支持的平台上，这些类型是IEEE标准 754 二进制浮点算术（分别对应单精度和双精度）的实现， 一直到下层处理器、操作系统和支持它的编译器。    

​     不准确意味着一些值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储和检索一个值可能出现一些缺失。  处理这些错误以及这些错误是如何在计算中传播的主题属于数学和计算机科学的一个完整的分支， 我们不会在这里进一步讨论它，这里的讨论仅限于如下几点：     

- ​        如果你要求准确的存储和计算（例如计算货币金额），应使用`numeric`类型。       
- ​        如果你想用这些类型做任何重要的复杂计算，尤其是那些你对范围情况（无穷、下溢）严重依赖的事情，那你应该仔细评诂你的实现。       
- ​        用两个浮点数值进行等值比较不可能总是按照期望地进行。       

​    

​     在所有当前支持的平台上，`real`类型的范围是 1E-37 to 1E+37 ，精度至少是 6 位小数。     `double precision`类型的范围是 1E-307 to 1E+308 ，精度至少是 15 位数字。     太大或者太小的值都会导致错误。 如果输入数字的精度太高，那么可能发生四舍五入。     太接近零的数字，如果不能体现出与零的区别就会导致下溢错误。    

​     默认情况下，浮点值以其最短精确的十进制表示的文本形式输出；所产生的十进制值与相同二进制精度的任何其他的值表示相比，更接近于真实存储的二进制值。    （但是，当前输出值永远不会*精确地*处于两个可表示的值之间，以免输入程序不能正确遵守舍近取整法则。）     对于`float8`值，此值最多使用 17 个有效十进制数字，对于`float4`值，最多使用9个数字。    

### 注意

​	  生成这种最短精确的输出格式比历史的四舍五入的格式要快得多。     

​	 为了与PostgreSQL的较旧版本生成的输出兼容，并允许降低输出精度，可以使用[extra_float_digits](http://www.postgres.cn/docs/13/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS)参数选择四舍五入的十进制输出。     将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于`float4`）或15（对于`float8`）个有效的十进制数字。     设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。    

​     设置[extra_float_digits](http://www.postgres.cn/docs/13/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS)位任何大于 0 的值将选择最短精确格式。    

### 注意

​     需要更精确值的应用需要设置[extra_float_digits](http://www.postgres.cn/docs/13/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS)为3以获取更精确值。  为了版本之间的最大兼容性，他们可以继续这样做。     



​     除了普通的数字值之外，浮点类型还有几个特殊值：


 `Infinity`
 `-Infinity`
 `NaN`

​     这些分别代表 IEEE 754 特殊值“infinity”、“negative infinity”以及“not-a-number”，     如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如`UPDATE table SET x = '-Infinity'`。 在输入时，这些字符串是以大小写不敏感的方式识别的。    

### 注意

​      IEEE754指定`NaN`不应该与任何其他浮点值（包括`NaN`）相等。为了允许浮点值被排序或者在基于树的索引中使用，PostgreSQL将`NaN`值视为相等，并且比所有非`NaN`值要更大。     

​     PostgreSQL还支持 SQL 标准表示法`float`和`float(*`p`*)`用于声明非精确的数字类型。在这里，*`p`*指定以*二进制*位表示的最低可接受精度。 在选取`real`类型的时候，PostgreSQL接受`float(1)`到`float(24)`，在选取`double precision`的时候，接受`float(25)`到`float(53)`。在允许范围之外的*`p`*值将导致一个错误。没有指定精度的`float`将被当作是`double precision`。    

### 8.1.4. 序数类型



### 注意

​      这一节描述了PostgreSQL特有的创建一个自增列的方法。另一种方法是使用SQL标准的标识列特性，它在[CREATE TABLE](http://www.postgres.cn/docs/13/sql-createtable.html)中描述。     

​     `smallserial`、`serial`和`bigserial`类型不是真正的类型，它们只是为了创建唯一标识符列而存在的方便符号（类似其它一些数据库中支持的`AUTO_INCREMENT`属性）。 在目前的实现中，下面一个语句：

```
CREATE TABLE tablename (
    colname SERIAL
);
```

​     等价于以下语句：

```
CREATE SEQUENCE tablename_colname_seq AS integer;
CREATE TABLE tablename (
    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
);
ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;
```

​     因此，我们就创建了一个整数列并且把它的缺省值安排为从一个序列发生器取值。应用了一个`NOT NULL`约束以确保空值不会被插入（在大多数情况下你可能还希望附加一个`UNIQUE`或者`PRIMARY KEY`约束避免意外地插入重复的值，但这个不是自动发生的）。最后，该序列被标记为“属于”该列，这样当列或表被删除时该序列也会被删除。    

### 注意

​        因为`smallserial`、`serial`和`bigserial`是用序列实现的，所以即使没有删除过行，在出现在列中的序列值可能有“空洞”或者间隙。如果一个从序列中分配的值被用在一行中，即使该行最终没有被成功地插入到表中，该值也被“用掉”了。例如，当插入事务回滚时就会发生这种情况。更多信息参见[第 9.16 节](http://www.postgres.cn/docs/13/functions-sequence.html)中的`nextval()`。      

​     要使用`serial`列插入序列的下一个数值到表中， 请指定`serial`列应该被赋予其缺省值。我们可以通过在`INSERT`语句中把该列排除在列列表之外来实现，也可以通过使用`DEFAULT`关键字来实现。    

​     类型名`serial`和`serial4`是等效的： 两个都创建`integer`列。类型名`bigserial`和`serial8`也一样，只不过它们创建一个 `bigint`列。如果你预计在表的生存期中使用的标识符数目超过 231 个，那么你应该使用`bigserial`。类型名`smallserial`和`serial2`也以相同方式工作，只不过它们创建一个`smallint`列。    

​     为一个`serial`列创建的序列在所属的列被删除的时候自动删除。你可以在不删除列的情况下删除序列，但是这会强制删除该列的默认值表达式。    

## 8.2. 货币类型

​    `money`类型存储固定小数精度的货币数字，参阅[表 8.3](http://www.postgres.cn/docs/13/datatype-money.html#DATATYPE-MONEY-TABLE)。小数的精度由数据库的[lc_monetary](http://www.postgres.cn/docs/13/runtime-config-client.html#GUC-LC-MONETARY)设置决定。表中展示的范围假设有两个小数位。可接受的输入格式很多，包括整数和浮点数文字，以及常用的货币格式，如`'$1,000.00'`。 输出通常是最后一种形式，但和区域相关。   

**表 8.3. 货币类型**

| 名字    | 存储尺寸 | 描述   | 范围                                         |
| ------- | -------- | ------ | -------------------------------------------- |
| `money` | 8 bytes  | 货币额 | -92233720368547758.08到+92233720368547758.07 |



​    由于这种数据类型的输出是区域敏感的，因此将`money`数据装入到一个具有不同`lc_monetary`设置的数据库是不起作用的。为了避免这种问题，在恢复一个转储到一个新数据库中之前，应确保新数据库的`lc_monetary`设置和被转储数据库的相同或者具有等效值。   

​    数据类型`numeric`、`int`和`bigint`的值可以被造型成`money`。从数据类型`real`和`double precision`的转换可以通过先造型成`numeric`来实现，例如：

```
SELECT '12.34'::float8::numeric::money;
```

​    但是，我们不推荐这样做。浮点数不应该被用来处理货币，因为浮点数可能会有圆整错误。   

​    一个`money`值可以在不损失精度的情况下被造型成`numeric`。转换到其他类型可能会丢失精度，并且必须采用两个阶段完成：

```
SELECT '52093.89'::money::numeric::float8;
```

   

​    一个`money`值被一个整数值除的除法结果会被截去分数部分。要得到圆整的结果，可以除以一个浮点值，或者在除法之前把`money`转换成`numeric`然后在除法之后转回`money`（如果要避免精度丢失的风险则后者更好）。当一个`money`值被另一个`money`值除时，结果是`double precision`（即一个纯数字，而不是金额），在除法中货币单位被约掉了。   

## 8.3. 字符类型



**表 8.4. 字符类型**

| 名字                                         | 描述           |
| -------------------------------------------- | -------------- |
| `character varying(*`n`*)`, `varchar(*`n`*)` | 有限制的变长   |
| `character(*`n`*)`, `char(*`n`*)`            | 定长，空格填充 |
| `text`                                       | 无限变长       |



​    [表 8.4](http://www.postgres.cn/docs/13/datatype-character.html#DATATYPE-CHARACTER-TABLE)显示了在PostgreSQL里可用的一般用途的字符类型。   

​    SQL定义了两种基本的字符类型： `character varying(*`n`*)`和`character(*`n`*)`， 其中*`n`*是一个正整数。两种类型都可以存储最多*`n`*个字符长的串。试图存储更长的串到这些类型的列里会产生一个错误， 除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度（这个看上去有点怪异的例外是SQL标准要求的）。 如果要存储的串比声明的长度短，类型为`character`的值将会用空白填满；而类型为`character varying`的值将只是存储短些的串。   

​    如果我们明确地把一个值造型成`character varying(*`n`*)`或者`character(*`n`*)`， 那么超长的值将被截断成*`n`*个字符，而不会抛出错误（这也是SQL标准的要求）。   

​    `varchar(*`n`*)`和`char(*`n`*)`的概念分别是`character varying(*`n`*)`和`character(*`n`*)`的别名。没有长度声明词的`character`等效于`character(1)`。如果不带长度说明词使用`character varying`，那么该类型接受任何长度的串。后者是一个PostgreSQL的扩展。   

​    另外，PostgreSQL提供`text`类型，它可以存储任何长度的串。尽管类型`text`不是SQL标准，但是许多其它 SQL 数据库系统也有它。   

​    类型`character`的值物理上都用空白填充到指定的长度*`n`*， 并且以这种方式存储和显示。不过，拖尾的空白被当作是没有意义的，并且在比较两个    `character`类型值时不会考虑它们。在空白有意义的排序规则中，这种行为可能会    产生意料之外的结果，例如`SELECT 'a '::CHAR(2) collate "C" <    E'a\n'::CHAR(2)`会返回真（即便`C`区域会认为一个空格比新行更大）。当把一个`character`值转换成其他    字符串类型之一时，拖尾的空白会被移除。请注意，在`character varying`和`text`值里， 结尾的空白语意上*是*有含义的，并且在使用模式匹配（如`LIKE`和正则表达式）时也会被考虑。   

​    这些类型的存储需求是 4 字节加上实际的字串，如果是 character 的话再加上填充的字节。长的字串将会自动被系统压缩，  因此在磁盘上的物理需求可能会更少些。长的数值也会存储在后台表里面，这样它们就不会干扰对短字段值的快速访问。 不管怎样，允许存储的最长字串大概是 1 GB。 （允许在数据类型声明中出现的的 n 的最大值比这还小。 修改这个行为没有甚么意义，因为在多字节编码下字符和字节的数目可能差别很大。  如果你想存储没有特定上限的长字串，那么使用 text 或者没有长度声明词的 character varying， 而不要选择一个任意长度限制。）    一个短串（最长126字节）的存储要求是1个字节外加实际的串，该串在`character`情况下包含填充的空白。长一些的串在前面需要4个字节而不是1个字节。长串会被系统自动压缩，这样在磁盘上的物理需求可能会更少。非常长的值也会被存储在背景表中，这样它们不会干扰对较短的列值的快速访问。在任何情况下，能被存储的最长的字符串是1GB（数据类型定义中*`n`*能允许的最大值比这个值要小。修改它没有用处，因为对于多字节字符编码来说，字符的数量和字节数可能完全不同。如果你想要存储没有指定上限的长串，使用`text`或没有长度声明的`character varying`，而不是给出一个任意长度限制）。   

### 提示

​     这三种类型之间没有性能差别，只不过是在使用填充空白的类型的时候需要更多存储尺寸，以及在存储到一个有长度约束的列时需要少量额外CPU周期来检查长度。虽然在某些其它的数据库系统里，`character(*`n`*)`有一定的性能优势，但在PostgreSQL里没有。事实上，`character(*`n`*)`通常是这三种类型之中最慢的一个，因为它需要额外的存储开销。在大多数情况下，应该使用`text`或者`character varying`。    

​    请参考[第 4.1.2.1 节](http://www.postgres.cn/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS)获取关于串文本的语法的信息，以及参阅[第 9 章](http://www.postgres.cn/docs/13/functions.html)获取关于可用操作符和函数的信息。 数据库的字符集决定用于存储文本值的字符集；有关字符集支持的更多信息，请参考[第 23.3 节](http://www.postgres.cn/docs/13/multibyte.html)。   

**例 8.1. 使用字符类型**

```
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- (1)

  a   | char_length
------+-------------
 ok   |           2


CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
ERROR:  value too long for type character varying(5)
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation
SELECT b, char_length(b) FROM test2;

   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
```

| [(1)](http://www.postgres.cn/docs/13/datatype-character.html#co.datatype-char) | 函数`char_length`在[第 9.4 节](http://www.postgres.cn/docs/13/functions-string.html)中讨论。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |



​    在PostgreSQL里另外还有两种定长字符类型，在[表 8.5](http://www.postgres.cn/docs/13/datatype-character.html#DATATYPE-CHARACTER-SPECIAL-TABLE)里显示。 `name`类型*只*用于在内部系统目录中存储标识符并且不是给一般用户使用的。该类型长度当前定为 64 字节（63 可用字符加结束符）但在`C`源代码应该使用常量 `NAMEDATALEN`引用。这个长度是在编译的时候设置的（因而可以为特殊用途调整），缺省的最大长度在以后的版本可能会改变。类型`"char"`（注意引号）和 `char(1)`是不一样的，它只用了一个字节的存储空间。它在系统内部用于系统目录当做简化的枚举类型用。   

**表 8.5. 特殊字符类型**

| 名字     | 存储尺寸 | 描述                 |
| -------- | -------- | -------------------- |
| `"char"` | 1字节    | 单字节内部类型       |
| `name`   | 64字节   | 用于对象名的内部类型 |

