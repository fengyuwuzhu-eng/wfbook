### 19.1.3 Replication with Global Transaction Identifiers 19.1.3 使用全局事务标识符进行复制

- [19.1.3.1 GTID Format and Storage 19.1.3.1 GTID 格式和存储](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html)
- [19.1.3.2 GTID Life Cycle 19.1.3.2 GTID 生命周期](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-lifecycle.html)
- [19.1.3.3 GTID Auto-Positioning 19.1.3.3 GTID 自动定位](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-auto-positioning.html)
- [19.1.3.4 Setting Up Replication Using GTIDs 19.1.3.4 使用 GTID 设置复制](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html)
- [19.1.3.5 Using GTIDs for Failover and Scaleout 19.1.3.5 使用 GTID 进行故障转移和横向扩展](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html)
- [19.1.3.6 Replication From a Source Without GTIDs to a Replica With GTIDs 19.1.3.6 从没有 GTID 的源复制到有 GTID 的副本](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-assign-anon.html)
- [19.1.3.7 Restrictions on Replication with GTIDs 19.1.3.7 使用 GTID 进行复制的限制](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-restrictions.html)
- [19.1.3.8 Stored Function Examples to Manipulate GTIDs 19.1.3.8 用于操作 GTID 的存储函数示例](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-functions.html)



​    This section explains transaction-based replication using    global transaction identifiers    (GTIDs). When using GTIDs, each transaction can be identified and    tracked as it is committed on the originating server and applied by    any replicas; this means that it is not necessary when using GTIDs    to refer to log files or positions within those files when starting    a new replica or failing over to a new source, which greatly    simplifies these tasks. Because GTID-based replication is completely    transaction-based, it is simple to determine whether sources and    replicas are consistent; as long as all transactions committed on a    source are also committed on a replica, consistency between the two    is guaranteed. You can use either statement-based or row-based    replication with GTIDs (see [Section 19.2.1, “Replication Formats”](https://dev.mysql.com/doc/refman/8.4/en/replication-formats.html));    however, for best results, we recommend that you use the row-based    format.  
本节介绍使用全局事务标识符 （GTID） 的基于事务的复制。使用 GTID  时，每个事务都可以在原始服务器上提交并由任何副本应用时被识别和跟踪;这意味着，在启动新副本或故障转移到新源时，使用 GTID  引用日志文件或这些文件中的位置时，没有必要，这大大简化了这些任务。由于基于 GTID  的复制完全基于事务，因此很容易确定源和副本是否一致;只要在源上提交的所有事务也都提交到副本上，就可以保证两者之间的一致性。您可以将基于语句的复制或基于行的复制与 GTID 一起使用（请参见[第 19.2.1 节 “复制格式”](https://dev.mysql.com/doc/refman/8.4/en/replication-formats.html)）;但是，为了获得最佳结果，我们建议您使用基于行的格式。

​    GTIDs are always preserved between source and replica. This means    that you can always determine the source for any transaction applied    on any replica by examining its binary log. In addition, once a    transaction with a given GTID is committed on a given server, any    subsequent transaction having the same GTID is ignored by that    server. Thus, a transaction committed on the source can be applied    no more than once on the replica, which helps to guarantee    consistency.  
GTID 始终保留在源和副本之间。这意味着您始终可以通过检查其二进制日志来确定应用于任何副本的任何事务的源。此外，在给定服务器上提交具有给定 GTID  的事务后，该服务器将忽略具有相同 GTID 的任何后续事务。因此，在源上提交的事务可以在副本上应用不超过一次，这有助于保证一致性。

​    This section discusses the following topics: 
本节讨论以下主题：

- ​        How GTIDs are defined and created, and how they are represented        in a MySQL server (see        [Section 19.1.3.1, “GTID Format and Storage”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html)).      
  如何定义和创建 GTID，以及它们在 MySQL 服务器中的表示方式（请参见[第 19.1.3.1 节 “ GTID 格式和存储”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html)
- ​        The life cycle of a GTID (see        [Section 19.1.3.2, “GTID Life Cycle”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-lifecycle.html)).      
  GTID 的生命周期（请参见[第 19.1.3.2 节 “ GTID 生命周期”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-lifecycle.html)
- ​        The auto-positioning function for synchronizing a replica and        source that use GTIDs (see        [Section 19.1.3.3, “GTID Auto-Positioning”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-auto-positioning.html)).      
  用于同步使用 GTID 的副本和源的自动定位功能（请参见[第 19.1.3.3 节 “ GTID 自动定位”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-auto-positioning.html)
- ​        A general procedure for setting up and starting GTID-based        replication (see [Section 19.1.3.4, “Setting Up Replication Using GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html)).      
  设置和启动基于 GTID 的复制的一般过程（参见[第 19.1.3.4 节 “使用 GTID 设置复制”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html)
- ​        Suggested methods for provisioning new replication servers when        using GTIDs (see [Section 19.1.3.5, “Using GTIDs for Failover and Scaleout”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html)).      
  使用 GTID 时预置新复制服务器的建议方法（请参见[第 19.1.3.5 节 “使用 GTID 进行故障转移和横向扩展”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html)
- ​        Restrictions and limitations that you should be aware of when        using GTID-based replication (see        [Section 19.1.3.7, “Restrictions on Replication with GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-restrictions.html)).      
  使用基于 GTID 的复制时应注意的限制和局限（请参见[第 19.1.3.7 节 “使用 GTID 进行复制的限制”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-restrictions.html)
- ​        Stored functions that you can use to work with GTIDs (see        [Section 19.1.3.8, “Stored Function Examples to Manipulate GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-functions.html)). 
  可用于处理 GTID 的存储函数（请参见[第 19.1.3.8 节 “操作 GTID 的存储函数示例”）。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-functions.html)

​    For information about MySQL Server options and variables relating to    GTID-based replication, see    [Section 19.1.6.5, “Global Transaction ID System Variables”](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html). See also    [Section 14.18.2, “Functions Used with Global Transaction Identifiers (GTIDs)”](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html), which describes SQL functions    supported by MySQL 8.4 for use with GTIDs. 
有关与基于 GTID 的复制相关的 MySQL 服务器选项和变量的信息，请参见[第 19.1.6.5 节 “全局事务 ID 系统变量”。](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html)另请参见[第 14.18.2 节 “与全局事务标识符 （GTID） 一起使用的函数”](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html)，其中描述了 MySQL 8.4 支持与 GTID 一起使用的 SQL 函数。

#### 19.1.3.1 GTID Format and Storage 19.1.3.1 GTID 格式和存储



​      A global transaction identifier (GTID) is a unique identifier      created and associated with each transaction committed on the      server of origin (the source). This identifier is unique not only      to the server on which it originated, but is unique across all      servers in a given replication topology.    
全局事务标识符 （GTID） 是创建的唯一标识符，并与在源服务器（源）上提交的每个事务相关联。此标识符不仅对于其来源的服务器是唯一的，而且在给定复制拓扑中的所有服务器中也是唯一的。

​      GTID assignment distinguishes between client transactions, which      are committed on the source, and replicated transactions, which      are reproduced on a replica. When a client transaction is      committed on the source, it is assigned a new GTID, provided that      the transaction was written to the binary log. Client transactions      are guaranteed to have monotonically increasing GTIDs without gaps      between the generated numbers. If a client transaction is not      written to the binary log (for example, because the transaction      was filtered out, or the transaction was read-only), it is not      assigned a GTID on the server of origin.    
GTID 分配区分了在源上提交的客户端事务和在副本上复制的复制事务。在源上提交 Client 端事务时，如果该事务已写入二进制日志，则会为其分配一个新的 GTID。保证客户端事务具有单调递增的 GTID，生成的数字之间没有间隙。如果 Client  端事务未写入二进制日志（例如，因为事务被过滤掉，或者事务是只读的），则不会在源服务器上为其分配 GTID。

​      Replicated transactions retain the same GTID that was assigned to      the transaction on the server of origin. The GTID is present      before the replicated transaction begins to execute, and is      persisted even if the replicated transaction is not written to the      binary log on the replica, or is filtered out on the replica. The      `mysql.gtid_executed` system table is used to      preserve the assigned GTIDs of all the transactions applied on a      MySQL server, except those that are stored in a currently active      binary log file.    
复制的事务保留分配给源服务器上事务的相同 GTID。GTID 在复制的事务开始执行之前就存在，并且即使复制的事务未写入副本上的二进制日志或在副本上被筛选掉，GTID 也会保留。`mysql.gtid_executed` 系统表用于保留 MySQL 服务器上应用的所有事务的已分配 GTID，但存储在当前活动的二进制日志文件中的事务除外。

​      The auto-skip function for GTIDs means that a transaction      committed on the source can be applied no more than once on the      replica, which helps to guarantee consistency. Once a transaction      with a given GTID has been committed on a given server, any      attempt to execute a subsequent transaction with the same GTID is      ignored by that server. No error is raised, and no statement in      the transaction is executed.    
GTID 的自动跳过功能意味着在源上提交的事务可以在副本上应用不超过一次，这有助于保证一致性。在给定服务器上提交具有给定 GTID 的事务后，该服务器将忽略执行具有相同 GTID 的后续事务的任何尝试。不会引发错误，也不会执行事务中的任何语句。

​      If a transaction with a given GTID has started to execute on a      server, but has not yet committed or rolled back, any attempt to      start a concurrent transaction on the server with the same GTID      blocks. The server neither begins to execute the concurrent      transaction nor returns control to the client. Once the first      attempt at the transaction commits or rolls back, concurrent      sessions that were blocking on the same GTID may proceed. If the      first attempt rolled back, one concurrent session proceeds to      attempt the transaction, and any other concurrent sessions that      were blocking on the same GTID remain blocked. If the first      attempt committed, all the concurrent sessions stop being blocked,      and auto-skip all the statements of the transaction.    
如果具有给定 GTID 的事务已开始在服务器上执行，但尚未提交或回滚，则在具有相同 GTID  块的服务器上启动并发事务的任何尝试。服务器既不开始执行并发事务，也不将控制权返回给客户端。一旦事务的第一次尝试提交或回滚，在同一 GTID  上阻塞的并发会话可以继续。如果第一次尝试回滚，则一个并发会话将继续尝试该事务，并且在同一 GTID  上阻塞的任何其他并发会话仍被阻止。如果提交了第一次尝试，则所有并发会话都将停止被阻止，并自动跳过事务的所有语句。

​      A GTID is represented as a pair of coordinates, separated by a      colon character (`:`), as shown here:    
GTID 表示为一对坐标，由冒号字符 （`：`） 分隔，如下所示：

```ini
GTID = source_id:transaction_id
```

​      The *`source_id`* identifies the      originating server. Normally, the source's      [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) is used for this      purpose. The *`transaction_id`* is a      sequence number determined by the order in which the transaction      was committed on the source. For example, the first transaction to      be committed has `1` as its      *`transaction_id`*, and the tenth      transaction to be committed on the same originating server is      assigned a *`transaction_id`* of      `10`. It is not possible for a transaction to      have `0` as a sequence number in a GTID. For      example, the twenty-third transaction to be committed originally      on the server with the UUID      `3E11FA47-71CA-11E1-9E33-C80AA9429562` has this      GTID:    
*`source_id`*标识原始服务器。通常，源的 [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) 用于此目的。*`transaction_id`* 是一个序列号，由事务在源上提交的顺序确定。例如，要提交的第一个事务的*`transaction_id`*为 `1`，而要在同一原始服务器上提交的第十个事务的*`transaction_id`*为 `10`。事务在 GTID 中不能将 `0` 作为序列号。例如，最初要在服务器上提交的第 23 个事务具有 UUID `3E11FA47-71CA-11E1-9E33-C80AA9429562` 的 GTID ：

```none
3E11FA47-71CA-11E1-9E33-C80AA9429562:23
```

​      The upper limit for sequence numbers for GTIDs on a server      instance is the number of non-negative values for a signed 64-bit      integer (`263 - 1`, or      `9223372036854775807`). If the server runs out of      GTIDs, it takes the action specified by      [`binlog_error_action`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_error_action). A warning      message is issued when the server instance is approaching the      limit.    
服务器实例上 GTID 的序列号上限是有符号 64 位整数（`2、63 - 1` 或 `9223372036854775807`）的非负值数。如果服务器用完 GTID，它将执行 [`binlog_error_action`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_error_action) 指定的操作。当服务器实例接近限制时，将发出警告消息。

​      MySQL 8.4 also supports tagged GTIDs. A tagged GTID      consists of three parts, separated by colon characters, as shown      here:    
MySQL 8.4 还支持标记的 GTID。标记的 GTID 由三部分组成，用冒号字符分隔，如下所示：

```ini
GTID = source_id:tag:transaction_id
```

​      In this case, the *`source_id`* and      *`transaction_id`* are as defined      previously. The *`tag`* is a user-defined      string used to identify a specific group of transactions; see the      description of the [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)      system variable for permitted syntax.      *Example*: the one-hundred-seventeenth      transaction to be committed originally on the server with the UUID      `ed102faf-eb00-11eb-8f20-0c5415bfaa1d` and the      tag `Domain_1` has this GTID:    
在这种情况下，*`source_id`* 和 *`transaction_id`* 与前面定义相同。*`标签`*是用户定义的字符串，用于标识特定的交易组;有关允许的语法，请参阅 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 系统变量的描述。*示例*：最初要在服务器上提交的第 117 个事务，其 UUID `ed102faf-eb00-11eb-8f20-0c5415bfaa1d` 和标签 `Domain_1` 具有以下 GTID：

```none
ed102faf-eb00-11eb-8f20-0c5415bfaa1d:Domain_1:117
```

​      The GTID for a transaction is shown in the output from      [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html), and it is used to identify an      individual transaction in the Performance Schema replication      status tables, for example,      [`replication_applier_status_by_worker`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-status-by-worker-table.html).      The value stored by the [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)      system variable (`@@GLOBAL.gtid_next`) is a      single GTID. 
事务的 GTID 显示在 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 的输出中，它用于标识 Performance Schema 复制状态表中的单个事务，例如 [ `replication_applier_status_by_worker` ](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-status-by-worker-table.html).[`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)系统变量 （`@@GLOBAL.gtid_next`） 存储的值是单个 GTID。

##### GTID Sets GTID 集



​        A GTID set is a set comprising one or more single GTIDs or        ranges of GTIDs. GTID sets are used in a MySQL server in several        ways. For example, the values stored by the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) and        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) system variables        are GTID sets. The [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html)        options `UNTIL SQL_BEFORE_GTIDS` and        `UNTIL SQL_AFTER_GTIDS` can be used to make a        replica process transactions only up to the first GTID in a GTID        set, or stop after the last GTID in a GTID set. The built-in        functions [`GTID_SUBSET()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset) and        [`GTID_SUBTRACT()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subtract) require GTID sets        as input.      
GTID 集是包含一个或多个单个 GTID 或 GTID 范围的集。GTID 集在 MySQL 服务器中以多种方式使用。例如，[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 和 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 系统变量存储的值是 GTID 集。[`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 选项 `UNTIL SQL_BEFORE_GTIDS` 和 `UNTIL SQL_AFTER_GTIDS` 可用于使副本仅处理 GTID 集中的第一个 GTID 事务，或在 GTID 集中的最后一个 GTID 之后停止。内置函数 [`GTID_SUBSET（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset) 和 [`GTID_SUBTRACT（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subtract) 需要 GTID 集作为输入。

​        A range of GTIDs originating from the same server can be        collapsed into a single expression, as shown here:      
源自同一服务器的 GTID 范围可以折叠为单个表达式，如下所示：

```none
3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
```

​        The above example represents the first through fifth        transactions originating on the MySQL server whose        [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) is        `3E11FA47-71CA-11E1-9E33-C80AA9429562`.        Multiple single GTIDs or ranges of GTIDs originating from the        same server can also be included in a single expression, with        the GTIDs or ranges separated by colons, as in the following        example:      
上面的示例表示源自 MySQL 服务器的第一个到第五个事务，其 [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) 为 `3E11FA47-71CA-11E1-9E33-C80AA9429562` 。源自同一服务器的多个单个 GTID 或 GTID 范围也可以包含在单个表达式中，GTID 或范围用冒号分隔，如以下示例所示：

```none
3E11FA47-71CA-11E1-9E33-C80AA9429562:1-3:11:47-49
```

​        A GTID set can include any combination of single GTIDs and        ranges of GTIDs, and it can include GTIDs originating from        different servers. This example shows the GTID set stored in the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable        (`@@GLOBAL.gtid_executed`) of a replica that        has applied transactions from more than one source:      
GTID 集可以包含单个 GTID 和 GTID 范围的任意组合，并且可以包含来自不同服务器的 GTID。此示例显示了存储在副本的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量 （`@@GLOBAL.gtid_executed`） 中的 GTID 集，该副本应用了来自多个源的事务：

```none
2174B383-5441-11E8-B90A-C80AA9429562:1-3, 24DA167-0C0C-11E8-8442-00059A3C7B00:1-19
```

​        When GTID sets are returned from server variables, UUIDs are in        alphabetical order, and numeric intervals are merged and in        ascending order.      
当从服务器变量返回 GTID 集时，UUID 按字母顺序排列，数字间隔按升序合并。

​        When constructing a GTID set, a user-defined tag is treated as        part of the UUID. This means that multiple GTIDs originating        from the same server and having the same tag can be included in        a single expression, as shown in this example:      
在构建 GTID 集时，用户定义的标记被视为 UUID 的一部分。这意味着源自同一服务器且具有相同标签的多个 GTID 可以包含在单个表达式中，如以下示例所示：

```none
3E11FA47-71CA-11E1-9E33-C80AA9429562:Domain_1:1-3:11:47-49
```

​        GTIDs originating from the same server but having different tags        are treated in a manner similar to those originating from        different servers, like this:      
源自同一服务器但具有不同标签的 GTID 的处理方式与来自不同服务器的 GTID 类似，如下所示：

```none
3E11FA47-71CA-11E1-9E33-C80AA9429562:Domain_1:1-3:15-21, 3E11FA47-71CA-11E1-9E33-C80AA9429562:Domain_2:8-52
```

​        The complete syntax for a GTID set is as follows:      
GTID 集的完整语法如下：

```sql
gtid_set:
    uuid_set [, uuid_set] ...
    | ''

uuid_set:
    uuid:[tag:]interval[:interval]...

uuid:
    hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh

h:
    [0-9|A-F]

tag:
    [a-z_][a-z0-9_]{0,31}

interval:
    m[-n]

    (m >= 1; n > m)
```

##### mysql.gtid_executed Table mysql.gtid_executed表



​        GTIDs are stored in a table named        `gtid_executed`, in the        `mysql` database. A row in this table contains,        for each GTID or set of GTIDs that it represents, the UUID of        the originating server, the user-defined tag (if there is one),        and the starting and ending transaction IDs of the set; for a        row referencing only a single GTID, these last two values are        the same.      
GTID 存储在 `mysql` 数据库中名为 `gtid_executed` 的表中。对于它所代表的每个 GTID 或一组 GTID，此表中的一行包含原始服务器的 UUID、用户定义的标记（如果有）以及该集的开始和结束事务 ID;对于仅引用单个 GTID 的行，最后两个值是相同的。

​        The `mysql.gtid_executed` table is created (if        it does not already exist) when MySQL Server is installed or        upgraded, using a [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html)        statement similar to that shown here:      
`mysql.gtid_executed` 表是在安装或升级 MySQL Server 时创建的（如果尚不存在），使用类似于此处所示的 [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) 语句：

```sql
CREATE TABLE gtid_executed (
  source_uuid CHAR(36) NOT NULL,
  interval_start BIGINT NOT NULL,
  interval_end BIGINT NOT NULL,
  gtid_tag CHAR(32) NOT NULL,
  PRIMARY KEY (source_uuid, gtid_tag, interval_start)
);
```

Warning 警告

​          As with other MySQL system tables, do not attempt to create or          modify this table yourself. 
与其他 MySQL 系统表一样，请勿尝试自行创建或修改此表。



​        The `mysql.gtid_executed` table is provided for        internal use by the MySQL server. It enables a replica to use        GTIDs when binary logging is disabled on the replica, and it        enables retention of the GTID state when the binary logs have        been lost. Note that the `mysql.gtid_executed`        table is cleared if you issue [`RESET BINARY         LOGS AND GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html).      
`mysql.gtid_executed` 表供 MySQL 服务器内部使用。它使副本能够在副本上禁用二进制日志记录时使用 GTID，并在二进制日志丢失时保留 GTID 状态。请注意，如果您发出 [ `RESET BINARY         LOGS AND GTIDS` ](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)`mysql.gtid_executed` 表。

​        GTIDs are stored in the `mysql.gtid_executed`        table only when [`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) is        `ON` or `ON_PERMISSIVE`. If        binary logging is disabled (`log_bin` is        `OFF`), or if        [`log_replica_updates`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_log_replica_updates) is        disabled, the server stores the GTID belonging to each        transaction together with the transaction in the buffer when the        transaction is committed, and the background thread adds the        contents of the buffer periodically as one or more entries to        the `mysql.gtid_executed` table. In addition,        the table is compressed periodically at a user-configurable        rate, as described in        [mysql.gtid_executed Table Compression](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html#replication-gtids-gtid-executed-table-compression).      
仅当 GTID 为 `ON` 或 `ON_PERMISSIVE` 时，GTID 才会存储在 `mysql.gtid_executed` 表中[`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)。如果禁用了二进制日志记录（`log_bin` 为 `OFF），`或者禁用[`了 log_replica_updates`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_log_replica_updates)，则服务器会在提交事务时将属于每个事务的 GTID 与事务一起存储在缓冲区中，并且后台线程会定期将缓冲区的内容作为一个或多个条目添加到`mysql.gtid_executed`表中。此外，表会以用户可配置的速率定期压缩，如 [mysql.gtid_executed Table Compression](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html#replication-gtids-gtid-executed-table-compression) 中所述。

​        If binary logging is enabled (`log_bin` is        `ON`), for the `InnoDB`        storage engine only, the server updates the        `mysql.gtid_executed` table in the same way as        when binary logging or replica update logging is disabled,        storing the GTID for each transaction at transaction commit        time. For other storage engines, the server updates the        `mysql.gtid_executed` table only when the        binary log is rotated or the server is shut down. At these        times, the server writes GTIDs for all transactions that were        written into the previous binary log into the        `mysql.gtid_executed` table.      
如果启用了二进制日志记录（`log_bin`为`ON），`则仅对于`InnoDB`存储引擎，服务器以与禁用二进制日志记录或副本更新日志记录时相同的方式更新`mysql.gtid_executed` table，并在事务提交时存储每个事务的 GTID。对于其他存储引擎，服务器仅在轮换二进制日志或关闭服务器时更新 `mysql.gtid_executed` 表。在这些时候，服务器会将写入先前二进制日志的所有事务的 GTID 写入 `mysql.gtid_executed` 表中。

​        If the `mysql.gtid_executed` table cannot be        accessed for writes, and the binary log file is rotated for any        reason other than reaching the maximum file size        ([`max_binlog_size`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_max_binlog_size)), the current        binary log file continues to be used. An error message is        returned to the client that requested the rotation, and a        warning is logged on the server. If the        `mysql.gtid_executed` table cannot be accessed        for writes and [`max_binlog_size`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_max_binlog_size)        is reached, the server responds according to its        [`binlog_error_action`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_error_action) setting. If        `IGNORE_ERROR` is set, an error is logged on        the server and binary logging is halted, or if        `ABORT_SERVER` is set, the server shuts down. 
如果无法访问 `mysql.gtid_executed` 表进行写入，并且由于达到最大文件大小 （[`max_binlog_size`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_max_binlog_size)） 以外的任何原因轮换了二进制日志文件，则继续使用当前的二进制日志文件。将向请求轮换的客户端返回一条错误消息，并在服务器上记录一条警告。如果无法访问 `mysql.gtid_executed` 表进行写入并且达到[`max_binlog_size`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_max_binlog_size)，则服务器将根据其 [`binlog_error_action`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_error_action) 设置进行响应。如果设置`了 IGNORE_ERROR`，则会在服务器上记录错误并停止二进制日志记录，或者如果设置`了 ABORT_SERVER`，则服务器将关闭。

##### mysql.gtid_executed Table Compression mysql.gtid_executed 表压缩



​        Over the course of time, the        `mysql.gtid_executed` table can become filled        with many rows referring to individual GTIDs that originate on        the same server, have the same GTID tag (if any), and whose        transaction IDs make up a range, similar to what is shown here:      
随着时间的推移，`mysql.gtid_executed` 表中可能会填充许多行，这些行引用源自同一服务器的各个 GTID，具有相同的 GTID 标记（如果有），并且其事务 ID 构成一个范围，类似于此处显示的内容：

```sql
+--------------------------------------+----------------+--------------+----------+
| source_uuid                          | interval_start | interval_end | gtid_tag |
|--------------------------------------+----------------+--------------|----------+
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 31             | 31           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 32             | 32           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 33             | 33           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 34             | 34           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 35             | 35           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 36             | 36           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 37           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 38             | 38           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 39             | 39           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40             | 40           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 41             | 41           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 42             | 42           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 43             | 43           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 44             | 44           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 45             | 45           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 46             | 46           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 47             | 47           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 48             | 48           | Domain_1 |
...
```

​        To save space, the MySQL server can compress the        `mysql.gtid_executed` table periodically by        replacing each such set of rows with a single row that spans the        entire interval of transaction identifiers, like this:      
为了节省空间，MySQL 服务器可以通过将每组这样的行替换为跨越整个事务标识符间隔的单行来定期压缩 `mysql.gtid_executed` table，如下所示：

```none
+--------------------------------------+----------------+--------------+----------+
| source_uuid                          | interval_start | interval_end | gtid_tag |
|--------------------------------------+----------------+--------------|----------+
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 31             | 35           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 36             | 39           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40             | 43           | Domain_1 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 44             | 46           | Domain_2 |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 47             | 48           | Domain_1 |
...
```

​        The server can carry out compression using a dedicated        foreground thread named        `thread/sql/compress_gtid_table`. This thread        is not listed in the output of [`SHOW         PROCESSLIST`](https://dev.mysql.com/doc/refman/8.4/en/show-processlist.html), but it can be viewed as a row in the        [`threads`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-threads-table.html) table, as shown here:      
服务器可以使用名为 `thread/sql/compress_gtid_table` 的专用前台线程执行压缩。此线程未在 [`SHOW PROCESSLIST`](https://dev.mysql.com/doc/refman/8.4/en/show-processlist.html) 的输出中列出，但可以在 [`threads`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-threads-table.html) 表中将其视为一行，如下所示：

```sql
mysql> SELECT * FROM performance_schema.threads WHERE NAME LIKE '%gtid%'\G
*************************** 1. row ***************************
          THREAD_ID: 26
               NAME: thread/sql/compress_gtid_table
               TYPE: FOREGROUND
     PROCESSLIST_ID: 1
   PROCESSLIST_USER: NULL
   PROCESSLIST_HOST: NULL
     PROCESSLIST_DB: NULL
PROCESSLIST_COMMAND: Daemon
   PROCESSLIST_TIME: 1509
  PROCESSLIST_STATE: Suspending
   PROCESSLIST_INFO: NULL
   PARENT_THREAD_ID: 1
               ROLE: NULL
       INSTRUMENTED: YES
            HISTORY: YES
    CONNECTION_TYPE: NULL
       THREAD_OS_ID: 18677
```

​        When binary logging is enabled on the server, this compression        method is not used, and instead the        `mysql.gtid_executed` table is compressed on        each binary log rotation. However, when binary logging is        disabled on the server, the        `thread/sql/compress_gtid_table` thread sleeps        until a specified number of transactions have been executed,        then wakes up to perform compression of the        `mysql.gtid_executed` table. It then sleeps        until the same number of transactions have taken place, then        wakes up to perform the compression again, repeating this loop        indefinitely. The number of transactions that elapse before the        table is compressed, and thus the compression rate, is        controlled by the value of the        [`gtid_executed_compression_period`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)        system variable. Setting that value to 0 means that the thread        never wakes up, meaning that this explicit compression method is        not used. Instead, compression occurs implicitly as required.      
在服务器上启用二进制日志记录时，不使用此压缩方法，而是在每次二进制日志轮换时压缩 `mysql.gtid_executed` 表。但是，当在服务器上禁用二进制日志记录时， `thread/sql/compress_gtid_table` 线程将休眠，直到执行了指定数量的事务，然后唤醒以执行 `mysql.gtid_executed` 表的压缩。然后，它会休眠，直到发生相同数量的事务，然后唤醒以再次执行压缩，无限期地重复此循环。在压缩 table 之前经过的事务数以及压缩率由[ `gtid_executed_compression_period` ](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)系统变量的值控制。将该值设置为 0 意味着线程永远不会唤醒，这意味着不使用此显式压缩方法。相反，压缩会根据需要隐式发生。

​        [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) transactions are written to        the `mysql.gtid_executed` table by a process        separate from that used for transactions involving storage        engines other than `InnoDB`. This process is        controlled by a different thread,        `innodb/clone_gtid_thread`. This GTID persister        thread collects GTIDs in groups, flushes them to the        `mysql.gtid_executed` table, then compresses        the table. If the server has a mix of        [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) transactions and        non-[`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) transactions, which are        written to the `mysql.gtid_executed` table        individually, the compression carried out by the        `compress_gtid_table` thread interferes with        the work of the GTID persister thread and can slow it        significantly. For this reason, it is recommended that you set        [`gtid_executed_compression_period`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)        to 0, so that the `compress_gtid_table` thread        is never activated.      
[`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 事务由一个进程写入 `mysql.gtid_executed` table 中，该进程与用于涉及 `InnoDB` 以外的存储引擎的事务的进程不同。此过程由不同的线程 `innodb/clone_gtid_thread` 控制。此 GTID 持久化线程将 GTID 分组收集，将它们刷新到 `mysql.gtid_executed` 表中，然后压缩表。如果服务器混合了 [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 事务和非 [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 事务，这些事务分别写入 `mysql.gtid_executed` table，则 `compress_gtid_table` 线程执行的压缩会干扰 GTID 持久线程的工作，并可能显着减慢它的速度。因此，建议您设置为 [ `gtid_executed_compression_period` ](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period) 0，以便永远不会激活 `compress_gtid_table` 线程。

​        The default value for        [`gtid_executed_compression_period`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)        is 0, and all transactions regardless of storage engine are        written to the `mysql.gtid_executed` table by        the GTID persister thread.      
的[ `gtid_executed_compression_period` ](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)默认值为 0，无论存储引擎如何，所有事务都由 GTID 持久线程写入 `mysql.gtid_executed` table。

​        When a server instance is started, if        [`gtid_executed_compression_period`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)        is set to a nonzero value and the        `thread/sql/compress_gtid_table` thread is        launched, in most server configurations, explicit compression is        performed for the `mysql.gtid_executed` table.        Compression is triggered by the thread launch. 
当服务器实例启动时，如果[ `gtid_executed_compression_period` ](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed_compression_period)设置为非零值并且线程被启动， `thread/sql/compress_gtid_table` 则在大多数服务器配置中，将对 `mysql.gtid_executed` table 执行显式压缩。压缩由线程启动触发。

#### 19.1.3.2 GTID Life Cycle 19.1.3.2 GTID 生命周期



​      The life cycle of a GTID consists of the following steps: 
GTID 的生命周期包括以下步骤：

1. ​          A transaction is executed and committed on the source. This          client transaction is assigned a GTID composed of the source's          UUID and the smallest nonzero transaction sequence number not          yet used on this server. The GTID is written to the source's          binary log (immediately preceding the transaction itself in          the log). If a client transaction is not written to the binary          log (for example, because the transaction was filtered out, or          the transaction was read-only), it is not assigned a GTID.        
   在源上执行并提交事务。为此客户端事务分配一个 GTID，该 GTID 由源的 UUID 和此服务器上尚未使用的最小非零事务序列号组成。GTID  将写入源的二进制日志（紧接在日志中事务本身之前）。如果客户端事务未写入二进制日志（例如，因为事务被过滤掉，或者事务是只读的），则不会为其分配  GTID。
2. ​          If a GTID was assigned for the transaction, the GTID is          persisted atomically at commit time by writing it to the          binary log at the beginning of the transaction (as a          `Gtid_log_event`). Whenever the binary log is          rotated or the server is shut down, the server writes GTIDs          for all transactions that were written into the previous          binary log file into the          `mysql.gtid_executed` table.        
   如果为事务分配了 GTID，则通过在事务开始时将 GTID 写入二进制日志（作为`Gtid_log_event`），在提交时以原子方式保留 GTID。每当轮换二进制日志或关闭服务器时，服务器都会将写入前一个二进制日志文件的所有事务的 GTID 写入`mysql.gtid_executed`表中。
3. ​          If a GTID was assigned for the transaction, the GTID is          externalized non-atomically (very shortly after the          transaction is committed) by adding it to the set of GTIDs in          the [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system          variable (`@@GLOBAL.gtid_executed`). This          GTID set contains a representation of the set of all committed          GTID transactions, and it is used in replication as a token          that represents the server state. With binary logging enabled          (as required for the source), the set of GTIDs in the          [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable          is a complete record of the transactions applied, but the          `mysql.gtid_executed` table is not, because          the most recent history is still in the current binary log          file.        
   如果为事务分配了 GTID，则通过将 GTID 添加到 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量 （`@@GLOBAL.gtid_executed`） 中的 GTID 集，以非原子方式（在事务提交后不久）将其外部化。此 GTID 集包含所有已提交的 GTID 事务集的表示形式，并在复制中用作表示服务器状态的令牌。启用二进制日志记录（根据源的要求）后，[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)系统变量中的 GTID 集是所应用事务的完整记录，但`mysql.gtid_executed`表不是，因为最近的历史记录仍在当前的二进制日志文件中。
4. ​          After the binary log data is transmitted to the replica and          stored in the replica's relay log (using established          mechanisms for this process, see          [Section 19.2, “Replication Implementation”](https://dev.mysql.com/doc/refman/8.4/en/replication-implementation.html), for details),          the replica reads the GTID and sets the value of its          [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) system variable as          this GTID. This tells the replica that the next transaction          must be logged using this GTID. It is important to note that          the replica sets `gtid_next` in a session          context.        
   在将二进制日志数据传输到副本并存储在副本的中继日志中（使用此过程的已建立机制，有关详细信息，请参见[第 19.2 节 “复制实现”](https://dev.mysql.com/doc/refman/8.4/en/replication-implementation.html)），副本将读取 GTID 并将其[`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)系统变量的值设置为此 GTID。这告诉副本必须使用此 GTID 记录下一个事务。请务必注意，副本集`gtid_next` session 上下文中。
5. ​          The replica verifies that no thread has yet taken ownership of          the GTID in [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) in          order to process the transaction. By reading and checking the          replicated transaction's GTID first, before processing the          transaction itself, the replica guarantees not only that no          previous transaction having this GTID has been applied on the          replica, but also that no other session has already read this          GTID but has not yet committed the associated transaction. So          if multiple clients attempt to apply the same transaction          concurrently, the server resolves this by letting only one of          them execute. The [`gtid_owned`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_owned)          system variable (`@@GLOBAL.gtid_owned`) for          the replica shows each GTID that is currently in use and the          ID of the thread that owns it. If the GTID has already been          used, no error is raised, and the auto-skip function is used          to ignore the transaction.        
   副本验证 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 中还没有线程获得 GTID 的所有权以处理事务。通过在处理事务本身之前首先读取和检查复制事务的 GTID，副本不仅保证没有在副本上应用具有此  GTID 的先前事务，而且没有其他会话已经读取此 GTID 但尚未提交关联的事务。因此，如果多个 Client  端尝试同时应用相同的事务，则服务器通过只允许其中一个执行来解决此问题。副本的 [`gtid_owned`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_owned) 系统变量 （`@@GLOBAL.gtid_owned`） 显示当前正在使用的每个 GTID 以及拥有它的线程的 ID。如果已使用 GTID，则不会引发错误，并且使用自动跳过函数来忽略事务。
6. ​          If the GTID has not been used, the replica applies the          replicated transaction. Because          [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) is set to the GTID          already assigned by the source, the replica does not attempt          to generate a new GTID for this transaction, but instead uses          the GTID stored in [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next).        
   如果尚未使用 GTID，则副本将应用复制的事务。由于 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 已设置为源已分配的 GTID，因此副本不会尝试为此事务生成新的 GTID，而是使用存储在 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 中的 GTID。
7. ​          If binary logging is enabled on the replica, the GTID is          persisted atomically at commit time by writing it to the          binary log at the beginning of the transaction (as a          `Gtid_log_event`). Whenever the binary log is          rotated or the server is shut down, the server writes GTIDs          for all transactions that were written into the previous          binary log file into the          `mysql.gtid_executed` table.        
   如果在副本上启用了二进制日志记录，则通过在事务开始时将 GTID 写入二进制日志（作为`Gtid_log_event`），在提交时以原子方式保留 GTID。每当轮换二进制日志或关闭服务器时，服务器都会将写入前一个二进制日志文件的所有事务的 GTID 写入`mysql.gtid_executed`表中。
8. ​          If binary logging is disabled on the replica, the GTID is          persisted atomically by writing it directly into the          `mysql.gtid_executed` table. MySQL appends a          statement to the transaction to insert the GTID into the          table. This operation is atomic for DDL statements as well as          for DML statements. In this situation, the          `mysql.gtid_executed` table is a complete          record of the transactions applied on the replica.        
   如果在副本上禁用了二进制日志记录，则通过将 GTID 直接写入 `mysql.gtid_executed` 表来以原子方式保留 GTID。MySQL 将语句附加到事务中，以将 GTID 插入表中。此操作对于 DDL 语句和 DML 语句都是原子的。在这种情况下，`mysql.gtid_executed` 表是应用于副本的事务的完整记录。
9. ​          Very shortly after the replicated transaction is committed on          the replica, the GTID is externalized non-atomically by adding          it to the set of GTIDs in the          [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable          (`@@GLOBAL.gtid_executed`) for the replica.          As for the source, this GTID set contains a representation of          the set of all committed GTID transactions. If binary logging          is disabled on the replica, the          `mysql.gtid_executed` table is also a          complete record of the transactions applied on the replica. If          binary logging is enabled on the replica, meaning that some          GTIDs are only recorded in the binary log, the set of GTIDs in          the [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system          variable is the only complete record. 
   在副本上提交复制的事务后不久，通过将 GTID 添加到副本的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量 （`@@GLOBAL.gtid_executed`） 中的 GTID 集中，以非原子方式将其外部化。至于源，此 GTID 集包含所有已提交的 GTID 事务集的表示形式。如果在副本上禁用了二进制日志记录，`则 mysql.gtid_executed` 表也是应用于副本的事务的完整记录。如果在副本上启用了二进制日志记录，这意味着某些 GTID 仅记录在二进制日志中，则 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量中的 GTID 集是唯一的完整记录。

​      Client transactions that are completely filtered out on the source      are not assigned a GTID, therefore they are not added to the set      of transactions in the      [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable, or      added to the `mysql.gtid_executed` table.      However, the GTIDs of replicated transactions that are completely      filtered out on the replica are persisted. If binary logging is      enabled on the replica, the filtered-out transaction is written to      the binary log as a `Gtid_log_event` followed by      an empty transaction containing only `BEGIN` and      `COMMIT` statements. If binary logging is      disabled, the GTID of the filtered-out transaction is written to      the `mysql.gtid_executed` table. Preserving the      GTIDs for filtered-out transactions ensures that the      `mysql.gtid_executed` table and the set of GTIDs      in the [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system      variable can be compressed. It also ensures that the filtered-out      transactions are not retrieved again if the replica reconnects to      the source, as explained in      [Section 19.1.3.3, “GTID Auto-Positioning”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-auto-positioning.html).    
在源上完全过滤掉的客户端事务不会分配 GTID，因此它们不会添加到 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量中的事务集中，也不会添加到`mysql.gtid_executed`表中。但是，在副本上完全筛选掉的复制事务的 GTID 将被保留。如果在副本上启用了二进制日志记录，则筛选出的事务将作为`Gtid_log_event`写入二进制日志，后跟仅包含 `BEGIN` 和 `COMMIT` 语句的空事务。如果禁用了二进制日志记录，则筛选出的事务的 GTID 将写入 `mysql.gtid_executed` 表中。保留筛选出的事务的 GTID 可确保可以压缩 `mysql.gtid_executed` 表和 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量中的 GTID 集。它还确保在副本重新连接到源时不会再次检索过滤掉的事务，如[第 19.1.3.3 节 “ GTID 自动定位”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-auto-positioning.html)中所述。

​      On a multithreaded replica (with      [`replica_parallel_workers > 0`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_parallel_workers)),      transactions can be applied in parallel, so replicated      transactions can commit out of order (unless      [`replica_preserve_commit_order =       1`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_preserve_commit_order)). When that happens, the set of GTIDs in the      [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable      contains multiple GTID ranges with gaps between them. (On a source      or a single-threaded replica, there are monotonically increasing      GTIDs without gaps between the numbers.) Gaps on multithreaded      replicas only occur among the most recently applied transactions,      and are filled in as replication progresses. When replication      threads are stopped cleanly using the [`STOP       REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html) statement, ongoing transactions are applied so      that the gaps are filled in. In the event of a shutdown such as a      server failure or the use of the      [`KILL`](https://dev.mysql.com/doc/refman/8.4/en/kill.html) statement to stop replication      threads, the gaps might remain. 
在多线程副本（[`replica_parallel_workers > 0`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_parallel_workers)）上，事务可以并行应用，因此复制的事务可以不按顺序提交（除非[ `replica_preserve_commit_order =       1` ](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_preserve_commit_order)）。发生这种情况时，[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量中的 GTID 集包含多个 GTID 范围，它们之间有间隙。（在源或单线程副本上，存在单调递增的 GTID，数字之间没有间隙。多线程副本上的间隙仅发生在最近应用的事务中，并随着复制的进行而填充。当使用 [`STOP REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html) 语句完全停止复制线程时，将应用正在进行的事务，以便填补间隙。如果发生关闭（例如服务器故障）或使用 [`KILL`](https://dev.mysql.com/doc/refman/8.4/en/kill.html) 语句停止复制线程，则间隙可能仍然存在。

##### What changes are assigned a GTID? 为哪些更改分配了 GTID？

​        The typical scenario is that the server generates a new GTID for        a committed transaction. However, GTIDs can also be assigned to        other changes besides transactions, and in some cases a single        transaction can be assigned multiple GTIDs.      
典型情况是服务器为提交的事务生成新的 GTID。但是，GTID 也可以分配给除事务之外的其他更改，在某些情况下，可以为单个事务分配多个 GTID。

​        Every database change (DDL or DML) that is written to the binary        log is assigned a GTID. This includes changes that are        autocommitted, and changes that are committed using        `BEGIN` and `COMMIT` or        `START TRANSACTION` statements. A GTID is also        assigned to the creation, alteration, or deletion of a database,        and of a non-table database object such as a procedure,        function, trigger, event, view, user, role, or grant.      
写入二进制日志的每个数据库更改（DDL 或 DML）都会分配一个 GTID。这包括自动提交的更改，以及使用 `BEGIN` 和 `COMMIT` 或 `START TRANSACTION` 语句提交的更改。GTID 还分配给数据库和非表数据库对象（如过程、函数、触发器、事件、视图、用户、角色或授权）的创建、更改或删除。

​        Non-transactional updates as well as transactional updates are        assigned GTIDs. In addition, for a non-transactional update, if        a disk write failure occurs while attempting to write to the        binary log cache and a gap is therefore created in the binary        log, the resulting incident log event is assigned a GTID.      
非事务性更新以及事务性更新都分配有 GTID。此外，对于非事务性更新，如果在尝试写入二进制日志缓存时发生磁盘写入故障，并因此在二进制日志中创建了间隙，则会为生成的事件日志事件分配一个 GTID。

​        When a table is automatically dropped by a generated statement        in the binary log, a GTID is assigned to the statement.        Temporary tables are dropped automatically when a replica begins        to apply events from a source that has just been started, and        when statement-based replication is in use        ([`binlog_format=STATEMENT`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format)) and a        user session that has open temporary tables disconnects. Tables        that use the [`MEMORY`](https://dev.mysql.com/doc/refman/8.4/en/memory-storage-engine.html) storage engine        are deleted automatically the first time they are accessed after        the server is started, because rows might have been lost during        the shutdown.      
当二进制日志中生成的语句自动删除表时，将为该语句分配一个 GTID。当副本开始从刚刚启动的源应用事件时，以及当基于语句的复制正在使用 （[`binlog_format=STATEMENT`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format)） 并且具有打开的临时表的用户会话断开连接时，将自动删除临时表。使用 [`MEMORY`](https://dev.mysql.com/doc/refman/8.4/en/memory-storage-engine.html) 存储引擎的 table 在服务器启动后首次访问时会自动删除，因为在关闭期间行可能已丢失。

​        When a transaction is not written to the binary log on the        server of origin, the server does not assign a GTID to it. This        includes transactions that are rolled back and transactions that        are executed while binary logging is disabled on the server of        origin, either globally (with `--skip-log-bin`        specified in the server's configuration) or for the session        (`SET @@SESSION.sql_log_bin = 0`). This also        includes no-op transactions when row-based replication is in use        ([`binlog_format=ROW`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format)).      
当事务未写入源服务器上的二进制日志时，服务器不会为其分配 GTID。这包括回滚的事务和在源服务器上禁用二进制日志记录时执行的事务，无论是全局的（在服务器配置中指定-`-skip-log-bin`）还是会话（`SET @@SESSION.sql_log_bin = 0`）。这还包括使用基于行的复制时的无操作事务 （[`binlog_format=ROW`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format)）。

​        XA transactions are assigned separate GTIDs for the `XA        PREPARE` phase of the transaction and the `XA        COMMIT` or `XA ROLLBACK` phase of the        transaction. XA transactions are persistently prepared so that        users can commit them or roll them back in the case of a failure        (which in a replication topology might include a failover to        another server). The two parts of the transaction are therefore        replicated separately, so they must have their own GTIDs, even        though a non-XA transaction that is rolled back would not have a        GTID.      
为事务的 `XA PREPARE` 阶段和事务的 `XA COMMIT` 或 `XA ROLLBACK` 阶段分配了单独的 GTID。XA 事务是持久准备的，以便用户可以在发生故障时提交它们或回滚它们（在复制拓扑中可能包括故障转移到另一台服务器）。因此，事务的两个部分是单独复制的，因此它们必须具有自己的 GTID，即使回滚的非 XA 事务没有 GTID。

​        In the following special cases, a single statement can generate        multiple transactions, and therefore be assigned multiple GTIDs: 
在以下特殊情况下，单个语句可以生成多个事务，因此可以分配多个 GTID：

- ​            A stored procedure is invoked that commits multiple            transactions. One GTID is generated for each transaction            that the procedure commits.          
  调用提交多个事务的存储过程。为该过程提交的每个事务生成一个 GTID。
- ​            A multi-table [`DROP TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html)            statement drops tables of different types. Multiple GTIDs            can be generated if any of the tables use storage engines            that do not support atomic DDL, or if any of the tables are            temporary tables.          
  多表 [`DROP TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) 语句会删除不同类型的表。如果任何表使用不支持原子 DDL 的存储引擎，或者任何表是临时表，则可以生成多个 GTID。
- ​            A            [`CREATE             TABLE ... SELECT`](https://dev.mysql.com/doc/refman/8.4/en/create-table-select.html) statement is issued when            row-based replication is in use            ([`binlog_format=ROW`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format)). One            GTID is generated for the [`CREATE             TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) action and one GTID is generated for the            row-insert actions. 
  当使用基于行的复制时 （[`binlog_format=ROW`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format)） 发出一个[ `CREATE             TABLE ... SELECT` ](https://dev.mysql.com/doc/refman/8.4/en/create-table-select.html)语句。为 [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) 操作生成一个 GTID，为 row-insert 操作生成一个 GTID。

##### The gtid_next System Variable gtid_next 系统变量

​        By default, for new transactions committed in user sessions, the        server automatically generates and assigns a new GTID. When the        transaction is applied on a replica, the GTID from the server of        origin is preserved. You can change this behavior by setting the        session value of the [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)        system variable: 
默认情况下，对于在用户会话中提交的新事务，服务器会自动生成并分配新的 GTID。当事务应用于副本时，将保留来自源服务器的 GTID。您可以通过设置 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 系统变量的 session 值来更改此行为：

- ​            When [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) is set to            `AUTOMATIC` (the default) and a transaction            is committed and written to the binary log, the server            automatically generates and assigns a new GTID. If a            transaction is rolled back or not written to the binary log            for another reason, the server does not generate and assign            a GTID.          
  当[`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)设置为`AUTOMATIC`（默认值）并且事务被提交并写入二进制日志时，服务器会自动生成并分配一个新的 GTID。如果由于其他原因回滚或未将事务写入二进制日志，则服务器不会生成和分配 GTID。
- ​            If you set [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) to            `AUTOMATIC:*`TAG`*`,            a new GTID including the specified tag is assigned to each            new transaction.          
  如果您将 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 设置为 `AUTOMATIC：*`TAG`*`，则会为每个新事务分配一个包含指定标签的新 GTID。
- ​            If you set [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) to a            valid GTID (consisting of a UUID, an optional tag, and a            transaction sequence number, separated by a colon), the            server assigns that GTID to your transaction. This GTID is            assigned and added to            [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) even when the            transaction is not written to the binary log, or when the            transaction is empty. 
  如果您将 [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) 设置为有效的 GTID（由 UUID、可选标签和事务序列号组成，用冒号分隔），则服务器会将该 GTID 分配给您的事务。即使事务未写入二进制日志或事务为空，也会分配此 GTID 并将其添加到 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)。

​        Note that after you set        [`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next) to a specific GTID        (in either        `*`UUID`*:*`NUMBER`*`        or        `*`UUID`*:*`TAG`*:*`NUMBER`*`        format), and the transaction has been committed or rolled back,        an explicit `SET @@SESSION.gtid_next` statement        must be issued before any other statement. You can use this to        set the GTID value back to `AUTOMATIC` if you        do not want to assign any more GTIDs explicitly.      
请注意，在将[`gtid_next`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_next)设置为特定 GTID（以 `*`UUID`*：*`NUMBER`*` 或 `*`UUID`*：*`TAG`*：*`NUMBER`*` 格式）并且事务已提交或回滚后，必须在任何其他语句之前发出显式 `SET @@SESSION.gtid_next` 语句。如果您不想显式分配更多 GTID，则可以使用此函数将 GTID 值设置回 `AUTOMATIC`。

​        When replication applier threads apply replicated transactions,        they use this technique, setting        `@@SESSION.gtid_next` explicitly to the GTID of        the replicated transaction as assigned on the server of origin.        This means the GTID from the server of origin is retained,        rather than a new GTID being generated and assigned by the        replica. It also means the GTID is added to        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) on the replica        even when binary logging or replica update logging is disabled        on the replica, or when the transaction is a no-op or is        filtered out on the replica.      
当复制应用程序线程应用复制的事务时，它们会使用此技术，将 `@@SESSION.gtid_next` 显式设置为在源服务器上分配的复制事务的 GTID。这意味着将保留来自源服务器的 GTID，而不是由副本生成和分配的新 GTID。这也意味着即使在副本上禁用了二进制日志记录或副本更新日志记录，或者当事务在副本上被筛选掉时，GTID 也会添加到副本上的[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)。

​        It is possible for a client to simulate a replicated transaction        by setting `@@SESSION.gtid_next` to a specific        GTID before executing the transaction. This technique is used by        [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) to generate a dump of the binary        log that the client can replay to preserve GTIDs. A simulated        replicated transaction committed through a client is completely        equivalent to a replicated transaction committed through a        replication applier thread, and they cannot be distinguished        after the fact. 
客户端可以通过在执行事务之前将 `@@SESSION.gtid_next` 设置为特定 GTID 来模拟复制的事务。[**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 使用此技术来生成二进制日志的转储，客户端可以重放该转储以保留 GTID。通过 Client 端提交的模拟复制事务与通过复制应用程序线程提交的复制事务完全等效，事后无法区分它们。

##### The `gtid_purged` System Variable `gtid_purged` 系统变量



​        The set of GTIDs in the        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) system variable        (`@@GLOBAL.gtid_purged`) contains the GTIDs of        all the transactions that have been committed on the server, but        that do not exist in any binary log file on the server.        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) is a subset of        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed). The following        categories of GTIDs are in        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged): 
[`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)系统变量 （`@@GLOBAL.gtid_purged`） 中的 GTID 集包含已在服务器上提交但不存在于服务器上的任何二进制日志文件中的所有事务的 GTID。[`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 是 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 的子集。以下类别的 GTID 分为 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)：

- ​            GTIDs of replicated transactions that were committed with            binary logging disabled on the replica.          
  在副本上禁用二进制日志记录的情况下提交的复制事务的 GTID。
- ​            GTIDs of transactions that were written to a binary log file            that has now been purged.          
  写入现已清除的二进制日志文件的事务的 GTID。
- ​            GTIDs that were added explicitly to the set by the statement            `SET @@GLOBAL.gtid_purged`. 
  由语句 `SET @@GLOBAL.gtid_purged` 显式添加到集合中的 GTID。

​        You can change the value of        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) in order to record        on the server that the transactions in a certain GTID set have        been applied, although they do not exist in any binary log on        the server. When you add GTIDs to        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged), they are also        added to [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed). An        example use case for this action is when you are restoring a        backup of one or more databases on a server, but you do not have        the relevant binary logs containing the transactions on the        server. You can also choose whether to replace the whole GTID        set in [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) with a        specified GTID set, or to add a specified GTID set to the GTIDs        already in [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged). For        details of how to do this, see the description for        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged).      
您可以更改 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 的值，以便在服务器上记录已应用某个 GTID 集中的事务，尽管它们不存在于服务器上的任何二进制日志中。当您将 GTID 添加到 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 时，它们也会添加到 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)。此操作的一个示例用例是，当您在服务器上还原一个或多个数据库的备份，但服务器上没有包含事务的相关二进制日志时。您还可以选择是将 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 中设置的整个 GTID 替换为指定的 GTID 集，还是将指定的 GTID 集添加到[`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)中已有的 GTID 集。有关如何执行此操作的详细信息，请参阅 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 的说明。

​        The sets of GTIDs in the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) and        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) system variables        are initialized when the server starts. Every binary log file        begins with the event        `Previous_gtids_log_event`, which contains the        set of GTIDs in all previous binary log files (composed from the        GTIDs in the preceding file's        `Previous_gtids_log_event`, and the GTIDs of        every `Gtid_log_event` in the preceding file        itself). The contents of        `Previous_gtids_log_event` in the oldest and        most recent binary log files are used to compute the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) and        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) sets at server        startup: 
[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 和 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 系统变量中的 GTID 集在服务器启动时初始化。每个二进制日志文件都以事件`Previous_gtids_log_event`开头，其中包含所有先前二进制日志文件中的 GTID 集（由前一个文件`Previous_gtids_log_event`中的 GTID 和前一个文件本身中每个`Gtid_log_event`的 GTID 组成）。最旧和最新的二进制日志文件中`Previous_gtids_log_event`的内容用于计算服务器启动时的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 和 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 集：

- ​            [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) is computed            as the union of the GTIDs in            `Previous_gtids_log_event` in the most            recent binary log file, the GTIDs of transactions in that            binary log file, and the GTIDs stored in the            `mysql.gtid_executed` table. This GTID set            contains all the GTIDs that have been used (or added            explicitly to [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged))            on the server, whether or not they are currently in a binary            log file on the server. It does not include the GTIDs for            transactions that are currently being processed on the            server (`@@GLOBAL.gtid_owned`).          
  [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)的计算方式为最新二进制日志文件中 `Previous_gtids_log_event` 的 GTID、该二进制日志文件中事务的 GTID 以及`存储在 mysql.gtid_executed` 表中的 GTID。此 GTID 集包含服务器上已使用（或显式添加到 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)）的所有 GTID，无论它们当前是否位于服务器上的二进制日志文件中。它不包括当前正在服务器上处理的事务的 GTID （`@@GLOBAL.gtid_owned`）。
- ​            [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) is computed by            first adding the GTIDs in            `Previous_gtids_log_event` in the most            recent binary log file and the GTIDs of transactions in that            binary log file. This step gives the set of GTIDs that are            currently, or were once, recorded in a binary log on the            server (`gtids_in_binlog`). Next, the GTIDs            in `Previous_gtids_log_event` in the oldest            binary log file are subtracted from            `gtids_in_binlog`. This step gives the set            of GTIDs that are currently recorded in a binary log on the            server (`gtids_in_binlog_not_purged`).            Finally, `gtids_in_binlog_not_purged` is            subtracted from            [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed). The result            is the set of GTIDs that have been used on the server, but            are not currently recorded in a binary log file on the            server, and this result is used to initialize            [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged). 
  [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)的计算方法是首先在最新的二进制日志文件中`Previous_gtids_log_event`添加 GTID，并在该二进制日志文件中添加事务的 GTID。此步骤提供当前或曾经记录在服务器上的二进制日志 （`gtids_in_binlog`） 中的 GTID 集。接下来，从最早的二进制日志文件中减去 `Previous_gtids_log_event` 中的 `GTID，gtids_in_binlog`。此步骤提供当前记录在服务器上的二进制日志 （`gtids_in_binlog_not_purged`） 中的 GTID 集。最后，从 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 中减去 `gtids_in_binlog_not_purged`。结果是已在服务器上使用但当前未记录在服务器上的二进制日志文件中的 GTID 集，此结果用于初始化[`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)。

##### Resetting the GTID Execution History 重置 GTID 执行历史记录

​        If you need to reset the GTID execution history on a server, use        the [`RESET BINARY LOGS AND GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)        statement. You might need to do this after carrying out test        queries to verify a replication setup on new GTID-enabled        servers, or when you want to join a new server to a replication        group but it contains some unwanted local transactions that are        not accepted by Group Replication. 
如果您需要在服务器上重置 GTID 执行历史记录，请使用 [`RESET BINARY LOGS AND GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html) 语句。在执行测试查询以验证启用了 GTID 的新服务器上的复制设置后，或者当您要将新服务器加入复制组，但它包含一些组复制不接受的不需要的本地事务时，您可能需要执行此操作。

Warning 警告

​          Use [`RESET BINARY LOGS AND GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)          with caution to avoid losing any wanted GTID execution history          and binary log files. 
请谨慎使用 [`RESET BINARY LOGS AND GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)，以避免丢失任何所需的 GTID 执行历史记录和二进制日志文件。

​        Before issuing [`RESET BINARY LOGS AND         GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html), ensure that you have backups of the server's        binary log files and binary log index file, if any, and obtain        and save the GTID set held in the global value of the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable        (for example, by issuing a `SELECT        @@GLOBAL.gtid_executed` statement and saving the        results). If you are removing unwanted transactions from that        GTID set, use [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) to examine the        contents of the transactions to ensure that they have no value,        contain no data that must be saved or replicated, and did not        result in data changes on the server.      
在发出[ `RESET BINARY LOGS AND         GTIDS` ](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)之前，请确保您有服务器的二进制日志文件和二进制日志索引文件（如果有）的备份，并获取并保存保存在 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量的全局值中的 GTID 集（例如，通过发出 `SELECT        @@GLOBAL.gtid_executed` 语句并保存结果）。如果要从该 GTID 集中删除不需要的事务，请使用 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 检查事务的内容，以确保它们没有值，不包含必须保存或复制的数据，并且不会导致服务器上的数据更改。

​        When you issue [`RESET BINARY LOGS AND         GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html), the following reset operations are carried out: 
当您发出 [ `RESET BINARY LOGS AND         GTIDS` ](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)时，将执行以下重置操作：

- ​            The value of the            [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) system variable            is set to an empty string (`''`).          
  [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 系统变量的值设置为空字符串 （`''`）。
- ​            The global value (but not the session value) of the            [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system            variable is set to an empty string.          
  [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)系统变量的全局值（但不是会话值）设置为空字符串。
- ​            The `mysql.gtid_executed` table is cleared            (see            [mysql.gtid_executed Table](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html#replication-gtids-gtid-executed-table)).          
  `mysql.gtid_executed` 表将被清除（请参阅[mysql.gtid_executed表](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html#replication-gtids-gtid-executed-table)）。
- ​            If the server has binary logging enabled, the existing            binary log files are deleted and the binary log index file            is cleared. 
  如果服务器启用了二进制日志记录，则会删除现有的二进制日志文件，并清除二进制日志索引文件。

​        Note that [`RESET BINARY LOGS AND         GTIDS`](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html) is the method to reset the GTID execution        history even if the server is a replica where binary logging is        disabled. [`RESET REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html) has no        effect on the GTID execution history. 
请注意，这是[ `RESET BINARY LOGS AND         GTIDS` ](https://dev.mysql.com/doc/refman/8.4/en/reset-binary-logs-and-gtids.html)重置 GTID 执行历史记录的方法，即使服务器是禁用二进制日志记录的副本。[`RESET REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html) 对 GTID 执行历史记录没有影响。

#### 19.1.3.3 GTID 自动定位



​      GTIDs replace the file-offset pairs previously required to      determine points for starting, stopping, or resuming the flow of      data between source and replica. When GTIDs are in use, all the      information that the replica needs for synchronizing with the      source is obtained directly from the replication data stream.    
GTID 取代了以前确定启动、停止或恢复源和副本之间数据流的点所需的文件偏移对。使用 GTID 时，副本与源同步所需的所有信息都是直接从复制数据流获取的。

​      To start a replica using GTID-based replication, you need to      enable the `SOURCE_AUTO_POSITION` option in the      [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)      statement. The alternative `SOURCE_LOG_FILE` and      `SOURCE_LOG_POS` options specify the name of the      log file and the starting position within the file, but with GTIDs      the replica does not need this nonlocal data. For full      instructions to configure and start sources and replicas using      GTID-based replication, see      [Section 19.1.3.4, “Setting Up Replication Using GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html).    
要使用基于 GTID 的复制启动副本，您需要在 [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) 语句中启用 `SOURCE_AUTO_POSITION` 选项。替代 `SOURCE_LOG_FILE` 和 `SOURCE_LOG_POS` 选项指定日志文件的名称和文件中的起始位置，但使用 GTID 时，副本不需要这些非本地数据。有关使用基于 GTID 的复制配置和启动源和副本的完整说明，请参见[第 19.1.3.4 节 “使用 GTID 设置复制”。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html)

​      The `SOURCE_AUTO_POSITION` option is disabled by      default. If multi-source replication is enabled on the replica,      you need to set the option for each applicable replication      channel. Disabling the `SOURCE_AUTO_POSITION`      option again causes the replica to revert to file-based      replication; this means that, when      `GTID_ONLY=ON`, some positions may be marked as      invalid, in which case you must also specify both      `SOURCE_LOG_FILE` and      `SOURCE_LOG_POS` when disabling      `SOURCE_AUTO_POSITION`.    
默认情况下，`SOURCE_AUTO_POSITION` 选项处于禁用状态。如果在副本上启用了多源复制，则需要为每个适用的复制通道设置选项。再次禁用 `SOURCE_AUTO_POSITION` 选项会导致副本恢复为基于文件的复制;这意味着，当 `GTID_ONLY=ON` 时，某些位置可能会被标记为无效，在这种情况下，在禁用 `SOURCE_AUTO_POSITION` 时，还必须同时指定 `SOURCE_LOG_FILE` 和 `SOURCE_LOG_POS`。

​      When a replica has GTIDs enabled      ([`GTID_MODE=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode),      `ON_PERMISSIVE,` or      `OFF_PERMISSIVE` ) and the      `SOURCE_AUTO_POSITION` option enabled,      auto-positioning is activated for connection to the source. The      source must have [`GTID_MODE=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) set      in order for the connection to succeed. In the initial handshake,      the replica sends a GTID set containing the transactions that it      has already received, committed, or both. This GTID set is equal      to the union of the set of GTIDs in the      [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) system variable      (`@@GLOBAL.gtid_executed`), and the set of GTIDs      recorded in the Performance Schema      [`replication_connection_status`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-connection-status-table.html) table      as received transactions (the result of the statement      `SELECT RECEIVED_TRANSACTION_SET FROM      PERFORMANCE_SCHEMA.replication_connection_status`).    
当副本启用了 GTID （[`GTID_MODE=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)、`ON_PERMISSIVE` 或 `OFF_PERMISSIVE` ）并且启用了 `SOURCE_AUTO_POSITION` 选项时，将激活自动定位以连接到源。源必须设置 [`GTID_MODE=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) 才能成功。在初始握手中，副本发送一个 GTID 集，其中包含它已接收和/或提交的事务。此 GTID 集等于 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 系统变量 （`@@GLOBAL.gtid_executed`） 中的 GTID 集与 Performance Schema [`replication_connection_status`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-connection-status-table.html) 表中记录为已接收事务的 GTID 集（语句 `SELECT RECEIVED_TRANSACTION_SET FROM      PERFORMANCE_SCHEMA.replication_connection_status` 的结果）的并集。

​      The source responds by sending all transactions recorded in its      binary log whose GTID is not included in the GTID set sent by the      replica. To do this, the source first identifies the appropriate      binary log file to begin working with, by checking the      `Previous_gtids_log_event` in the header of each      of its binary log files, starting with the most recent. When the      source finds the first `Previous_gtids_log_event`      which contains no transactions that the replica is missing, it      begins with that binary log file. This method is efficient and      only takes a significant amount of time if the replica is behind      the source by a large number of binary log files. The source then      reads the transactions in that binary log file and subsequent      files up to the current one, sending the transactions with GTIDs      that the replica is missing, and skipping the transactions that      were in the GTID set sent by the replica. The elapsed time until      the replica receives the first missing transaction depends on its      offset in the binary log file. This exchange ensures that the      source only sends the transactions with a GTID that the replica      has not already received or committed. If the replica receives      transactions from more than one source, as in the case of a      diamond topology, the auto-skip function ensures that the      transactions are not applied twice.    
源通过发送其二进制日志中记录的所有事务来响应，这些事务的 GTID 不包含在副本发送的 GTID 集中。为此，源首先通过检查每个二进制日志文件的标头中的`Previous_gtids_log_event`来确定要开始使用的相应二进制日志文件，从最新的开始。当源找到第一个不包含副本缺少的事务的`Previous_gtids_log_event`时，它将从该二进制日志文件开始。此方法非常有效，并且仅当副本落后于源大量二进制日志文件时，才需要大量时间。然后，源读取该二进制日志文件和后续文件中的事务，直到当前文件，发送具有副本缺少的 GTID 的事务，并跳过副本发送的 GTID  集中的事务。副本收到第一个缺失事务之前经过的时间取决于其在二进制日志文件中的偏移量。此交换可确保源仅发送副本尚未接收或提交的 GTID  的事务。如果副本从多个源接收事务（如菱形拓扑），则自动跳过功能可确保事务不会应用两次。

​      If any of the transactions that should be sent by the source have      been purged from the source's binary log, or added to the set      of GTIDs in the [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)      system variable by another method, the source sends the error      [`ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS`](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_source_has_purged_required_gtids)      to the replica, and replication does not start. The GTIDs of the      missing purged transactions are identified and listed in the      source's error log in the warning message      [`ER_FOUND_MISSING_GTIDS`](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_found_missing_gtids). The      replica cannot recover automatically from this error because parts      of the transaction history that are needed to catch up with the      source have been purged. Attempting to reconnect without the      `SOURCE_AUTO_POSITION` option enabled only      results in the loss of the purged transactions on the replica. The      correct approach to recover from this situation is for the replica      to replicate the missing transactions listed in the      [`ER_FOUND_MISSING_GTIDS`](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_found_missing_gtids) message      from another source, or for the replica to be replaced by a new      replica created from a more recent backup. Consider revising the      binary log expiration period      ([`binlog_expire_logs_seconds`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_expire_logs_seconds)) on      the source to ensure that the situation does not occur again.    
如果已从源的二进制日志中清除了应由源发送的任何事务，或通过其他方法将其添加到[`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)系统变量中的 GTID 集中，则源会将错误[ `ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS` ](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_source_has_purged_required_gtids)发送到副本，并且复制不会启动。缺少的已清除事务的 GTID 将被识别并列在警告消息 [`ER_FOUND_MISSING_GTIDS`](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_found_missing_gtids) 的源错误日志中。副本无法自动从此错误中恢复，因为已清除与源同步所需的部分事务历史记录。尝试在未启用 `SOURCE_AUTO_POSITION` 选项的情况下重新连接只会导致副本上清除的事务丢失。从这种情况中恢复的正确方法是让副本从另一个源复制 [`ER_FOUND_MISSING_GTIDS`](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_found_missing_gtids) 消息中列出的缺失事务，或者让副本替换为从较新的备份创建的新副本。请考虑修改源上的二进制日志过期期限 （[`binlog_expire_logs_seconds`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_expire_logs_seconds)） 以确保这种情况不会再次发生。

​      If during the exchange of transactions it is found that the      replica has received or committed transactions with the      source's UUID in the GTID, but the source itself does not      have a record of them, the source sends the error      [`ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE`](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_replica_has_more_gtids_than_source)      to the replica and replication does not start. This situation can      occur if a source that does not have      [`sync_binlog=1`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_sync_binlog) set experiences a      power failure or operating system crash, and loses committed      transactions that have not yet been synchronized to the binary log      file, but have been received by the replica. The source and      replica can diverge if any clients commit transactions on the      source after it is restarted, which can lead to the situation      where the source and replica are using the same GTID for different      transactions. The correct approach to recover from this situation      is to check manually whether the source and replica have diverged.      If the same GTID is now in use for different transactions, you      either need to perform manual conflict resolution for individual      transactions as required, or remove either the source or the      replica from the replication topology. If the issue is only      missing transactions on the source, you can make the source into a      replica instead, allow it to catch up with the other servers in      the replication topology, and then make it a source again if      needed.    
如果在事务交换期间发现副本已接收或提交了 GTID 中具有源 UUID 的事务，但源本身没有它们的记录，则源会将错误[ `ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE` ](https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html#error_er_replica_has_more_gtids_than_source)发送到副本，并且复制不会启动。如果未设置 [`sync_binlog=1`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_sync_binlog)  的源遇到电源故障或操作系统崩溃，并且丢失尚未同步到二进制日志文件但副本已接收的已提交事务，则可能会出现这种情况。如果任何客户端在重新启动后在源上提交事务，则源和副本可能会发散，这可能导致源和副本对不同的事务使用相同的 GTID 的情况。从这种情况中恢复的正确方法是手动检查源和副本是否已分叉。如果现在相同的 GTID  用于不同的事务，则需要根据需要对单个事务执行手动冲突解决，或者从复制拓扑中删除源或副本。如果问题仅在于源上缺少事务，则可以将源转换为副本，允许它与复制拓扑中的其他服务器保持同步，然后根据需要再次将其设置为源。

​      For a multi-source replica in a diamond topology (where the      replica replicates from two or more sources, which in turn      replicate from a common source), when GTID-based replication is in      use, ensure that any replication filters or other channel      configuration are identical on all channels on the multi-source      replica. With GTID-based replication, filters are applied only to      the transaction data, and GTIDs are not filtered out. This happens      so that a replica’s GTID set stays consistent with the      source’s, meaning GTID auto-positioning can be used without      re-acquiring filtered out transactions each time. In the case      where the downstream replica is multi-source and receives the same      transaction from multiple sources in a diamond topology, the      downstream replica now has multiple versions of the transaction,      and the result depends on which channel applies the transaction      first. The second channel to attempt it skips the transaction      using GTID auto-skip, because the transaction’s GTID was added      to the [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) set by the      first channel. With identical filtering on the channels, there is      no problem because all versions of the transaction contain the      same data, so the results are the same. However, with different      filtering on the channels, the database can become inconsistent      and replication can hang. 
对于菱形拓扑中的多源副本（其中副本从两个或多个源复制，而这些源又从公共源复制），当使用基于 GTID 的复制时，请确保多源副本上的所有通道上的任何复制过滤器或其他通道配置都相同。使用基于 GTID  的复制时，筛选条件仅应用于事务数据，并且不会筛选掉 GTID。发生这种情况是为了使副本的 GTID 集与源的 GTID  集保持一致，这意味着可以使用 GTID  自动定位，而无需每次都重新获取筛选出的事务。如果下游副本是多源的，并且从菱形拓扑中的多个源接收相同的事务，则下游副本现在具有事务的多个版本，结果取决于哪个通道首先应用事务。第二个尝试它的通道使用 GTID 自动跳过跳过事务，因为事务的 GTID 已添加到第一个通道设置的[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)中。在通道上进行相同的过滤时，没有问题，因为所有版本的事务都包含相同的数据，因此结果是相同的。但是，如果通道上的筛选方式不同，数据库可能会变得不一致，并且复制可能会挂起。

#### 19.1.3.4 Setting Up Replication Using GTIDs 19.1.3.4 使用 GTID 设置复制



​      This section describes a process for configuring and starting      GTID-based replication in MySQL 8.4. This is a      “cold start” procedure that assumes either that you      are starting the source server for the first time, or that it is      possible to stop it; for information about provisioning replicas      using GTIDs from a running source server, see      [Section 19.1.3.5, “Using GTIDs for Failover and Scaleout”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html). For information      about changing GTID mode on servers online, see      [Section 19.1.4, “Changing GTID Mode on Online Servers”](https://dev.mysql.com/doc/refman/8.4/en/replication-mode-change-online.html).    
本节介绍在 MySQL 8.4 中配置和启动基于 GTID 的复制的过程。这是一个“冷启动”过程，它假定您是第一次启动源服务器，或者可以停止它;有关使用来自正在运行的源服务器的 GTID 预置副本的信息，请参见[第 19.1.3.5 节 “使用 GTID 进行故障转移和横向扩展”。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html)有关在联机服务器上更改 GTID 模式的信息，请参见[第 19.1.4 节 “在联机服务器上更改 GTID 模式](https://dev.mysql.com/doc/refman/8.4/en/replication-mode-change-online.html)”。

​      The key steps in this startup process for the simplest possible      GTID replication topology, consisting of one source and one      replica, are as follows: 
对于最简单的 GTID 复制拓扑（由一个源和一个副本组成），此启动过程中的关键步骤如下：

1. ​          If replication is already running, synchronize both servers by          making them read-only.        
   如果复制已在运行，请通过将两个服务器设置为只读来同步这两个服务器。

2. ​          Stop both servers.         停止两台服务器。

3. ​          Restart both servers with GTIDs enabled and the correct          options configured.        
   在启用 GTID 并配置正确选项的情况下重新启动两台服务器。

   ​          The [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html) options necessary to start the          servers as described are discussed in the example that follows          later in this section.        
   如所描述的 [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html) 选项，将在本节后面的示例中讨论。

4. ​          Instruct the replica to use the source as the replication data          source and to use auto-positioning. The SQL statements needed          to accomplish this step are described in the example that          follows later in this section.        
   指示副本使用源作为复制数据源并使用自动定位。本节后面的示例描述了完成此步骤所需的 SQL 语句。

5. ​          Take a new backup. Binary logs containing transactions without          GTIDs cannot be used on servers where GTIDs are enabled, so          backups taken before this point cannot be used with your new          configuration.        
   进行新的备份。包含没有 GTID 的事务的二进制日志不能在启用了 GTID 的服务器上使用，因此在此之前进行的备份不能用于您的新配置。

6. ​          Start the replica, then disable read-only mode on both          servers, so that they can accept updates. 
   启动副本，然后在两台服务器上禁用只读模式，以便它们可以接受更新。

​      In the following example, two servers are already running as      source and replica, using MySQL's binary log position-based      replication protocol. If you are starting with new servers, see      [Section 19.1.2.3, “Creating a User for Replication”](https://dev.mysql.com/doc/refman/8.4/en/replication-howto-repuser.html) for information about      adding a specific user for replication connections and      [Section 19.1.2.1, “Setting the Replication Source Configuration”](https://dev.mysql.com/doc/refman/8.4/en/replication-howto-masterbaseconfig.html) for      information about setting the      [`server_id`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_id) variable. The following      examples show how to store [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html) startup      options in server's option file, see      [Section 6.2.2.2, “Using Option Files”](https://dev.mysql.com/doc/refman/8.4/en/option-files.html) for more information. Alternatively      you can use startup options when running      [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html).    
在以下示例中，两个服务器已经使用 MySQL 的基于二进制日志位置的复制协议作为源和副本运行。如果要从新服务器开始，请参阅 [第 19.1.2.3 节 “创建用于复制的用户”](https://dev.mysql.com/doc/refman/8.4/en/replication-howto-repuser.html) 了解有关为复制连接添加特定用户的信息，以及[第 19.1.2.1 节 “设置复制源配置”](https://dev.mysql.com/doc/refman/8.4/en/replication-howto-masterbaseconfig.html) 以了解有关设置 [`server_id`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_id) 变量的信息。以下示例显示了如何将 [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html) 启动选项存储在服务器的选项文件中，有关更多信息，请参见[第 6.2.2.2 节 “使用选项文件”。](https://dev.mysql.com/doc/refman/8.4/en/option-files.html)或者，您可以在运行 [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html) 时使用启动选项。

​      Most of the steps that follow require the use of the MySQL      `root` account or another MySQL user account that      has the [`SUPER`](https://dev.mysql.com/doc/refman/8.4/en/privileges-provided.html#priv_super) privilege.      [**mysqladmin**](https://dev.mysql.com/doc/refman/8.4/en/mysqladmin.html) `shutdown` requires      either the `SUPER` privilege or the      [`SHUTDOWN`](https://dev.mysql.com/doc/refman/8.4/en/privileges-provided.html#priv_shutdown) privilege.    
以下大多数步骤都需要使用 MySQL `根`账户或具有 [`SUPER`](https://dev.mysql.com/doc/refman/8.4/en/privileges-provided.html#priv_super) 权限的其他 MySQL 用户账户。[**mysqladmin**](https://dev.mysql.com/doc/refman/8.4/en/mysqladmin.html)`shutdown` 需要 `SUPER` 权限或 [`SHUTDOWN`](https://dev.mysql.com/doc/refman/8.4/en/privileges-provided.html#priv_shutdown) 权限。

**Step 1: Synchronize the servers.**         This step is only required when working with servers which are        already replicating without using GTIDs. For new servers proceed        to Step 3. Make the servers read-only by setting the        [`read_only`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_read_only) system variable to        `ON` on each server by issuing the following:      
**步骤 1：同步服务器。** 仅当使用已在不使用 GTID 进行复制的服务器时，才需要执行此步骤。对于新服务器，请继续执行步骤 3。通过发出以下命令，将每台服务器上的 [`read_only`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_read_only) 系统变量设置为 `ON`，使服务器只读：

```sql
mysql> SET @@GLOBAL.read_only = ON;
```

​      Wait for all ongoing transactions to commit or roll back. Then,      allow the replica to catch up with the source. *It is      extremely important that you make sure the replica has processed      all updates before continuing*.           
等待所有正在进行的事务提交或回滚。然后，允许副本赶上源。在*继续之前，确保副本已处理所有更新，这一点非常重要*。

​      If you use binary logs for anything other than replication, for      example to do point in time backup and restore, wait until you do      not need the old binary logs containing transactions without      GTIDs. Ideally, wait for the server to purge all binary logs, and      wait for any existing backup to expire. 
如果您将二进制日志用于复制以外的任何用途，例如进行时间点备份和恢复，请等到您不需要包含没有 GTID 的事务的旧二进制日志。理想情况下，等待服务器清除所有二进制日志，然后等待任何现有备份过期。

Important 重要

​        It is important to understand that logs containing transactions        without GTIDs cannot be used on servers where GTIDs are enabled.        Before proceeding, you must be sure that transactions without        GTIDs do not exist anywhere in the topology. 
请务必了解，包含没有 GTID 的事务的日志不能在启用了 GTID 的服务器上使用。在继续之前，您必须确保没有 GTID 的事务在拓扑中的任何位置都不存在。

**Step 2: Stop both servers.**         Stop each server using [**mysqladmin**](https://dev.mysql.com/doc/refman/8.4/en/mysqladmin.html) as shown        here, where *`username`* is the user name        for a MySQL user having sufficient privileges to shut down the        server:      
**第 2 步：停止两台服务器。** 使用 [**mysqladmin**](https://dev.mysql.com/doc/refman/8.4/en/mysqladmin.html) 停止每个服务器，如下所示，其中 *`username`* 是具有足够权限关闭服务器的 MySQL 用户的用户名：

```terminal
$> mysqladmin -uusername -p shutdown
```

​      Then supply this user's password at the prompt.    
然后在提示符处提供此用户的密码。

**Step 3: Start both servers with GTIDs enabled.**         To enable GTID-based replication, each server must be started        with GTID mode enabled by setting the        [`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) variable to        `ON`, and with the        [`enforce_gtid_consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency)        variable enabled to ensure that only statements which are safe        for GTID-based replication are logged. For example:      
**第 3 步：在启用 GTID 的情况下启动两台服务器。** 要启用基于 GTID 的复制，必须通过将 [`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) 变量设置为 `ON` 来启用 GTID 模式，并启用 [`enforce_gtid_consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) 变量以确保仅记录对基于 GTID 的复制安全的语句。例如：

```ini
gtid_mode=ON
enforce-gtid-consistency=ON
```

​      Start each replica with      [`--skip-replica-start`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#option_mysqld_skip-replica-start). For more      information on GTID related options and variables, see      [Section 19.1.6.5, “Global Transaction ID System Variables”](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html).    
使用 [`--skip-replica-start`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#option_mysqld_skip-replica-start) 启动每个副本。有关 GTID 相关选项和变量的更多信息，请参见[第 19.1.6.5 节 “全局事务 ID 系统变量”。](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html)

​      It is not mandatory to have binary logging enabled in order to use      GTIDs when using the      [mysql.gtid_executed Table](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html#replication-gtids-gtid-executed-table). Source      servers must always have binary logging enabled in order to be      able to replicate. However, replica servers can use GTIDs but      without binary logging. If you need to disable binary logging on a      replica server, you can do this by specifying the      [`--skip-log-bin`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#option_mysqld_log-bin)      and [`--log-replica-updates=OFF`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_log_replica_updates)      options for the replica.    
在使用 [mysql.gtid_executed Table](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-concepts.html#replication-gtids-gtid-executed-table) 时，不强制要求启用二进制日志记录才能使用 GTID。源服务器必须始终启用二进制日志记录才能进行复制。但是，副本服务器可以使用 GTID，但不能使用二进制日志记录。如果需要在副本服务器上禁用二进制日志记录，可以通过为副本指定 [`--skip-log-bin`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#option_mysqld_log-bin) 和 [`--log-replica-updates=OFF`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_log_replica_updates) 选项来实现。

**Step 4: Configure the replica to use GTID-based auto-positioning.**         Tell the replica to use the source with GTID based transactions        as the replication data source, and to use GTID-based        auto-positioning rather than file-based positioning. Issue a        [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) on        the replica, including the        `SOURCE_AUTO_POSITION` option in the statement        to tell the replica that the source's transactions are        identified by GTIDs.      
**第 4 步：将副本配置为使用基于 GTID 的自动定位。** 告诉副本使用具有基于 GTID 的事务的源作为复制数据源，并使用基于 GTID 的自动定位而不是基于文件的定位。在副本上发出[`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)，在语句中包含`SOURCE_AUTO_POSITION`选项，以告诉副本源的事务由 GTID 标识。

​      You may also need to supply appropriate values for the      source's host name and port number as well as the user name      and password for a replication user account which can be used by      the replica to connect to the source; if these have already been      set prior to Step 1 and no further changes need to be made, the      corresponding options can safely be omitted from the statement      shown here.    
您可能还需要为源的主机名和端口号以及复制用户帐户的用户名和密码提供适当的值，副本可以使用该帐户连接到源;如果在步骤 1 之前已经设置了这些选项，并且不需要进行进一步的更改，则可以安全地从此处显示的语句中省略相应的选项。

```sql
mysql> CHANGE REPLICATION SOURCE TO
     >     SOURCE_HOST = host,
     >     SOURCE_PORT = port,
     >     SOURCE_USER = user,
     >     SOURCE_PASSWORD = password,
     >     SOURCE_AUTO_POSITION = 1;
```

**Step 5: Take a new backup.**         Existing backups that were made before you enabled GTIDs can no        longer be used on these servers now that you have enabled GTIDs.        Take a new backup at this point, so that you are not left        without a usable backup.      
**第 5 步：进行新的备份。** 启用 GTID 后，在启用 GTID 之前所做的现有备份将无法再在这些服务器上使用。此时进行新的备份，这样您就不会没有可用的备份。

​      For instance, you can execute [`FLUSH       LOGS`](https://dev.mysql.com/doc/refman/8.4/en/flush.html#flush-logs) on the server where you are taking backups. Then      either explicitly take a backup or wait for the next iteration of      any periodic backup routine you may have set up.    
例如，您可以在要进行备份的服务器上执行 [`FLUSH LOGS`](https://dev.mysql.com/doc/refman/8.4/en/flush.html#flush-logs)。然后显式进行备份或等待您可能已设置的任何定期备份例程的下一次迭代。

**Step 6: Start the replica and disable read-only mode.**         Start the replica like this:      
**步骤 6：启动副本并禁用只读模式。** 按如下方式启动副本：

```sql
mysql> START REPLICA;
```

​      The following step is only necessary if you configured a server to      be read-only in Step 1. To allow the server to begin accepting      updates again, issue the following statement:    
只有在步骤 1 中将服务器配置为只读时，才需要执行以下步骤。要允许服务器再次开始接受更新，请发出以下语句：

```sql
mysql> SET @@GLOBAL.read_only = OFF;
```

​      GTID-based replication should now be running, and you can begin      (or resume) activity on the source as before.      [Section 19.1.3.5, “Using GTIDs for Failover and Scaleout”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html), discusses creation      of new replicas when using GTIDs. 
基于 GTID 的复制现在应该正在运行，您可以像以前一样在源上开始（或恢复）活动。[第 19.1.3.5 节 “使用 GTID 进行故障转移和扩展”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html)讨论了在使用 GTID 时创建新副本。

#### 19.1.3.5 使用 GTID 进行故障转移和横向扩展



​      There are a number of techniques when using MySQL Replication with      Global Transaction Identifiers (GTIDs) for provisioning a new      replica which can then be used for scaleout, being promoted to      source as necessary for failover. This section describes the      following techniques: 
使用带有全局事务标识符 （GTID） 的 MySQL 复制来预置新副本时，有许多技术可以将其用于横向扩展，并根据需要提升为源以进行故障转移。本节介绍以下技术：

- ​          [Simple replication 简单复制](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-failover-replicate)        
- ​          [Copying data and transactions to the replica
  将数据和事务复制到副本](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-failover-copy)        
- ​          [Injecting empty transactions
  注入空事务](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-failover-empty)        
- ​          [Excluding transactions with gtid_purged
  不包括 gtid_purged 的交易](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-failover-gtid-purged)        
- ​          [Restoring GTID mode replicas
  恢复 GTID 模式副本](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-restoring-mysqlbinlog)

​      Global transaction identifiers were added to MySQL Replication for      the purpose of simplifying in general management of the      replication data flow and of failover activities in particular.      Each identifier uniquely identifies a set of binary log events      that together make up a transaction. GTIDs play a key role in      applying changes to the database: the server automatically skips      any transaction having an identifier which the server recognizes      as one that it has processed before. This behavior is critical for      automatic replication positioning and correct failover.    
将全局事务标识符添加到 MySQL Replication  中，以简化复制数据流的一般管理，特别是故障转移活动。每个标识符唯一标识一组共同构成事务的二进制日志事件。GTID  在将更改应用于数据库方面起着关键作用：服务器会自动跳过任何具有标识符的事务，服务器将其识别为之前处理过的标识符。此行为对于自动复制定位和正确故障转移至关重要。

​      The mapping between identifiers and sets of events comprising a      given transaction is captured in the binary log. This poses some      challenges when provisioning a new server with data from another      existing server. To reproduce the identifier set on the new      server, it is necessary to copy the identifiers from the old      server to the new one, and to preserve the relationship between      the identifiers and the actual events. This is necessary for      restoring a replica that is immediately available as a candidate      to become a new source on failover or switchover.    
标识符与构成给定事务的事件集之间的映射在二进制日志中捕获。当使用来自另一台现有服务器的数据预置新服务器时，这会带来一些挑战。要在新服务器上重现设置的标识符，必须将标识符从旧服务器复制到新服务器，并保留标识符与实际事件之间的关系。这对于还原可立即用作故障转移或切换时成为新源的候选副本是必需的。

**Simple replication.**         The easiest way to reproduce all identifiers and transactions on        a new server is to make the new server into the replica of a        source that has the entire execution history, and enable global        transaction identifiers on both servers. See        [Section 19.1.3.4, “Setting Up Replication Using GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html), for more information.      
**简单复制。** 在新服务器上重现所有标识符和事务的最简单方法是将新服务器变成具有整个执行历史记录的源的副本，并在两个服务器上启用全局事务标识符。有关更多信息，请参见[第 19.1.3.4 节 “使用 GTID 设置复制”。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html)

​      Once replication is started, the new server copies the entire      binary log from the source and thus obtains all information about      all GTIDs.    
一旦复制开始，新服务器就会从源复制整个二进制日志，从而获得有关所有 GTID 的所有信息。

​      This method is simple and effective, but requires the replica to      read the binary log from the source; it can sometimes take a      comparatively long time for the new replica to catch up with the      source, so this method is not suitable for fast failover or      restoring from backup. This section explains how to avoid fetching      all of the execution history from the source by copying binary log      files to the new server.    
这种方法简单有效，但需要副本从源读取二进制日志;有时，新副本可能需要相对较长的时间才能赶上源，因此此方法不适用于快速故障转移或从备份中恢复。本节介绍如何通过将二进制日志文件复制到新服务器来避免从源获取所有执行历史记录。

**Copying data and transactions to the replica.**         Executing the entire transaction history can be time-consuming        when the source server has processed a large number of        transactions previously, and this can represent a major        bottleneck when setting up a new replica. To eliminate this        requirement, a snapshot of the data set, the binary logs and the        global transaction information the source server contains can be        imported to the new replica. The server where the snapshot is        taken can be either the source or one of its replicas, but you        must ensure that the server has processed all required        transactions before copying the data.      
**将数据和事务复制到副本。** 当源服务器之前处理了大量事务时，执行整个事务历史记录可能非常耗时，这可能是设置新副本时的主要瓶颈。为了消除此要求，可以将数据集的快照、二进制日志和源服务器包含的全局事务信息导入到新副本中。拍摄快照的服务器可以是源服务器，也可以是其副本之一，但您必须确保在复制数据之前服务器已处理所有必需的事务。

​      There are several variants of this method, the difference being in      the manner in which data dumps and transactions from binary logs      are transferred to the replica, as outlined here: 
此方法有几种变体，区别在于将数据转储和二进制日志中的事务传输到副本的方式，如下所述：

- ​          Data Set 数据集

  ​                Create a dump file using [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) on                the source server. Set the [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html)                option [`--source-data`](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html#option_mysqldump_source-data)                to 1, to include a [`CHANGE                 REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement with binary                logging information. Set the                [`--set-gtid-purged`](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html#option_mysqldump_set-gtid-purged)                option to `AUTO` (the default) or                `ON`, to include information about                executed transactions in the dump. Then use the                [**mysql**](https://dev.mysql.com/doc/refman/8.4/en/mysql.html) client to import the dump file                on the target server.               在源服务器上使用 [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) 创建转储文件。将 [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) 选项 [`--source-data`](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html#option_mysqldump_source-data) 设置为 1，以包含包含二进制日志记录信息的[ `CHANGE                 REPLICATION SOURCE TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)语句。将 [`--set-gtid-purged`](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html#option_mysqldump_set-gtid-purged) 选项设置为 `AUTO`（默认值）或 `ON，`以在转储中包含有关已执行事务的信息。然后使用 [**mysql**](https://dev.mysql.com/doc/refman/8.4/en/mysql.html) 客户端在目标服务器上导入转储文件。                Alternatively, create a data snapshot of the source                server using raw data files, then copy these files to                the target server, following the instructions in                [Section 19.1.2.5, “Choosing a Method for Data Snapshots”](https://dev.mysql.com/doc/refman/8.4/en/replication-snapshot-method.html). If you                use [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) tables, you can                use the **mysqlbackup** command from the                MySQL Enterprise Backup component to produce a consistent snapshot. This                command records the log name and offset corresponding to                the snapshot to be used on the replica. MySQL Enterprise Backup is a                commercial product that is included as part of a MySQL                Enterprise subscription. See                [Section 32.1, “MySQL Enterprise Backup Overview”](https://dev.mysql.com/doc/refman/8.4/en/mysql-enterprise-backup.html) for detailed                information.               或者，使用原始数据文件创建源服务器的数据快照，然后按照[第 19.1.2.5 节 “选择数据快照方法”](https://dev.mysql.com/doc/refman/8.4/en/replication-snapshot-method.html)中的说明将这些文件复制到目标服务器。如果您使用 [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 表，则可以使用 MySQL Enterprise Backup 组件中的 **mysqlbackup** 命令生成一致的快照。该命令记录副本上使用的快照对应的日志名称和偏移量。MySQL Enterprise Backup 是包含在 MySQL Enterprise 订阅中的商业产品。有关详细信息，请参见[第 32.1 节 “ MySQL Enterprise Backup 概述”。](https://dev.mysql.com/doc/refman/8.4/en/mysql-enterprise-backup.html)                Alternatively, stop both the source and target servers,                copy the contents of the source's data directory to the                new replica's data directory, then restart the                replica. If you use this method, the replica must be                configured for GTID-based replication, in other words                with [`gtid_mode=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode). For                instructions and important information for this method,                see                [Section 19.1.2.8, “Adding Replicas to a Replication Environment”](https://dev.mysql.com/doc/refman/8.4/en/replication-howto-additionalslaves.html).  或者，停止源服务器和目标服务器，将源数据目录的内容复制到新副本的数据目录，然后重新启动副本。如果使用此方法，则必须为基于 GTID 的复制配置副本，换句话说，使用 [`gtid_mode=ON。`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)有关此方法的说明和重要信息，请参见[第 19.1.2.8 节 “将副本添加到复制环境”。](https://dev.mysql.com/doc/refman/8.4/en/replication-howto-additionalslaves.html)

- ​          Transaction History         交易记录

  ​            If the source server has a complete transaction history in            its binary logs (that is, the GTID set            `@@GLOBAL.gtid_purged` is empty), you can            use these methods.  如果源服务器的二进制日志中有完整的事务历史记录（即 `@@GLOBAL.gtid_purged` 集的 GTID 为空），则可以使用这些方法。                 Import the binary logs from the source server to the new                replica using [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html), with the                [`--read-from-remote-server`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_read-from-remote-server)                and                [`--read-from-remote-source`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_read-from-remote-source)                options.               使用 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 将二进制日志从源服务器导入到新副本，并使用 [`--read-from-remote-server`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_read-from-remote-server) 和 [`--read-from-remote-source`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_read-from-remote-source) 选项。                Alternatively, copy the source server's binary log files                to the replica. You can make copies from the replica                using [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) with the                [`--read-from-remote-server`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_read-from-remote-server)                and [`--raw`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_raw) options.                These can be read into the replica by using                [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) `>`                `*`file`*`                (without the [`--raw`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_raw)                option) to export the binary log files to SQL files,                then passing these files to the [**mysql**](https://dev.mysql.com/doc/refman/8.4/en/mysql.html)                client for processing. Ensure that all of the binary log                files are processed using a single                [**mysql**](https://dev.mysql.com/doc/refman/8.4/en/mysql.html) process, rather than multiple                connections. For example:               或者，将源服务器的二进制日志文件复制到副本。您可以使用 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 和 [`--read-from-remote-server`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_read-from-remote-server) 和 [`--raw`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_raw) 选项从副本中复制。通过使用 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html)`>``*`文件`*`（不带 [`--raw`](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html#option_mysqlbinlog_raw) 选项）将二进制日志文件导出到 SQL 文件，然后将这些文件传递给 [**mysql**](https://dev.mysql.com/doc/refman/8.4/en/mysql.html) 客户端进行处理，可以将这些文件读入副本。确保使用单个 [**mysql**](https://dev.mysql.com/doc/refman/8.4/en/mysql.html) 进程而不是多个连接处理所有二进制日志文件。例如：`$> mysqlbinlog copied-binlog.000001 copied-binlog.000002 | mysql -u root -p`                For more information, see                [Section 6.6.9.3, “Using mysqlbinlog to Back Up Binary Log Files”](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog-backup.html).  有关更多信息，请参见[第 6.6.9.3 节 “使用 mysqlbinlog 备份二进制日志文件”。](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog-backup.html)

​      This method has the advantage that a new server is available      almost immediately; only those transactions that were committed      while the snapshot or dump file was being replayed still need to      be obtained from the existing source. This means that the      replica's availability is not instantaneous, but only a      relatively short amount of time should be required for the replica      to catch up with these few remaining transactions.    
此方法的优点是新服务器几乎可以立即使用;只有那些在重放快照或转储文件时提交的事务仍需要从现有源获取。这意味着副本的可用性不是即时的，而只需要相对较短的时间，副本就可以赶上这几个剩余的事务。

​      Copying over binary logs to the target server in advance is      usually faster than reading the entire transaction execution      history from the source in real time. However, it may not always      be feasible to move these files to the target when required, due      to size or other considerations. The two remaining methods for      provisioning a new replica discussed in this section use other      means to transfer information about transactions to the new      replica.    
提前将二进制日志复制到目标服务器通常比从源实时读取整个事务执行历史更快。但是，由于大小或其他考虑，在需要时将这些文件移动到目标可能并不总是可行的。本节中讨论的其余两种预置新副本的方法使用其他方法将有关事务的信息传输到新副本。

**Injecting empty transactions.**         The source's global        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) variable contains        the set of all transactions executed on the source. Rather than        copy the binary logs when taking a snapshot to provision a new        server, you can instead note the content of        `gtid_executed` on the server from which the        snapshot was taken. Before adding the new server to the        replication chain, simply commit an empty transaction on the new        server for each transaction identifier contained in the        source's `gtid_executed`, like this:      
**注入空交易。** 源的全局 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 变量包含在源上执行的所有事务的集合。在拍摄快照以预置新服务器时，您可以记录从中拍摄快照的服务器上的`gtid_executed`内容，而不是复制二进制日志。在将新服务器添加到复制链之前，只需在新服务器上为源`gtid_executed`中包含的每个事务标识符提交一个空事务，如下所示：

```sql
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';

BEGIN;
COMMIT;

SET GTID_NEXT='AUTOMATIC';
```

​      Once all transaction identifiers have been reinstated in this way      using empty transactions, you must flush and purge the      replica's binary logs, as shown here, where      *`N`* is the nonzero suffix of the current      binary log file name:    
使用空事务以这种方式恢复所有事务标识符后，您必须刷新并清除副本的二进制日志，如下所示，其中 *`N`* 是当前二进制日志文件名的非零后缀：

```sql
FLUSH LOGS;
PURGE BINARY LOGS TO 'source-bin.00000N';
```

​      You should do this to prevent this server from flooding the      replication stream with false transactions in the event that it is      later promoted to the source. (The [`FLUSH       LOGS`](https://dev.mysql.com/doc/refman/8.4/en/flush.html#flush-logs) statement forces the creation of a new binary log      file; [`PURGE BINARY LOGS`](https://dev.mysql.com/doc/refman/8.4/en/purge-binary-logs.html) purges the      empty transactions, but retains their identifiers.)    
您应该这样做，以防止此服务器在复制流稍后被提升到源时用虚假事务淹没复制流。（[`FLUSH LOGS`](https://dev.mysql.com/doc/refman/8.4/en/flush.html#flush-logs) 语句强制创建新的二进制日志文件;[`PURGE BINARY LOGS`](https://dev.mysql.com/doc/refman/8.4/en/purge-binary-logs.html) 清除空事务，但保留其标识符。

​      This method creates a server that is essentially a snapshot, but      in time is able to become a source as its binary log history      converges with that of the replication stream (that is, as it      catches up with the source or sources). This outcome is similar in      effect to that obtained using the remaining provisioning method,      which we discuss in the next few paragraphs.    
此方法创建的服务器本质上是一个快照，但随着其二进制日志历史记录与复制流的二进制日志历史记录收敛（即，当它与一个或多个源同步时），它能够及时成为源。此结果在效果上类似于使用 remaining provisioning 方法获得的结果，我们将在接下来的几段中讨论。

**Excluding transactions with gtid_purged.**         The source's global        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) variable contains        the set of all transactions that have been purged from the        source's binary log. As with the method discussed        previously (see        [Injecting empty transactions](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-failover-empty)), you can        record the value of        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) on the server        from which the snapshot was taken (in place of copying the        binary logs to the new server). Unlike the previous method,        there is no need to commit empty transactions (or to issue        [`PURGE BINARY LOGS`](https://dev.mysql.com/doc/refman/8.4/en/purge-binary-logs.html)); instead, you        can set [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) on the        replica directly, based on the value of        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) on the server        from which the backup or snapshot was taken.      
**不包括 gtid_purged 的交易。** 源的全局 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) 变量包含已从源的二进制日志中清除的所有事务的集合。与前面讨论的方法一样（请参阅 [注入空事务](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-failover.html#replication-gtids-failover-empty) ），您可以在拍摄快照的服务器上记录 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 的值（而不是将二进制日志复制到新服务器）。与前面的方法不同，不需要提交空事务（或发出 [`PURGE BINARY LOGS）;`](https://dev.mysql.com/doc/refman/8.4/en/purge-binary-logs.html)相反，您可以根据从中生成备份或快照的服务器上的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 值直接在副本上设置 [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)。

​      As with the method using empty transactions, this method creates a      server that is functionally a snapshot, but in time is able to      become a source as its binary log history converges with that of      the source and other replicas.    
与使用空事务的方法一样，此方法会创建一个服务器，该服务器在功能上是快照，但随着其二进制日志历史记录与源和其他副本的二进制日志历史记录收敛，它能够及时成为源。

**Restoring GTID mode replicas.**         When restoring a replica in a GTID based replication setup that        has encountered an error, injecting an empty transaction may not        solve the problem because an event does not have a GTID.      
**还原 GTID 模式副本。** 在遇到错误的基于 GTID 的复制设置中恢复副本时，注入空事务可能无法解决问题，因为事件没有 GTID。

​      Use [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) to find the next transaction,      which is probably the first transaction in the next log file after      the event. Copy everything up to the `COMMIT` for      that transaction, being sure to include the `SET      @@SESSION.gtid_next`. Even if you are not using row-based      replication, you can still run binary log row events in the      command line client.    
使用 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 查找下一个事务，这可能是事件之后下一个日志文件中的第一个事务。将所有内容复制到该事务的 `COMMIT` 中，确保包含 `SET @@SESSION.gtid_next`。即使您不使用基于行的复制，您仍然可以在命令行客户端中运行二进制日志行事件。

​      Stop the replica and run the transaction you copied. The      [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) output sets the delimiter to      `/*!*/;`, so set it back to the default, like      this:    
停止副本并运行您复制的事务。[**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 输出将分隔符设置为 `/*！*/;`，因此请将其设置回默认值，如下所示：

```sql
mysql> DELIMITER ;
```

​      Restart replication from the correct position automatically:    
自动从正确的位置重新启动复制：

```sql
mysql> SET gtid_next=AUTOMATIC;
mysql> RESET REPLICA;
mysql> START REPLICA;
```

#### 19.1.3.6 Replication From a Source Without GTIDs to a Replica With GTIDs 19.1.3.6 从没有 GTID 的源复制到有 GTID 的副本



​      You can set up replication channels to assign a GTID to replicated      transactions that do not already have one. This feature enables      replication from a source server that does not have GTIDs enabled      and does not use GTID-based replication, to a replica that has      GTIDs enabled. If it is possible to enable GTIDs on the      replication source server, as described in      [Section 19.1.4, “Changing GTID Mode on Online Servers”](https://dev.mysql.com/doc/refman/8.4/en/replication-mode-change-online.html), use that      approach instead. This feature is designed for replication source      servers where you cannot enable GTIDs. Note that as is standard      for MySQL replication, this feature does not support replication      from MySQL source servers earlier than the previous release      series, so MySQL 8.3 is the earliest supported      source for a MySQL 8.4 replica.    
您可以设置复制通道，将 GTID 分配给还没有 GTID 的复制事务。此功能支持从未启用 GTID 且不使用基于 GTID 的复制的源服务器复制到启用了 GTID 的副本。如果可以在复制源服务器上启用 GTID，如[第 19.1.4 节 “更改联机服务器上的 GTID 模式”](https://dev.mysql.com/doc/refman/8.4/en/replication-mode-change-online.html)中所述，请改用该方法。此功能专为无法启用 GTID 的复制源服务器而设计。请注意，作为 MySQL 复制的标准，此功能不支持从早于上一个版本系列的 MySQL 源服务器进行复制，因此 MySQL 8.3 是 MySQL 8.4 副本最早支持的源。

​      You can enable GTID assignment on a replication channel using the      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` option      of the [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)      statement. `LOCAL` assigns a GTID including the      replica's own UUID (the      [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) setting).      `*`uuid`*` assigns a GTID      including the specified UUID, such as the      [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) setting for the      replication source server. Using a nonlocal UUID lets you      differentiate between transactions that originated on the replica      and transactions that originated on the source, and for a      multi-source replica, between transactions that originated on      different sources. If any of the transactions sent by the source      do have a GTID already, that GTID is retained. 
您可以使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) 语句的选项在复制通道上启用 GTID 分配。`LOCAL` 分配一个 GTID，包括副本自己的 UUID（[`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) 设置）。`*`uuid`*` 分配一个包含指定 UUID 的 GTID，例如复制源服务器的 [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) 设置。使用非本地 UUID 可以区分源自副本的事务和源自源的事务，对于多源副本，可以区分源自不同源的事务。如果源发送的任何交易确实已经具有 GTID，则会保留该 GTID。

Important 重要

​        A replica set up with        `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` on any        channel cannot be promoted to replace the replication source        server in the event that failover is required, and a backup        taken from the replica cannot be used to restore the replication        source server. The same restriction applies to replacing or        restoring other replicas that use        `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` on any        channel. 
在需要故障转移的情况下，无法提升在任何通道上设置的副本 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 以替换复制源服务器，并且从副本中获取的备份不能用于恢复复制源服务器。相同的限制适用于替换或恢复在任何通道上使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 的其他副本。

​      The replica must have      [`gtid_mode=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) set, and this cannot      be changed afterwards, unless you set      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS=OFF`. If      the replica server is started without GTIDs enabled and with      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` set for      any replication channels, the settings are not changed, but a      warning message is written to the error log explaining how to      change the situation.    
副本必须设置 [`gtid_mode=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)，并且之后无法更改，除非您将 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS=OFF` .如果在未启用 GTID 的情况下启动副本服务器，并且为任何复制通道设置了 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` GTID，则不会更改设置，但会将警告消息写入错误日志，说明如何更改这种情况。

​      For a multi-source replica, you can have a mix of channels that      use `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`, and      channels that do not. Channels specific to Group Replication      cannot use      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`, but an      asynchronous replication channel for another source on a server      instance that is a Group Replication group member can do so. For a      channel on a Group Replication group member, do not specify the      Group Replication group name as the UUID for creating the GTIDs.    
对于多源副本，您可以混合使用使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 的通道和不使用的通道。特定于 Group Replication 的通道不能使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` ，但作为 Group Replication 组成员的服务器实例上另一个源的异步复制通道可以这样做。对于 Group Replication  组成员上的通道，请勿将 Group Replication group name 指定为用于创建 GTID 的 UUID。

​      Using `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` on      a replication channel is not the same as introducing GTID-based      replication for the channel. The GTID set      ([`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)) from a replica      set up with      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` should      not be transferred to another server or compared with another      server's [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) set. The      GTIDs that are assigned to the anonymous transactions, and the      UUID you choose for them, only have significance for that      replica's own use. The exception to this is any downstream      replicas of the replica where you enabled      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`, and any      servers that were created from a backup of that replica.    
 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 在复制通道上使用与为通道引入基于 GTID 的复制不同。不应将副本 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 设置中的 GTID 集 （[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)） 传输到另一台服务器或与其他服务器的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 集进行比较。分配给匿名事务的 GTID 以及您为它们选择的 UUID 仅对该副本自身的使用具有重要意义。例外情况是您启用了 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 的副本的任何下游副本，以及从该副本的备份创建的任何服务器。

​      If you set up any downstream replicas, these servers do not have      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` enabled.      Only the replica that is receiving transactions directly from the      non-GTID source server needs to have      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` set on      the relevant replication channel. Among that replica and its      downstream replicas, you can compare GTID sets, fail over from one      replica to another, and use backups to create additional replicas,      as you would in any GTID-based replication topology.      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` is used      where transactions are received from a non-GTID server outside      this group.    
如果您设置了任何下游副本，则这些服务器尚未 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 启用。只有直接从非 GTID 源服务器接收事务的副本才需要在相关复制通道上进行 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 设置。在该副本及其下游副本中，您可以比较 GTID 集，从一个副本故障转移到另一个副本，并使用备份创建其他副本，就像在任何基于 GTID 的复制拓扑中一样。 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 用于从该组外的非 GTID 服务器接收事务的情况。

​      A replication channel using      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` has the      following behavior differences to GTID-based replication: 
复制通道使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 与基于 GTID 的复制具有以下行为差异：

- ​          GTIDs are assigned to the replicated transactions when they          are applied (unless they already had a GTID). A GTID would          normally be assigned on the replication source server when the          transaction is committed, and sent to the replica along with          the transaction. On a multi-threaded replica, this means the          order of the GTIDs does not necessarily match the order of the          transactions, even if          [`replica_preserve_commit_order`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_preserve_commit_order)          = 1.        
  GTID 在应用时分配给复制的事务（除非它们已经具有 GTID）。提交事务时，通常会在复制源服务器上分配 GTID，并与事务一起发送到副本。在多线程副本上，这意味着 GTID 的顺序不一定与事务的顺序匹配，即使 [`replica_preserve_commit_order`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_preserve_commit_order) = 1。
- ​          The `SOURCE_LOG_FILE` and          `SOURCE_LOG_POS` options of the          [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)          statement are used to position the replication I/O (receiver)          thread, rather than the          `SOURCE_AUTO_POSITION` option.        
  [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) 语句的 `SOURCE_LOG_FILE` 和 `SOURCE_LOG_POS` 选项用于定位复制 I/O（接收方）线程，而不是 `SOURCE_AUTO_POSITION` 选项。
- ​          The `SET GLOBAL sql_replica_skip_counter`          statement is used to skip transactions on a replication          channel set up with          `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`,          rather than the method of committing empty transactions. For          instructions, see          [Section 19.1.7.3, “Skipping Transactions”](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html).        
  该 `SET GLOBAL sql_replica_skip_counter` 语句用于跳过使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 设置的复制通道上的事务，而不是提交空事务的方法。有关说明，请参见[第 19.1.7.3 节 “跳过事务”。](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html)
- ​          The `UNTIL SQL_BEFORE_GTIDS` and          `UNTIL_SQL_AFTER_GTIDS` options of the          [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statement cannot          be used for the channel.        
  [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句的 `UNTIL SQL_BEFORE_GTIDS` 和 `UNTIL_SQL_AFTER_GTIDS` 选项不能用于通道。
- ​          The function          [`WAIT_FOR_EXECUTED_GTID_SET()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_wait-for-executed-gtid-set)          works across the server and can be used to wait for any          downstream replicas of the server that have          `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`          enabled. To wait for the channel with          `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`          enabled to catch up with the source, which does not use GTIDs,          use the [`SOURCE_POS_WAIT()`](https://dev.mysql.com/doc/refman/8.4/en/replication-functions-synchronization.html#function_source-pos-wait)          function. 
  函数 [`WAIT_FOR_EXECUTED_GTID_SET（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_wait-for-executed-gtid-set) 在整个服务器中工作，可用于等待已启用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 的服务器的任何下游副本。要等待启用了 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 的通道赶上不使用 GTID 的源，请使用 [`SOURCE_POS_WAIT（）`](https://dev.mysql.com/doc/refman/8.4/en/replication-functions-synchronization.html#function_source-pos-wait) 函数。

​      The Performance Schema      [`replication_applier_configuration`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-configuration-table.html)      table shows whether GTIDs are assigned to anonymous transactions      on a replication channel, what the UUID is, and whether it is the      UUID of the replica server (`LOCAL`) or a      user-specified UUID (`UUID`). The information is      also recorded in the applier metadata repository. A      [`RESET REPLICA       ALL`](https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html) statement resets the      `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` setting,      but a [`RESET REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html) statement does      not. 
Performance Schema [ `replication_applier_configuration` ](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-configuration-table.html) 表显示是否将 GTID 分配给复制通道上的匿名事务，UUID 是什么，以及它是副本服务器的 UUID （`LOCAL`） 还是用户指定的 `UUID （UUID`）。该信息也记录在 applier 元数据存储库中。[`RESET REPLICA ALL`](https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html) 语句会重置 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 设置，但 [`RESET REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/reset-replica.html) 语句不会。

#### 19.1.3.7 使用 GTID 进行复制的限制



​      Because GTID-based replication is dependent on transactions, some      features otherwise available in MySQL are not supported when using      it. This section provides information about restrictions on and      limitations of replication with GTIDs.    
由于基于 GTID 的复制依赖于事务，因此在使用 MySQL 时不支持 MySQL 中其他可用的某些功能。本节提供有关使用 GTID 进行复制的限制和限制的信息。

**Updates involving nontransactional storage engines.**         When using GTIDs, updates to tables using nontransactional        storage engines such as [`MyISAM`](https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html)        cannot be made in the same statement or transaction as updates        to tables using transactional storage engines such as        [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html).      
**涉及非事务性存储引擎的更新。** 使用 GTID 时，使用非事务存储引擎（如 [`MyISAM`](https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html)）对 table 的更新不能与对使用事务存储引擎（如 [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html)）的 table 的更新在同一语句或事务中进行。

​      This restriction is due to the fact that updates to tables that      use a nontransactional storage engine mixed with updates to tables      that use a transactional storage engine within the same      transaction can result in multiple GTIDs being assigned to the      same transaction.    
此限制是由于以下事实：对使用非事务性存储引擎的 table 的更新与对在同一事务中使用事务性存储引擎的 table 的更新混合在一起，可能会导致将多个 GTID 分配给同一事务。

​      Such problems can also occur when the source and the replica use      different storage engines for their respective versions of the      same table, where one storage engine is transactional and the      other is not. Also be aware that triggers that are defined to      operate on nontransactional tables can be the cause of these      problems.    
当源和副本对同一 table 的各自版本使用不同的存储引擎时，也会出现此类问题，其中一个存储引擎是事务性的，而另一个不是。另请注意，定义为对非事务性 table 进行操作的触发器可能是导致这些问题的原因。

​      In any of the cases just mentioned, the one-to-one correspondence      between transactions and GTIDs is broken, with the result that      GTID-based replication cannot function correctly.    
在刚才提到的任何情况下，事务和 GTID 之间的一一对应关系都会中断，从而导致基于 GTID 的复制无法正常工作。

**CREATE TABLE ... SELECT statements.**         For storage engines which support atomic DDL,        [`CREATE         TABLE ... SELECT`](https://dev.mysql.com/doc/refman/8.4/en/create-table-select.html) is recorded in the binary log as one        transaction. For more information, see        [Section 15.1.1, “Atomic Data Definition Statement Support”](https://dev.mysql.com/doc/refman/8.4/en/atomic-ddl.html).      
**创建表 ...SELECT 语句。** 对于支持原子 DDL 的存储引擎，[ `CREATE         TABLE ... SELECT` ](https://dev.mysql.com/doc/refman/8.4/en/create-table-select.html)在二进制日志中记录为一个事务。有关更多信息，请参见[第 15.1.1 节 “原子数据定义语句支持”。](https://dev.mysql.com/doc/refman/8.4/en/atomic-ddl.html)

**Temporary tables.**         If [`binlog_format`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format) is set to        `STATEMENT`,        [`CREATE TEMPORARY         TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) and        [`DROP TEMPORARY         TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) statements cannot be used inside transactions,        procedures, functions, and triggers when GTIDs are in use on the        server (that is, when the        [`enforce_gtid_consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) system        variable is set to `ON`). They can be used        outside these contexts when GTIDs are in use, provided that        [`autocommit=1`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_autocommit) is set. When        [`binlog_format`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format) is set to        `ROW` or `MIXED`,        [`CREATE TEMPORARY         TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) and        [`DROP TEMPORARY         TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) statements are allowed inside a transaction,        procedure, function, or trigger when GTIDs are in use. The        statements are not written to the binary log and are therefore        not replicated to replicas. The use of row-based replication        means that the replicas remain in sync without the need to        replicate temporary tables. If the removal of these statements        from a transaction results in an empty transaction, the        transaction is not written to the binary log.      
**临时表。** 如果 [`binlog_format`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format) 设置为 `STATEMENT，`[ `CREATE TEMPORARY         TABLE` ](https://dev.mysql.com/doc/refman/8.4/en/create-table.html)并且当 GTID 在服务器上使用 GTID 时（即，[`当 enforce_gtid_consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) 系统变量设置为 `ON`）时，不能在事务、过程、函数和触发器中使用 [`DROP TEMPORARY TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) 语句。当使用 GTID 时，可以在这些上下文之外使用它们，前提是设置了 [`autocommit=1`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_autocommit)。当 [`binlog_format`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_binlog_format) 设置为 `ROW` 或 `MIXED` 时，[ `CREATE TEMPORARY         TABLE` ](https://dev.mysql.com/doc/refman/8.4/en/create-table.html)并且在使用 GTID 时，允许在事务、过程、函数或触发器中使用 [`DROP TEMPORARY TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) 语句。这些语句不会写入二进制日志，因此不会复制到副本。使用基于行的复制意味着副本保持同步，而无需复制临时表。如果从事务中删除这些语句导致空事务，则该事务不会写入二进制日志。

**Preventing execution of unsupported statements.**         To prevent execution of statements that would cause GTID-based        replication to fail, all servers must be started with the        [`--enforce-gtid-consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) option        when enabling GTIDs. This causes statements of any of the types        discussed previously in this section to fail with an error.      
**防止执行不支持的语句。** 为防止执行会导致基于 GTID 的复制失败的语句，在启用 GTID 时，必须使用 [`--enforce-gtid-consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) 选项启动所有服务器。这会导致本节前面讨论的任何类型的语句失败并出现错误。

​      Note that      [`--enforce-gtid-consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) only      takes effect if binary logging takes place for a statement. If      binary logging is disabled on the server, or if statements are not      written to the binary log because they are removed by a filter,      GTID consistency is not checked or enforced for the statements      that are not logged.    
请注意， [`--enforce-gtid-consistency`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_enforce_gtid_consistency) 仅在对语句进行二进制日志记录时生效。如果在服务器上禁用了二进制日志记录，或者如果语句由于过滤器删除而未写入二进制日志，则不会检查或强制执行未记录的语句的 GTID 一致性。

​      For information about other required startup options when enabling      GTIDs, see [Section 19.1.3.4, “Setting Up Replication Using GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html).    
有关启用 GTID 时其他必需的启动选项的信息，请参见[第 19.1.3.4 节 “使用 GTID 设置复制”。](https://dev.mysql.com/doc/refman/8.4/en/replication-gtids-howto.html)

**Skipping transactions.**         [`sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_sql_replica_skip_counter)is not        available when using GTID-based replication. If you need to skip        transactions, use the value of the source's        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) variable instead.        If you have enabled GTID assignment on a replication channel        using the        `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` option        of the [`CHANGE REPLICATION SOURCE         TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement,        [`sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_sql_replica_skip_counter) is        available. For more information, see        [Section 19.1.7.3, “Skipping Transactions”](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html).      
**跳过事务。** 使用基于 GTID 的复制时[`，sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_sql_replica_skip_counter)不可用。如果您需要跳过事务，请改用源的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 变量的值。如果已使用[ `CHANGE REPLICATION SOURCE         TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)语句 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 选项在复制通道上启用了 GTID 分配，[`则sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_sql_replica_skip_counter)可用。有关更多信息，请参见[第 19.1.7.3 节 “跳过事务”。](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html)

**Ignoring servers.**         [`IGNORE_SERVER_IDS`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html#crs-opt-ignore_server_ids) cannot be        used with [`CHANGE REPLICATION SOURCE         TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) when using GTIDs, because transactions that have        already been applied are automatically ignored. Before starting        GTID-based replication, check for and clear all ignored server        ID lists that have previously been set on the servers involved.        The [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html)        statement, which can be issued for individual channels, displays        the list of ignored server IDs if there is one. If there is no        list, the `Replicate_Ignore_Server_Ids` field        is blank. If the list of ignored server IDs is not empty, you        can clear it with `CHANGE REPLICATION SOURCE TO ...        IGNORE_SERVER_IDS=()` (in other words, with an empty        list of server IDs to be ignored). 
**忽略服务器。** 使用 GTID 时，[`IGNORE_SERVER_IDS`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html#crs-opt-ignore_server_ids)不能与 [ `CHANGE REPLICATION SOURCE         TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) 一起使用，因为已应用的事务将被自动忽略。在开始基于 GTID 的复制之前，请检查并清除之前在相关服务器上设置的所有被忽略的服务器 ID 列表。[`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html) 语句（可针对单个通道发出）显示被忽略的服务器 ID 的列表（如果有）。如果没有列表，`则 Replicate_Ignore_Server_Ids` 字段为空。如果忽略的服务器 ID 列表不为空，则可以使用 （换句话说，要忽略的服务器 ID 列表为空） 将其清除 `CHANGE REPLICATION SOURCE TO ...        IGNORE_SERVER_IDS=()` 。

#### 19.1.3.8 Stored Function Examples to Manipulate GTIDs 19.1.3.8 用于操作 GTID 的存储函数示例

​      This section provides examples of stored functions (see      [Chapter 27, *Stored Objects*](https://dev.mysql.com/doc/refman/8.4/en/stored-objects.html)) which you can create using some      of the built-in functions provided by MySQL for use with      GTID-based replication, listed here: 
本节提供了存储函数的示例（请参见[第 27 章 ，*存储对象*](https://dev.mysql.com/doc/refman/8.4/en/stored-objects.html)），您可以使用 MySQL 提供的一些内置函数创建这些函数，以便与基于 GTID 的复制一起使用，如下所示：

- ​          [`GTID_SUBSET()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset): Shows whether          one GTID set is a subset of another.        
  [`GTID_SUBSET（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset)）：显示一个 GTID 集是否是另一个 GTID 集的子集。
- ​          [`GTID_SUBTRACT()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subtract): Returns the          GTIDs from one GTID set that are not in another.        
  [`GTID_SUBTRACT（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subtract)：返回一个 GTID 集中不属于另一个 GTID 集中的 GTID。
- ​          `WAIT_FOR_EXECUTED_GTID_SET()`: Waits until          all transactions in a given GTID set have been executed. 
  `WAIT_FOR_EXECUTED_GTID_SET（）`：等待给定 GTID 集中的所有事务都已执行完毕。

​      See [Section 14.18.2, “Functions Used with Global Transaction Identifiers (GTIDs)”](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html), more more information about      the functions just listed.    
参见[第 14.18.2 节 “与全局事务标识符 （GTID） 一起使用的函数”](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html)，有关刚刚列出的函数的更多信息。

​      Note that in these stored functions, the delimiter command has      been used to change the MySQL statement delimiter to a vertical      bar, like this:    
请注意，在这些存储的函数中，delimiter 命令用于将 MySQL 语句分隔符更改为竖线，如下所示：

```sql
mysql> delimiter |
```

​      All of the stored functions shown in this section take string      representations of GTID sets as arguments, so GTID sets must      always be quoted when used with them.    
本节中显示的所有存储函数都将 GTID 集的字符串表示形式作为参数，因此在与 GTID 集一起使用时，必须始终引用它们。

​      This function returns nonzero (true) if two GTID sets are the same      set, even if they are not formatted in the same way:    
如果两个 GTID 集是同一集，则此函数返回非零 （true），即使它们的格式不同：

```sql
CREATE FUNCTION GTID_IS_EQUAL(gs1 LONGTEXT, gs2 LONGTEXT)
  RETURNS INT
  RETURN GTID_SUBSET(gs1, gs2) AND GTID_SUBSET(gs2, gs1)
|
```

​      This function returns nonzero (true) if two GTID sets are      disjoint:    
如果两个 GTID 集不相交，则此函数返回非零 （true）：

```sql
CREATE FUNCTION GTID_IS_DISJOINT(gs1 LONGTEXT, gs2 LONGTEXT)
RETURNS INT
  RETURN GTID_SUBSET(gs1, GTID_SUBTRACT(gs1, gs2))
|
```

​      This function returns nonzero (true) if two GTID sets are disjoint      and `sum` is their union:    
如果两个 GTID 集不相交，并且 `sum` 是它们的并集，则此函数返回非零 （true）：

```sql
CREATE FUNCTION GTID_IS_DISJOINT_UNION(gs1 LONGTEXT, gs2 LONGTEXT, sum LONGTEXT)
RETURNS INT
  RETURN GTID_IS_EQUAL(GTID_SUBTRACT(sum, gs1), gs2) AND
         GTID_IS_EQUAL(GTID_SUBTRACT(sum, gs2), gs1)
|
```

​      This function returns a normalized form of the GTID set, in all      uppercase, with no whitespace and no duplicates, with UUIDs in      alphabetic order and intervals in numeric order: 
此函数返回 GTID 集的规范化形式，全部大写，没有空格和重复项，UUID 按字母顺序排列，间隔按数字顺序排列：

```sql
CREATE FUNCTION GTID_NORMALIZE(gs LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gs, '')
|
```

​    

​      This function returns the union of two GTID sets:    
此函数返回两个 GTID 集的并集：

```sql
CREATE FUNCTION GTID_UNION(gs1 LONGTEXT, gs2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_NORMALIZE(CONCAT(gs1, ',', gs2))
|
```

​      This function returns the intersection of two GTID sets.    
此函数返回两个 GTID 集的交集。

```sql
CREATE FUNCTION GTID_INTERSECTION(gs1 LONGTEXT, gs2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gs1, GTID_SUBTRACT(gs1, gs2))
|
```

​      This function returns the symmetric difference between two GTID      sets, that is, the GTIDs that exist in `gs1` but      not in `gs2`, as well as the GTIDs that exist in      `gs2` but not in `gs1`.    
该函数返回两个 GTID 集之间的对称差值，即 `gs1` 中存在但不在 `gs2` 中的 GTID，以及 `gs2` 中存在但不在 `gs1` 中的 GTID。

```sql
CREATE FUNCTION GTID_SYMMETRIC_DIFFERENCE(gs1 LONGTEXT, gs2 LONGTEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(CONCAT(gs1, ',', gs2), GTID_INTERSECTION(gs1, gs2))
|
```

​      This function removes from a GTID set all the GTIDs with the      specified origin, and returns the remaining GTIDs, if any. The      UUID is the identifier used by the server where the transaction      originated, which is normally the value of      [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid).    
此函数从 GTID 集中删除具有指定来源的所有 GTID，并返回剩余的 GTID（如果有）。UUID 是发起事务的服务器使用的标识符，通常是 [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) 的值。

```sql
CREATE FUNCTION GTID_SUBTRACT_UUID(gs LONGTEXT, uuid TEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gs, CONCAT(UUID, ':1-', (1 << 63) - 2))
|
```

​      This function acts as the reverse of the previous one; it returns      only those GTIDs from the GTID set that originate from the server      with the specified identifier (UUID).    
此函数与前一个函数相反;它仅返回 GTID 集中源自具有指定标识符 （UUID） 的服务器的 GTID。

```sql
CREATE FUNCTION GTID_INTERSECTION_WITH_UUID(gs LONGTEXT, uuid TEXT)
RETURNS LONGTEXT
  RETURN GTID_SUBTRACT(gs, GTID_SUBTRACT_UUID(gs, uuid))
|
```



**Example 19.1 Verifying that a replica is up to date
例 19.1 验证副本是否为最新版本**

​        The built-in functions        [`GTID_SUBSET()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset) and        [`GTID_SUBTRACT()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subtract) can be used to        check that a replica has applied at least every transaction that        a source has applied.      
内置函数 [`GTID_SUBSET（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset) 和 [`GTID_SUBTRACT（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subtract) 可用于检查副本是否至少应用了源已应用的每个事务。

​        To perform this check with `GTID_SUBSET()`,        execute the following statement on the replica:      
要使用 `GTID_SUBSET（）` 执行此检查，请在副本上执行以下语句：

```sql
SELECT GTID_SUBSET(source_gtid_executed, replica_gtid_executed);
```

​        If the returns value is `0` (false), this means        that some GTIDs in        *`source_gtid_executed`* are not present        in *`replica_gtid_executed`*, and that        the replica has not yet applied transactions that were applied        on the source, which means that the replica is not up to date.      
如果返回值为 `0` （false），则表示 *`source_gtid_executed`* 中的某些 GTID 在 *`replica_gtid_executed`* 中不存在，并且副本尚未应用在源上应用的事务，这意味着副本不是最新的。

​        To perform the same check with        `GTID_SUBTRACT()`, execute the following        statement on the replica:      
要使用 `GTID_SUBTRACT（）` 执行相同的检查，请在副本上执行以下语句：

```sql
SELECT GTID_SUBTRACT(source_gtid_executed, replica_gtid_executed);
```

​        This statement returns any GTIDs that are in        *`source_gtid_executed`* but not in        *`replica_gtid_executed`*. If any GTIDs        are returned, the source has applied some transactions that the        replica has not applied, and the replica is therefore not up to        date. 
此语句返回 *`source_gtid_executed`* 但不*`replica_gtid_executed`*的任何 GTID。如果返回任何 GTID，则源已应用了一些副本尚未应用的事务，因此副本不是最新的。



**Example 19.2 Backup and restore scenario
例 19.2 备份和还原方案**

​        The stored functions `GTID_IS_EQUAL()`,        `GTID_IS_DISJOINT()`, and        `GTID_IS_DISJOINT_UNION()` can be used to        verify backup and restore operations involving multiple        databases and servers. In this example scenario,        `server1` contains database        `db1`, and `server2` contains        database `db2`. The goal is to copy database        `db2` to `server1`, and the        result on `server1` should be the union of the        two databases. The procedure used is to back up        `server2` using [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html),        then to restore this backup on `server1`.      
存储的函数 `GTID_IS_EQUAL（）、``GTID_IS_DISJOINT（）` 和 `GTID_IS_DISJOINT_UNION（）` 可用于验证涉及多个数据库和服务器的备份和恢复操作。在此示例场景中，`server1` 包含数据库 `db1，server2` 包含``数据库 `db2`。目标是将数据库 `db2` 复制到 `server1，server1` 上的结果应该是两个数据库的``并集。使用的过程是使用 [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) 备份 `server2`，然后在 `server1` 上恢复此备份。

​        Provided that [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) was run with        [`--set-gtid-purged`](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html#option_mysqldump_set-gtid-purged) set to        `ON` or `AUTO` (the default),        the output contains a `SET        @@GLOBAL.gtid_purged` statement which adds the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) set from        `server2` to the        [`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged) set on        `server1`. `gtid_purged`        contains the GTIDs of all the transactions that have been        committed on a given server but which do not exist in any binary        log file on the server. When database `db2` is        copied to `server1`, the GTIDs of the        transactions committed on `server2`, which are        not in the binary log files on `server1`, must        be added to `gtid_purged` for        `server1` to make the set complete.      
如果 [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) 是在 [`--set-gtid-purged`](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html#option_mysqldump_set-gtid-purged) 设置为 `ON` 或 `AUTO`（默认值）的情况下运行的，则输出包含一个 `SET        @@GLOBAL.gtid_purged` 语句，该语句将 `server2` 上的[`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)集添加到 `server1` 上的[`gtid_purged`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_purged)集。`gtid_purged` 包含已在给定服务器上提交但不存在于服务器上的任何二进制日志文件中的所有事务的 GTID。将数据库 `db2` 复制到 `server1` 时，必须在 `server2` 上提交的事务的 GTID（不在 `server1` 上的二进制日志文件中）添加到 `server1` 的 `gtid_purged` 中，以使该集完整。

​        The stored functions can be used to assist with the following        steps in this scenario: 
在此方案中，存储的函数可用于协助执行以下步骤：

- ​            Use `GTID_IS_EQUAL()` to verify that the            backup operation computed the correct GTID set for the            `SET @@GLOBAL.gtid_purged` statement. On            `server2`, extract that statement from the            [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) output, and store the GTID set            into a local variable, such as            `$gtid_purged_set`. Then execute the            following statement:          
  使用 `GTID_IS_EQUAL（）` 验证备份操作是否为 `SET @@GLOBAL.gtid_purged` 语句计算了正确的 GTID 集。在 `server2` 上，从 [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) 输出中提取该语句，并将 GTID 集存储到局部变量中，例如 `$gtid_purged_set`。然后执行以下语句：

  ```sql
  server2> SELECT GTID_IS_EQUAL($gtid_purged_set, @@GLOBAL.gtid_executed);
  ```

  ​            If the result is 1, the two GTID sets are equal, and the set            has been computed correctly.          
  如果结果为 1，则两个 GTID 集相等，并且已正确计算该集。

- ​            Use `GTID_IS_DISJOINT()` to verify that the            GTID set in the [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) output does not            overlap with the `gtid_executed` set on            `server1`. Having identical GTIDs present            on both servers causes errors when copying database            `db2` to `server1`. To            check, on `server1`, extract and store            `gtid_purged` from the output into a local            variable as done previously, then execute the following            statement:          
  使用 `GTID_IS_DISJOINT（）` 验证 [**mysqldump**](https://dev.mysql.com/doc/refman/8.4/en/mysqldump.html) 输出中设置的 GTID 是否与 `server1` 上设置的 `gtid_executed` 重叠。如果两个服务器上存在相同的 GTID，则在将数据库 `db2` 复制到 `server1` 时会导致错误。要检查，请在 `server1` 上，像以前一样从输出中提取`gtid_purged`并将其存储到局部变量中，然后执行以下语句：

  ```sql
  server1> SELECT GTID_IS_DISJOINT($gtid_purged_set, @@GLOBAL.gtid_executed);
  ```

  ​            If the result is 1, there is no overlap between the two GTID            sets, so no duplicate GTIDs are present.          
  如果结果为 1，则两个 GTID 集之间没有重叠，因此不存在重复的 GTID。

- ​            Use `GTID_IS_DISJOINT_UNION()` to verify            that the restore operation resulted in the correct GTID            state on `server1`. Before restoring the            backup, on `server1`, obtain the existing            `gtid_executed` set by executing the            following statement:          
  使用 `GTID_IS_DISJOINT_UNION（）` 验证还原操作是否在 `server1` 上产生了正确的 GTID 状态。在还原备份之前，在 `server1` 上，通过执行以下语句获取现有`gtid_executed`集：

  ```sql
  server1> SELECT @@GLOBAL.gtid_executed;
  ```

  ​            Store the result in a local variable            `$original_gtid_executed`, as well as the            set from `gtid_purged` in another local            variable as described previously. When the backup from            `server2` has been restored onto            `server1`, execute the following statement            to verify the GTID state:          
  如前所述，将结果存储在局部变量 `$original_gtid_executed` 中，并将 `gtid_purged` 的集合存储在另一个局部变量中。将 `server2` 中的备份还原到 `server1` 后，执行以下语句以验证 GTID 状态：

  ```sql
  server1> SELECT 
        ->   GTID_IS_DISJOINT_UNION($original_gtid_executed,
        ->                          $gtid_purged_set,
        ->                          @@GLOBAL.gtid_executed);
  ```

  ​            If the result is `1`, the stored function            has verified that the original            `gtid_executed` set from            `server1`            (`$original_gtid_executed`) and the            `gtid_purged` set that was added from            `server2`            (`$gtid_purged_set`) have no overlap, and            that the updated `gtid_executed` set on            `server1` now consists of the previous            `gtid_executed` set from            `server1` plus the            `gtid_purged` set from            `server2`, which is the desired result.            Ensure that this check is carried out before any further            transactions take place on `server1`,            otherwise the new transactions in            `gtid_executed` cause it to fail. 
  如果结果为 `1`，则存储函数已验证从 `server1` `gtid_executed`集 （`$original_gtid_executed`） 和从 `server2` 添加的`gtid_purged`集 （`$gtid_purged_set`） 没有重叠，并且 `server1` 上更新的`gtid_executed`集现在由 `server1` 中的上一个`gtid_executed`集加上 `server2` 中的`gtid_purged`集组成，这是所需的结果。确保在 `server1` 上发生任何进一步的事务之前执行此检查，否则 `gtid_executed` 中的新事务将导致其失败。



**Example 19.3 Selecting the most up-to-date replica for manual failover
例 19.3 为手动故障转移选择最新的副本**

​        The stored function `GTID_UNION()` can be used        to identify the most up-to-date replica from a set of replicas,        in order to perform a manual failover operation after a source        server has stopped unexpectedly. If some of the replicas are        experiencing replication lag, this stored function can be used        to compute the most up-to-date replica without waiting for all        the replicas to apply their existing relay logs, and therefore        to minimize the failover time. The function can return the union        of [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) on each        replica with the set of transactions received by the replica,        which is recorded in the Performance Schema        [`replication_connection_status`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-connection-status-table.html)        table. You can compare these results to find which        replica's record of transactions is the most up to date,        even if not all of the transactions have been committed yet.      
stored 函数 `GTID_UNION（）` 可用于从一组副本中识别最新副本，以便在源服务器意外停止后执行手动故障转移操作。如果某些副本出现复制滞后，则此存储函数可用于计算最新副本，而无需等待所有副本应用其现有的中继日志，从而最大限度地减少故障转移时间。该函数可以返回每个副本上 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 与副本接收的事务集的并集，该事务集记录在 Performance Schema [`replication_connection_status`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-connection-status-table.html)表中。您可以比较这些结果以查找哪个副本的事务记录是最新的，即使尚未提交所有事务。

​        On each replica, compute the complete record of transactions by        issuing the following statement:      
在每个副本上，通过发出以下语句来计算事务的完整记录：

```sql
SELECT GTID_UNION(RECEIVED_TRANSACTION_SET, @@GLOBAL.gtid_executed)
    FROM performance_schema.replication_connection_status
    WHERE channel_name = 'name';
```

​        You can then compare the results from each replica to see which        one has the most up-to-date record of transactions, and use this        replica as the new source. 
然后，您可以比较每个副本的结果，以查看哪个副本具有最新的事务记录，并将此副本用作新源。



**Example 19.4 Checking for extraneous transactions on a replica
例 19.4 检查副本上的无关事务**

​        The stored function `GTID_SUBTRACT_UUID()` can        be used to check whether a replica has received transactions        that did not originate from its designated source or sources. If        it has, there might be an issue with your replication setup, or        with a proxy, router, or load balancer. This function works by        removing from a GTID set all the GTIDs from a specified        originating server, and returning the remaining GTIDs, if any.      
stored 函数 `GTID_SUBTRACT_UUID（）` 可用于检查复本是否收到了并非源自其指定源或源的事务。如果存在，则您的复制设置或代理、路由器或负载均衡器可能存在问题。此函数的工作原理是从 GTID 集中删除来自指定原始服务器的所有 GTID，并返回剩余的 GTID（如果有）。

​        For a replica with a single source, issue the following        statement, giving the identifier of the originating source,        which is normally the same as        [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid):      
对于具有单个源的副本，请发出以下语句，并提供原始源的标识符，该标识符通常与 [`server_uuid`](https://dev.mysql.com/doc/refman/8.4/en/replication-options.html#sysvar_server_uuid) 相同：

```sql
SELECT GTID_SUBTRACT_UUID(@@GLOBAL.gtid_executed, server_uuid_of_source);
```

​        If the result is not empty, the transactions returned are extra        transactions that did not originate from the designated source.      
如果结果不为空，则返回的事务是不是来自指定源的额外事务。

​        For a replica in a multisource topology, include the server UUID        of each source in the function call, like this:      
对于多源拓扑中的副本，请在函数调用中包含每个源的服务器 UUID，如下所示：

```sql
SELECT 
  GTID_SUBTRACT_UUID(GTID_SUBTRACT_UUID(@@GLOBAL.gtid_executed,
                                        server_uuid_of_source_1),
                                        server_uuid_of_source_2);
```

​        If the result is not empty, the transactions returned are extra        transactions that did not originate from any of the designated        sources. 
如果结果不为空，则返回的事务是不是来自任何指定源的额外事务。



**Example 19.5 Verifying that a server in a replication topology is read-only
例 19.5 验证复制拓扑中的服务器是否为只读服务器**

​        The stored function        `GTID_INTERSECTION_WITH_UUID()` can be used to        verify that a server has not originated any GTIDs and is in a        read-only state. The function returns only those GTIDs from the        GTID set that originate from the server with the specified        identifier. If any of the transactions listed in        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) from this server        use the server's own identifier, the server itself        originated those transactions. You can issue the following        statement on the server to check:      
存储函数 `GTID_INTERSECTION_WITH_UUID（）` 可用于验证服务器是否未生成任何 GTID 并且处于只读状态。该函数仅返回 GTID 集中源自具有指定标识符的服务器的 GTID。如果来自此服务器的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)中列出的任何事务使用服务器自己的标识符，则服务器本身发起了这些事务。您可以在服务器上发出以下语句进行检查：

```sql
SELECT GTID_INTERSECTION_WITH_UUID(@@GLOBAL.gtid_executed, my_server_uuid);
```



**Example 19.6 Validating an additional replica in multisource replication
例 19.6 验证多源复制中的其他副本**

​        The stored function        `GTID_INTERSECTION_WITH_UUID()` can be used to        find out if a replica attached to a multisource replication        setup has applied all the transactions originating from one        particular source. In this scenario, `source1`        and `source2` are both sources and replicas and        replicate to each other. `source2` also has its        own replica. The replica also receives and applies transactions        from `source1` if `source2` is        configured with        [`log_replica_updates=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_log_replica_updates), but it        does not do so if `source2` uses        `log_replica_updates=OFF`. Whichever the case,        we currently want only to find out if the replica is up to date        with `source2`. In this situation,        `GTID_INTERSECTION_WITH_UUID()` can be used to        identify the transactions that `source2`        originated, discarding the transactions that        `source2` has replicated from        `source1`. The built-in function        [`GTID_SUBSET()`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset) can then be used to        compare the result with the        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) set on the        replica. If the replica is up to date with        `source2`, the `gtid_executed`        set on the replica contains all the transactions in the        intersection set (the transactions that originated from        `source2`).      
存储函数 `GTID_INTERSECTION_WITH_UUID（）` 可用于确定附加到多源复制设置的副本是否已应用源自一个特定源的所有事务。在这种情况下，`source1` 和 `source2` 既是源又是副本，并且相互复制。`Source2` 也有自己的副本。如果 `source2` 配置了 [`log_replica_updates=ON，`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-binary-log.html#sysvar_log_replica_updates)则副本还会从 `source1` 接收和应用事务，但如果 `source2` 使用 `log_replica_updates=OFF，`则副本不会这样做。无论哪种情况，我们目前只想了解副本是否与 `source2` 保持同步。在这种情况下，`GTID_INTERSECTION_WITH_UUID（）` 可用于标识 `source2` 发起的事务，丢弃 `source2` 从 `source1` 复制的事务。然后，可以使用内置函数 [`GTID_SUBSET（）`](https://dev.mysql.com/doc/refman/8.4/en/gtid-functions.html#function_gtid-subset) 将结果与副本上设置[`的gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)进行比较。如果副本与 `source2` 保持同步，则副本上的`gtid_executed`集包含交集集中的所有事务（源自 `source2` 的事务）。

​        To carry out this check, store the values of        `gtid_executed` and the server UUID from        `source2` and the value of        [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) from the replica        into user variables as follows:      
要执行此检查，请将 `source2` 中的 `gtid_executed` 和服务器 UUID 的值以及副本中的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) 的值存储到用户变量中，如下所示：

```sql
source2> SELECT @@GLOBAL.gtid_executed INTO @source2_gtid_executed;

source2> SELECT @@GLOBAL.server_uuid INTO @source2_server_uuid;

replica> SELECT @@GLOBAL.gtid_executed INTO @replica_gtid_executed;
```

​        Then use `GTID_INTERSECTION_WITH_UUID()` and        `GTID_SUBSET()` with these variables as input,        as follows:      
然后使用 `GTID_INTERSECTION_WITH_UUID（）` 和 `GTID_SUBSET（）` 将这些变量作为输入，如下所示：

```sql
SELECT 
  GTID_SUBSET(
    GTID_INTERSECTION_WITH_UUID(@source2_gtid_executed,
                                @source2_server_uuid),
                                @replica_gtid_executed);
```

​        The server identifier from `source2`        (`@source2_server_uuid`) is used with        `GTID_INTERSECTION_WITH_UUID()` to identify and        return only those GTIDs from the set of GTIDs that originated on        `source2`, omitting those that originated on        `source1`. The resulting GTID set is then        compared with the set of all executed GTIDs on the replica,        using `GTID_SUBSET()`. If this statement        returns nonzero (true), all the identified GTIDs from        `source2` (the first set input) are also found        in [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed) from the        replica, meaning that the replica has received and executed all        the transactions that originated from        `source2`. 
来自 `source2` （`@source2_server_uuid`） 的服务器标识符与 `GTID_INTERSECTION_WITH_UUID（）` 一起使用，以标识和仅返回源自 `source2` 的 GTID 集中的那些 GTID，而忽略源自 `source1` 的那些 GTID。然后使用 `GTID_SUBSET（）` 将生成的 GTID 集与副本上所有已执行的 GTID 集进行比较。如果此语句返回非零 （true），则来自 `source2`（第一组输入）的所有已识别 GTID 也会在副本的 [`gtid_executed`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_executed)中找到，这意味着副本已接收并执行源自 `source2` 的所有事务。