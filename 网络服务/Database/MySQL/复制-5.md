### 9.1.7 Common Replication Administration Tasks 19.1.7 常见复制管理任务

- [19.1.7.1 Checking Replication Status 19.1.7.1 检查复制状态](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-status.html)
- [19.1.7.2 Pausing Replication on the Replica 19.1.7.2 在副本上暂停复制](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-pausing.html)
- [19.1.7.3 Skipping Transactions 19.1.7.3 跳过事务](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html)

​      Once replication has been started it executes without requiring      much regular administration. This section describes how to check      the status of replication, how to pause a replica, and how to skip      a failed transaction on a replica. 
复制启动后，无需太多定期管理即可执行。本节介绍如何检查复制状态、如何暂停副本以及如何跳过副本上失败的事务。

Tip 提示

​        To deploy multiple instances of MySQL, you can use [InnoDB Cluster](https://dev.mysql.com/doc/mysql-shell/8.4/en/mysql-innodb-cluster.html) which enables you to easily administer a group of MySQL server instances in [MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.4/en/). InnoDB Cluster wraps MySQL Group Replication in a programmatic  environment that enables you easily deploy a cluster of MySQL instances  to achieve high availability. In addition, InnoDB Cluster interfaces  seamlessly with [MySQL Router](https://dev.mysql.com/doc/mysql-router/8.4/en/), which enables your applications to connect to the cluster without  writing your own failover process. For similar use cases that do not  require high availability, however, you can use [InnoDB ReplicaSet](https://dev.mysql.com/doc/mysql-shell/8.4/en/mysql-innodb-replicaset.html). Installation instructions for MySQL Shell can be found [here](https://dev.mysql.com/doc/mysql-shell/8.4/en/mysql-shell-install.html). 
要部署多个 MySQL 实例，您可以使用 [InnoDB Cluster](https://dev.mysql.com/doc/mysql-shell/8.4/en/mysql-innodb-cluster.html)，它使您能够在 [MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.4/en/) 中轻松管理一组 MySQL 服务器实例。InnoDB Cluster 将 MySQL 组复制包装在编程环境中，使您能够轻松部署 MySQL 实例集群以实现高可用性。此外，InnoDB Cluster 与 [MySQL Router](https://dev.mysql.com/doc/mysql-router/8.4/en/) 无缝连接，这使您的应用程序无需编写自己的故障转移过程即可连接到集群。但是，对于不需要高可用性的类似使用案例，您可以使用 [InnoDB ReplicaSet](https://dev.mysql.com/doc/mysql-shell/8.4/en/mysql-innodb-replicaset.html)。[可在此处](https://dev.mysql.com/doc/mysql-shell/8.4/en/mysql-shell-install.html)找到 MySQL Shell 的安装说明。

#### 19.1.7.1 Checking Replication Status 19.1.7.1 检查复制状态

​        The most common task when managing a replication process is to        ensure that replication is taking place and that there have been        no errors between the replica and the source.      
管理复制过程时，最常见的任务是确保正在进行复制，并且副本和源之间没有错误。

​        The [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html)        statement, which you must execute on each replica, provides        information about the configuration and status of the connection        between the replica server and the source server. The MySQL        Performance Schema contains replication tables that provide this        information in a more accessible form. See        [Section 29.12.11, “Performance Schema Replication Tables”](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-tables.html).      
必须在每个副本上执行的 [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html) 语句提供有关副本服务器和源服务器之间连接的配置和状态的信息。MySQL Performance Schema 包含复制 table，这些 table 以更易于访问的形式提供此信息。参见[第 29.12.11 节 “性能模式复制 table”。](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-tables.html)

​        The replication heartbeat information shown in the Performance        Schema replication tables lets you check that the replication        connection is active even if the source has not sent events to        the replica recently. The source sends a heartbeat signal to a        replica if there are no updates to, and no unsent events in, the        binary log for a longer period than the heartbeat interval. The        `SOURCE_HEARTBEAT_PERIOD` setting on the source        (set by [`CHANGE REPLICATION SOURCE         TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)) specifies the frequency of the heartbeat, which        defaults to half of the connection timeout interval for the        replica (specified by the system variable        [`replica_net_timeout`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_net_timeout). The        [`replication_connection_status`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-connection-status-table.html)        Performance Schema table shows when the most recent heartbeat        signal was received by a replica, and how many heartbeat signals        it has received.      
Performance Schema 复制表中显示的复制检测信号信息允许您检查复制连接是否处于活动状态，即使源最近未向副本发送事件。如果二进制日志没有更新，并且没有未发送的事件，并且比检测信号间隔更长的时间，则源会向副本发送检测信号。源上的 `SOURCE_HEARTBEAT_PERIOD` 设置（由 设置）[ `CHANGE REPLICATION SOURCE         TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)指定检测信号的频率，默认为副本连接超时间隔（由系统变量 [`replica_net_timeout`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_net_timeout) 指定）的一半。[`replication_connection_status`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-connection-status-table.html) Performance Schema 表显示副本何时收到最近的检测信号，以及它收到了多少个检测信号。

​        You can use [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html)        to check on the status of an individual replica; this statement        provides the information shown here:      
您可以使用 [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html) 检查单个副本的状态;此语句提供的信息如下所示：

```sql
mysql> SHOW REPLICA STATUS\G
*************************** 1. row ***************************
             Replica_IO_State: Waiting for source to send event
                  Source_Host: 127.0.0.1
                  Source_User: root
                  Source_Port: 13000
                Connect_Retry: 1
              Source_Log_File: master-bin.000001
          Read_Source_Log_Pos: 927
               Relay_Log_File: slave-relay-bin.000002
                Relay_Log_Pos: 1145
        Relay_Source_Log_File: master-bin.000001
           Replica_IO_Running: Yes
          Replica_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Source_Log_Pos: 927
              Relay_Log_Space: 1355
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Source_SSL_Allowed: No
           Source_SSL_CA_File:
           Source_SSL_CA_Path:
              Source_SSL_Cert:
            Source_SSL_Cipher:
               Source_SSL_Key:
        Seconds_Behind_Source: 0
Source_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Source_Server_Id: 1
                  Source_UUID: 73f86016-978b-11ee-ade5-8d2a2a562feb
             Source_Info_File: mysql.slave_master_info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
    Replica_SQL_Running_State: Replica has read all relay log; waiting for more updates
           Source_Retry_Count: 10
                  Source_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Source_SSL_Crl:
           Source_SSL_Crlpath:
           Retrieved_Gtid_Set: 73f86016-978b-11ee-ade5-8d2a2a562feb:1-3
            Executed_Gtid_Set: 73f86016-978b-11ee-ade5-8d2a2a562feb:1-3
                Auto_Position: 1
         Replicate_Rewrite_DB:
                 Channel_Name:
           Source_TLS_Version:
       Source_public_key_path:
        Get_Source_public_key: 0
            Network_Namespace:
```

​        The key fields from the status report to examine are: 
要检查的状态报告中的关键字段包括：

- ​            `Replica_IO_State`: The current status of            the replica. See [Section 10.14.5, “Replication I/O (Receiver) Thread States”](https://dev.mysql.com/doc/refman/8.4/en/replica-io-thread-states.html),            and [Section 10.14.6, “Replication SQL Thread States”](https://dev.mysql.com/doc/refman/8.4/en/replica-sql-thread-states.html), for more            information.          
  `Replica_IO_State`：副本的当前状态。有关更多信息，请参见[第 10.14.5 节 “复制 I/O（接收方）线程状态”](https://dev.mysql.com/doc/refman/8.4/en/replica-io-thread-states.html)和[第 10.14.6 节 “复制 SQL 线程状态”。](https://dev.mysql.com/doc/refman/8.4/en/replica-sql-thread-states.html)

- ​            `Replica_IO_Running`: Whether the I/O            (receiver) thread for reading the source's binary log is            running. Normally, you want this to be            `Yes` unless you have not yet started            replication or have explicitly stopped it with            [`STOP REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html).          
  `Replica_IO_Running`：用于读取源的二进制日志的 I/O（接收方）线程是否正在运行。通常，除非您尚未开始复制或已使用 [`STOP REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html) 显式停止复制，否则您希望此值为 `Yes`。

- ​            `Replica_SQL_Running`: Whether the SQL            thread for executing events in the relay log is running. As            with the I/O thread, this should normally be            `Yes`.          
  `Replica_SQL_Running`：执行 Relay Log 中事件的 SQL 线程是否正在运行。与 I/O 线程一样，这通常应该是 `Yes`。

- ​            `Last_IO_Error`,            `Last_SQL_Error`: The last errors            registered by the I/O (receiver) and SQL (applier) threads            when processing the relay log. Ideally these should be            blank, indicating no errors.          
  `Last_IO_Error`、`Last_SQL_Error`：I/O（接收方）和 SQL（应用程序）线程在处理中继日志时注册的最后一个错误。理想情况下，这些应为空，表示没有错误。

- ​            `Seconds_Behind_Source`: The number of            seconds that the replication SQL (applier) thread is behind            processing the source binary log. A high number (or an            increasing one) can indicate that the replica is unable to            handle events from the source in a timely fashion.          
  `Seconds_Behind_Source`：复制 SQL（应用程序）线程在处理源二进制日志后发生的秒数。较大的数字（或增加的数字）可能表示副本无法及时处理来自源的事件。

  ​            A value of 0 for `Seconds_Behind_Source`            can usually be interpreted as meaning that the replica has            caught up with the source, but there are some cases where            this is not strictly true. For example, this can occur if            the network connection between source and replica is broken            but the replication I/O (receiver) thread has not yet            noticed this; that is, the time period set by            [`replica_net_timeout`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_net_timeout) has not            yet elapsed.          
  `Seconds_Behind_Source` 的值为 0 通常可以解释为表示副本已赶上源，但在某些情况下，这并非严格意义。例如，如果源和副本之间的网络连接断开，但复制 I/O（接收方）线程尚未注意到这一点，则可能会发生这种情况;也就是说，[`replica_net_timeout`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_replica_net_timeout) 设置的时间段尚未过去。

  ​            It is also possible that transient values for            `Seconds_Behind_Source` may not reflect the            situation accurately. When the replication SQL (applier)            thread has caught up on I/O,            `Seconds_Behind_Source` displays 0; but            when the replication I/O (receiver) thread is still queuing            up a new event, `Seconds_Behind_Source` may            show a large value until the replication applier thread            finishes executing the new event. This is especially likely            when the events have old timestamps; in such cases, if you            execute [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html)            several times in a relatively short period, you may see this            value change back and forth repeatedly between 0 and a            relatively large value. 
  `Seconds_Behind_Source` 的瞬态值也可能无法准确反映情况。当复制 SQL（应用程序）线程赶上 I/O 时，`Seconds_Behind_Source` 显示 0;但是，当复制 I/O（接收方）线程仍在对新事件进行排队时，`Seconds_Behind_Source`可能会显示较大的值，直到复制应用程序线程完成执行新事件。当事件具有旧时间戳时，这种情况尤其可能发生;在这种情况下，如果您在相对较短的时间内多次执行 [`SHOW REPLICA STATUS`](https://dev.mysql.com/doc/refman/8.4/en/show-replica-status.html)，您可能会看到此值在 0 和相对较大的值之间来回重复变化。

​        Several pairs of fields provide information about the progress        of the replica in reading events from the source binary log and        processing them in the relay log: 
几对字段提供有关副本从源二进制日志读取事件并在中继日志中处理事件的进度的信息：

- ​            (`Master_Log_file`,            `Read_Master_Log_Pos`): Coordinates in the            source binary log indicating how far the replication I/O            (receiver) thread has read events from that log.          
  （`Master_Log_file`、`Read_Master_Log_Pos`）：源二进制日志中的坐标，指示复制 I/O（接收方）线程从该日志中读取事件的距离。
- ​            (`Relay_Master_Log_File`,            `Exec_Master_Log_Pos`): Coordinates in the            source binary log indicating how far the replication SQL            (applier) thread has executed events received from that log.          
  （`Relay_Master_Log_File`、`Exec_Master_Log_Pos`）：源二进制日志中的坐标，指示复制 SQL（应用程序）线程执行从该日志接收的事件的距离。
- ​            (`Relay_Log_File`,            `Relay_Log_Pos`): Coordinates in the            replica relay log indicating how far the replication SQL            (applier) thread has executed the relay log. These            correspond to the preceding coordinates, but are expressed            in replica relay log coordinates rather than source binary            log coordinates. 
  （`Relay_Log_File`、`Relay_Log_Pos`）：副本中继日志中的坐标，指示复制 SQL（应用程序）线程执行中继日志的距离。这些坐标对应于前面的坐标，但以副本中继对数坐标而不是源二进制对数坐标表示。

​        On the source, you can check the status of connected replicas        using [`SHOW PROCESSLIST`](https://dev.mysql.com/doc/refman/8.4/en/show-processlist.html) to examine        the list of running processes. Replica connections have        `Binlog Dump` in the `Command`        field:      
在源上，您可以使用 [`SHOW PROCESSLIST`](https://dev.mysql.com/doc/refman/8.4/en/show-processlist.html) 检查已连接副本的状态，以检查正在运行的进程列表。副本连接在 `Command` 字段中具有 `Binlog Dump`：

```sql
mysql> SHOW PROCESSLIST \G;
*************************** 4. row ***************************
     Id: 10
   User: root
   Host: replica1:58371
     db: NULL
Command: Binlog Dump
   Time: 777
  State: Has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
```

​        Because it is the replica that drives the replication process,        very little information is available in this report.      
由于它是驱动复制过程的副本，因此此报表中提供的信息非常少。

​        For replicas that were started with the        [`--report-host`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_report_host) option and are        connected to the source, the [`SHOW         REPLICAS`](https://dev.mysql.com/doc/refman/8.4/en/show-replicas.html) statement on the source shows basic        information about the replicas. The output includes the ID of        the replica server, the value of the        [`--report-host`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_report_host) option, the        connecting port, and source ID:      
对于使用 [`--report-host`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_report_host) 选项启动并连接到源的副本，源上的 [`SHOW REPLICAS`](https://dev.mysql.com/doc/refman/8.4/en/show-replicas.html) 语句显示有关副本的基本信息。输出包括副本服务器的 ID、[`--report-host`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_report_host) 选项的值、连接端口和源 ID：

```sql
mysql> SHOW REPLICAS;
+-----------+----------+------+-------------------+-----------+
| Server_id | Host     | Port | Rpl_recovery_rank | Source_id |
+-----------+----------+------+-------------------+-----------+
|        10 | replica1 | 3306 |                 0 |         1 |
+-----------+----------+------+-------------------+-----------+
1 row in set (0.00 sec)
```

#### 19.1.7.2 Pausing Replication on the Replica 19.1.7.2 在副本上暂停复制

​        You can stop and start replication on the replica using the        [`STOP REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html) and        [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statements.      
您可以使用 [`STOP REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html) 和 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句在副本上停止和启动复制。

​        To stop processing of the binary log from the source, use        [`STOP REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html):      
要停止处理来自源的二进制日志，请使用 [`STOP REPLICA：`](https://dev.mysql.com/doc/refman/8.4/en/stop-replica.html)

```sql
mysql> STOP REPLICA;
```

​        When replication is stopped, the replication I/O (receiver)        thread stops reading events from the source binary log and        writing them to the relay log, and the SQL thread stops reading        events from the relay log and executing them. You can pause the        I/O (receiver) or SQL (applier) thread individually by        specifying the thread type:      
当复制停止时，复制 I/O（接收方）线程将停止从源二进制日志读取事件并将其写入中继日志，而 SQL 线程将停止从中继日志中读取事件并执行它们。您可以通过指定线程类型来单独暂停 I/O（接收方）或 SQL（应用程序）线程：

```sql
mysql> STOP REPLICA IO_THREAD;
mysql> STOP REPLICA SQL_THREAD;
```

​        To start execution again, use the [`START         REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statement:      
要再次开始执行，请使用 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句：

```sql
mysql> START REPLICA;
```

​        To start a particular thread, specify the thread type:      
要启动特定线程，请指定线程类型：

```sql
mysql> START REPLICA IO_THREAD;
mysql> START REPLICA SQL_THREAD;
```

​        For a replica that performs updates only by processing events        from the source, stopping only the SQL thread can be useful if        you want to perform a backup or other task. The I/O (receiver)        thread continues to read events from the source but they are not        executed. This makes it easier for the replica to catch up when        you restart the SQL (applier) thread.      
对于仅通过处理来自源的事件来执行更新的副本，如果要执行备份或其他任务，则仅停止 SQL 线程可能很有用。I/O（接收方）线程继续从源读取事件，但不会执行这些事件。这使得副本在重新启动 SQL （applier） 线程时更容易赶上。

​        Stopping only the receiver thread enables the events in the        relay log to be executed by the applier thread up to the point        where the relay log ends. This can be useful when you want to        pause execution to catch up with events already received from        the source, when you want to perform administration on the        replica but also ensure that it has processed all updates to a        specific point. This method can also be used to pause event        receipt on the replica while you conduct administration on the        source. Stopping the receiver thread but permitting the applier        thread to run helps ensure that there is not a massive backlog        of events to be executed when replication is started again. 
仅停止接收方线程使中继日志中的事件能够由应用线程执行，直到中继日志结束。当您想要暂停执行以赶上已从源接收的事件时，当您想要对副本执行管理，但同时确保它已处理到特定点的所有更新时，这可能很有用。此方法还可用于在对源执行管理时暂停副本上的事件接收。停止接收方线程但允许 applier 线程运行有助于确保在再次启动复制时不会有大量积压的事件要执行。

#### 19.1.7.3 Skipping Transactions 19.1.7.3 跳过事务

​        If replication stops due to an issue with an event in a        replicated transaction, you can resume replication by skipping        the failed transaction on the replica. Before skipping a        transaction, ensure that the replication I/O (receiver) thread        is stopped as well as the SQL (applier) thread.      
如果复制由于复制的事务中的事件问题而停止，您可以通过跳过副本上的失败事务来恢复复制。在跳过事务之前，请确保复制 I/O（接收方）线程以及 SQL（应用程序）线程已停止。

​        First you need to identify the replicated event that caused the        error. Details of the error and the last successfully applied        transaction are recorded in the Performance Schema table        [`replication_applier_status_by_worker`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-status-by-worker-table.html).        You can use [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) to retrieve and        display the events that were logged around the time of the        error. For instructions to do this, see        [Section 9.5, “Point-in-Time (Incremental) Recovery”](https://dev.mysql.com/doc/refman/8.4/en/point-in-time-recovery.html). Alternatively, you can        issue [`SHOW RELAYLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-relaylog-events.html) on the        replica or [`SHOW BINLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-binlog-events.html) on        the source.      
首先，您需要确定导致错误的复制事件。错误和上次成功应用的事务的详细信息记录在 Performance Schema 表中[ `replication_applier_status_by_worker` ](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-status-by-worker-table.html)。您可以使用 [**mysqlbinlog**](https://dev.mysql.com/doc/refman/8.4/en/mysqlbinlog.html) 检索和显示在错误发生前后记录的事件。有关执行此操作的说明，请参见[第 9.5 节 “时间点（增量）恢复”。](https://dev.mysql.com/doc/refman/8.4/en/point-in-time-recovery.html)或者，您可以在副本上发出 [`SHOW RELAYLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-relaylog-events.html) 或在源上发出 [`SHOW BINLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-binlog-events.html)。

​        Before skipping the transaction and restarting the replica,        check these points: 
在跳过事务并重新启动副本之前，请检查以下几点：

- ​            Is the transaction that stopped replication from an unknown            or untrusted source? If so, investigate the cause in case            there are any security considerations that indicate the            replica should not be restarted.          
  停止复制的事务是否来自未知或不受信任的源？如果是这样，请调查原因，以防有任何安全注意事项表明不应重新启动副本。
- ​            Does the transaction that stopped replication need to be            applied on the replica? If so, either make the appropriate            corrections and reapply the transaction, or manually            reconcile the data on the replica.          
  停止复制的事务是否需要应用于副本？如果是这样，请进行适当的更正并重新应用事务，或者手动协调副本上的数据。
- ​            Did the transaction that stopped replication need to be            applied on the source? If not, undo the transaction manually            on the server where it originally took place. 
  是否需要将停止复制的事务应用于源？否则，请在最初发生事务的服务器上手动撤消事务。

​        To skip the transaction, choose one of the following methods as        appropriate: 
要跳过事务，请根据需要选择以下方法之一：

- ​            When GTIDs are in use            ([`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) is            `ON`), see            [Section 19.1.7.3.1, “Skipping Transactions With GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html#replication-administration-skip-gtid) .          
  使用 GTID 时（[`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) 为 `ON），`请参阅 [Section 19.1.7.3.1， “Skipping Transactions With GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html#replication-administration-skip-gtid) 。
- ​            When GTIDs are not in use or are being phased in            ([`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) is            `OFF`, `OFF_PERMISSIVE`,            or `ON_PERMISSIVE`), see            [Section 19.1.7.3.2, “Skipping Transactions Without GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html#replication-administration-skip-nogtid).          
  当 GTID 未使用或正在逐步采用（[`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)为 `OFF、``OFF_PERMISSIVE` 或 `ON_PERMISSIVE`）时，请参见[第 19.1.7.3.2 节 “跳过没有 GTID 的事务”。](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html#replication-administration-skip-nogtid)
- ​            If you have enabled GTID assignment on a replication channel            using the            `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`            option of the [`CHANGE REPLICATION SOURCE             TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement, see            [Section 19.1.7.3.2, “Skipping Transactions Without GTIDs”](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html#replication-administration-skip-nogtid).            Using            `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` on            a replication channel is not the same as introducing            GTID-based replication for the channel, and you cannot use            the transaction skipping method for GTID-based replication            with those channels. 
  如果您已使用该语句的选项在复制通道上启用了 GTID 分配，请参见[第 19.1.7.3.2 节 “跳过没有 GTID 的事务”。](https://dev.mysql.com/doc/refman/8.4/en/replication-administration-skip.html#replication-administration-skip-nogtid) `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` [ `CHANGE REPLICATION SOURCE             TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)在复制通道上使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 与为通道引入基于 GTID 的复制不同，并且您不能对这些通道使用事务跳过方法进行基于 GTID 的复制。

​        To restart replication after skipping the transaction, issue        [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html), with the        `FOR CHANNEL` clause if the replica is a        multi-source replica. 
要在跳过事务后重新启动复制，如果副本是多源副本，请发出 [`START REPLICA，`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html)并使用 `FOR CHANNEL` 子句。

##### 19.1.7.3.1 Skipping Transactions With GTIDs 19.1.7.3.1 跳过使用 GTID 的事务

​          When GTIDs are in use          ([`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) is          `ON`), the GTID for a committed transaction          is persisted on the replica even if the content of the          transaction is filtered out. This feature prevents a replica          from retrieving previously filtered transactions when it          reconnects to the source using GTID auto-positioning. It can          also be used to skip a transaction on the replica, by          committing an empty transaction in place of the failing          transaction.        
当 GTID 正在使用时（[`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)为 `ON），`即使事务的内容被过滤掉，已提交事务的 GTID 也会保留在副本上。此功能可防止副本在使用 GTID 自动定位重新连接到源时检索以前筛选的事务。它还可用于跳过副本上的事务，方法是提交一个空事务来代替失败的事务。

​          This method of skipping transactions is not suitable when you          have enabled GTID assignment on a replication channel using          the `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`          option of the [`CHANGE REPLICATION SOURCE           TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement.        
当您使用 statement 的选项在复制通道上启用 GTID 分配时， `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` [ `CHANGE REPLICATION SOURCE           TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)这种跳过事务的方法不适用。

​          If the failing transaction generated an error in a worker          thread, you can obtain its GTID directly from the          `APPLYING_TRANSACTION` field in the          Performance Schema table          [`replication_applier_status_by_worker`](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-status-by-worker-table.html).          To see what the transaction is, issue          [`SHOW RELAYLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-relaylog-events.html) on the          replica or [`SHOW BINLOG           EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-binlog-events.html) on the source, and search the output for a          transaction preceded by that GTID.        
如果失败的事务在工作线程中生成了错误，您可以直接从 Performance Schema 表中[ `replication_applier_status_by_worker` ](https://dev.mysql.com/doc/refman/8.4/en/performance-schema-replication-applier-status-by-worker-table.html)的 `APPLYING_TRANSACTION` 字段获取其 GTID 。要查看事务是什么，请在副本上发出 [`SHOW RELAYLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-relaylog-events.html) 或在源上发出 [`SHOW BINLOG EVENTS`](https://dev.mysql.com/doc/refman/8.4/en/show-binlog-events.html)，并在输出中搜索该 GTID 前面的事务。

​          When you have assessed the failing transaction for any other          appropriate actions as described previously (such as security          considerations), to skip it, commit an empty transaction on          the replica that has the same GTID as the failing transaction.          For example:        
当您评估了失败的事务是否存在前面描述的任何其他适当操作（例如安全注意事项）后，要跳过它，请在与失败事务具有相同 GTID 的副本上提交一个空事务。例如：

```sql
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';
BEGIN;
COMMIT;
SET GTID_NEXT='AUTOMATIC';
```

​          The presence of this empty transaction on the replica means          that when you issue a [`START           REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statement to restart replication, the          replica uses the auto-skip function to ignore the failing          transaction, because it sees a transaction with that GTID has          already been applied. If the replica is a multi-source          replica, you do not need to specify the channel name when you          commit the empty transaction, but you do need to specify the          channel name when you issue [`START           REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html).        
副本上存在此空事务意味着，当您发出 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句以重新启动复制时，副本将使用自动跳过函数来忽略失败的事务，因为它看到已应用具有该 GTID 的事务。如果副本是多源副本，则无需在提交空事务时指定通道名称，但在发出 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 时需要指定通道名称。

​          Note that if binary logging is in use on this replica, the          empty transaction enters the replication stream if the replica          becomes a source or primary in the future. If you need to          avoid this possibility, consider flushing and purging the          replica's binary logs, as in this example:        
请注意，如果此副本上使用二进制日志记录，则如果副本将来成为源或主副本，则空事务将进入复制流。如果需要避免这种可能性，请考虑刷新和清除副本的二进制日志，如以下示例所示：

```sql
FLUSH LOGS;
PURGE BINARY LOGS TO 'binlog.000146';
```

​          The GTID of the empty transaction is persisted, but the          transaction itself is removed by purging the binary log files. 
空事务的 GTID 将被保留，但通过清除二进制日志文件来删除事务本身。

##### 19.1.7.3.2 Skipping Transactions Without GTIDs 19.1.7.3.2 跳过没有 GTID 的事务

​          To skip failing transactions when GTIDs are not in use or are          being phased in ([`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) is          `OFF`, `OFF_PERMISSIVE`, or          `ON_PERMISSIVE`), you can skip a specified          number of events by issuing `SET GLOBAL          sql_replica_skip_counter`. Alternatively, you can          skip past an event or events by issuing a          [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)          statement to move the source binary log position forward.        
要在 GTID 未使用或正在分阶段实施（[`gtid_mode`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)为 `OFF、``OFF_PERMISSIVE` 或 `ON_PERMISSIVE`）时跳过失败的事务，您可以通过发出 `SET GLOBAL          sql_replica_skip_counter` .或者，您可以通过发出 [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) 语句来跳过一个或多个事件，以向前移动源二进制日志位置。

​          These methods are also suitable when you have enabled GTID          assignment on a replication channel using the          `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS`          option of the [`CHANGE REPLICATION SOURCE           TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement.        
当您使用语句 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 的选项在复制通道上启用 GTID 分配时，[ `CHANGE REPLICATION SOURCE           TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)这些方法也适用。

​          When you use these methods, it is important to understand that          you are not necessarily skipping a complete transaction, as is          always the case with the GTID-based method described          previously. These non-GTID-based methods are not aware of          transactions as such, but instead operate on events. The          binary log is organized as a sequence of groups known as event          groups, and each event group consists of a sequence of events. 
使用这些方法时，请务必了解您不一定会跳过完整的事务，就像前面描述的基于 GTID 的方法一样。这些非基于 GTID 的方法不知道事务本身，而是对事件进行操作。二进制日志组织为一系列称为事件组的组，每个事件组由一系列事件组成。

- ​              For transactional tables, an event group corresponds to a              transaction.            
  对于事务表，事件组对应于事务。
- ​              For nontransactional tables, an event group corresponds to              a single SQL statement. 
  对于非事务性表，事件组对应于单个 SQL 语句。

​          A single transaction can contain changes to both transactional          and nontransactional tables.        
单个事务可以包含对事务性和非事务性 table 的更改。

​          When you use a `SET GLOBAL          sql_replica_skip_counter` statement to skip events          and the resulting position is in the middle of an event group,          the replica continues to skip events until it reaches the end          of the group. Execution then starts with the next event group.          The [`CHANGE REPLICATION SOURCE           TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement does not have this function, so you          must be careful to identify the correct location to restart          replication at the beginning of an event group. However, using          [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)          means you do not have to count the events that need to be          skipped, as you do with `SET GLOBAL          sql_replica_skip_counter`, and instead you can just          specify the location to restart. 
当您使用语句 `SET GLOBAL          sql_replica_skip_counter` 跳过事件并且结果位置位于事件组的中间时，副本将继续跳过事件，直到到达组的末尾。然后，执行从下一个事件组开始。该[ `CHANGE REPLICATION SOURCE           TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)语句没有此功能，因此您必须小心确定正确的位置，以便在事件组的开头重新启动复制。但是，使用 [`CHANGE REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) 意味着您不必像使用 `SET GLOBAL          sql_replica_skip_counter` 那样对需要跳过的事件进行计数，而只需指定要重新启动的位置即可。

###### 19.1.7.3.2.1 Skipping Transactions With `SET GLOBAL sql_replica_skip_counter` 19.1.7.3.2.1 跳过事务 `SET GLOBAL sql_replica_skip_counter` 



​            When you have assessed the failing transaction for any other            appropriate actions as described previously (such as            security considerations), count the number of events that            you need to skip. One event normally corresponds to one SQL            statement in the binary log, but note that statements that            use `AUTO_INCREMENT` or            [`LAST_INSERT_ID()`](https://dev.mysql.com/doc/refman/8.4/en/information-functions.html#function_last-insert-id) count as two            events in the binary log. When binary log transaction            compression is in use, a compressed transaction payload            (`Transaction_payload_event`) is counted as            a single counter value, so all the events inside it are            skipped as a unit.          
在评估了失败的事务是否存在前面描述的任何其他适当操作（例如安全注意事项）后，请计算需要跳过的事件数。一个事件通常对应于二进制日志中的一个 SQL 语句，但请注意，使用 `AUTO_INCREMENT` 或 [`LAST_INSERT_ID（）`](https://dev.mysql.com/doc/refman/8.4/en/information-functions.html#function_last-insert-id) 的语句在二进制日志中计为两个事件。当使用二进制日志事务压缩时，压缩的事务负载 （`Transaction_payload_event`） 被计为单个计数器值，因此其中的所有事件都作为一个单元跳过。

​            If you want to skip the complete transaction, you can count            the events to the end of the transaction, or you can just            skip the relevant event group. Remember that with            [`SET             GLOBAL sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/set-variable.html#set-variable-system-variables), the replica            continues to skip to the end of an event group. Make sure            you do not skip too far forward and go into the next event            group or transaction so that it is not also skipped.          
如果要跳过完整的事务，可以将事件计数到事务结束，也可以直接跳过相关的事件组。请记住，使用 [ `SET             GLOBAL sql_replica_skip_counter` ](https://dev.mysql.com/doc/refman/8.4/en/set-variable.html#set-variable-system-variables)时，副本将继续跳到事件组的末尾。确保您不要跳得太远，然后进入下一个事件组或事务，以免也被跳过。

​            Issue the `SET` statement as follows, where            *`N`* is the number of events from            the source to skip:          
按如下方式发出 `SET` 语句，其中 *`N`* 是源中要跳过的事件数：

```sql
SET GLOBAL sql_replica_skip_counter = N
```

​            This statement cannot be issued if            [`gtid_mode=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode) is set, or if            the replication I/O (receiver) and SQL (applier) threads are            running.          
如果设置了 [`gtid_mode=ON`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-gtids.html#sysvar_gtid_mode)，或者复制 I/O（接收方）和 SQL（应用程序）线程正在运行，则无法发出此语句。

​            The `SET GLOBAL sql_replica_skip_counter`            statement has no immediate effect. When you issue the            [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statement for            the next time following this `SET`            statement, the new value for the system variable            [`sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_sql_replica_skip_counter) is            applied, and the events are skipped. That            [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statement also            automatically sets the value of the system variable back to            0. If the replica is a multi-source replica, when you issue            that [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) statement,            the `FOR CHANNEL` clause is required. Make            sure that you name the correct channel, otherwise events are            skipped on the wrong channel. 
该 `SET GLOBAL sql_replica_skip_counter` 声明没有立即效果。当您在此 `SET` 语句之后下次发出 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句时，将应用系统变量 [`sql_replica_skip_counter`](https://dev.mysql.com/doc/refman/8.4/en/replication-options-replica.html#sysvar_sql_replica_skip_counter) 的新值，并跳过事件。该 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句还自动将系统变量的值设置回 0。如果副本是多源副本，则在发出该 [`START REPLICA`](https://dev.mysql.com/doc/refman/8.4/en/start-replica.html) 语句时，需要 `FOR CHANNEL` 子句。请确保命名正确的通道，否则会在错误的通道上跳过事件。

###### 19.1.7.3.2.2 Skipping Transactions With CHANGE REPLICATION SOURCE TO 19.1.7.3.2.2 使用 CHANGE REPLICATION SOURCE TO 跳过事务

​            When you have assessed the failing transaction for any other            appropriate actions as described previously (such as            security considerations), identify the coordinates (file and            position) in the source's binary log that represent a            suitable position to restart replication. This can be the            start of the event group following the event that caused the            issue, or the start of the next transaction. The replication            I/O (receiver) thread begins reading from the source at            these coordinates the next time the thread starts, skipping            the failing event. Make sure that you have identified the            position accurately, because this statement does not take            event groups into account.          
在评估了失败的事务是否执行了前面描述的任何其他适当操作（例如安全注意事项）后，请确定源的二进制日志中的坐标（文件和位置），这些坐标表示重新启动复制的合适位置。这可以是导致问题的事件之后事件组的开始，也可以是下一个事务的开始。复制 I/O（接收方）线程在下次启动时开始从这些坐标处的源读取数据，跳过失败事件。确保您已准确识别位置，因为此语句未考虑事件组。

​            Issue the [`CHANGE REPLICATION SOURCE             TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement as follows, where            *`source_log_name`* is the binary log            file that contains the restart position, and            *`source_log_pos`* is the number            representing the restart position as stated in the binary            log file:          
按如下方式发出[ `CHANGE REPLICATION SOURCE             TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)语句，其中 *`source_log_name`* 是包含重启位置的二进制日志文件，*`source_log_pos`* 是表示二进制日志文件中所述的重启位置的数字：

```sql
CHANGE REPLICATION SOURCE TO SOURCE_LOG_FILE='source_log_name', SOURCE_LOG_POS=source_log_pos;
```

​            If the replica is a multi-source replica, you must use the            `FOR CHANNEL` clause to name the            appropriate channel on the [`CHANGE             REPLICATION SOURCE TO`](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html) statement.          
如果副本是多源副本，则必须使用 `FOR CHANNEL` 子句在[ `CHANGE             REPLICATION SOURCE TO` ](https://dev.mysql.com/doc/refman/8.4/en/change-replication-source-to.html)语句上命名相应的通道。

​            This statement cannot be issued if            `SOURCE_AUTO_POSITION` is            `1`, or if the replication I/O (receiver)            and SQL (applier) threads are running. If you need to use            this method of skipping a transaction when            `SOURCE_AUTO_POSITION=1`, you can change            the setting to `SOURCE_AUTO_POSITION=0`            while issuing the statement, then change it back again            afterwards. For example:          
如果 `SOURCE_AUTO_POSITION` 为 `1`，或者复制 I/O（接收方）和 SQL（应用程序）线程正在运行，则无法发出此语句。如果需要在`SOURCE_AUTO_POSITION=1` 时使用这种跳过事务的方法，可以在发出语句时将设置更改为 `SOURCE_AUTO_POSITION=0`，然后再次更改回来。例如：

```sql
CHANGE REPLICATION SOURCE TO SOURCE_AUTO_POSITION=0, SOURCE_LOG_FILE='binlog.000145', SOURCE_LOG_POS=235;
CHANGE REPLICATION SOURCE TO SOURCE_AUTO_POSITION=1;
```