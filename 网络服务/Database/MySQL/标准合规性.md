## MySQL 标准合规性

- [1.7.1 MySQL Extensions to Standard SQL 1.7.1 标准 SQL 的 MySQL 扩展](https://dev.mysql.com/doc/refman/8.4/en/extensions-to-ansi.html)
- [1.7.2 MySQL Differences from Standard SQL 1.7.2 MySQL 与标准 SQL 的区别](https://dev.mysql.com/doc/refman/8.4/en/differences-from-ansi.html)
- [1.7.3 How MySQL Deals with Constraints 1.7.3 MySQL 如何处理约束](https://dev.mysql.com/doc/refman/8.4/en/constraints.html)



​      This section describes how MySQL relates to the ANSI/ISO SQL      standards. MySQL Server has many extensions to the SQL standard,      and here you can find out what they are and how to use them. You      can also find information about functionality missing from MySQL      Server, and how to work around some of the differences.    
本节介绍 MySQL 与 ANSI/ISO SQL 标准的关系。MySQL Server 对 SQL 标准有许多扩展，在这里您可以了解它们是什么以及如何使用它们。您还可以找到有关 MySQL Server 中缺少的功能以及如何解决一些差异的信息。

​      The SQL standard has been evolving since 1986 and several versions      exist. In this manual, “SQL-92” refers to the      standard released in 1992. “SQL:1999”,      “SQL:2003”, “SQL:2008”, and      “SQL:2011” refer to the versions of the standard      released in the corresponding years, with the last being the most      recent version. We use the phrase “the SQL standard”      or “standard SQL” to mean the current version of the      SQL Standard at any time.    
SQL 标准自 1986 年以来一直在发展，目前存在多个版本。在本手册中，“SQL-92”是指 1992 年发布的标准。“SQL：1999”、“SQL：2003”、“SQL：2008”和“SQL：2011”是指相应年份发布的标准版本，最后一个版本为最新版本。我们在任何时候都使用“the SQL standard”或“standard SQL”一词来表示 SQL Standard 的当前版本。

​      One of our main goals with the product is to continue to work      toward compliance with the SQL standard, but without sacrificing      speed or reliability. We are not afraid to add extensions to SQL      or support for non-SQL features if this greatly increases the      usability of MySQL Server for a large segment of our user base.      The [`HANDLER`](https://dev.mysql.com/doc/refman/8.4/en/handler.html) interface is an example      of this strategy. See [Section 15.2.5, “HANDLER Statement”](https://dev.mysql.com/doc/refman/8.4/en/handler.html).    
该产品的主要目标之一是继续努力实现 SQL 标准合规性，但不会牺牲速度或可靠性。我们并不害怕向 SQL 添加扩展或支持非 SQL 功能，如果这大大提高了 MySQL Server 对我们大部分用户群的可用性。[`HANDLER`](https://dev.mysql.com/doc/refman/8.4/en/handler.html) 接口是此策略的一个示例。参见[第 15.2.5 节 “ HANDLER 语句”。](https://dev.mysql.com/doc/refman/8.4/en/handler.html)

​      We continue to support transactional and nontransactional      databases to satisfy both mission-critical 24/7 usage and heavy      Web or logging usage.    
我们继续支持事务性和非事务性数据库，以满足任务关键型 24/7 使用和大量 Web 或日志记录使用。

​      MySQL Server was originally designed to work with medium-sized      databases (10-100 million rows, or about 100MB per table) on small      computer systems. Today MySQL Server handles terabyte-sized      databases.    
MySQL Server 最初设计用于小型计算机系统上的中型数据库（10-1 亿行，或每个表约 100MB）。如今，MySQL Server 可以处理 TB 级的数据库。

​      We are not targeting real-time support, although MySQL replication      capabilities offer significant functionality.    
尽管 MySQL 复制功能提供了重要的功能，但我们并不以实时支持为目标。

​      MySQL supports ODBC levels 0 to 3.51.    
MySQL 支持 ODBC 级别 0 到 3.51。

​      MySQL supports high-availability database clustering using the      [`NDBCLUSTER`](https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster.html) storage engine. See      [Chapter 25, *MySQL NDB Cluster 8.4*](https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster.html).    
MySQL 使用 [`NDBCLUSTER`](https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster.html) 存储引擎支持高可用性数据库集群。请参见[第 25 章 ，*MySQL NDB Cluster 8.4*](https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster.html)。

​      We implement XML functionality which supports most of the W3C      XPath standard. See [Section 14.11, “XML Functions”](https://dev.mysql.com/doc/refman/8.4/en/xml-functions.html).    
我们实现了支持大多数 W3C XPath 标准的 XML 功能。参见[第 14.11 节 “ XML 函数”。](https://dev.mysql.com/doc/refman/8.4/en/xml-functions.html)

​      MySQL supports a native JSON data type as defined by RFC 7159, and      based on the ECMAScript standard (ECMA-262). See      [Section 13.5, “The JSON Data Type”](https://dev.mysql.com/doc/refman/8.4/en/json.html). MySQL also implements a subset of the      SQL/JSON functions specified by a pre-publication draft of the      SQL:2016 standard; see [Section 14.17, “JSON Functions”](https://dev.mysql.com/doc/refman/8.4/en/json-functions.html), for more      information. 
MySQL 支持 RFC 7159 定义的原生 JSON 数据类型，并基于 ECMAScript 标准 （ECMA-262）。参见[第 13.5 节 “JSON 数据类型”。](https://dev.mysql.com/doc/refman/8.4/en/json.html)MySQL 还实现了由 SQL：2016 标准的预发布草案指定的 SQL/JSON 函数的子集;有关更多信息，请参见[第 14.17 节 “ JSON 函数”。](https://dev.mysql.com/doc/refman/8.4/en/json-functions.html)

### Selecting SQL Modes 选择 SQL 模式

​      The MySQL server can operate in different SQL modes, and can apply      these modes differently for different clients, depending on the      value of the [`sql_mode`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_sql_mode) system      variable. DBAs can set the global SQL mode to match site server      operating requirements, and each application can set its session      SQL mode to its own requirements.    
MySQL 服务器可以在不同的 SQL 模式下运行，并且可以根据 [`sql_mode`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_sql_mode) 系统变量的值为不同的 Client 端以不同的方式应用这些模式。DBA 可以设置全局 SQL 模式以匹配站点服务器的运行要求，并且每个应用程序都可以根据自己的要求设置其会话 SQL 模式。

​      Modes affect the SQL syntax MySQL supports and the data validation      checks it performs. This makes it easier to use MySQL in different      environments and to use MySQL together with other database      servers.    
模式会影响 MySQL 支持的 SQL 语法及其执行的数据验证检查。这使得在不同环境中使用 MySQL 以及将 MySQL 与其他数据库服务器一起使用变得更加容易。

​      For more information on setting the SQL mode, see      [Section 7.1.11, “Server SQL Modes”](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html). 
有关设置 SQL 模式的更多信息，请参见[第 7.1.11 节 “服务器 SQL 模式”。](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html)

### Running MySQL in ANSI Mode 在 ANSI 模式下运行 MySQL



​      To run MySQL Server in ANSI mode, start [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html)      with the [`--ansi`](https://dev.mysql.com/doc/refman/8.4/en/server-options.html#option_mysqld_ansi) option. Running the      server in ANSI mode is the same as starting it with the following      options:    
要在 ANSI 模式下运行 MySQL Server，请使用 [`--ansi`](https://dev.mysql.com/doc/refman/8.4/en/server-options.html#option_mysqld_ansi) 选项启动 [**mysqld**](https://dev.mysql.com/doc/refman/8.4/en/mysqld.html)。在 ANSI 模式下运行服务器与使用以下选项启动服务器相同：

```terminal
--transaction-isolation=SERIALIZABLE --sql-mode=ANSI
```

​      To achieve the same effect at runtime, execute these two      statements:    
要在运行时实现相同的效果，请执行以下两条语句：

```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SET GLOBAL sql_mode = 'ANSI';
```

​      You can see that setting the      [`sql_mode`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_sql_mode) system variable to      `'ANSI'` enables all SQL mode options that are      relevant for ANSI mode as follows:    
您可以看到，将 [`sql_mode`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_sql_mode) 系统变量设置为 `'ANSI'` 将启用与 ANSI 模式相关的所有 SQL 模式选项，如下所示：

```sql
mysql> SET GLOBAL sql_mode='ANSI';
mysql> SELECT @@GLOBAL.sql_mode;
        -> 'REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ANSI'
```

​      Running the server in ANSI mode with      [`--ansi`](https://dev.mysql.com/doc/refman/8.4/en/server-options.html#option_mysqld_ansi) is not quite the same as      setting the SQL mode to `'ANSI'` because the      [`--ansi`](https://dev.mysql.com/doc/refman/8.4/en/server-options.html#option_mysqld_ansi) option also sets the      transaction isolation level.    
使用 [`--ansi`](https://dev.mysql.com/doc/refman/8.4/en/server-options.html#option_mysqld_ansi) 以 ANSI 模式运行服务器与将 SQL 模式设置为 `'ANSI'` 并不完全相同，因为 [`--ansi`](https://dev.mysql.com/doc/refman/8.4/en/server-options.html#option_mysqld_ansi) 选项还设置事务隔离级别。

​      See [Section 7.1.7, “Server Command Options”](https://dev.mysql.com/doc/refman/8.4/en/server-options.html). 
参见[第 7.1.7 节 “服务器命令选项”。](https://dev.mysql.com/doc/refman/8.4/en/server-options.html)

### 标准 SQL 的 MySQL 扩展



​        MySQL Server supports some extensions that you are not likely to        find in other SQL DBMSs. Be warned that if you use them, your        code is most likely not portable to other SQL servers. In some        cases, you can write code that includes MySQL extensions, but is        still portable, by using comments of the following form:      
MySQL Server 支持一些在其他 SQL DBMS 中不太可能找到的扩展。请注意，如果使用它们，您的代码很可能无法移植到其他 SQL Server。在某些情况下，您可以使用以下形式的注释编写包含 MySQL 扩展但仍可移植的代码：

```sql
/*! MySQL-specific code */
```

​        In this case, MySQL Server parses and executes the code within        the comment as it would any other SQL statement, but other SQL        servers should ignore the extensions. For example, MySQL Server        recognizes the `STRAIGHT_JOIN` keyword in the        following statement, but other servers should not:      
在这种情况下，MySQL Server 会像解析任何其他 SQL 语句一样解析和执行 comment 中的代码，但其他 SQL Server 应忽略扩展。例如，MySQL Server 可以识别以下语句中的 `STRAIGHT_JOIN` 关键字，但其他服务器不应识别：

```sql
SELECT /*! STRAIGHT_JOIN */ col1 FROM table1,table2 WHERE ...
```

​        If you add a version number after the `!`        character, the syntax within the comment is executed only if the        MySQL version is greater than or equal to the specified version        number. The `KEY_BLOCK_SIZE` clause in the        following comment is executed only by servers from MySQL 5.1.10        or higher:      
如果在 `！` 字符后添加版本号，则仅当 MySQL 版本大于或等于指定的版本号时，才会执行注释中的语法。以下注释中的 `KEY_BLOCK_SIZE` 子句仅由 MySQL 5.1.10 或更高版本的服务器执行：

```sql
CREATE TABLE t1(a INT, KEY (a)) /*!50110 KEY_BLOCK_SIZE=1024 */;
```

​        The following descriptions list MySQL extensions, organized by        category. 
以下描述列出了按类别组织的 MySQL 扩展。

- ​            Organization of data on disk          
  磁盘上的数据组织

  

  

  

  

  ​            MySQL Server maps each database to a directory under the            MySQL data directory, and maps tables within a database to            file names in the database directory. Consequently, database            and table names are case-sensitive in MySQL Server on            operating systems that have case-sensitive file names (such            as most Unix systems). See            [Section 11.2.3, “Identifier Case Sensitivity”](https://dev.mysql.com/doc/refman/8.4/en/identifier-case-sensitivity.html).          
  MySQL Server 将每个数据库映射到 MySQL 数据目录下的目录，并将数据库中的表映射到数据库目录中的文件名。因此，在具有区分大小写的文件名的操作系统（例如大多数 Unix 系统）上的 MySQL Server 中，数据库和表名区分大小写。参见[第 11.2.3 节 “标识符区分大小写”。](https://dev.mysql.com/doc/refman/8.4/en/identifier-case-sensitivity.html)

- ​            General language syntax 通用语言语法

  - ​                By default, strings can be enclosed by                `"` as well as `'`. If                the [`ANSI_QUOTES`](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html#sqlmode_ansi_quotes) SQL                mode is enabled, strings can be enclosed only by                `'` and the server interprets strings                enclosed by `"` as identifiers.              
    默认情况下，字符串可以用 `“` 和 `'` 括起来。如果开启[`了 ANSI_QUOTES`](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html#sqlmode_ansi_quotes) SQL 模式，则字符串只能用 `'` 括起来，服务器会将 `“` 括起来的字符串解释为标识符。
  - ​                `\` is the escape character in strings.              
    `\` 是字符串中的转义字符。
  - ​                In SQL statements, you can access tables from different                databases with the                *`db_name.tbl_name`* syntax. Some                SQL servers provide the same functionality but call this                `User space`. MySQL Server doesn't                support tablespaces such as used in statements like                this: `CREATE TABLE ralph.my_table ... IN                my_tablespace`. 
    在 SQL 语句中，您可以使用 *`db_name.tbl_name`* 语法访问来自不同数据库的表。某些 SQL Server 提供相同的功能，但将此称为`用户空间`。MySQL Server 不支持表空间，例如在如下语句中使用的表空间： `CREATE TABLE ralph.my_table ... IN                my_tablespace` .

- ​            SQL statement syntax SQL 语句语法

  - ​                The [`ANALYZE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/analyze-table.html),                [`CHECK TABLE`](https://dev.mysql.com/doc/refman/8.4/en/check-table.html),                [`OPTIMIZE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/optimize-table.html), and                [`REPAIR TABLE`](https://dev.mysql.com/doc/refman/8.4/en/repair-table.html) statements.              
    [`ANALYZE TABLE、`](https://dev.mysql.com/doc/refman/8.4/en/analyze-table.html)[`CHECK TABLE、`](https://dev.mysql.com/doc/refman/8.4/en/check-table.html)[`OPTIMIZE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/optimize-table.html) 和 [`REPAIR TABLE`](https://dev.mysql.com/doc/refman/8.4/en/repair-table.html) 语句。
  - ​                The [`CREATE DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/create-database.html),                [`DROP DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/drop-database.html), and                [`ALTER DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/alter-database.html)                statements. See [Section 15.1.12, “CREATE DATABASE Statement”](https://dev.mysql.com/doc/refman/8.4/en/create-database.html),                [Section 15.1.24, “DROP DATABASE Statement”](https://dev.mysql.com/doc/refman/8.4/en/drop-database.html), and                [Section 15.1.2, “ALTER DATABASE Statement”](https://dev.mysql.com/doc/refman/8.4/en/alter-database.html).              
    [`CREATE DATABASE、`](https://dev.mysql.com/doc/refman/8.4/en/create-database.html)[`DROP DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/drop-database.html) 和 [`ALTER DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/alter-database.html) 语句。参见[第 15.1.12 节 “ CREATE DATABASE 语句”](https://dev.mysql.com/doc/refman/8.4/en/create-database.html)，[第 15.1.24 节 “ DROP DATABASE 语句”](https://dev.mysql.com/doc/refman/8.4/en/drop-database.html)和[第 15.1.2 节 “ ALTER DATABASE 语句”。](https://dev.mysql.com/doc/refman/8.4/en/alter-database.html)
  - ​                The [`DO`](https://dev.mysql.com/doc/refman/8.4/en/do.html) statement.              
    [`DO`](https://dev.mysql.com/doc/refman/8.4/en/do.html) 语句。
  - ​                [`EXPLAIN                 SELECT`](https://dev.mysql.com/doc/refman/8.4/en/explain.html) to obtain a description of how tables                are processed by the query optimizer.              
    [ `EXPLAIN                 SELECT` ](https://dev.mysql.com/doc/refman/8.4/en/explain.html)获取查询优化器如何处理表的描述。
  - ​                The [`FLUSH`](https://dev.mysql.com/doc/refman/8.4/en/flush.html) and                [`RESET`](https://dev.mysql.com/doc/refman/8.4/en/reset.html) statements.              
    [`FLUSH`](https://dev.mysql.com/doc/refman/8.4/en/flush.html) 和 [`RESET`](https://dev.mysql.com/doc/refman/8.4/en/reset.html) 语句。
  - ​                The                [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set-variable.html)                statement. See [Section 15.7.6.1, “SET Syntax for Variable Assignment”](https://dev.mysql.com/doc/refman/8.4/en/set-variable.html).              
    [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set-variable.html) 语句。参见[第 15.7.6.1 节 “变量赋值的 SET 语法”。](https://dev.mysql.com/doc/refman/8.4/en/set-variable.html)
  - ​                The [`SHOW`](https://dev.mysql.com/doc/refman/8.4/en/show.html) statement. See                [Section 15.7.7, “SHOW Statements”](https://dev.mysql.com/doc/refman/8.4/en/show.html). The information produced by many                of the MySQL-specific                [`SHOW`](https://dev.mysql.com/doc/refman/8.4/en/show.html) statements can be                obtained in more standard fashion by using                [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) to query                `INFORMATION_SCHEMA`. See                [Chapter 28, *INFORMATION_SCHEMA Tables*](https://dev.mysql.com/doc/refman/8.4/en/information-schema.html).              
    [`SHOW`](https://dev.mysql.com/doc/refman/8.4/en/show.html) 语句。参见[第 15.7.7 节 “ SHOW 语句”。](https://dev.mysql.com/doc/refman/8.4/en/show.html)通过使用 [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) 查询 `INFORMATION_SCHEMA`，可以以更标准的方式获取许多特定于 MySQL 的 [`SHOW`](https://dev.mysql.com/doc/refman/8.4/en/show.html) 语句生成的信息。请参见[第 28 章 *INFORMATION_SCHEMA表*](https://dev.mysql.com/doc/refman/8.4/en/information-schema.html)。
  - ​                                                  Use of [`LOAD DATA`](https://dev.mysql.com/doc/refman/8.4/en/load-data.html). In many                cases, this syntax is compatible with Oracle                [`LOAD DATA`](https://dev.mysql.com/doc/refman/8.4/en/load-data.html). See                [Section 15.2.9, “LOAD DATA Statement”](https://dev.mysql.com/doc/refman/8.4/en/load-data.html).              
    使用 [`LOAD DATA`](https://dev.mysql.com/doc/refman/8.4/en/load-data.html)。在许多情况下，此语法与 Oracle [`LOAD DATA`](https://dev.mysql.com/doc/refman/8.4/en/load-data.html) 兼容。参见[第 15.2.9 节 “ LOAD DATA 语句”。](https://dev.mysql.com/doc/refman/8.4/en/load-data.html)
  - ​                Use of [`RENAME TABLE`](https://dev.mysql.com/doc/refman/8.4/en/rename-table.html). See                [Section 15.1.36, “RENAME TABLE Statement”](https://dev.mysql.com/doc/refman/8.4/en/rename-table.html).              
    使用 [`RENAME TABLE`](https://dev.mysql.com/doc/refman/8.4/en/rename-table.html)。参见[第 15.1.36 节 “ RENAME TABLE 语句”。](https://dev.mysql.com/doc/refman/8.4/en/rename-table.html)
  - ​                Use of [`REPLACE`](https://dev.mysql.com/doc/refman/8.4/en/replace.html) instead of                [`DELETE`](https://dev.mysql.com/doc/refman/8.4/en/delete.html) plus                [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html). See                [Section 15.2.12, “REPLACE Statement”](https://dev.mysql.com/doc/refman/8.4/en/replace.html).              
    使用 [`REPLACE`](https://dev.mysql.com/doc/refman/8.4/en/replace.html) 而不是 [`DELETE`](https://dev.mysql.com/doc/refman/8.4/en/delete.html) 加 [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html)。参见[第 15.2.12 节 “ REPLACE 语句”。](https://dev.mysql.com/doc/refman/8.4/en/replace.html)
  - ​                Use of `CHANGE                *`col_name`*`,                `DROP                *`col_name`*`, or                [`DROP INDEX`](https://dev.mysql.com/doc/refman/8.4/en/drop-index.html),                `IGNORE` or `RENAME`                in [`ALTER TABLE`](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html)                statements. Use of multiple `ADD`,                `ALTER`, `DROP`, or                `CHANGE` clauses in an                [`ALTER TABLE`](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html) statement.                See [Section 15.1.9, “ALTER TABLE Statement”](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html).              
    在 [`ALTER TABLE`](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html) 语句中使用 `CHANGE                *`col_name`*` 、 `DROP *`col_name`*` 或 [`DROP INDEX`](https://dev.mysql.com/doc/refman/8.4/en/drop-index.html)、`IGNORE` 或 `RENAME` 。在 [`ALTER TABLE`](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html) 语句中使用多个 `ADD`、`ALTER、``DROP` 或 `CHANGE` 子句。参见[第 15.1.9 节 “ ALTER TABLE 语句”。](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html)
  - ​                Use of index names, indexes on a prefix of a column, and                use of `INDEX` or                `KEY` in [`CREATE                 TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) statements. See                [Section 15.1.20, “CREATE TABLE Statement”](https://dev.mysql.com/doc/refman/8.4/en/create-table.html).              
    在 [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) 语句中使用索引名称、列前缀上的索引以及使用 `INDEX` 或 `KEY`。参见[第 15.1.20 节 “ CREATE TABLE 语句”。](https://dev.mysql.com/doc/refman/8.4/en/create-table.html)
  - ​                Use of `TEMPORARY` or `IF NOT                EXISTS` with [`CREATE                 TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html).              
    将 `TEMPORARY` 或 `IF NOT EXISTS` 与 [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) 一起使用。
  - ​                Use of `IF EXISTS` with                [`DROP TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) and                [`DROP DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/drop-database.html).              
    将 `IF EXISTS` 与 [`DROP TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) 和 [`DROP DATABASE`](https://dev.mysql.com/doc/refman/8.4/en/drop-database.html) 一起使用。
  - ​                The capability of dropping multiple tables with a single                [`DROP TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) statement.              
    使用单个 [`DROP TABLE`](https://dev.mysql.com/doc/refman/8.4/en/drop-table.html) 语句删除多个表的功能。
  - ​                The `ORDER BY` and                `LIMIT` clauses of the                [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) and                [`DELETE`](https://dev.mysql.com/doc/refman/8.4/en/delete.html) statements.              
    [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) 和 [`DELETE`](https://dev.mysql.com/doc/refman/8.4/en/delete.html) 语句的 `ORDER BY` 和 `LIMIT` 子句。
  - ​                `INSERT INTO *`tbl_name`*                SET *`col_name`* = ...`                syntax.               `INSERT INTO *`tbl_name`*                SET *`col_name`* = ...` 语法。
  - ​                The `DELAYED` clause of the                [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html) and                [`REPLACE`](https://dev.mysql.com/doc/refman/8.4/en/replace.html) statements.              
    [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html) 和 [`REPLACE`](https://dev.mysql.com/doc/refman/8.4/en/replace.html) 语句的 `DELAYED` 子句。
  - ​                The `LOW_PRIORITY` clause of the                [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html),                [`REPLACE`](https://dev.mysql.com/doc/refman/8.4/en/replace.html),                [`DELETE`](https://dev.mysql.com/doc/refman/8.4/en/delete.html), and                [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) statements.              
    [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html)、[`REPLACE`](https://dev.mysql.com/doc/refman/8.4/en/replace.html)、[`DELETE`](https://dev.mysql.com/doc/refman/8.4/en/delete.html) 和 [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) 语句的 `LOW_PRIORITY` 子句。
  - ​                Use of `INTO OUTFILE` or `INTO                DUMPFILE` in                [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) statements. See                [Section 15.2.13, “SELECT Statement”](https://dev.mysql.com/doc/refman/8.4/en/select.html).              
    在 [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) 语句中使用 `INTO OUTFILE` 或 `INTO DUMPFILE`。参见[第 15.2.13 节 “ SELECT 语句”。](https://dev.mysql.com/doc/refman/8.4/en/select.html)
  - ​                Options such as `STRAIGHT_JOIN` or                `SQL_SMALL_RESULT` in                [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) statements.              
    [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) 语句中的 `STRAIGHT_JOIN` 或 `SQL_SMALL_RESULT` 等选项。
  - ​                You don't need to name all selected columns in the                `GROUP BY` clause. This gives better                performance for some very specific, but quite normal                queries. See                [Section 14.19, “Aggregate Functions”](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions-and-modifiers.html).              
    您无需在 `GROUP BY` 子句中命名所有选定的列。这为一些非常具体但非常正常的查询提供了更好的性能。参见[第 14.19 节 “聚合函数”。](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions-and-modifiers.html)
  - ​                You can specify `ASC` and                `DESC` with `GROUP                BY`, not just with `ORDER BY`.              
    您可以使用 `GROUP BY` 指定 `ASC` 和 `DESC`，而不仅仅是使用 `ORDER BY`。
  - ​                The ability to set variables in a statement with the                `:=` assignment operator. See                [Section 11.4, “User-Defined Variables”](https://dev.mysql.com/doc/refman/8.4/en/user-variables.html). 
    使用 `：=` 赋值运算符在语句中设置变量的能力。参见[第 11.4 节 “用户定义的变量”。](https://dev.mysql.com/doc/refman/8.4/en/user-variables.html)

- ​            Data types 数据类型

  - ​                The [`MEDIUMINT`](https://dev.mysql.com/doc/refman/8.4/en/integer-types.html),                [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html), and                [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) data types, and the                various [`BLOB`](https://dev.mysql.com/doc/refman/8.4/en/blob.html) and                [`TEXT`](https://dev.mysql.com/doc/refman/8.4/en/blob.html) data types.              
    [`MEDIUMINT、`](https://dev.mysql.com/doc/refman/8.4/en/integer-types.html)[`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) 和 [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) 数据类型，以及各种 [`BLOB`](https://dev.mysql.com/doc/refman/8.4/en/blob.html) 和 [`TEXT`](https://dev.mysql.com/doc/refman/8.4/en/blob.html) 数据类型。
  - ​                The `AUTO_INCREMENT`,                `BINARY`, `NULL`,                `UNSIGNED`, and                `ZEROFILL` data type attributes. 
    `AUTO_INCREMENT`、`BINARY、``NULL、``UNSIGNED` 和 `ZEROFILL` 数据类型属性。

- ​            Functions and operators 函数和运算符

  - ​                To make it easier for users who migrate from other SQL                environments, MySQL Server supports aliases for many                functions. For example, all string functions support                both standard SQL syntax and ODBC syntax.              
    为了方便从其他 SQL 环境迁移的用户，MySQL Server 支持许多函数的别名。例如，所有字符串函数都支持标准 SQL 语法和 ODBC 语法。

  - ​                MySQL Server understands the                [`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) and                [`&&`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and)                operators to mean logical OR and AND, as in the C                programming language. In MySQL Server,                [`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) and                [`OR`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) are                synonyms, as are                [`&&`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and)                and [`AND`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and).                Because of this nice syntax, MySQL Server doesn't                support the standard SQL                [`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) operator                for string concatenation; use                [`CONCAT()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_concat) instead. Because                [`CONCAT()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_concat) takes any number                of arguments, it is easy to convert use of the                [`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) operator                to MySQL Server.              
    MySQL服务器理解[`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or)和[`&&`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and)运算符表示逻辑OR和AND，就像在C编程语言中一样。在MySQL服务器中，[`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or)和[`OR`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or)是同义词，[`&&`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and)和[`AND`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and)也是同义词。由于这种很好的语法，MySQL Server 不支持用于字符串串联的标准 SQL [`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) 运算符;请改用 [`CONCAT（）`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_concat) 。因为 [`CONCAT（）`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_concat) 接受任意数量的参数，所以很容易将 [`||`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) 运算符的使用转换为 MySQL Server。

  - ​                Use of [`COUNT(DISTINCT                 *`value_list`*)`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_count) where                *`value_list`* has more than one                element.              
    使用 [ `COUNT(DISTINCT                 *`value_list`*)` ](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_count) where *`value_list`* 具有多个元素。

  - ​                String comparisons are case-insensitive by default, with                sort ordering determined by the collation of the current                character set, which is `utf8mb4` by                default. To perform case-sensitive comparisons instead,                you should declare your columns with the                `BINARY` attribute or use the                `BINARY` cast, which causes comparisons                to be done using the underlying character code values                rather than a lexical ordering.              
    默认情况下，字符串比较不区分大小写，排序顺序由当前字符集的排序规则确定，默认情况下为 `utf8mb4`。要执行区分大小写的比较，您应该使用 `BINARY` 属性声明列或使用 `BINARY` 强制转换，这会导致使用基础字符代码值而不是词法排序来进行比较。

  - ​                                                  The [`%`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod)                operator is a synonym for                [`MOD()`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod). That is,                `*`N`* %                *`M`*` is equivalent to                [`MOD(*`N`*,*`M`*)`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod).                [`%`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod) is                supported for C programmers and for compatibility with                PostgreSQL.              
    [`%`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod) 运算符是 [`MOD（）`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod) 的同义词。也就是说，`*`N`* % *`M`*` 等效于 [`MOD（*`N，M`*）。*``*`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod)[`%`](https://dev.mysql.com/doc/refman/8.4/en/mathematical-functions.html#function_mod) 支持 C 程序员以及与 PostgreSQL 的兼容性。

  - ​                The [`=`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_equal),                [`<>`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_not-equal),                [`<=`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_less-than-or-equal),                [`<`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_less-than),                [`>=`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_greater-than-or-equal),                [`>`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_greater-than),                [`<<`](https://dev.mysql.com/doc/refman/8.4/en/bit-functions.html#operator_left-shift),                [`>>`](https://dev.mysql.com/doc/refman/8.4/en/bit-functions.html#operator_right-shift),                [`<=>`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_equal-to),                [`AND`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and),                [`OR`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or), or                [`LIKE`](https://dev.mysql.com/doc/refman/8.4/en/string-comparison-functions.html#operator_like)                operators may be used in expressions in the output                column list (to the left of the `FROM`)                in [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) statements. For                example:              
    [`=`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_equal)、[`<>`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_not-equal)、[`<=`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_less-than-or-equal)、[`<`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_less-than)[`、>=`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_greater-than-or-equal)、[`>`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_greater-than)、[`<<`](https://dev.mysql.com/doc/refman/8.4/en/bit-functions.html#operator_left-shift)、[`>>`](https://dev.mysql.com/doc/refman/8.4/en/bit-functions.html#operator_right-shift)、[`<=>、AND`](https://dev.mysql.com/doc/refman/8.4/en/comparison-operators.html#operator_equal-to)、[`OR`](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_or) 或 [`LIKE`](https://dev.mysql.com/doc/refman/8.4/en/string-comparison-functions.html#operator_like) 运算符可用于 [`SELECT`](https://dev.mysql.com/doc/refman/8.4/en/select.html) 语句中输出列列表（`FROM` 左侧）中的表达式。 [``](https://dev.mysql.com/doc/refman/8.4/en/logical-operators.html#operator_and)例如：

    ```sql
    mysql> SELECT col1=1 AND col2=2 FROM my_table;
    ```

  - ​                The [`LAST_INSERT_ID()`](https://dev.mysql.com/doc/refman/8.4/en/information-functions.html#function_last-insert-id)                function returns the most recent                `AUTO_INCREMENT` value. See                [Section 14.15, “Information Functions”](https://dev.mysql.com/doc/refman/8.4/en/information-functions.html).              
    [`LAST_INSERT_ID（）`](https://dev.mysql.com/doc/refman/8.4/en/information-functions.html#function_last-insert-id) 函数返回最新的 `AUTO_INCREMENT` 值。参见[第 14.15 节 “信息功能”。](https://dev.mysql.com/doc/refman/8.4/en/information-functions.html)

  - ​                [`LIKE`](https://dev.mysql.com/doc/refman/8.4/en/string-comparison-functions.html#operator_like) is permitted on                numeric values.              
    允许对数值执行 [`LIKE`](https://dev.mysql.com/doc/refman/8.4/en/string-comparison-functions.html#operator_like)。

  - ​                The [`REGEXP`](https://dev.mysql.com/doc/refman/8.4/en/regexp.html#operator_regexp) and                [`NOT REGEXP`](https://dev.mysql.com/doc/refman/8.4/en/regexp.html#operator_not-regexp) extended regular                expression operators.              
    [`REGEXP`](https://dev.mysql.com/doc/refman/8.4/en/regexp.html#operator_regexp) 和 [`NOT REGEXP`](https://dev.mysql.com/doc/refman/8.4/en/regexp.html#operator_not-regexp) 扩展了正则表达式运算符。

  - ​                [`CONCAT()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_concat) or                [`CHAR()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_char) with one argument                or more than two arguments. (In MySQL Server, these                functions can take a variable number of arguments.)              
    [`CONCAT（）`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_concat) 或 [`CHAR（）`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_char) 具有一个参数或两个以上的参数。（在 MySQL Server 中，这些函数可以采用可变数量的参数。

  - ​                The [`BIT_COUNT()`](https://dev.mysql.com/doc/refman/8.4/en/bit-functions.html#function_bit-count),                [`CASE`](https://dev.mysql.com/doc/refman/8.4/en/flow-control-functions.html#operator_case),                [`ELT()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_elt),                [`FROM_DAYS()`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_from-days),                [`FORMAT()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_format),                [`IF()`](https://dev.mysql.com/doc/refman/8.4/en/flow-control-functions.html#function_if),                [`MD5()`](https://dev.mysql.com/doc/refman/8.4/en/encryption-functions.html#function_md5),                [`PERIOD_ADD()`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_period-add),                [`PERIOD_DIFF()`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_period-diff),                [`TO_DAYS()`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_to-days), and                [`WEEKDAY()`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_weekday) functions.              
    [`BIT_COUNT（）、`](https://dev.mysql.com/doc/refman/8.4/en/bit-functions.html#function_bit-count)[`大小写`](https://dev.mysql.com/doc/refman/8.4/en/flow-control-functions.html#operator_case)、[`ELT（）、`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_elt)[`FROM_DAYS（）、`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_from-days)[`FORMAT（）`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_format)、[`IF（）`](https://dev.mysql.com/doc/refman/8.4/en/flow-control-functions.html#function_if)、[`MD5（）、`](https://dev.mysql.com/doc/refman/8.4/en/encryption-functions.html#function_md5)[`PERIOD_ADD（）、`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_period-add)[`PERIOD_DIFF（）、`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_period-diff)[`TO_DAYS（）`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_to-days) 和 [`WEEKDAY（）`](https://dev.mysql.com/doc/refman/8.4/en/date-and-time-functions.html#function_weekday) 函数。

  - ​                Use of [`TRIM()`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_trim) to trim                substrings. Standard SQL supports removal of single                characters only.              
    使用 [`TRIM（）`](https://dev.mysql.com/doc/refman/8.4/en/string-functions.html#function_trim) 修剪子字符串。标准 SQL 仅支持删除单个字符。

  - ​                The `GROUP BY` functions                [`STD()`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_std),                [`BIT_OR()`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_bit-or),                [`BIT_AND()`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_bit-and),                [`BIT_XOR()`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_bit-xor), and                [`GROUP_CONCAT()`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_group-concat). See                [Section 14.19, “Aggregate Functions”](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions-and-modifiers.html). 
    `GROUP BY` 函数 [`STD（）、`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_std)[`BIT_OR（）、BIT_AND`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_bit-or)[`（）、`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_bit-and)[`BIT_XOR（）`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_bit-xor) 和 [`GROUP_CONCAT（）。`](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions.html#function_group-concat)参见[第 14.19 节 “聚合函数”。](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions-and-modifiers.html)

### MySQL 与标准 SQL 的区别

- [1.7.2.1 SELECT INTO TABLE Differences 1.7.2.1 SELECT INTO TABLE 差异](https://dev.mysql.com/doc/refman/8.4/en/ansi-diff-select-into-table.html)
- [1.7.2.2 UPDATE Differences 1.7.2.2 UPDATE 差异](https://dev.mysql.com/doc/refman/8.4/en/ansi-diff-update.html)
- [1.7.2.3 FOREIGN KEY Constraint Differences 1.7.2.3 FOREIGN KEY 约束差异](https://dev.mysql.com/doc/refman/8.4/en/ansi-diff-foreign-keys.html)
- [1.7.2.4 '--' as the Start of a Comment 1.7.2.4 '--' 作为注释的开头](https://dev.mysql.com/doc/refman/8.4/en/ansi-diff-comments.html)



​        We try to make MySQL Server follow the ANSI SQL standard and the        ODBC SQL standard, but MySQL Server performs operations        differently in some cases: 
我们尝试使 MySQL Server 遵循 ANSI SQL 标准和 ODBC SQL 标准，但 MySQL Server 在某些情况下执行操作的方式不同：

- ​            There are several differences between the MySQL and standard            SQL privilege systems. For example, in MySQL, privileges for            a table are not automatically revoked when you delete a            table. You must explicitly issue a            [`REVOKE`](https://dev.mysql.com/doc/refman/8.4/en/revoke.html) statement to revoke            privileges for a table. For more information, see            [Section 15.7.1.8, “REVOKE Statement”](https://dev.mysql.com/doc/refman/8.4/en/revoke.html).          
  MySQL 和标准 SQL 权限系统之间存在一些差异。例如，在 MySQL 中，删除表时不会自动撤销表的权限。您必须显式发出 [`REVOKE`](https://dev.mysql.com/doc/refman/8.4/en/revoke.html) 语句来撤销 table 的权限。有关更多信息，请参见[第 15.7.1.8 节 “ REVOKE 语句”。](https://dev.mysql.com/doc/refman/8.4/en/revoke.html)
- ​            The [`CAST()`](https://dev.mysql.com/doc/refman/8.4/en/cast-functions.html#function_cast) function does not            support cast to [`REAL`](https://dev.mysql.com/doc/refman/8.4/en/floating-point-types.html) or            [`BIGINT`](https://dev.mysql.com/doc/refman/8.4/en/integer-types.html). See            [Section 14.10, “Cast Functions and Operators”](https://dev.mysql.com/doc/refman/8.4/en/cast-functions.html). 
  [`CAST（）`](https://dev.mysql.com/doc/refman/8.4/en/cast-functions.html#function_cast) 函数不支持转换为 [`REAL`](https://dev.mysql.com/doc/refman/8.4/en/floating-point-types.html) 或 [`BIGINT`](https://dev.mysql.com/doc/refman/8.4/en/integer-types.html)。参见[第 14.10 节 “强制转换函数和运算符”。](https://dev.mysql.com/doc/refman/8.4/en/cast-functions.html)

#### SELECT INTO TABLE 差异



​          MySQL Server doesn't support the `SELECT ... INTO          TABLE` Sybase SQL extension. Instead, MySQL Server          supports the          [`INSERT INTO ...           SELECT`](https://dev.mysql.com/doc/refman/8.4/en/insert-select.html) standard SQL syntax, which is basically the          same thing. See [Section 15.2.7.1, “INSERT ... SELECT Statement”](https://dev.mysql.com/doc/refman/8.4/en/insert-select.html). For example:        
MySQL Server 不支持 `SELECT ... INTO          TABLE` Sybase SQL 扩展。相反，MySQL Server 支持[ `INSERT INTO ...           SELECT` ](https://dev.mysql.com/doc/refman/8.4/en/insert-select.html)标准的 SQL 语法，这基本上是一样的。参见[第 15.2.7.1 节 “INSERT ...SELECT 语句”。](https://dev.mysql.com/doc/refman/8.4/en/insert-select.html)例如：

```sql
INSERT INTO tbl_temp2 (fld_id)
    SELECT tbl_temp1.fld_order_id
    FROM tbl_temp1 WHERE tbl_temp1.fld_order_id > 100;
```

​          Alternatively, you can use          [`SELECT ... INTO           OUTFILE`](https://dev.mysql.com/doc/refman/8.4/en/select-into.html) or          [`CREATE TABLE ...           SELECT`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html).        
或者，您也可以使用 [ `SELECT ... INTO           OUTFILE` ](https://dev.mysql.com/doc/refman/8.4/en/select-into.html) 或 [ `CREATE TABLE ...           SELECT` ](https://dev.mysql.com/doc/refman/8.4/en/create-table.html)。

​          You can use [`SELECT ...           INTO`](https://dev.mysql.com/doc/refman/8.4/en/select.html) with user-defined variables. The same syntax          can also be used inside stored routines using cursors and          local variables. See [Section 15.2.13.1, “SELECT ... INTO Statement”](https://dev.mysql.com/doc/refman/8.4/en/select-into.html). 
您可以使用 [`SELECT ...INTO`](https://dev.mysql.com/doc/refman/8.4/en/select.html) 替换为用户定义的变量。相同的语法也可以在使用游标和局部变量的存储例程中使用。参见[第 15.2.13.1 节 “SELECT ...INTO 语句”。](https://dev.mysql.com/doc/refman/8.4/en/select-into.html)

#### UPDATE 差异



​          If you access a column from the table to be updated in an          expression, [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) uses the          current value of the column. The second assignment in the          following statement sets `col2` to the          current (updated) `col1` value, not the          original `col1` value. The result is that          `col1` and `col2` have the          same value. This behavior differs from standard SQL.        
如果您从表中访问要在表达式中更新的列，[`则 UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) 将使用该列的当前值。以下语句中的第二个赋值将 `col2` 设置为当前（更新的）`col1` 值，而不是原始的 `col1` 值。结果是 `col1` 和 `col2` 具有相同的值。此行为与标准 SQL 不同。

```sql
UPDATE t1 SET col1 = col1 + 1, col2 = col1;
```

#### FOREIGN KEY Constraint Differences 1.7.2.3 FOREIGN KEY 约束差异



​          The MySQL implementation of foreign key constraints differs          from the SQL standard in the following key respects: 
外键约束的 MySQL 实现在以下关键方面与 SQL 标准不同：

- ​              If there are several rows in the parent table with the              same referenced key value,              [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) performs a foreign key              check as if the other parent rows with the same key value              do not exist. For example, if you define a              `RESTRICT` type constraint, and there is              a child row with several parent rows,              `InnoDB` does not permit the deletion of              any of the parent rows. This is shown in the following              example:            
  如果父表中有多行具有相同的引用键值，[`则 InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 将执行外键检查，就像具有相同键值的其他父行不存在一样。例如，如果定义了 `RESTRICT` 类型约束，并且有一个子行具有多个父行，则 `InnoDB` 不允许删除任何父行。以下示例显示了这一点：

  ```sql
  mysql> CREATE TABLE parent (
      ->     id INT,
      ->     INDEX (id)
      -> ) ENGINE=InnoDB;
  Query OK, 0 rows affected (0.04 sec)
  
  mysql> CREATE TABLE child (
      ->     id INT,
      ->     parent_id INT,
      ->     INDEX par_ind (parent_id),
      ->     FOREIGN KEY (parent_id)
      ->         REFERENCES parent(id)
      ->         ON DELETE RESTRICT
      -> ) ENGINE=InnoDB;
  Query OK, 0 rows affected (0.02 sec)
  
  mysql> INSERT INTO parent (id) 
      ->     VALUES ROW(1), ROW(2), ROW(3), ROW(1);
  Query OK, 4 rows affected (0.01 sec)
  Records: 4  Duplicates: 0  Warnings: 0
  
  mysql> INSERT INTO child (id,parent_id) 
      ->     VALUES ROW(1,1), ROW(2,2), ROW(3,3);
  Query OK, 3 rows affected (0.01 sec)
  Records: 3  Duplicates: 0  Warnings: 0
  
  mysql> DELETE FROM parent WHERE id=1;
  ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key
  constraint fails (`test`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY
  (`parent_id`) REFERENCES `parent` (`id`) ON DELETE RESTRICT)
  ```

- ​              If `ON UPDATE CASCADE` or `ON              UPDATE SET NULL` recurses to update the              *same table* it has previously updated              during the same cascade, it acts like              `RESTRICT`. This means that you cannot              use self-referential `ON UPDATE CASCADE`              or `ON UPDATE SET NULL` operations. This              is to prevent infinite loops resulting from cascaded              updates. A self-referential `ON DELETE SET              NULL`, on the other hand, is possible, as is a              self-referential `ON DELETE CASCADE`.              Cascading operations may not be nested more than 15 levels              deep.            
  如果 `ON UPDATE CASCADE` 或 `ON              UPDATE SET NULL` 递归以更新它之前在同一级联期间更新的*同一 table*，则其行为类似于 `RESTRICT。`这意味着您不能使用自引用 `ON UPDATE CASCADE` 或 `ON UPDATE SET NULL` 操作。这是为了防止级联更新导致无限循环。另一方面，自引用 `ON DELETE SET              NULL` 是可能的，自引用 `ON DELETE CASCADE` 也是可能的。级联操作的嵌套深度不得超过 15 层。

- ​              In an SQL statement that inserts, deletes, or updates many              rows, foreign key constraints (like unique constraints)              are checked row-by-row. When performing foreign key              checks, [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) sets shared              row-level locks on child or parent records that it must              examine. MySQL checks foreign key constraints immediately;              the check is not deferred to transaction commit. According              to the SQL standard, the default behavior should be              deferred checking. That is, constraints are only checked              after the *entire SQL statement* has              been processed. This means that it is not possible to              delete a row that refers to itself using a foreign key.            
  在插入、删除或更新许多行的 SQL 语句中，将逐行检查外键约束（如唯一约束）。执行外键检查时， [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 在它必须检查的子记录或父记录上设置共享行级锁。MySQL 会立即检查外键约束;检查不会推迟到 Transaction Commit。根据 SQL 标准，默认行为应该是延迟检查。也就是说，只有在处理完*整个 SQL 语句*后才会检查约束。这意味着无法删除使用外键引用自身的行。

- ​              No storage engine, including `InnoDB`,              recognizes or enforces the `MATCH` clause              used in referential-integrity constraint definitions. Use              of an explicit `MATCH` clause does not              have the specified effect, and it causes `ON              DELETE` and `ON UPDATE` clauses              to be ignored. Specifying the `MATCH`              should be avoided.            
  任何存储引擎（包括 `InnoDB`）都无法识别或强制执行引用完整性约束定义中使用的 `MATCH` 子句。使用显式 `MATCH` 子句不具有指定的效果，并且会导致忽略 `ON DELETE` 和 `ON UPDATE` 子句。应避免指定 `MATCH`。

  ​              The `MATCH` clause in the SQL standard              controls how `NULL` values in a composite              (multiple-column) foreign key are handled when comparing              to a primary key in the referenced table. MySQL              essentially implements the semantics defined by              `MATCH SIMPLE`, which permits a foreign              key to be all or partially `NULL`. In              that case, a (child table) row containing such a foreign              key can be inserted even though it does not match any row              in the referenced (parent) table. (It is possible to              implement other semantics using triggers.)            
  SQL 标准中的 `MATCH` 子句控制在与引用表中的主键进行比较时如何处理复合（多列）外键中的 `NULL` 值。MySQL 实质上实现了 `MATCH SIMPLE` 定义的语义，它允许外键全部或部分为 `NULL。`在这种情况下，可以插入包含此类外键的（子表）行，即使它与引用的（父）表中的任何行都不匹配。（可以使用 triggers 实现其他语义。

- ​              A `FOREIGN KEY` constraint that              references a non-`UNIQUE` key is not              standard SQL but rather an              [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) extension that is now              deprecated, and must be enabled by setting              [`restrict_fk_on_non_standard_key`](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_restrict_fk_on_non_standard_key).              You should expect support for use of nonstandard keys to              be removed in a future version of MySQL, and migrate away              from them now.            
  引用非 `UNIQUE` 键的 `FOREIGN KEY` 约束不是标准 SQL，而是现已弃用的 [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 扩展，必须通过设置 [ `restrict_fk_on_non_standard_key` ](https://dev.mysql.com/doc/refman/8.4/en/server-system-variables.html#sysvar_restrict_fk_on_non_standard_key)来启用。您应该期望在未来版本的 MySQL 中删除对使用非标准键的支持，并立即从它们迁移出去。

  ​              The [`NDB`](https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster.html) storage engine              requires an explicit unique key (or primary key) on any              column referenced as a foreign key, as per the SQL              standard.            
  根据 SQL 标准， [`NDB`](https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster.html) 存储引擎要求在引用为外键的任何列上具有显式的唯一键（或主键）。

- ​              For storage engines that do not support foreign keys (such              as [`MyISAM`](https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html)), MySQL Server              parses and ignores foreign key specifications.            
  对于不支持外键的存储引擎（例如 [`MyISAM），`](https://dev.mysql.com/doc/refman/8.4/en/myisam-storage-engine.html)MySQL Server 会解析并忽略外键规范。

- ​              MySQL parses but ignores “inline              `REFERENCES` specifications” (as              defined in the SQL standard) where the references are              defined as part of the column specification. MySQL accepts              `REFERENCES` clauses only when specified              as part of a separate `FOREIGN KEY`              specification.            
  MySQL 解析但忽略“内联 `REFERENCES` 规范”（如 SQL 标准中所定义），其中引用被定义为列规范的一部分。仅当指定为单独的 `FOREIGN KEY` 规范的一部分时，MySQL 才接受 `REFERENCES` 子句。

  ​              Defining a column to use a `REFERENCES              *`tbl_name`*(*`col_name`*)`              clause has no actual effect and *serves only as a              memo or comment to you that the column which you are              currently defining is intended to refer to a column in              another table*. It is important to realize when              using this syntax that: 
  定义列以使用 `REFERENCES              *`tbl_name`*(*`col_name`*)` 子句没有实际效果，*仅作为您当前定义的列旨在引用另一个表中的列的备注或注释*。在使用此语法时，请务必注意：

  - ​                  MySQL does not perform any sort of check to make sure                  that *`col_name`* actually                  exists in *`tbl_name`* (or even                  that *`tbl_name`* itself                  exists).                
    MySQL 不执行任何类型的检查来确保 *`col_name`* 确实存在于 *`tbl_name`* 中（甚至 *`tbl_name`* 本身也存在）。
  - ​                  MySQL does not perform any sort of action on                  *`tbl_name`* such as deleting                  rows in response to actions taken on rows in the table                  which you are defining; in other words, this syntax                  induces no `ON DELETE` or `ON                  UPDATE` behavior whatsoever. (Although you                  can write an `ON DELETE` or                  `ON UPDATE` clause as part of the                  `REFERENCES` clause, it is also                  ignored.)                
    MySQL 不会对 *`tbl_name`* 执行任何类型的操作，例如删除行以响应对表中您正在定义的行执行的操作;换句话说，此语法不会引起任何 `ON DELETE` 或 `ON UPDATE` 行为。（尽管可以将 `ON DELETE` 或 `ON UPDATE` 子句编写为 `REFERENCES` 子句的一部分，但它也会被忽略。
  - ​                  This syntax creates a *column*; it                  does **not** create any                  sort of index or key. 
    此语法创建一个*列*;它不会创建任何类型的索引或键。

  ​              You can use a column so created as a join column, as shown              here:            
  您可以使用这样创建的列作为联接列，如下所示：

  ```sql
  CREATE TABLE person (
      id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
      name CHAR(60) NOT NULL,
      PRIMARY KEY (id)
  );
  
  CREATE TABLE shirt (
      id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
      style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
      color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
      owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
      PRIMARY KEY (id)
  );
  
  INSERT INTO person VALUES (NULL, 'Antonio Paz');
  
  SELECT @last := LAST_INSERT_ID();
  
  INSERT INTO shirt VALUES
      ROW(NULL, 'polo', 'blue', @last),
      ROW(NULL, 'dress', 'white', @last),
      ROW(NULL, 't-shirt', 'blue', @last);
  
  INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');
  
  SELECT @last := LAST_INSERT_ID();
  
  INSERT INTO shirt VALUES
      ROW(NULL, 'dress', 'orange', @last),
      ROW(NULL, 'polo', 'red', @last),
      ROW(NULL, 'dress', 'blue', @last),
      ROW(NULL, 't-shirt', 'white', @last);
  
  SELECT * FROM person;
  +----+---------------------+
  | id | name                |
  +----+---------------------+
  |  1 | Antonio Paz         |
  |  2 | Lilliana Angelovska |
  +----+---------------------+
  
  SELECT * FROM shirt;
  +----+---------+--------+-------+
  | id | style   | color  | owner |
  +----+---------+--------+-------+
  |  1 | polo    | blue   |     1 |
  |  2 | dress   | white  |     1 |
  |  3 | t-shirt | blue   |     1 |
  |  4 | dress   | orange |     2 |
  |  5 | polo    | red    |     2 |
  |  6 | dress   | blue   |     2 |
  |  7 | t-shirt | white  |     2 |
  +----+---------+--------+-------+
  
  SELECT s.* FROM person p INNER JOIN shirt s
     ON s.owner = p.id
  WHERE p.name LIKE 'Lilliana%'
     AND s.color <> 'white';
  
  +----+-------+--------+-------+
  | id | style | color  | owner |
  +----+-------+--------+-------+
  |  4 | dress | orange |     2 |
  |  5 | polo  | red    |     2 |
  |  6 | dress | blue   |     2 |
  +----+-------+--------+-------+
  ```

  ​              When used in this fashion, the              `REFERENCES` clause is not displayed in              the output of [`SHOW CREATE               TABLE`](https://dev.mysql.com/doc/refman/8.4/en/show-create-table.html) or              [`DESCRIBE`](https://dev.mysql.com/doc/refman/8.4/en/describe.html):            
  以这种方式使用时，`REFERENCES` 子句不会显示在 [ `SHOW CREATE               TABLE` ](https://dev.mysql.com/doc/refman/8.4/en/show-create-table.html) 或 [`DESCRIBE`](https://dev.mysql.com/doc/refman/8.4/en/describe.html) 的输出中：

  ```sql
  mysql> SHOW CREATE TABLE shirt\G
  *************************** 1. row ***************************
  Table: shirt
  Create Table: CREATE TABLE `shirt` (
  `id` smallint(5) unsigned NOT NULL auto_increment,
  `style` enum('t-shirt','polo','dress') NOT NULL,
  `color` enum('red','blue','orange','white','black') NOT NULL,
  `owner` smallint(5) unsigned NOT NULL,
  PRIMARY KEY  (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
  ```

​          For information about foreign key constraints, see          [Section 15.1.20.5, “FOREIGN KEY Constraints”](https://dev.mysql.com/doc/refman/8.4/en/create-table-foreign-keys.html). 
有关外键约束的信息，请参见[第 15.1.20.5 节 “ FOREIGN KEY 约束”。](https://dev.mysql.com/doc/refman/8.4/en/create-table-foreign-keys.html)

#### 1.7.2.4 '--' as the Start of a Comment 1.7.2.4 '--' 作为注释的开头



​          Standard SQL uses the C syntax `/* this is a comment          */` for comments, and MySQL Server supports this          syntax as well. MySQL also support extensions to this syntax          that enable MySQL-specific SQL to be embedded in the comment;          see [Section 11.7, “Comments”](https://dev.mysql.com/doc/refman/8.4/en/comments.html).        
标准 SQL 使用 C 语法 `/* this is a comment          */` 进行注释，MySQL Server 也支持此语法。MySQL 还支持对此语法的扩展，从而可以将特定于 MySQL 的 SQL 嵌入到 comment 中;参见[第 11.7 节 “注释”。](https://dev.mysql.com/doc/refman/8.4/en/comments.html)

​          MySQL Server also uses `#` as the start          comment character. This is nonstandard.        
MySQL Server 还使用 `#` 作为开始注释字符。这是不标准的。

​          Standard SQL also uses “`--`” as a          start-comment sequence. MySQL Server supports a variant of the          `--` comment style; the `--`          start-comment sequence is accepted as such, but must be          followed by a whitespace character such as a space or newline.          The space is intended to prevent problems with generated SQL          queries that use constructs such as the following, which          updates the balance to reflect a charge:        
标准 SQL 还使用 “`--`” 作为开始注释序列。MySQL Server 支持 `--` 注释样式的变体;`--` start-comment 序列可以这样接受，但后面必须跟一个空白字符，例如空格或换行符。该空间旨在防止生成的 SQL 查询出现问题，这些查询使用如下结构，这些结构会更新余额以反映费用：

```sql
UPDATE account SET balance=balance-charge
WHERE account_id=user_id
```

​          Consider what happens when `charge` has a          negative value such as `-1`, which might be          the case when an amount is credited to the account. In this          case, the generated statement looks like this:        
考虑当 `charge` 具有负值（如 `-1`）时会发生什么情况，当金额贷记到账户时，可能会出现这种情况。在本例中，生成的语句如下所示：

```sql
UPDATE account SET balance=balance--1
WHERE account_id=5752;
```

​          `balance--1` is valid standard SQL, but          `--` is interpreted as the start of a          comment, and part of the expression is discarded. The result          is a statement that has a completely different meaning than          intended:        
`balance--1` 是有效的标准 SQL，但 `--` 被解释为注释的开头，并且表达式的一部分被丢弃。结果是一个含义与预期完全不同的语句：

```sql
UPDATE account SET balance=balance
WHERE account_id=5752;
```

​          This statement produces no change in value at all. To keep          this from happening, MySQL requires a whitespace character          following the `--` for it to be recognized as          a start-comment sequence in MySQL Server, so that an          expression such as `balance--1` is always          safe to use. 
此语句根本不会产生 value 的变化。为了防止这种情况发生，MySQL 需要在 `--` 后面加上一个空格字符，以便在 MySQL Server 中将其识别为开始注释序列，以便像 `balance--1` 这样的表达式始终可以安全使用。

[MySQL 8.4 参考手册](https://dev.mysql.com/doc/refman/8.4/en/) / [...](https://dev.mysql.com/doc/refman/8.4/en/constraints.html) / MySQL 如何处理约束

### 1.7.3 How MySQL Deals with Constraints 1.7.3 MySQL 如何处理约束

- [1.7.3.1 PRIMARY KEY and UNIQUE Index Constraints 1.7.3.1 PRIMARY KEY 和 UNIQUE 索引约束](https://dev.mysql.com/doc/refman/8.4/en/constraint-primary-key.html)
- [1.7.3.2 FOREIGN KEY Constraints 1.7.3.2 外键约束](https://dev.mysql.com/doc/refman/8.4/en/constraint-foreign-key.html)
- [1.7.3.3 ENUM and SET Constraints 1.7.3.3 ENUM 和 SET 约束](https://dev.mysql.com/doc/refman/8.4/en/constraint-enum.html)



​        MySQL enables you to work both with transactional tables that        permit rollback and with nontransactional tables that do not.        Because of this, constraint handling is a bit different in MySQL        than in other DBMSs. We must handle the case when you have        inserted or updated a lot of rows in a nontransactional table        for which changes cannot be rolled back when an error occurs.      
MySQL 使您能够使用允许回滚的事务性 table 和不允许回滚的非事务性 table。因此，MySQL 中的约束处理与其他 DBMS 中的约束处理略有不同。当您在非事务性表中插入或更新了大量行时，我们必须处理这种情况，这些行的更改在发生错误时无法回滚。

​        The basic philosophy is that MySQL Server tries to produce an        error for anything that it can detect while parsing a statement        to be executed, and tries to recover from any errors that occur        while executing the statement. We do this in most cases, but not        yet for all.      
基本原理是 MySQL Server 尝试在解析要执行的语句时可以检测到的任何内容产生错误，并尝试从执行语句时发生的任何错误中恢复。我们在大多数情况下都这样做，但目前还不是针对所有人。

​        The options MySQL has when an error occurs are to stop the        statement in the middle or to recover as well as possible from        the problem and continue. By default, the server follows the        latter course. This means, for example, that the server may        coerce invalid values to the closest valid values.      
MySQL 在发生错误时的选项是在中间停止语句，或者尽可能从问题中恢复并继续。默认情况下，服务器遵循后一种方式。这意味着，例如，服务器可能会将无效值强制转换为最接近的有效值。

​        Several SQL mode options are available to provide greater        control over handling of bad data values and whether to continue        statement execution or abort when errors occur. Using these        options, you can configure MySQL Server to act in a more        traditional fashion that is like other DBMSs that reject        improper input. The SQL mode can be set globally at server        startup to affect all clients. Individual clients can set the        SQL mode at runtime, which enables each client to select the        behavior most appropriate for its requirements. See        [Section 7.1.11, “Server SQL Modes”](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html).      
可以使用多个 SQL 模式选项来更好地控制错误数据值的处理，以及在发生错误时是继续执行语句还是中止。使用这些选项，您可以将 MySQL Server  配置为以更传统的方式运行，就像其他拒绝不当输入的 DBMS 一样。SQL  模式可以在服务器启动时全局设置，以影响所有客户端。各个客户端可以在运行时设置 SQL 模式，这使每个客户端都可以选择最适合其要求的行为。参见[第 7.1.11 节 “服务器 SQL 模式”。](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html)

​        The following sections describe how MySQL Server handles        different types of constraints. 
以下部分描述了 MySQL Server 如何处理不同类型的约束。

#### PRIMARY KEY 和 UNIQUE 索引约束



​          Normally, errors occur for data-change statements (such as          [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html) or          [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html)) that would violate          primary-key, unique-key, or foreign-key constraints. If you          are using a transactional storage engine such as          `InnoDB`, MySQL automatically rolls back the          statement. If you are using a nontransactional storage engine,          MySQL stops processing the statement at the row for which the          error occurred and leaves any remaining rows unprocessed.        
通常，违反主键、唯一键或外键约束的数据更改语句（如 [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html) 或 [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html)）会发生错误。如果您使用的是事务性存储引擎（例如 `InnoDB`），则 MySQL 会自动回滚该语句。如果您使用的是非事务性存储引擎，则 MySQL 将停止处理发生错误的行上的语句，并使其余任何行保持未处理状态。

​          MySQL supports an `IGNORE` keyword for          [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html),          [`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html), and so forth. If you          use it, MySQL ignores primary-key or unique-key violations and          continues processing with the next row. See the section for          the statement that you are using ([Section 15.2.7, “INSERT Statement”](https://dev.mysql.com/doc/refman/8.4/en/insert.html),          [Section 15.2.17, “UPDATE Statement”](https://dev.mysql.com/doc/refman/8.4/en/update.html), and so forth).        
MySQL 支持 [`INSERT`](https://dev.mysql.com/doc/refman/8.4/en/insert.html)、[`UPDATE`](https://dev.mysql.com/doc/refman/8.4/en/update.html) 等的 `IGNORE` 关键字。如果使用它，MySQL 将忽略主键或唯一键冲突并继续处理下一行。请参阅您正在使用的语句的部分（[第 15.2.7 节 “ INSERT 语句”](https://dev.mysql.com/doc/refman/8.4/en/insert.html)，[第 15.2.17 节 “ UPDATE 语句”](https://dev.mysql.com/doc/refman/8.4/en/update.html)等）。

​          You can get information about the number of rows actually          inserted or updated with the          [`mysql_info()`](https://dev.mysql.com/doc/c-api/8.4/en/mysql-info.html) C API function.          You can also use the [`SHOW           WARNINGS`](https://dev.mysql.com/doc/refman/8.4/en/show-warnings.html) statement. See          [mysql_info()](https://dev.mysql.com/doc/c-api/8.4/en/mysql-info.html), and          [Section 15.7.7.42, “SHOW WARNINGS Statement”](https://dev.mysql.com/doc/refman/8.4/en/show-warnings.html).        
您可以使用 [`mysql_info（）`](https://dev.mysql.com/doc/c-api/8.4/en/mysql-info.html) C API 函数获取有关实际插入或更新的行数的信息。您还可以使用 [`SHOW WARNINGS`](https://dev.mysql.com/doc/refman/8.4/en/show-warnings.html) 语句。参见 [mysql_info（）](https://dev.mysql.com/doc/c-api/8.4/en/mysql-info.html) 和 [第 15.7.7.42 节 “SHOW WARNINGS 语句”。](https://dev.mysql.com/doc/refman/8.4/en/show-warnings.html)

​          `InnoDB` and `NDB` tables          support foreign keys. See          [Section 1.7.3.2, “FOREIGN KEY Constraints”](https://dev.mysql.com/doc/refman/8.4/en/constraint-foreign-key.html). 
`InnoDB` 和 `NDB` 表支持外键。参见[第 1.7.3.2 节 “FOREIGN KEY 约束”。](https://dev.mysql.com/doc/refman/8.4/en/constraint-foreign-key.html)

#### 7.3.2 外键约束



​          Foreign keys let you cross-reference related data across          tables, and          [foreign key           constraints](https://dev.mysql.com/doc/refman/8.4/en/glossary.html#glos_foreign_key_constraint) help keep this spread-out data consistent.        
外键允许您跨表交叉引用相关数据，[而外键约束](https://dev.mysql.com/doc/refman/8.4/en/glossary.html#glos_foreign_key_constraint)有助于保持此分布数据的一致性。

​          MySQL supports `ON UPDATE` and `ON          DELETE` foreign key references in          [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) and          [`ALTER TABLE`](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html) statements. The          available referential actions are `RESTRICT`,          `CASCADE`, `SET NULL`, and          `NO ACTION` (the default).        
MySQL 在 [`CREATE TABLE`](https://dev.mysql.com/doc/refman/8.4/en/create-table.html) 和 [`ALTER TABLE`](https://dev.mysql.com/doc/refman/8.4/en/alter-table.html) 语句中支持 `ON UPDATE` 和 `ON DELETE` 外键引用。可用的引用操作包括 `RESTRICT、``CASCADE`、`SET NULL` 和 `NO ACTION`（默认值）。

​          `SET DEFAULT` is also supported by the MySQL          Server but is currently rejected as invalid by          [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html). Since MySQL does not          support deferred constraint checking, `NO          ACTION` is treated as `RESTRICT`.          For the exact syntax supported by MySQL for foreign keys, see          [Section 15.1.20.5, “FOREIGN KEY Constraints”](https://dev.mysql.com/doc/refman/8.4/en/create-table-foreign-keys.html).        
MySQL 服务器也支持 `SET DEFAULT`，但当前被 [`InnoDB`](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html) 拒绝为无效。由于 MySQL 不支持延迟约束检查，因此 `NO ACTION` 被视为 `RESTRICT`。有关 MySQL 支持的外键确切语法，请参见[第 15.1.20.5 节 “ FOREIGN KEY 约束”。](https://dev.mysql.com/doc/refman/8.4/en/create-table-foreign-keys.html)

​          `MATCH FULL`, `MATCH          PARTIAL`, and `MATCH SIMPLE` are          allowed, but their use should be avoided, as they cause the          MySQL Server to ignore any `ON DELETE` or          `ON UPDATE` clause used in the same          statement. `MATCH` options do not have any          other effect in MySQL, which in effect enforces `MATCH          SIMPLE` semantics full-time.        
允许`使用 MATCH FULL`、`MATCH PARTIAL` 和 `MATCH SIMPLE`，但应避免使用它们，因为它们会导致 MySQL 服务器忽略同一语句中使用的任何 `ON DELETE` 或 `ON UPDATE` 子句。`MATCH` 选项在 MySQL 中没有任何其他影响，这实际上是全职强制执行 `MATCH SIMPLE` 语义。

​          MySQL requires that foreign key columns be indexed; if you          create a table with a foreign key constraint but no index on a          given column, an index is created.        
MySQL 要求对外键列进行索引;如果创建具有外键约束但在给定列上没有索引的表，则会创建一个索引。

​          You can obtain information about foreign keys from the          Information Schema          [`KEY_COLUMN_USAGE`](https://dev.mysql.com/doc/refman/8.4/en/information-schema-key-column-usage-table.html) table. An          example of a query against this table is shown here:        
您可以从 Information Schema [`KEY_COLUMN_USAGE`](https://dev.mysql.com/doc/refman/8.4/en/information-schema-key-column-usage-table.html) 表中获取有关外键的信息。针对此表的查询示例如下所示：

```sql
mysql> SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME
     > FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
     > WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL;
+--------------+---------------+-------------+-----------------+
| TABLE_SCHEMA | TABLE_NAME    | COLUMN_NAME | CONSTRAINT_NAME |
+--------------+---------------+-------------+-----------------+
| fk1          | myuser        | myuser_id   | f               |
| fk1          | product_order | customer_id | f2              |
| fk1          | product_order | product_id  | f1              |
+--------------+---------------+-------------+-----------------+
3 rows in set (0.01 sec)
```

​          Information about foreign keys on `InnoDB`          tables can also be found in the          [`INNODB_FOREIGN`](https://dev.mysql.com/doc/refman/8.4/en/information-schema-innodb-foreign-table.html) and          [`INNODB_FOREIGN_COLS`](https://dev.mysql.com/doc/refman/8.4/en/information-schema-innodb-foreign-cols-table.html) tables, in          the `INFORMATION_SCHEMA` database.        
有关 `InnoDB` 表上的外键的信息也可以在 `INFORMATION_SCHEMA` 数据库中的 [`INNODB_FOREIGN`](https://dev.mysql.com/doc/refman/8.4/en/information-schema-innodb-foreign-table.html) 和 [`INNODB_FOREIGN_COLS`](https://dev.mysql.com/doc/refman/8.4/en/information-schema-innodb-foreign-cols-table.html) 表中找到。

​          `InnoDB` and `NDB` tables          support foreign keys. 
`InnoDB` 和 `NDB` 表支持外键。

#### ENUM 和 SET 约束

​          [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) and          [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) columns provide an          efficient way to define columns that can contain only a given          set of values. See [Section 13.3.5, “The ENUM Type”](https://dev.mysql.com/doc/refman/8.4/en/enum.html), and          [Section 13.3.6, “The SET Type”](https://dev.mysql.com/doc/refman/8.4/en/set.html).        
[`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) 和 [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) 列提供了一种有效的方法来定义只能包含一组给定值的列。参见[第 13.3.5 节 “ ENUM 类型”](https://dev.mysql.com/doc/refman/8.4/en/enum.html)和[第 13.3.6 节 “ SET 类型”。](https://dev.mysql.com/doc/refman/8.4/en/set.html)

​          Unless strict mode is disabled (not recommended, but see          [Section 7.1.11, “Server SQL Modes”](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html)), the definition of a          [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) or          [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) column acts as a constraint          on values entered into the column. An error occurs for values          that do not satisfy these conditions: 
除非禁用严格模式（不推荐，但请参见[第 7.1.11 节 “服务器 SQL 模式”](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html)），否则 [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) 或 [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) 列的定义将作为对输入到列中的值的约束。对于不满足以下条件的值，将发生错误：

- ​              An [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) value must be one              of those listed in the column definition, or the internal              numeric equivalent thereof. The value cannot be the error              value (that is, 0 or the empty string). For a column              defined as              [`ENUM('a','b','c')`](https://dev.mysql.com/doc/refman/8.4/en/enum.html), values              such as `''`, `'d'`, or              `'ax'` are invalid and are rejected.            
  [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) 值必须是列定义中列出的值之一，或者是其内部等效数值。该值不能是错误值（即 0 或空字符串）。对于定义为 [`ENUM（'a'，'b'，'c'）`](https://dev.mysql.com/doc/refman/8.4/en/enum.html) 的列，`''`、`'d'` 或 `'ax'` 等值无效并被拒绝。
- ​              A [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) value must be the              empty string or a value consisting only of the values              listed in the column definition separated by commas. For a              column defined as              [`SET('a','b','c')`](https://dev.mysql.com/doc/refman/8.4/en/set.html), values              such as `'d'` or              `'a,b,c,d'` are invalid and are rejected. 
  [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html) 值必须是空字符串或仅包含列定义中列出的值（以逗号分隔）的值。对于定义为 [`SET（'a'，'b'，'c'）`](https://dev.mysql.com/doc/refman/8.4/en/set.html) 的列，`'d'` 或 `'a，b，c，d'` 等值无效并被拒绝。

​          Errors for invalid values can be suppressed in strict mode if          you use [`INSERT           IGNORE`](https://dev.mysql.com/doc/refman/8.4/en/insert.html) or `UPDATE IGNORE`. In this          case, a warning is generated rather than an error. For          [`ENUM`](https://dev.mysql.com/doc/refman/8.4/en/enum.html), the value is inserted as          the error member (`0`). For          [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html), the value is inserted as          given except that any invalid substrings are deleted. For          example, `'a,x,b,y'` results in a value of          `'a,b'`. 
如果使用 [`INSERT IGNORE`](https://dev.mysql.com/doc/refman/8.4/en/insert.html) 或 `UPDATE IGNORE，`则可以在严格模式下禁止显示无效值的错误。在这种情况下，将生成警告而不是错误。对于 [`ENUM，`](https://dev.mysql.com/doc/refman/8.4/en/enum.html)该值将作为错误成员 （`0`） 插入。对于 [`SET`](https://dev.mysql.com/doc/refman/8.4/en/set.html)，将按给定方式插入值，但会删除任何无效的子字符串。例如，`'a，x，b，y'` 导致值 `'a，b'`。