# slapd 配置

# Backup and restore OpenLDAP 备份和恢复 OpenLDAP

Now we have LDAP running just the way we want, it is time to ensure we can save all of our work and restore it as needed.
现在，LDAP可以按照我们想要的方式运行，是时候确保我们可以保存所有工作并根据需要恢复它了。

What we need is a way to back up the directory database(s) – specifically the configuration backend (`cn=config`) and the DIT (`dc=example,dc=com`). If we are going to backup those databases into, say, `/export/backup`, we could use `slapcat` as shown in the following script, called `/usr/local/bin/ldapbackup`:
我们需要的是一种备份目录数据库的方法——特别是配置后端 （ `cn=config` ） 和 DIT （ `dc=example,dc=com` ）。如果我们要将这些数据库备份到，例如， `/export/backup` 我们可以使用 `slapcat` 以下脚本中所示的数据库，称为 `/usr/local/bin/ldapbackup` ：

```bash
#!/bin/bash

set -e

BACKUP_PATH=/export/backup
SLAPCAT=/usr/sbin/slapcat

nice ${SLAPCAT} -b cn=config > ${BACKUP_PATH}/config.ldif
nice ${SLAPCAT} -b dc=example,dc=com > ${BACKUP_PATH}/example.com.ldif
chown root:root ${BACKUP_PATH}/*
chmod 600 ${BACKUP_PATH}/*.ldif
```

> **Note**: 注意：
>  These files are uncompressed text files containing everything in your  directory including the tree layout, usernames, and every password. So,  you might want to consider making `/export/backup` an encrypted partition and even having the script encrypt those files  as it creates them. Ideally you should do both, but that depends on your security requirements.
> 这些文件是未压缩的文本文件，包含目录中的所有内容，包括树布局、用户名和每个密码。因此，您可能需要考虑创建一个 `/export/backup` 加密分区，甚至让脚本在创建这些文件时对其进行加密。理想情况下，您应该同时执行这两项操作，但这取决于您的安全要求。

Then, it is just a matter of having a cron script to run this program as  often as you feel comfortable with. For many, once a day suffices. For  others, more often is required. Here is an example of a cron script  called `/etc/cron.d/ldapbackup` that is run every night at 22:45h:
然后，只需有一个 cron 脚本来运行这个程序，只要你觉得舒服。对于许多人来说，每天一次就足够了。对于其他人来说，需要更频繁。下面是一个 cron 脚本的示例 `/etc/cron.d/ldapbackup` ，该脚本每晚 22：45 运行：

```plaintext
MAILTO=backup-emails@domain.com
45 22 * * *  root    /usr/local/bin/ldapbackup
```

Now the files are created, they should be copied to a backup server.
现在文件已创建，应将其复制到备份服务器。

Assuming we did a fresh reinstall of LDAP, the restore process could be something like this:
假设我们重新安装了 LDAP，恢复过程可能如下所示：

```bash
#!/bin/bash

set -e

BACKUP_PATH=/export/backup
SLAPADD=/usr/sbin/slapadd

if [ -n "$(ls -l /var/lib/ldap/* 2>/dev/null)" -o -n "$(ls -l /etc/ldap/slapd.d/* 2>/dev/null)" ]; then
    echo Run the following to remove the existing db:
    echo sudo systemctl stop slapd.service
    echo sudo rm -rf /etc/ldap/slapd.d/* /var/lib/ldap/*
    exit 1
fi
sudo systemctl stop slapd.service || :
sudo slapadd -F /etc/ldap/slapd.d -b cn=config -l /export/backup/config.ldif
sudo slapadd -F /etc/ldap/slapd.d -b dc=example,dc=com -l /export/backup/example.com.ldif
sudo chown -R openldap:openldap /etc/ldap/slapd.d/
sudo chown -R openldap:openldap /var/lib/ldap/
sudo systemctl start slapd.service
```

This is a simplistic backup strategy, of course. It’s being shown here as a  reference for the basic tooling you can use for backups and restores.
当然，这是一种简单的备份策略。此处显示它作为可用于备份和还原的基本工具的参考。

------

# LDAP access control LDAP 访问控制

The management of what type of access (read, write, etc) users should be granted for resources is known as **access control**. The configuration directives involved are called **access control lists** or ACLs.
管理应为用户授予资源的访问类型（读取、写入等）称为访问控制。所涉及的配置指令称为访问控制列表或 ACL。

When we [installed the `slapd` package](https://ubuntu.com/server/docs/install-and-configure-ldap), various ACLs were set up automatically. We will look at a few important consequences of those defaults and, in so doing, we’ll get an idea of  how ACLs work and how they’re configured.
当我们安装 `slapd` 软件包时，会自动设置各种 ACL。我们将研究这些默认值的一些重要后果，在此过程中，我们将了解 ACL 的工作原理以及它们的配置方式。

To get the effective ACL for an LDAP query we need to look at the ACL  entries of both the database being queried, and those of the special  frontend database instance. Note that the ACLs belonging to the frontend database are always appended to the database-specific ACLs, and the  first match ‘wins’.
为了获得LDAP查询的有效ACL，我们需要查看被查询的数据库和特殊前端数据库实例的ACL条目。请注意，属于前端数据库的 ACL 始终追加到特定于数据库的 ACL 中，并且第一个匹配项“获胜”。

## Getting the ACLs 获取 ACL

The following commands will give, respectively, the ACLs of the `mdb` database (`dc=example,dc=com`) and those of the frontend database:
以下命令将分别给出 `mdb` 数据库 （ `dc=example,dc=com` ） 和前端数据库的 ACL：

```bash
$ sudo ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b \
cn=config '(olcDatabase={1}mdb)' olcAccess
    
dn: olcDatabase={1}mdb,cn=config
olcAccess: {0}to attrs=userPassword by self write by anonymous auth by * none
olcAccess: {1}to attrs=shadowLastChange by self write by * read
olcAccess: {2}to * by * read

$ sudo ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b \
cn=config '(olcDatabase={-1}frontend)' olcAccess
    
dn: olcDatabase={-1}frontend,cn=config
olcAccess: {0}to * by dn.exact=gidNumber=0+uidNumber=0,cn=peercred,cn=external
 ,cn=auth manage by * break
olcAccess: {1}to dn.exact="" by * read
olcAccess: {2}to dn.base="cn=Subschema" by * read
```

> **Note**: 注意：
>  The Root DN always has full rights to its database and does not need to be included in any ACL.
> 根 DN 始终对其数据库拥有完全权限，不需要包含在任何 ACL 中。

## Interpreting the results 解释结果

The first two ACLs are crucial:
前两个 ACL 至关重要：

```plaintext
olcAccess: {0}to attrs=userPassword by self write by anonymous auth by * none
olcAccess: {1}to attrs=shadowLastChange by self write by * read
```

This can be represented differently for easier reading:
为了便于阅读，可以以不同的方式表示：

```plaintext
to attrs=userPassword
    by self write
    by anonymous auth
    by * none
    
to attrs=shadowLastChange
    by self write
    by * read
```

These ACLs enforce the following:
这些 ACL 强制执行以下操作：

- Anonymous ‘auth’ access is provided to the **userPassword** attribute so that users can authenticate, or **bind**. Perhaps counter-intuitively, ‘by anonymous auth’ is needed even when  anonymous access to the DIT is unwanted, otherwise this would be a  chicken-and-egg problem: before authentication, all users are anonymous.
  提供对 userPassword 属性的匿名“身份验证”访问，以便用户可以进行身份验证或绑定。也许与直觉相反，即使不需要对 DIT 的匿名访问，也需要“匿名身份验证”，否则这将是一个先有鸡还是先有蛋的问题：在身份验证之前，所有用户都是匿名的。
- The ‘by self write’ ACL grants write access to the **userPassword** attribute to users who authenticated as the DN where the attribute lives. In other words, users can update the **userPassword** attribute of their own entries.
  “自写”ACL 将对 userPassword 属性的写入访问权限授予作为该属性所在的 DN 进行身份验证的用户。换句话说，用户可以更新自己条目的 userPassword 属性。
- The **userPassword** attribute is otherwise inaccessible by all other users, with the  exception of the Root DN, who always has access and doesn’t need to be  mentioned explicitly.
  否则，所有其他用户都无法访问 userPassword 属性，但根 DN 除外，根 DN 始终具有访问权限，无需显式提及。
- In order for users to change their own password, using `passwd` or other utilities, the user’s own **shadowLastChange** attribute needs to be writable. All other directory users get to read this attribute’s contents.
  为了让用户更改自己的密码、using `passwd` 或其他实用程序，用户自己的 shadowLastChange 属性需要是可写的。所有其他目录用户都可以读取此属性的内容。

This DIT can be searched anonymously because of `to * by * read` in this ACL, which grants read access to everything else, by anyone (including anonymous):
此 DIT 可以匿名搜索，因为 `to * by * read` 在此 ACL 中，任何人（包括匿名）都授予对其他所有内容的读取访问权限：

```plaintext
to *
    by * read
```

If this is unwanted then you need to change the ACL. To force  authentication during a bind request you can alternatively (or in  combination with the modified ACL) use the `olcRequire: authc` directive.
如果这是不需要的，则需要更改 ACL。若要在绑定请求期间强制进行身份验证，也可以（或与修改后的 ACL 结合使用）使用该 `olcRequire: authc` 指令。

## SASL identity SASL 标识

There is no administrative account (“Root DN”) created for the `slapd-config` database. There is, however, a SASL identity that is granted full access to it. It represents the localhost’s superuser (`root`/`sudo`). Here it is:
没有为 `slapd-config` 数据库创建管理帐户（“根 DN”）。但是，有一个 SASL 身份被授予对其的完全访问权限。它表示 localhost 的超级用户 （ `root` / `sudo` ）。在这里：

```plaintext
dn.exact=gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth 
```

The following command will display the ACLs of the `slapd-config` database:
以下命令将显示 `slapd-config` 数据库的 ACL：

```bash
$ sudo ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b \
cn=config '(olcDatabase={0}config)' olcAccess
    
dn: olcDatabase={0}config,cn=config
olcAccess: {0}to * by dn.exact=gidNumber=0+uidNumber=0,cn=peercred,
              cn=external,cn=auth manage by * break
```

Since this is a SASL identity we need to use a SASL **mechanism** when invoking the LDAP utility in question – the **EXTERNAL** mechanism (see the previous command for an example). Note that:
由于这是一个 SASL 身份，因此在调用相关 LDAP 实用程序时，我们需要使用 SASL 机制 – EXTERNAL 机制（有关示例，请参阅前面的命令）。请注意：

- You must use `sudo` to become the root identity in order for the ACL to match.
  您必须使用 `sudo` to 成为根标识，ACL 才能匹配。
- The EXTERNAL mechanism works via **Interprocess Communication** (IPC, UNIX domain sockets). This means you must use the `ldapi` URI format.
  EXTERNAL 机制通过进程间通信（IPC、UNIX 域套接字）工作。这意味着您必须使用 `ldapi` URI 格式。

A succinct way to get all the ACLs is like this:
获取所有 ACL 的简洁方法是这样的：

```bash
$ sudo ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b \
cn=config '(olcAccess=*)' olcAccess olcSuffix
```

## Next steps 后续步骤

See how to [set up LDAP users and groups](https://ubuntu.com/server/docs/how-to-set-up-ldap-users-and-groups).
了解如何设置 LDAP 用户和组。

## Further reading 延伸阅读

- See the man page for [slapd.access](http://manpages.ubuntu.com/manpages/slapd.access.html).
  请参见 slapd.access 的手册页。
- The [access control topic](https://openldap.org/doc/admin25/guide.html#Access Control) in the OpenLDAP administrator’s guide.
  OpenLDAP 管理员指南中的访问控制主题。

# OpenLDAP replication OpenLDAP 复制

The LDAP service becomes increasingly important as more networked systems  begin to depend on it. In such an environment, it is standard practice  to build redundancy (high availability) into LDAP to prevent disruption  should the LDAP server become unresponsive. This is done through **LDAP replication**.
随着越来越多的网络系统开始依赖LDAP服务，LDAP服务变得越来越重要。在这样的环境中，标准做法是在 LDAP 中构建冗余（高可用性），以防止在 LDAP 服务器无响应时中断。这是通过 LDAP 复制完成的。

Replication is achieved via the Sync replication engine, **syncrepl**. This allows changes to be synchronised using a *Consumer - Provider* model. A detailed description of this replication mechanism can be found in the [OpenLDAP administrator’s guide](https://openldap.org/doc/admin24/guide.html#LDAP Sync Replication) and in its defining [RFC 4533](http://www.rfc-editor.org/rfc/rfc4533.txt).
复制是通过同步复制引擎 syncrepl 实现的。这允许使用使用者 - 提供者模型同步更改。有关此复制机制的详细说明，请参阅 OpenLDAP 管理员指南及其定义 RFC 4533。

There are two ways to use this replication:
有两种方法可以使用此复制：

- **Standard replication**: Changed entries are sent to the consumer in their entirety. For example, if the `userPassword` attribute of the `uid=john,ou=people,dc=example,dc=com` entry changed, then the whole entry is sent to the consumer.
  标准复制：更改的条目将完整地发送给使用者。例如，如果 `uid=john,ou=people,dc=example,dc=com` 条目的 `userPassword` 属性发生更改，则整个条目将发送给使用者。
- **Delta replication**: Only the actual change is sent, instead of the whole entry.
  增量复制：仅发送实际更改，而不是整个条目。

The delta replication sends less data over the network, but is more complex to set up. We will show both in this guide.
增量复制通过网络发送的数据较少，但设置起来更复杂。我们将在本指南中展示两者。

> **Important**: 重要：
>  You **must** have Transport Layer Security (TLS) enabled already before proceeding with this guide. Please consult the [LDAP with TLS guide](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls) for details of how to set this up.
> 在继续执行本指南之前，必须已启用传输层安全性 （TLS）。有关如何设置的详细信息，请参阅带有 TLS 的 LDAP 指南。

## Provider configuration - replication user 提供程序配置 - 复制用户

Both replication strategies will need a replication user, as well as updates to the ACLs and limits regarding this user. To create the replication  user, save the following contents to a file called `replicator.ldif`:
这两种复制策略都需要一个复制用户，以及 ACL 的更新和有关此用户的限制。若要创建复制用户，请将以下内容保存到名为 `replicator.ldif` ：

```plaintext
dn: cn=replicator,dc=example,dc=com
objectClass: simpleSecurityObject
objectClass: organizationalRole
cn: replicator
description: Replication user
userPassword: {CRYPT}x
```

Then add it with `ldapadd`:
然后添加它： `ldapadd` 

```bash
$ ldapadd -x -ZZ -D cn=admin,dc=example,dc=com -W -f replicator.ldif
Enter LDAP Password:
adding new entry "cn=replicator,dc=example,dc=com"
```

Now set a password for it with `ldappasswd`:
现在为 `ldappasswd` 它设置密码：

```bash
$ ldappasswd -x -ZZ -D cn=admin,dc=example,dc=com -W -S cn=replicator,dc=example,dc=com
New password:
Re-enter new password:
Enter LDAP Password:
```

The next step is to give this replication user the correct privileges, i.e.:
下一步是授予此复制用户正确的权限，即：

- Read access to the content that we want replicated
  对要复制的内容的读取访问权限
- No search limits on this content
  此内容没有搜索限制

For that we need to update the ACLs on the provider. Since ordering  matters, first check what the existing ACLs look like on the `dc=example,dc=com` tree:
为此，我们需要更新提供程序上的 ACL。由于排序很重要，因此首先检查现有 ACL 在 `dc=example,dc=com` 树上的外观：

```bash
$ sudo ldapsearch -Q -Y EXTERNAL -H ldapi:/// -LLL -b cn=config '(olcSuffix=dc=example,dc=com)' olcAccess
dn: olcDatabase={1}mdb,cn=config
olcAccess: {0}to attrs=userPassword by self write by anonymous auth by * none
olcAccess: {1}to attrs=shadowLastChange by self write by * read
olcAccess: {2}to * by * read
```

What we need is to insert a new rule before the first one, and also adjust the limits for the replicator user. Prepare the `replicator-acl-limits.ldif` file with this content:
我们需要在第一个规则之前插入一个新规则，并调整复制器用户的限制。准备包含以下内容的文件 `replicator-acl-limits.ldif` ：

```plaintext
dn: olcDatabase={1}mdb,cn=config
changetype: modify
add: olcAccess
olcAccess: {0}to *
  by dn.exact="cn=replicator,dc=example,dc=com" read
  by * break
-
add: olcLimits
olcLimits: dn.exact="cn=replicator,dc=example,dc=com"
  time.soft=unlimited time.hard=unlimited
  size.soft=unlimited size.hard=unlimited
```

And add it to the server:
并将其添加到服务器：

```bash
$ sudo ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f replicator-acl-limits.ldif
modifying entry "olcDatabase={1}mdb,cn=config"
```

## Provider configuration - standard replication 提供程序配置 - 标准复制

The remaining configuration for the provider using standard replication is to add the `syncprov` overlay on top of the `dc=example,dc=com` database.
使用标准复制的提供程序的其余配置是在 `dc=example,dc=com` 数据库之上添加 `syncprov` 覆盖。

Create a file called `provider_simple_sync.ldif` with this content:
创建一个使用以下内容调用 `provider_simple_sync.ldif` 的文件：

```plaintext
# Add indexes to the frontend db.
dn: olcDatabase={1}mdb,cn=config
changetype: modify
add: olcDbIndex
olcDbIndex: entryCSN eq
-
add: olcDbIndex
olcDbIndex: entryUUID eq

#Load the syncprov module.
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: syncprov

# syncrepl Provider for primary db
dn: olcOverlay=syncprov,olcDatabase={1}mdb,cn=config
changetype: add
objectClass: olcOverlayConfig
objectClass: olcSyncProvConfig
olcOverlay: syncprov
olcSpCheckpoint: 100 10
olcSpSessionLog: 100
```

> **Customisation warning**: 自定义警告：
>  The LDIF above has some parameters that you should review before deploying in production on your directory. In particular – `olcSpCheckpoint` and `olcSpSessionLog`.
> 上面的 LDIF 包含一些参数，在目录的生产环境中部署之前，应查看这些参数。特别是 - `olcSpCheckpoint` 和 `olcSpSessionLog` .
>  Please see the [slapo-syncprov(5) man page](http://manpages.ubuntu.com/manpages/man5/slapo-syncprov.5.html). In general, `olcSpSessionLog` should be equal to (or preferably larger than) the number of entries in your directory. Also see [ITS #8125](https://www.openldap.org/its/index.cgi/?findid=8125) for details on an existing bug.
> 请参见 slapo-syncprov（5） 手册页。通常， `olcSpSessionLog` 应等于（或最好大于）目录中的条目数。另请参阅 ITS #8125 以获取有关现有 bug 的详细信息。

Add the new content:
添加新内容：

```bash
sudo ldapadd -Q -Y EXTERNAL -H ldapi:/// -f provider_simple_sync.ldif
```

The Provider is now configured.
提供程序现已配置完毕。

## Consumer configuration - standard replication 使用者配置 - 标准复制

Install the software by going through [the installation steps](https://ubuntu.com/server/docs/install-and-configure-ldap#heading--installation). Make sure schemas and the database suffix are the same, and [enable TLS](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls#heading--certs-for-consumer).
通过安装步骤安装软件。确保架构和数据库后缀相同，并启用 TLS。

Create an LDIF file with the following contents and name it `consumer_simple_sync.ldif`:
创建一个包含以下内容的 LDIF 文件并将其 `consumer_simple_sync.ldif` 命名为：

```plaintext
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: syncprov

dn: olcDatabase={1}mdb,cn=config
changetype: modify
add: olcDbIndex
olcDbIndex: entryUUID eq
-
add: olcSyncrepl
olcSyncrepl: rid=0
  provider=ldap://ldap01.example.com
  bindmethod=simple
  binddn="cn=replicator,dc=example,dc=com" credentials=<secret>
  searchbase="dc=example,dc=com"
  schemachecking=on
  type=refreshAndPersist retry="60 +"
  starttls=critical tls_reqcert=demand
-
add: olcUpdateRef
olcUpdateRef: ldap://ldap01.example.com
```

Ensure the following attributes have the correct values:
确保以下属性具有正确的值：

- **`provider`**: Provider server’s hostname – `ldap01.example.com` in this example – or IP address. It must match what is presented in the provider’s SSL certificate.
   `provider` ：提供程序服务器的主机名（ `ldap01.example.com` 在本例中）或 IP 地址。它必须与提供程序的 SSL 证书中显示的内容匹配。
- **`binddn`**: The bind DN for the replicator user.
   `binddn` ：复制器用户的绑定 DN。
- **`credentials`**: The password you selected for the replicator user.
   `credentials` ：您为复制器用户选择的密码。
- **`searchbase`**: The database suffix you’re using, i.e., content that is to be replicated.
   `searchbase` ：您正在使用的数据库后缀，即要复制的内容。
- **`olcUpdateRef`**: Provider server’s hostname or IP address, given to clients if they try to write to this consumer.
   `olcUpdateRef` ：提供商服务器的主机名或 IP 地址，如果客户端尝试写入此使用者，则提供给客户端。
- **`rid`**: Replica ID, a unique 3-digit ID that identifies the replica. Each consumer should have at least one `rid`.
   `rid` ：副本 ID，用于标识副本的唯一 3 位 ID。每个消费者至少应该有一个 `rid` .

> **Note**: 注意：
>  A successful encrypted connection via `START_TLS` is being enforced in this configuration, to avoid sending the credentials in the clear across the network. See [LDAP with TLS](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls) for details on how to set up OpenLDAP with trusted SSL certificates.
> 在此配置中强制执行成功的加密连接 `START_TLS` ，以避免通过网络以明文形式发送凭据。有关如何使用受信任的 SSL 证书设置 OpenLDAP 的详细信息，请参阅使用 TLS 的 LDAP。

Add the new configuration:
添加新配置：

```bash
sudo ldapadd -Q -Y EXTERNAL -H ldapi:/// -f consumer_simple_sync.ldif
```

Now you’re done! The `dc=example,dc=com` tree should now be synchronising.
现在你完成了！树 `dc=example,dc=com` 现在应该正在同步。

## Provider configuration - delta replication 提供程序配置 - 增量复制

The remaining provider configuration for delta replication is:
增量复制的其余提供程序配置为：

- Create a new database called `accesslog`
  创建一个名为 `accesslog` 
- Add the `syncprov` overlay on top of the `accesslog` and `dc=example,dc=com` databases
  在 `accesslog` 和 `dc=example,dc=com` 数据库之上添加 `syncprov` 覆盖
- Add the `accesslog` overlay on top of the `dc=example,dc=com` database
  在 `dc=example,dc=com` 数据库顶部添加 `accesslog` 覆盖

### Add `syncprov` and `accesslog` overlays and DBs 添加 `syncprov` 和 `accesslog` 叠加以及数据库

Create an LDIF file with the following contents and name it `provider_sync.ldif`:
创建一个包含以下内容的 LDIF 文件并将其 `provider_sync.ldif` 命名为：

```plaintext
# Add indexes to the frontend db.
dn: olcDatabase={1}mdb,cn=config
changetype: modify
add: olcDbIndex
olcDbIndex: entryCSN eq
-
add: olcDbIndex
olcDbIndex: entryUUID eq
    
#Load the syncprov and accesslog modules.
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: syncprov
-
add: olcModuleLoad
olcModuleLoad: accesslog
    
# Accesslog database definitions
dn: olcDatabase={2}mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: {2}mdb
olcDbDirectory: /var/lib/ldap/accesslog
olcSuffix: cn=accesslog
olcRootDN: cn=admin,dc=example,dc=com
olcDbIndex: default eq
olcDbIndex: entryCSN,objectClass,reqEnd,reqResult,reqStart
olcAccess: {0}to * by dn.exact="cn=replicator,dc=example,dc=com" read by * break
olcLimits: dn.exact="cn=replicator,dc=example,dc=com"
  time.soft=unlimited time.hard=unlimited
  size.soft=unlimited size.hard=unlimited
    
# Accesslog db syncprov.
dn: olcOverlay=syncprov,olcDatabase={2}mdb,cn=config
changetype: add
objectClass: olcOverlayConfig
objectClass: olcSyncProvConfig
olcOverlay: syncprov
olcSpNoPresent: TRUE
olcSpReloadHint: TRUE
    
# syncrepl Provider for primary db
dn: olcOverlay=syncprov,olcDatabase={1}mdb,cn=config
changetype: add
objectClass: olcOverlayConfig
objectClass: olcSyncProvConfig
olcOverlay: syncprov
olcSpCheckpoint: 100 10
olcSpSessionLog: 100
    
# accesslog overlay definitions for primary db
dn: olcOverlay=accesslog,olcDatabase={1}mdb,cn=config
objectClass: olcOverlayConfig
objectClass: olcAccessLogConfig
olcOverlay: accesslog
olcAccessLogDB: cn=accesslog
olcAccessLogOps: writes
olcAccessLogSuccess: TRUE
# scan the accesslog DB every day, and purge entries older than 7 days
olcAccessLogPurge: 07+00:00 01+00:00
```

> **Customisation warning**: 自定义警告：
>  The LDIF above has some parameters that you should review before deploying in production on your directory. In particular – `olcSpCheckpoint`, `olcSpSessionLog`.
> 上面的 LDIF 包含一些参数，在目录的生产环境中部署之前，应查看这些参数。特别是 – `olcSpCheckpoint` ， `olcSpSessionLog` .
>  Please see the [slapo-syncprov(5) manpage](http://manpages.ubuntu.com/manpages/man5/slapo-syncprov.5.html). In general, `olcSpSessionLog` should be equal to (or preferably larger than) the number of entries in your directory. Also see [ITS #8125](https://www.openldap.org/its/index.cgi/?findid=8125) for details on an existing bug.
> 请参见 slapo-syncprov（5） 手册页。通常， `olcSpSessionLog` 应等于（或最好大于）目录中的条目数。另请参阅 ITS #8125 以获取有关现有 bug 的详细信息。
>  For `olcAccessLogPurge`, please check the [slapo-accesslog(5) manpage](http://manpages.ubuntu.com/manpages/man5/slapo-accesslog.5.html).
> 请 `olcAccessLogPurge` 查看 slapo-accesslog（5） 手册页。

Create a directory: 创建目录：

```bash
sudo -u openldap mkdir /var/lib/ldap/accesslog
```

Add the new content:
添加新内容：

```bash
sudo ldapadd -Q -Y EXTERNAL -H ldapi:/// -f provider_sync.ldif
```

The Provider is now configured.
提供程序现已配置完毕。

## Consumer configuration 使用者配置

Install the software by going through [the installation steps](https://ubuntu.com/server/docs/install-and-configure-ldap#heading--installation). Make sure schemas and the database suffix are the same, and [enable TLS](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls#heading--certs-for-consumer).
通过安装步骤安装软件。确保架构和数据库后缀相同，并启用 TLS。

Create an LDIF file with the following contents and name it `consumer_sync.ldif`:
创建一个包含以下内容的 LDIF 文件并将其 `consumer_sync.ldif` 命名为：

```plaintext
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: syncprov
    
dn: olcDatabase={1}mdb,cn=config
changetype: modify
add: olcDbIndex
olcDbIndex: entryUUID eq
-
add: olcSyncrepl
olcSyncrepl: rid=0
  provider=ldap://ldap01.example.com
  bindmethod=simple
  binddn="cn=replicator,dc=example,dc=com" credentials=<secret>
  searchbase="dc=example,dc=com"
  logbase="cn=accesslog"
  logfilter="(&(objectClass=auditWriteObject)(reqResult=0))"
  schemachecking=on
  type=refreshAndPersist retry="60 +"
  syncdata=accesslog
  starttls=critical tls_reqcert=demand
-
add: olcUpdateRef
olcUpdateRef: ldap://ldap01.example.com
```

Ensure the following attributes have the correct values:
确保以下属性具有正确的值：

- **`provider`**: Provider server’s hostname – `ldap01.example.com` in this example – or IP address. It must match what is presented in the provider’s SSL certificate.
   `provider` ：提供程序服务器的主机名（ `ldap01.example.com` 在本例中）或 IP 地址。它必须与提供程序的 SSL 证书中显示的内容匹配。
- **`binddn`**: The bind DN for the replicator user.
   `binddn` ：复制器用户的绑定 DN。
- **`credentials`**: The password you selected for the replicator user.
   `credentials` ：您为复制器用户选择的密码。
- **`searchbase`**: The database suffix you’re using, i.e., content that is to be replicated.
   `searchbase` ：您正在使用的数据库后缀，即要复制的内容。
- **`olcUpdateRef`**: Provider server’s hostname or IP address, given to clients if they try to write to this consumer.
   `olcUpdateRef` ：提供商服务器的主机名或 IP 地址，如果客户端尝试写入此使用者，则提供给客户端。
- **rid**: Replica ID, a unique 3-digit ID that identifies the replica. Each consumer should have at least one `rid`.
  rid：副本 ID，用于标识副本的唯一 3 位 ID。每个消费者至少应该有一个 `rid` .

> **Note**: 注意：
>  Note that a successful encrypted connection via `START_TLS` is being enforced in this configuration, to avoid sending the credentials in the clear across the network. See [LDAP with TLS](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls) for details on how to set up OpenLDAP with trusted SSL certificates.
> 请注意，在此配置中强制执行成功的加密连接 `START_TLS` ，以避免通过网络以明文形式发送凭据。有关如何使用受信任的 SSL 证书设置 OpenLDAP 的详细信息，请参阅使用 TLS 的 LDAP。

Add the new configuration:
添加新配置：

```bash
sudo ldapadd -Q -Y EXTERNAL -H ldapi:/// -f consumer_sync.ldif
```

You’re done! The `dc=example,dc=com` tree should now be synchronising.
大功告成！树 `dc=example,dc=com` 现在应该正在同步。

## Testing 测试

Once replication starts, you can monitor it by running:
复制开始后，可以通过运行以下命令来监视它：

```bash
$ ldapsearch -z1 -LLL -x -s base -b dc=example,dc=com contextCSN
dn: dc=example,dc=com
contextCSN: 20200423222317.722667Z#000000#000#000000
```

On both the provider and the consumer. Once the `contextCSN` value for both match, both trees are in sync. Every time a change is  done in the provider, this value will change and so should the one in  the consumer(s).
在提供者和消费者身上。一旦两者 `contextCSN` 的值匹配，两棵树就会同步。每次在提供程序中进行更改时，此值都会更改，使用者中的值也应更改。

If your connection is slow and/or your LDAP database large, it might take a while for the consumer’s `contextCSN` match the provider’s. But, you will know it is progressing since the consumer’s `contextCSN` will be steadily increasing.
如果您的连接速度较慢和/或您的 LDAP 数据库很大，则消费者可能需要一段时间才能 `contextCSN` 与提供商匹配。但是，您会知道它正在进步，因为消费者的将 `contextCSN` 稳步增长。

If the consumer’s `contextCSN` is missing or does not match the provider, you should stop and figure out the issue before continuing. Try checking the `slapd` entries in `/var/log/syslog` in the provider to see if the consumer’s authentication requests were  successful, or that its requests to retrieve data return no errors. In  particular, verify that you can connect to the provider from the  consumer as the replicator BindDN using `START_TLS`:
如果消费者的 `contextCSN` 缺失或与提供商不匹配，则应停止并找出问题所在，然后再继续。尝试在提供程序中签入 `/var/log/syslog` 条目 `slapd` ，以查看使用者的身份验证请求是否成功，或者其检索数据的请求是否未返回任何错误。具体而言，请验证是否可以使用以下命令 `START_TLS` 从使用者作为复制器 BindDN 连接到提供程序：

```bash
ldapwhoami -x -ZZ -D cn=replicator,dc=example,dc=com -W -h ldap01.example.com
```

For our example, you should now see the `john` user in the replicated tree:
对于我们的示例，您现在应该在复制树中看到用户 `john` ：

```bash
$ ldapsearch -x -LLL -b dc=example,dc=com -h ldap02.example.com '(uid=john)' uid
dn: uid=john,ou=People,dc=example,dc=com
uid: john
```

## References 引用

- [Replication types, OpenLDAP Administrator’s Guide
  《OpenLDAP 管理员指南》中的复制类型](https://openldap.org/doc/admin24/guide.html#Configuring the different replication types)
- [LDAP Sync Replication - OpenLDAP Administrator’s Guide
  LDAP 同步复制 - OpenLDAP 管理员指南](https://openldap.org/doc/admin24/guide.html#LDAP Sync Replication)
- [RFC 4533](http://www.rfc-editor.org/rfc/rfc4533.txt). RFC 4533 中。

# How to set up LDAP users and groups 如何设置 LDAP 用户和组

Once you [have a working LDAP server](https://ubuntu.com/server/docs/install-and-configure-ldap), you will need to install libraries on the client that know how and when to contact it. On Ubuntu, this was traditionally done by installing the `libnss-ldap` package, but nowadays you should use the [System Security Services Daemon (SSSD)](https://ubuntu.com/server/docs/introduction-to-network-user-authentication-with-sssd). To find out how to use LDAP with SSSD, refer to [our SSSD and LDAP](https://ubuntu.com/server/docs/how-to-set-up-sssd-with-ldap) guide.
一旦你有一个工作的LDAP服务器，你就需要在客户端上安装知道如何以及何时联系它的库。在 Ubuntu 上，这传统上是通过安装 `libnss-ldap` 软件包来完成的，但现在您应该使用系统安全服务守护程序 （SSSD）。要了解如何将 LDAP 与 SSSD 配合使用，请参阅我们的 SSSD 和 LDAP 指南。

## User and group management - `ldapscripts` 用户和组管理 - `ldapscripts` 

A common use case for an LDAP server is to store UNIX user and group  information in the directory. There are many tools out there, and big  deployments will usually develop their own. However, as a quick and easy way to get started with storing user and group information in OpenLDAP, you can use the `ldapscripts` package.
LDAP 服务器的一个常见用例是将 UNIX 用户和组信息存储在目录中。市面上有很多工具，大型部署通常会开发自己的工具。但是，作为开始在 OpenLDAP 中存储用户和组信息的快速简便方法，您可以使用该 `ldapscripts` 软件包。

### Install ldapscripts 安装 ldapscripts

You can install `ldapscripts` by running the following command:
您可以通过运行以下命令进行安装 `ldapscripts` ：

```bash
sudo apt install ldapscripts
```

Then edit the file `/etc/ldapscripts/ldapscripts.conf` to arrive at something similar to the following:
然后编辑文件 `/etc/ldapscripts/ldapscripts.conf` 以达到类似于以下内容的内容：

```plaintext
SERVER=ldap://ldap01.example.com
LDAPBINOPTS="-ZZ"
BINDDN='cn=admin,dc=example,dc=com'
BINDPWDFILE="/etc/ldapscripts/ldapscripts.passwd"
SUFFIX='dc=example,dc=com'
GSUFFIX='ou=Groups'
USUFFIX='ou=People'
MSUFFIX='ou=Computers'
```

> **Note**: 注意：
>  Adjust **SERVER** and related **SUFFIX** options to suit your directory structure.
> 调整 SERVER 和相关后缀选项以适合您的目录结构。
>  Here, we are forcing use of **START_TLS** (`-ZZ` parameter). Refer to [LDAP with TLS](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls) to learn how to set up the server with TLS support.
> 在这里，我们强制使用 START_TLS （ `-ZZ` parameter）。请参阅使用 TLS 的 LDAP，了解如何设置支持 TLS 的服务器。

Store the `cn=admin` password in the `/etc/ldapscripts/ldapscripts.passwd` file and make sure it’s only readable by the *root* local user:
将 `cn=admin` 密码存储在 `/etc/ldapscripts/ldapscripts.passwd` 文件中，并确保只有 root 本地用户才能读取：

```bash
 echo -n 'password' | sudo tee /etc/ldapscripts/ldapscripts.passwd
sudo chmod 400 /etc/ldapscripts/ldapscripts.passwd
```

> **Note**: 注意：
>  The password file must contain exactly and only the password characters, no end-of-line or anything else. The `echo` command above with the `-n` paremeter achieves that by supressing the *EOL* character `\n`. And in order to prevent the password from appearing in the shell history, the *echo* command line is prefixed by a space.
> 密码文件必须完全且仅包含密码字符，不能包含行尾或其他任何内容。上面带有 `-n` paremeter `echo` 的命令通过抑制 EOL 字符 `\n` 来实现这一点。并且为了防止密码出现在 shell 历史记录中，echo 命令行以空格为前缀。

The scripts are now ready to help manage your directory.
这些脚本现在已准备就绪，可帮助管理您的目录。

## Manage users and groups with ldapscripts 使用 ldapscripts 管理用户和组

Here are some brief examples you can use to manage users and groups using `ldapscripts`.
下面是一些简短的示例，可用于管理用户和组 `ldapscripts` 。

### Create a new user 创建新用户

```bash
sudo ldapaddgroup george
sudo ldapadduser george george
```

This will create a group and user with name “george” and set the user’s primary group (*gid*) to “george” as well.
这将创建一个名为“george”的组和用户，并将用户的主要组 （gid） 设置为“george”。

### Change a user’s password 更改用户密码

```bash
$ sudo ldapsetpasswd george

Changing password for user uid=george,ou=People,dc=example,dc=com
New Password: 
Retype New Password: 
Successfully set password for user uid=george,ou=People,dc=example,dc=com
```

## Delete a user 删除用户

```bash
sudo ldapdeleteuser george
```

Note that this won’t delete the user’s primary group, but will remove the user from supplementary ones.
请注意，这不会删除用户的主要组，但会将用户从补充组中删除。

## Add a group 添加组

```bash
sudo ldapaddgroup qa
```

## Delete a group 删除群组

```bash
sudo ldapdeletegroup qa
```

## Add a user to a group 将用户添加到组

```bash
sudo ldapaddusertogroup george qa
```

You should now see a `memberUid` attribute for the `qa` group with a value of `george`.
现在，您应该会看到值为 的 `qa` `george` 组的 `memberUid` 属性。

## Remove a user from a group 从组中删除用户

```bash
sudo ldapdeleteuserfromgroup george qa
```

The `memberUid` attribute should now be removed from the `qa` group.
现在应从 `qa` 组中删除该 `memberUid` 属性。

## Manage user attributes with `ldapmodifyuser` 使用 `ldapmodifyuser` 

The `ldapmodifyuser` script allows you to add, remove, or replace a user’s attributes. The script uses the same syntax as the `ldapmodify` utility. For example:
该 `ldapmodifyuser` 脚本允许您添加、删除或替换用户的属性。该脚本使用与 `ldapmodify` 实用程序相同的语法。例如：

```bash
sudo ldapmodifyuser george
# About to modify the following entry :
dn: uid=george,ou=People,dc=example,dc=com
objectClass: account
objectClass: posixAccount
cn: george
uid: george
uidNumber: 10001
gidNumber: 10001
homeDirectory: /home/george
loginShell: /bin/bash
gecos: george
description: User account
userPassword:: e1NTSEF9eXFsTFcyWlhwWkF1eGUybVdFWHZKRzJVMjFTSG9vcHk=
        
# Enter your modifications here, end with CTRL-D.
dn: uid=george,ou=People,dc=example,dc=com
replace: gecos
gecos: George Carlin
```

The user’s `gecos` should now be “George Carlin”.
用户现在 `gecos` 应该是“George Carlin”。

## `ldapscripts` templates `ldapscripts` 模板

A nice feature of `ldapscripts` is the template system. Templates allow you to customise the attributes of user, group, and machine objects. For example, to enable the `user` template, edit `/etc/ldapscripts/ldapscripts.conf` by changing:
一个很好的功能 `ldapscripts` 是模板系统。模板允许您自定义用户、组和计算机对象的属性。例如，要启用 `user` 模板，请通过更改以下内容进行编辑 `/etc/ldapscripts/ldapscripts.conf` ：

```plaintext
UTEMPLATE="/etc/ldapscripts/ldapadduser.template"
```

There are sample templates in the `/usr/share/doc/ldapscripts/examples` directory. Copy or rename the `ldapadduser.template.sample` file to `/etc/ldapscripts/ldapadduser.template`:
 `/usr/share/doc/ldapscripts/examples` 目录中有示例模板。将 `ldapadduser.template.sample` 文件复制或重命名为 `/etc/ldapscripts/ldapadduser.template` ：

```bash
sudo cp /usr/share/doc/ldapscripts/examples/ldapadduser.template.sample \
/etc/ldapscripts/ldapadduser.template
```

Edit the new template to add the desired attributes. The following will create new users with an `objectClass` of `inetOrgPerson`:
编辑新模板以添加所需的属性。以下将创建具有 `objectClass` of 的新 `inetOrgPerson` 用户：

```plaintext
dn: uid=<user>,<usuffix>,<suffix>
objectClass: inetOrgPerson
objectClass: posixAccount
cn: <user>
sn: <ask>
uid: <user>
uidNumber: <uid>
gidNumber: <gid>
homeDirectory: <home>
loginShell: <shell>
gecos: <user>
description: User account
title: Employee
```

Notice the `<ask>` option used for the **sn** attribute. This will make `ldapadduser` prompt you for its value.
请注意用于 sn 属性的 `<ask>` 选项。这将使 `ldapadduser` 提示您了解其价值。

There are utilities in the package that were not covered here. This command will output a list of them:
软件包中有一些实用程序未在此处介绍。此命令将输出它们的列表：

```bash
dpkg -L ldapscripts | grep /usr/sbin
```

## Next steps 后续步骤

Now that you know how to set up and modify users and groups, it’s a good idea to secure your LDAP communication by [setting up Transport Layer Security (TLS)](https://ubuntu.com/server/docs/ldap-and-transport-layer-security-tls).
现在，您已经知道如何设置和修改用户和组，最好通过设置传输层安全性 （TLS） 来保护 

# LDAP and Transport Layer Security (TLS) LDAP 和传输层安全性 （TLS）

When authenticating to an OpenLDAP server it is best to do so using an  encrypted session. This can be accomplished using Transport Layer  Security (TLS).
在对OpenLDAP服务器进行身份验证时，最好使用加密会话进行身份验证。这可以使用传输层安全性 （TLS） 来实现。

Here, we will be our own Certificate Authority (CA) and then create and sign  our LDAP server certificate as that CA. This guide will use the `certtool` utility to complete these tasks. For simplicity, this is being done on  the OpenLDAP server itself, but your real internal CA should be  elsewhere.
在这里，我们将成为我们自己的证书颁发机构 （CA），然后创建并签署我们的 LDAP 服务器证书作为该 CA。本指南将使用该 `certtool` 实用程序来完成这些任务。为简单起见，这是在OpenLDAP服务器本身上完成的，但真正的内部CA应该在其他地方。

Install the `gnutls-bin` and `ssl-cert` packages:
安装 `gnutls-bin` 和 `ssl-cert` 包：

```bash
sudo apt install gnutls-bin ssl-cert
```

Create a private key for the Certificate Authority:
为证书颁发机构创建私钥：

```bash
sudo certtool --generate-privkey --bits 4096 --outfile /etc/ssl/private/mycakey.pem
```

Create the template/file `/etc/ssl/ca.info` to define the CA:
创建模板/文件 `/etc/ssl/ca.info` 以定义 CA：

```plaintext
cn = Example Company
ca
cert_signing_key
expiration_days = 3650
```

Create the self-signed CA certificate:
创建自签名 CA 证书：

```bash
sudo certtool --generate-self-signed \
--load-privkey /etc/ssl/private/mycakey.pem \
--template /etc/ssl/ca.info \
--outfile /usr/local/share/ca-certificates/mycacert.crt
```

> **Note**: 注意：
>  Yes, the `--outfile` path is correct. We are writing the CA certificate to `/usr/local/share/ca-certificates`. This is where `update-ca-certificates` will pick up trusted local CAs from. To pick up CAs from `/usr/share/ca-certificates`, a call to `dpkg-reconfigure ca-certificates` is necessary.
> 是的， `--outfile` 路径是正确的。我们正在将 CA 证书写入 `/usr/local/share/ca-certificates` 。这是从中获取受信任的本地 CA 的位置 `update-ca-certificates` 。要从 `/usr/share/ca-certificates` 中获取 CA，需要调用 `dpkg-reconfigure ca-certificates` 。

Run `update-ca-certificates` to add the new CA certificate to the list of trusted CAs. Note the one added CA:
运行 `update-ca-certificates` 以将新的 CA 证书添加到受信任的 CA 列表中。请注意添加的 CA：

```bash
$ sudo update-ca-certificates
Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d...
done.
```

This also creates a `/etc/ssl/certs/mycacert.pem` symlink pointing to the real file in `/usr/local/share/ca-certificates`.
这还会创建一个指向 中实际文件的 `/etc/ssl/certs/mycacert.pem` `/usr/local/share/ca-certificates` 符号链接。

Make a private key for the server:
为服务器创建私钥：

```bash
sudo certtool --generate-privkey \
--bits 2048 \
--outfile /etc/ldap/ldap01_slapd_key.pem
```

> **Note**: 注意：
>  Replace `ldap01` in the filename with your server’s hostname. Naming the certificate and key for the host and service that will be using them will help keep  things clear.
> 将文件名替换 `ldap01` 为服务器的主机名。为将使用它们的主机和服务命名证书和密钥将有助于保持清晰。

Create the `/etc/ssl/ldap01.info` info file containing:
创建包含以下内容的信息 `/etc/ssl/ldap01.info` 文件：

```plaintext
organization = Example Company
cn = ldap01.example.com
tls_www_server
encryption_key
signing_key
expiration_days = 365
```

The above certificate is good for 1 year, and it’s valid only for the `ldap01.example.com` hostname. You can adjust this according to your needs.
上述证书有效期为 1 年，仅对 `ldap01.example.com` 主机名有效。您可以根据需要进行调整。

Create the server’s certificate:
创建服务器的证书：

```bash
sudo certtool --generate-certificate \
--load-privkey /etc/ldap/ldap01_slapd_key.pem \
--load-ca-certificate /etc/ssl/certs/mycacert.pem \
--load-ca-privkey /etc/ssl/private/mycakey.pem \
--template /etc/ssl/ldap01.info \
--outfile /etc/ldap/ldap01_slapd_cert.pem
```

Adjust permissions and ownership:
调整权限和所有权：

```bash
sudo chgrp openldap /etc/ldap/ldap01_slapd_key.pem
sudo chmod 0640 /etc/ldap/ldap01_slapd_key.pem
```

Your server is now ready to accept the new TLS configuration.
您的服务器现在已准备好接受新的 TLS 配置。

Create the file `certinfo.ldif` with the following contents (adjust paths and filenames accordingly):
创建包含以下内容的文件 `certinfo.ldif` （相应地调整路径和文件名）：

```plaintext
dn: cn=config
add: olcTLSCACertificateFile
olcTLSCACertificateFile: /etc/ssl/certs/mycacert.pem
-
add: olcTLSCertificateFile
olcTLSCertificateFile: /etc/ldap/ldap01_slapd_cert.pem
-
add: olcTLSCertificateKeyFile
olcTLSCertificateKeyFile: /etc/ldap/ldap01_slapd_key.pem
```

Use the `ldapmodify` command to tell `slapd` about our TLS work via the `slapd-config` database:
使用命令 `ldapmodify` 通过 `slapd-config` 数据库讲述 `slapd` 我们的 TLS 工作：

```bash
sudo ldapmodify -Y EXTERNAL -H ldapi:/// -f certinfo.ldif
```

If you need access to **LDAPS** (LDAP over SSL), then you need to edit `/etc/default/slapd` and include `ldaps:///` in `SLAPD_SERVICES` like below:
如果您需要访问LDAPS（基于SSL的LDAP），则需要编辑 `/etc/default/slapd` 并包含 `ldaps:///` 以下 `SLAPD_SERVICES` 内容：

```plaintext
SLAPD_SERVICES="ldap:/// ldapi:/// ldaps:///"
```

And restart `slapd` with:
然后 `slapd` 重新启动：

```bash
sudo systemctl restart slapd
```

Note that *StartTLS* will be available without the change above, and does NOT need a `slapd` restart.
请注意，StartTLS 无需上述更改即可使用，并且不需要 `slapd` 重新启动。

Test *StartTLS*: 测试 StartTLS：

```bash
$ ldapwhoami -x -ZZ -H ldap://ldap01.example.com
anonymous
```

Test LDAPS: 测试 LDAPS：

```bash
$ ldapwhoami -x -H ldaps://ldap01.example.com
anonymous
```

## Certificate for an OpenLDAP replica OpenLDAP 副本的证书

To generate a certificate pair for an OpenLDAP replica (consumer), create a holding directory (which will be used for the eventual transfer) and  run the following:
要为 OpenLDAP 副本（使用者）生成证书对，请创建一个保存目录（将用于最终传输）并运行以下命令：

```bash
mkdir ldap02-ssl
cd ldap02-ssl
certtool --generate-privkey \
--bits 2048 \
--outfile ldap02_slapd_key.pem
```

Create an info file, `ldap02.info`, for the Consumer server, adjusting its values according to your requirements:
为 Consumer 服务器创建一个信息文件 `ldap02.info` ，并根据您的要求调整其值：

```bash
organization = Example Company
cn = ldap02.example.com
tls_www_server
encryption_key
signing_key
expiration_days = 365
```

Create the Consumer’s certificate:
创建使用者的证书：

```bash
    sudo certtool --generate-certificate \
    --load-privkey ldap02_slapd_key.pem \
    --load-ca-certificate /etc/ssl/certs/mycacert.pem \
    --load-ca-privkey /etc/ssl/private/mycakey.pem \
    --template ldap02.info \
    --outfile ldap02_slapd_cert.pem
```

> **Note**: 注意：
>  We had to use `sudo` to get access to the CA’s private key. This means the generated  certificate file is owned by root. You should change that ownership back to your regular user before copying these files over to the Consumer.
> 我们必须使用它 `sudo` 来访问 CA 的私钥。这意味着生成的证书文件归 root 所有。在将这些文件复制到使用者之前，您应该将该所有权更改回您的普通用户。

Get a copy of the CA certificate:
获取 CA 证书的副本：

```bash
cp /etc/ssl/certs/mycacert.pem .
```

We’re done. Now transfer the `ldap02-ssl` directory to the Consumer. Here we use `scp` (adjust accordingly):
大功告成。现在将 `ldap02-ssl` 目录传输到 Consumer。在这里我们使用 `scp` （相应地调整）：

```bash
cd ..
scp -r ldap02-ssl user@consumer:
```

On the Consumer side, install the certificate files you just transferred:
在消费者端，安装刚刚传输的证书文件：On the Consumer side， install the certificate files you just transferred：

```bash
sudo cp ldap02_slapd_cert.pem ldap02_slapd_key.pem /etc/ldap
sudo chgrp openldap /etc/ldap/ldap02_slapd_key.pem
sudo chmod 0640 /etc/ldap/ldap02_slapd_key.pem
sudo cp mycacert.pem /usr/local/share/ca-certificates/mycacert.crt
sudo update-ca-certificates
```

Create the file `certinfo.ldif` with the following contents (adjust accordingly regarding paths and filenames, if needed):
创建包含以下内容的文件 `certinfo.ldif` （如果需要，请相应地调整路径和文件名）：

```plaintext
dn: cn=config
add: olcTLSCACertificateFile
olcTLSCACertificateFile: /etc/ssl/certs/mycacert.pem
-
add: olcTLSCertificateFile
olcTLSCertificateFile: /etc/ldap/ldap02_slapd_cert.pem
-
add: olcTLSCertificateKeyFile
olcTLSCertificateKeyFile: /etc/ldap/ldap02_slapd_key.pem
```

Configure the `slapd-config` database:
配置 `slapd-config` 数据库：

```bash
sudo ldapmodify -Y EXTERNAL -H ldapi:/// -f certinfo.ldif
```

Like before, if you want to enable LDAPS, edit `/etc/default/slapd` and add `ldaps:///` to `SLAPD_SERVICES`, and then restart `slapd`.
和以前一样，如果要启用 LDAPS，请编辑 `/etc/default/slapd` 并添加到 `ldaps:///` `SLAPD_SERVICES` ，然后重新启动 `slapd` 。

Test *StartTLS*: 测试 StartTLS：

```bash
$ ldapwhoami -x -ZZ -H ldap://ldap02.example.com
anonymous
```

Test LDAPS: 测试 LDAPS：

```bash
$ ldapwhoami -x -H ldaps://ldap02.example.com
anonymous
```









OpenLDAP 2.3 及更高版本已过渡到使用动态运行时配置引擎 slapd-config（5）。

slapd-config（5）：

* is fully LDAP-enabled 已完全启用LDAP
* 使用标准 LDAP 操作进行管理
* 将其配置数据存储在 LDIF 数据库中，通常存储在 `/usr/local/etc/openldap/slapd.d` 目录中。
* 允许随时更改 slapd 的所有配置选项，通常不需要重新启动服务器即可使更改生效。

旧风格的 slapd.conf（5）文件仍然受支持，但它的使用已被弃用，并且在未来的 OpenLDAP 版本中将取消对它的支持。

> **Note:** 
>
> 尽管 slapd-config（5）系统将其配置存储为（基于文本的）LDIF 文件，但永远不应该直接编辑任何 LDIF 文件。配置更改应通过 LDAP 操作执行，例如ldapadd（1）、ldapdelete（1）或 ldapmodify（1）。对于脱机修改（当服务器未运行时），请使用 slapadd（8）和 slapmodify（8）。
>
> ou will need to continue to use the older *slapd.conf*(5) configuration system if your OpenLDAP installation requires the use of  one or more backends or overlays that have not been updated to use the *slapd-config*(5) system.  As of OpenLDAP 2.4.33, all of the official backends have been  updated.  There may be additional contributed or experimental overlays  that also have not been updated.
>
> 如果 OpenLDAP 安装需要使用一个或多个尚未更新为使用 slapd-config（5）系统的后端或覆盖，则需要继续使用旧的 slapd.conf（5）配置系统。截至OpenLDAP 2.4.33，所有官方后端都已更新。可能还有其他贡献的或实验性的叠加也没有更新。

## 配置布局

The slapd configuration is stored as a special LDAP directory with a  predefined schema and DIT. There are specific objectClasses used to  carry global configuration options, schema definitions, backend and  database definitions, and assorted other items. A sample config tree is  shown in Figure 5.1.

slapd 配置存储为一个具有预定义模式和 DIT 的特殊 LDAP 目录。有一些特定的对象类用于承载全局配置选项、模式定义、后端和数据库定义以及各种其他项。一个示例配置树如图所示。

 ![](../../../../Image/config_dit.png)

Other objects may be part of the configuration but were omitted from the illustration for clarity.其他物体可能是配置的一部分，但为了清楚起见，从图示中省略了。

slapd-config 配置树有一个非常具体的结构。该树的根名为 `cn=config` ，包含全局配置设置。其他设置包含在单独的子条目中：

- 动态加载的模块

  只有在使用 `--enable modules` 选项配置软件时，才能使用这些选项。

- 模式定义

  `cn=schema,cn=config`条目包含系统模式（所有在 slapd 中硬编码的模式）。

  `cn=chema,cn=config` 的子条目包含从配置文件加载或在运行时添加的用户模式。

- 特定于后端的配置

- 数据库特定配置

  Overlays are defined in children of the Database entry. 

  套印格式是在数据库条目的子项中定义的。

  Databases and Overlays may also have other miscellaneous children.

  数据库和套印格式也可能有其他杂项子项。

LDIF 文件的常规规则适用于配置信息：以 `#` 字符开头的注释行将被忽略。如果一行以单个空格开头，则它被视为前一行的延续（即使前一行是注释），并且单个前导空格被删除。条目用空行分隔。

配置 LDIF 的总体布局如下：

```ini
# global configuration settings
dn: cn=config
objectClass: olcGlobal
cn: config
<global config settings>

# schema definitions
dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema
<system schema>

dn: cn={X}core,cn=schema,cn=config
objectClass: olcSchemaConfig
cn: {X}core
<core schema>

# additional user-specified schema
...

# backend definitions
dn: olcBackend=<typeA>,cn=config
objectClass: olcBackendConfig
olcBackend: <typeA>
<backend-specific settings>

# database definitions
dn: olcDatabase={X}<typeA>,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {X}<typeA>
<database-specific settings>

# subsequent definitions and settings
...
```

上面列出的一些条目的名称中有一个数字索引 `｛X｝` 。虽然大多数配置设置都有固有的排序依赖关系（即，一个设置必须在设置下一个设置之前生效），但 LDAP 数据库本质上是无序的。数字索引用于在配置数据库中强制执行一致的排序，以便保留所有排序依赖项。在大多数情况下，不必提供索引；它将根据创建条目的顺序自动生成。

配置指令被指定为各个属性的值。slapd 配置中使用的大多数属性和对象类的名称中都有一个前缀 `olc`（OpenLDAP Configuration)。通常，属性和旧式的 slapd.conf 配置关键字之间存在一对一的对应关系，使用关键字作为属性名称，并附加 `olc` 前缀。

配置指令可以采用参数。如果是这样的话，参数之间用空格隔开。如果一个参数包含空格，那么该参数应该用双引号括起来。在下面的描述中，应该用实际文本替换的参数显示在方括号 `<>` 中。

该分发版包含一个示例配置文件，该文件将安装在 `/usr/local/etc/openldap` 目录中。`/usr/local/etc/openldap/schema` 目录中还提供了许多包含模式定义（属性类型和对象类）的文件。

## 配置指令

### `cn=config`

此条目中包含的指令通常适用于整个服务器。其中大多数是面向系统或连接的，与数据库无关。此条目必须具有 `olcGlobal` 对象类。

#### `olcIdleTimeout: <integer>`

指定强制关闭空闲客户端连接之前等待的秒数。默认值 0 将禁用此功能。

#### `olcLogLevel: <level>`

此指令指定应将日志语句和操作统计信息发送到 syslog（当前记录到 syslogd（8）`LOG_LOCAL4` 工具）的级别。您必须配置了OpenLDAP `--enable-debug` （默认设置）才能正常工作，但始终启用的两个统计级别除外。日志级别可以指定为整数，也可以指定为关键字。可使用多个日志级别，并且这些级别是相加的。`＜level＞` 的可能值为：

| **Level** | **Keyword**    | **Description**                                              |
| --------- | -------------- | ------------------------------------------------------------ |
| -1        | any            | enable all debugging                                         |
| 0         |                | no debugging                                                 |
| 1         | (0x1 trace)    | trace function calls                                         |
| 2         | (0x2 packets)  | debug packet handling                                        |
| 4         | (0x4 args)     | heavy trace debugging                                        |
| 8         | (0x8 conns)    | connection management                                        |
| 16        | (0x10 BER)     | print out packets sent and received                          |
| 32        | (0x20 filter)  | search filter processing                                     |
| 64        | (0x40 config)  | configuration processing                                     |
| 128       | (0x80 ACL)     | access control list processing                               |
| 256       | (0x100 stats)  | stats log connections/operations/results                     |
| 512       | (0x200 stats2) | stats log entries sent                                       |
| 1024      | (0x400 shell)  | print communication with shell backends                      |
| 2048      | (0x800 parse)  | print entry parsing debugging                                |
| 16384     | (0x4000 sync)  | syncrepl consumer processing                                 |
| 32768     | (0x8000 none)  | only messages that get logged regardless of configured log level |

The desired log level can be input as a single integer that combines  the (ORed) desired levels, both in decimal or in hexadecimal notation,  as a list of integers (that are ORed internally), or as a list of the  names that are shown between brackets, such that所需的日志级别可以作为单个整数输入，该整数组合了（ORed）所需级别（十进制或十六进制表示法）、整数列表（内部 ORed）或括号之间显示的名称列表，以下是等效的。

```ini
olcLogLevel 129
olcLogLevel 0x81
olcLogLevel 128 1
olcLogLevel 0x80 0x1
olcLogLevel acl trace
```

示例：

```ini
olcLogLevel -1
# 这将启用所有日志级别。

olcLogLevel conns filter
# 只需记录连接和搜索筛选器处理。

olcLogLevel none
# 记录那些已记录的消息，而不考虑配置的日志级别。这与在不进行日志记录时将日志级别设置为0不同。至少需要“无”级别才能记录高优先级消息。
```

默认：

```ini
olcLogLevel stats
```

Basic stats logging is configured by default.默认情况下配置为记录基本统计。

#### `olcReferral <URI>`

This directive specifies the referral to pass back when slapd cannot find a local database to handle a request.此指令指定当slapd找不到本地数据库来处理请求时要传递回的引用。

示例：

```
olcReferral: ldap://root.openldap.org
```

This will refer non-local queries to the global root LDAP server at  the OpenLDAP Project. Smart LDAP clients can re-ask their query at that  server, but note that most of these clients are only going to know how  to handle simple LDAP URLs that contain a host part and optionally a  distinguished name part.

这将把非本地查询引用到Open LDAP项目中的全局根LDAP服务器。智能LDAP客户端可以在该服务器上重新询问他们的查询，但请注意，这些客户端中的大多数只知道如何处理包含主机部分和可选的可分辨名称部分的简单LDAP URL。

#### 样本

```ini
dn: cn=config
objectClass: olcGlobal
cn: config
olcIdleTimeout: 30
olcLogLevel: Stats
olcReferral: ldap://root.openldap.org
```

### cn=module

如果在配置 slapd 时启用了对动态加载模块的支持，则可以使用 `cn=module` 条目来指定要加载的模块集。模块条目必须具有 `olcModuleList` 对象类。

#### `olcModuleLoad: <filename>`

指定要加载的动态可加载模块的名称。文件名可以是绝对路径名，也可以是简单的文件名。Non-absolute names are searched for in the directories specified by the `olcModulePath` directive.在 `olcModulePath` 指令指定的目录中搜索非绝对名称。

#### `olcModulePath: <pathspec>`

指定要搜索可加载模块的目录列表。路径通常以冒号分隔，但这取决于操作系统。

#### 样本

```ini
dn: cn=module{0},cn=config
objectClass: olcModuleList
cn: module{0}
olcModuleLoad: /usr/local/lib/smbk5pwd.la

dn: cn=module{1},cn=config
objectClass: olcModuleList
cn: module{1}
olcModulePath: /usr/local/lib:/usr/local/lib/slapd
olcModuleLoad: accesslog.la
olcModuleLoad: pcache.la
```

### `cn=schema`

cn=schema 条目包含所有在 slapd 中硬编码的模式定义。因此，该条目中的值是由 slapd 生成的，因此不需要在配置文件中提供模式值。但是，该条目仍然必须定义，以作为要在下面添加的用户定义模式的基础。架构条目必须具有 `olcSchemaConfig` 对象类。

####  `olcAttributeTypes: <RFC4512 Attribute Type Description>`

此指令定义属性类型。

####  `olcObjectClasses: <RFC4512 Object Class Description>`

此指令定义一个对象类。

#### 样本

```ini
dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema

dn: cn=test,cn=schema,cn=config
objectClass: olcSchemaConfig
cn: test
olcAttributeTypes: ( 1.1.1
  NAME 'testAttr'
  EQUALITY integerMatch
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )
olcAttributeTypes: ( 1.1.2 NAME 'testTwo' EQUALITY caseIgnoreMatch
  SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.44 )
olcObjectClasses: ( 1.1.3 NAME 'testObject'
  MAY ( testAttr $ testTwo ) AUXILIARY )
```

### 特定于后端的指令

后端指令适用于相同类型的所有数据库实例，并且根据指令的不同，可能会被数据库指令覆盖。后端条目必须具有 `olcBackendConfig` 对象类。

#### `olcBackend: <type>`

此指令命名后端特定的配置条目。`<type>`应该是表中列出的受支持的后端类型之一。

| **Types**  | **Description**                                       |
| ---------- | ----------------------------------------------------- |
| `asyncmet` | a Asynchronous Metadirectory backend                  |
| `config`   | Slapd configuration backend                           |
| `dnssrv`   | DNS SRV backend                                       |
| `ldap`     | Lightweight Directory Access Protocol (Proxy) backend |
| `ldif`     | Lightweight Data Interchange Format backend           |
| `mdb`      | Memory-Mapped DB backend                              |
| `meta`     | Metadirectory backend                                 |
| `monitor`  | Monitor backend                                       |
| `null`     | Null backend                                          |
| `passwd`   | Provides read-only access to *passwd*(5)              |
| `perl`     | Perl Programmable backend                             |
| `relay`    | Relay backend                                         |
| `sock`     | Socket backend                                        |
| `sql`      | SQL Programmable backend                              |
| `wt`       | WiredTiger backend                                    |

示例：

```ini
olcBackend: mdb
```

这标志着一个新的 MDB 后端定义的开始。目前，只有 back-mdb 实现这种类型的任何选项，因此任何其他后端都不需要此设置。

#### 样本

```ini
dn: olcBackend=mdb,cn=config
objectClass: olcBackendConfig
olcBackend: mdb
olcBkMdbIdlExp: 16
```

### 数据库特定指令

每种类型的数据库都支持本节中的指令。数据库条目必须具有 `olcDatabaseConfig` 对象类。

#### `olcDatabase: [{<index>}]<type>`

此指令命名特定的数据库实例。使用数字 {<index>} 来区分相同类型的多个数据库。通常可以省略索引，slapd会自动生成索引。`<type>` 应该是上表中列出的受支持的后端类型之一或 `frontend` 类型。

`frontend` 是一个特殊的数据库，用于保存应应用于所有其他数据库的数据库级别选项。后续的数据库定义也可能覆盖某些前端设置。

`config` 数据库也是特殊的；`config` 和 `frontend` 数据库总是隐式创建的，即使它们没有显式配置，而且它们是在任何其他数据库之前创建的。

示例：

```ini
olcDatabase: mdb
```

这标志着一个新的MDB数据库实例的开始。

#### `olcAccess: to <what> [ by <who> [<accesslevel>] [<control>] ]+`

此指令授予一个或多个请求者（由 <who> 指定）对一组条目和/或属性（由 <what> 指定）的访问权限（由 <accesslevel> 指定）。

> **Note:**
>
> 如果未指定 `olcAccess` 指令，则默认的访问控制策略 `to * by * read` 允许所有用户（包括经过身份验证的用户和匿名用户）进行读取访问。
>
> Access controls defined in the frontend are appended to all other databases' controls.
>
> 前端中定义的访问控件附加到所有其他数据库的控件中。

#### `olcReadonly { TRUE | FALSE }`

此指令将数据库置于“只读”模式。任何修改数据库的尝试都将返回一个“不愿意执行”的错误。如果在使用者上设置，syncrepl 发送的修改仍将发生。

默认：

```ini
olcReadonly: FALSE
```

#### `olcRootDN: <DN>`

This directive specifies the DN that is not subject to access control or administrative limit restrictions for operations on this database.   The DN need not refer to an entry in this database or even in the  directory. The DN may refer to a SASL identity.

此指令指定对该数据库的操作不受访问控制或管理限制的 DN。DN 不需要引用该数据库中的条目，甚至不需要引用目录中的条目。DN 可以指 SASL 标识。

基于条目的示例：

```ini
olcRootDN: cn=Manager,dc=example,dc=com
```

基于 SASL 的示例：

```ini
olcRootDN: uid=root,cn=example.com,cn=digest-md5,cn=auth
```

#### `olcRootPW: <password>`

This directive can be used to specify a password for the DN for the rootdn (when the rootdn is set to a DN within the database).此指令可用于为 rootdn 的 DN 指定密码（当 rootdn 在数据库中设置为 DN 时）。

示例：

```ini
olcRootPW: secret
```

还允许以 RFC2307 的形式提供密码的散列。slappasswd（8）可以用于生成密码散列。

示例：

```ini
olcRootPW: {SSHA}ZKKuqbEKJfKSXhUbHG3fG8MDn9j1v4QN
```

该哈希是使用命令 `slappasswd -s secret` 生成的。

#### `olcSizeLimit: <integer>`

此指令指定从搜索操作返回的最大条目数。

默认：

```ini
olcSizeLimit: 500
```

#### `olcSuffix: <dn suffix>`

此指令指定将传递到此后端数据库的查询的 DN 后缀。可以给出多个后缀行，通常每个数据库定义至少需要一个后缀行。（某些后端类型，如 `frontend` 和 `monitor` ，使用硬编码后缀，该后缀在配置中可能不会被覆盖。）

示例：

```ini
olcSuffix: dc=example,dc=com
```

Queries with a DN ending in "dc=example,dc=com" will be passed to this backend.

DN 以“dc=example，dc=com” 结尾的查询将传递到此后端。

> **Note:** 
>
> When the backend to pass a query to is selected,  slapd looks at the suffix value(s) in each database definition in the  order in which they were configured. Thus, if one database suffix is a  prefix of another, it must appear after it in the configuration.
>
> 当选择要将查询传递到的后端时，slapd 会按照配置的顺序查看每个数据库定义中的后缀值。因此，如果一个数据库后缀是另一个数据库的前缀，那么它必须出现在配置中的后面。

#### `olcSyncrepl`

```ini
olcSyncrepl: rid=<replica ID>
       provider=ldap[s]://<hostname>[:port]
       [type=refreshOnly|refreshAndPersist]
       [interval=dd:hh:mm:ss]
       [retry=[<retry interval> <# of retries>]+]
       searchbase=<base DN>
       [filter=<filter str>]
       [scope=sub|one|base]
       [attrs=<attr list>]
       [exattrs=<attr list>]
       [attrsonly]
       [sizelimit=<limit>]
       [timelimit=<limit>]
       [schemachecking=on|off]
       [bindmethod=simple|sasl]
       [binddn=<DN>]
       [saslmech=<mech>]
       [authcid=<identity>]
       [authzid=<identity>]
       [credentials=<passwd>]
       [realm=<realm>]
       [secprops=<properties>]
       [starttls=yes|critical]
       [tls_cert=<file>]
       [tls_key=<file>]
       [tls_cacert=<file>]
       [tls_cacertdir=<path>]
       [tls_reqcert=never|allow|try|demand]
       [tls_cipher_suite=<ciphers>]
       [tls_crlcheck=none|peer|all]
       [logbase=<base DN>]
       [logfilter=<filter str>]
       [syncdata=default|accesslog|changelog]
```

This directive specifies the current database as a consumer of the provider content by establishing the current *slapd*(8) as a replication consumer site running a syncrepl replication engine.  此指令通过将当前slapd（8）建立为运行syncrepl复制引擎的复制使用者站点，将当前数据库指定为提供程序内容的使用者。The provider database is located at the provider site specified by the `provider` parameter. 提供程序数据库位于提供程序参数指定的提供程序站点。The consumer database is kept up-to-date with the provider  content using the LDAP Content Synchronization protocol. 消费者数据库使用LDAP内容同步协议与提供者内容保持最新。有关该协议的更多信息，请参阅 RFC4533 。

The `rid` parameter is used for identification of the current `syncrepl` directive within the replication consumer server, where `<replica ID>` uniquely identifies the syncrepl specification described by the current `syncrepl` directive. `<replica ID>` is non-negative and is no more than three decimal digits in length.`rid` 参数用于标识复制使用者服务器中的当前syncrepl指令，其中＜replica ID＞唯一标识由当前syncrepl指令描述的syncrepl规范<副本ID>为非负数，长度不超过三位小数。

The `provider` parameter specifies the replication provider site containing the provider content as an LDAP URI. The `provider` parameter specifies a scheme, a host and optionally a port where the  provider slapd instance can be found. Either a domain name or IP address may be used for <hostname>. Examples are `ldap://provider.example.com:389` or `ldaps://192.168.1.1:636`. If <port> is not given, the standard LDAP port number (389 or  636) is used. Note that the syncrepl uses a consumer-initiated protocol, and hence its specification is located on the consumer.

provider参数将包含提供程序内容的复制提供程序站点指定为LDAP URI。provider参数指定了一个方案、一个主机以及一个可以在其中找到provider  slapd实例的端口（可选）。＜主机名＞可以使用域名或IP地址。例如ldap://provider.example.com:389或ldaps://192.168.1.1:636.如果未给定＜port＞，则使用标准LDAP端口号（389或636）。请注意，syncrepl使用消费者发起的协议，因此其规范位于消费者上。

The content of the syncrepl consumer is defined using a search  specification as its result set. The consumer slapd will send search  requests to the provider slapd according to the search specification.  The search specification includes `searchbase`, `scope`, `filter`, `attrs`, `exattrs`, `attrsonly`, `sizelimit`, and `timelimit` parameters as in the normal search specification. The `searchbase` parameter has no default value and must always be specified. The `scope` defaults to `sub`, the `filter` defaults to `(objectclass=*)`, `attrs` defaults to `"*,+"` to replicate all user and operational attributes, and `attrsonly` is unset by default. Both `sizelimit` and `timelimit` default to "unlimited", and only positive integers or "unlimited" may be specified. The `exattrs` option may also be used to specify attributes that should be omitted from incoming entries.

syncrepl使用者的内容是使用搜索规范作为其结果集来定义的。消费者slapd将根据搜索规范向提供者slapd发送搜索请求。搜索规范包括普通搜索规范中的searchbase、scope、filter、attrs、exattrs、attrsonly、sizelimit和timelimit参数。searchbase参数没有默认值，必须始终指定。作用域默认为sub，筛选器默认为（objectclass=*），attrs默认为“*，+”以复制所有用户和操作属性，attrsonly默认为未设置。sizelimit和timelimit都默认为“unlimited”，并且只能指定正整数或“unlimite”。exattrs选项也可以用于指定应该从传入条目中省略的属性。

The LDAP Content Synchronization protocol has two operation types: `refreshOnly` and `refreshAndPersist`. The operation type is specified by the `type` parameter. In the `refreshOnly` operation, the next synchronization search operation is periodically  rescheduled at an interval time after each synchronization operation  finishes. The interval is specified by the `interval` parameter. It is set to one day by default. In the `refreshAndPersist` operation, a synchronization search remains persistent in the provider *slapd* instance. Further updates to the provider will generate `searchResultEntry` to the consumer slapd as the search responses to the persistent synchronization search.

LDAP内容同步协议有两种操作类型：refresh Only和refresh and  Persist。操作类型由类型参数指定。在“仅刷新”操作中，在每个同步操作完成后的某个间隔时间，会定期重新安排下一个同步搜索操作。间隔由间隔参数指定。默认情况下设置为一天。在刷新和持久化操作中，同步搜索在提供者slapd实例中保持持久。对提供者的进一步更新将为使用者生成搜索结果条目，作为对持久同步搜索的搜索响应。

If an error occurs during replication, the consumer will attempt to  reconnect according to the retry parameter which is a list of the  <retry interval> and <# of retries> pairs. For example,  retry="60 10 300 3" lets the consumer retry every 60 seconds for the  first 10 times and then retry every 300 seconds for the next three times before stop retrying. + in <#  of retries> means indefinite  number of retries until success.

如果复制过程中发生错误，使用者将尝试根据retry参数重新连接，该参数是和<#of retries>对的列表。例如，retry=“60 10 300 3”允许使用者在前10次中每60秒重试一次，然后在停止重试之前，在接下来的三次中每300秒重试一次。+在＜重试次数＞中，表示在成功之前重试的次数不确定。

The schema checking can be enforced at the LDAP Sync consumer site by turning on the `schemachecking` parameter. If it is turned on, every replicated entry will be checked  for its schema as the entry is stored on the consumer. Every entry in  the consumer should contain those attributes required by the schema  definition. If it is turned off, entries will be stored without checking schema conformance. The default is off.

通过启用schemachecking参数，可以在LDAP  Sync使用者站点强制执行架构检查。如果启用了它，则在条目存储在使用者上时，将检查每个复制的条目的架构。使用者中的每个条目都应该包含模式定义所需的那些属性。如果它被关闭，条目将在不检查模式一致性的情况下被存储。默认设置为禁用。

The `binddn` parameter gives the DN to bind as for the  syncrepl searches to the provider slapd. It should be a DN which has  read access to the replication content in the provider database.

binddn参数为syncrepl搜索提供程序slapd提供了要绑定的DN。它应该是对提供程序数据库中的复制内容具有读取访问权限的DN。

The `bindmethod` is `simple` or `sasl`, depending on whether simple password-based authentication or SASL authentication is to be used when connecting to the provider *slapd* instance.

bindmethod是simple还是sasl，这取决于在连接到提供者slapd实例时使用的是简单的基于密码的身份验证还是sasl身份验证。

Simple authentication should not be used unless adequate data  integrity and confidentiality protections are in place (e.g. TLS or  IPsec). Simple authentication requires specification of `binddn` and `credentials` parameters.

除非有足够的数据完整性和机密性保护（例如TLS或IPsec），否则不应使用简单的身份验证。简单身份验证需要指定binddn和凭据参数。

SASL authentication is generally recommended.  SASL authentication requires specification of a mechanism using the `saslmech` parameter. Depending on the mechanism, an authentication identity and/or credentials can be specified using `authcid` and `credentials`, respectively.  The `authzid` parameter may be used to specify an authorization identity.

通常建议使用SASL身份验证。SASL身份验证需要指定使用saslmech参数的机制。根据机制的不同，可以分别使用authcid和凭据指定身份验证标识和/或凭据。authzid参数可以用于指定授权标识。

The `realm` parameter specifies a realm which a certain mechanisms authenticate the identity within. The `secprops` parameter specifies Cyrus SASL security properties.

realm参数指定一个领域，某些机制在该领域中验证身份。secprops参数指定Cyrus SASL安全财产。

The `starttls` parameter specifies use of the StartTLS  extended operation to establish a TLS session before authenticating to  the provider. If the `critical` argument is supplied, the session will be aborted if the StartTLS request fails.  Otherwise the syncrepl  session continues without TLS.  The tls_reqcert setting defaults to `"demand"` and the other TLS settings default to the same as the main slapd TLS settings.

starttls参数指定在向提供程序进行身份验证之前，使用启动TLS扩展操作来建立TLS会话。如果提供了关键参数，则如果启动TLS请求失败，会话将中止。否则，syncrepl会话将在没有TLS的情况下继续。tls-reqcert设置默认为“demand”，其他tls设置默认为与主slapd tls设置相同。

Rather than replicating whole entries, the consumer can query logs of data modifications.  This mode of operation is referred to as *delta syncrepl*.  In addition to the above parameters, the `logbase` and `logfilter` parameters must be set appropriately for the log that will be used. The `syncdata` parameter must be set to either `"accesslog"` if the log conforms to the *slapo-accesslog*(5) log format, or `"changelog"` if the log conforms to the obsolete *changelog* format. If the `syncdata` parameter is omitted or set to `"default"` then the log parameters are ignored.

消费者可以查询数据修改的日志，而不是复制整个条目。这种操作模式被称为delta syncrepl。除了上述参数外，还必须为将要使用的日志适当设置logbase和logfilter参数。如果日志符合slapo  accesslog（5）日志格式，则syncdata参数必须设置为“accesslog”；如果日志符合过时的更改日志格式，那么syncdata参数则必须设置为”changelog“。如果省略了syncdata参数或将其设置为“默认”，则会忽略日志参数。

syncrepl 复制机制由 mdb 后端支持。

#### `olcTimeLimit: <integer>`

此指令指定 slapd（实时）回答搜索请求所花费的最大秒数。如果请求在此时间内未完成，则会返回一个指示超时的结果。

默认：

```ini
olcTimeLimit: 3600
```

#### `olcUpdateref: <URL>`

此指令仅适用于副本（或卷影）slapd（8）实例。它指定返回到客户端的 URL ，客户端在副本上提交更新请求。如果多次指定，则会提供每个 URL 。

示例：

```ini
olcUpdateref:   ldap://provider.example.net
```

#### 样本

```ini
dn: olcDatabase=frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: frontend
olcReadOnly: FALSE

dn: olcDatabase=config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: config
olcRootDN: cn=Manager,dc=example,dc=com
```

### MDB 后端指令

此类别中的指令仅适用于 MDB 数据库后端。它们将应用于配置中的所有 “database mdb” 实例。

#### 5.2.6.1. olcBkMdbIdlExp <exponent>

Specify a power of 2 for the maximum size of an index slot. The  default is 16, yielding a maximum slot size of 2^16 or 65536. The  specified value must be in the range of 16-30.

This setting helps with the case where certain search filters are  slow to return results due to an index slot having collapsed to a range  value.  This occurs when the number of candidate entries that match the  filter for the index slot exceed the configured slot size.

If this setting is decreased on a server with existing MDB databases, each db will immediately need its indices to be rebuilt while slapd is offline with the "slapindex -q -t" command.

If this setting is increased on a server with existing MDB databases, each db will need its indices rebuilt to take advantage of  the change for indices that have already been converted to ranges.

### 5.2.7. MDB Database Directives

Directives in this category apply to the MDB database  backend. They are used in an olcDatabase entry in addition to the  generic database directives defined above.  For a complete reference of  MDB configuration directives, see *slapd-mdb*(5). In addition to the `olcDatabaseConfig` objectClass, MDB database entries must have the `olcMdbConfig` objectClass.

#### 5.2.7.1. olcDbDirectory: <directory>

This directive specifies the directory where the MDB files containing the database and associated indices live.

Default:

```
        olcDbDirectory: /usr/local/var/openldap-data
```

#### 5.2.7.2. olcDbCheckpoint: <kbyte> <min>

This directive specifies the frequency for flushing the database disk buffers. This directive is only needed if the *olcDbNoSync* option is `TRUE`. The checkpoint will occur if either <kbyte> data has been written or <min> minutes have passed since the last checkpoint. Both  arguments default to zero, in which case they are ignored. When the  <min> argument is non-zero, an internal task will run every  <min> minutes to perform the checkpoint. Note: currently the  _kbyte_ setting is unimplemented.

Example:

```
        olcDbCheckpoint: 1024 10
```

#### 5.2.7.3. olcDbEnvFlags: {nosync,nometasync,writemap,mapasync,nordahead}

This option specifies flags for finer-grained control of  the  LMDB  library's operation.

- `nosync`: This is exactly the same as the dbnosync directive.
- `nometasync`: Flush the data on a commit, but skip the  sync of the meta page. This mode is slightly faster than doing a full  sync, but can potentially lose the last committed transaction if the  operating system crashes. If both nometasync and nosync are set, the  nosync flag takes precedence.
- `writemap`: Use a writable memory map instead of just  read-only. This speeds up write operations but makes the database  vulnerable to corruption in case any bugs in slapd cause stray writes  into the mmap region.
- `mapasync`: When using a writable memory map and  performing flushes on each commit, use an asynchronous flush instead of a synchronous flush (the default). This option has no effect if writemap  has not been set. It also has no effect if nosync is set.
- `nordahead`: Turn off file readahead. Usually the OS  performs readahead on every read request. This usually boosts read  performance but can be harmful to random access read performance if the  system's memory is full and the DB is larger than RAM. This option is  not implemented on Windows.

#### 5.2.7.4. olcDbIndex: {<attrlist> | default} [pres,eq,approx,sub,none]

This directive specifies the indices to maintain for the given attribute. If only an `<attrlist>` is given, the default indices are maintained. The index keywords  correspond to the common types of matches that may be used in an LDAP  search filter.

Example:

```
        olcDbIndex: default pres,eq
        olcDbIndex: uid
        olcDbIndex: cn,sn pres,eq,sub
        olcDbIndex: objectClass eq
```

The first line sets the default set of indices to maintain to present and equality.  The second line causes the default (pres,eq) set of  indices to be maintained for the `uid` attribute type. The third line causes present, equality, and substring indices to be maintained for `cn` and `sn` attribute types.  The fourth line causes an equality index for the `objectClass` attribute type.

There is no index keyword for inequality matches. Generally these  matches do not use an index. However, some attributes do support  indexing for inequality matches, based on the equality index.

A substring index can be more explicitly specified as `subinitial`, `subany`, or `subfinal`, corresponding to the three possible components of a substring match  filter. A subinitial index only indexes substrings that appear at the  beginning of an attribute value. A subfinal index only indexes  substrings that appear at the end of an attribute value, while subany  indexes substrings that occur anywhere in a value.

Note that by default, setting an index for an attribute also affects  every subtype of that attribute. E.g., setting an equality index on the `name` attribute causes `cn`, `sn`, and every other attribute that inherits from `name` to be indexed.

By default, no indices are maintained.  It is generally advised that minimally an equality index upon objectClass be maintained.

```
        olcDbIndex: objectClass eq
```

Additional indices should be configured corresponding to the most  common searches that are used on the database. Presence indexing should  not be configured for an attribute unless the attribute occurs very  rarely in the database, and presence searches on the attribute occur  very frequently during normal use of the directory. Most applications  don't use presence searches, so usually presence indexing is not very  useful.

If this setting is changed while slapd is running, an internal task  will be run to generate the changed index data. All server operations  can continue as normal while the indexer does its work.  If slapd is  stopped before the index task completes, indexing will have to be  manually completed using the slapindex tool.

#### 5.2.7.5. olcDbMaxEntrySize: <bytes>

Specify the maximum size of an entry in bytes. Attempts to store an  entry larger than this size will be rejected with the error  LDAP_ADMINLIMIT_EXCEEDED. The default is 0, which is unlimited.

#### 5.2.7.6. olcDbMaxReaders: <integer>

This directive specifies the maximum number of threads that may have  concurrent read access to the database. Tools such as slapcat count as a single thread, in addition to threads in any active slapd processes.  The default is 126.

#### 5.2.7.7. olcDbMaxSize: <bytes>

This directive specifies the maximum size of the database in bytes. A memory map of this size is allocated at startup time and the database  will not be allowed to grow beyond this size. The default is 10485760  bytes (10MB). This setting may be changed upward if the configured limit needs to be increased.



------

**Note:** It is important to set this to as large a value  as possible, (relative to anticipated growth of the actual data over  time) since growing the size later may not be practical when the system  is under heavy load.

------



#### 5.2.7.8. olcDbMode: { <octal> | <symbolic> }

This directive specifies the file protection mode that newly created database index files should have. This can be in the form `0600` or `-rw-------`

Default:

```
        olcDbMode: 0600
```

#### 5.2.7.9. olcDbMultival: { <attrlist> | default } <integer> hi,<integer> lo

Specify the number of values for which a multivalued attribute is  stored in a separate table. Normally entries are stored as a single blob inside the database. When an entry gets very large or contains  attributes with a very large number of values, modifications on that  entry may get very slow. Splitting the large attributes out to a  separate table can improve the performance of modification operations.  The threshold is specified as a pair of integers. If the number of  values exceeds the hi threshold the values will be split out. If a  modification deletes enough values to bring an attribute below the lo  threshold the values will be removed from the separate table and merged  back into the main entry blob. The threshold can be set for a specific  list of attributes, or the default can be configured for all other  attributes. The default value for both hi and lo thresholds is UINT_MAX, which keeps all attributes in the main blob.

In addition to increasing write performance of operations the use of multival can also decrease fragmentation of the primary MDB database.

#### 5.2.7.10. olcDbRtxnsize: <entries>

This directive specifies the maximum number of entries to process in a single read transaction when executing a large search. Long-lived read  transactions prevent old database pages from being reused in write  transactions, and so can cause significant growth of the database file  when there is heavy write traffic. This setting causes the read  transaction in large searches to be released and reacquired after the  given number of entries has been read, to give writers the opportunity  to reclaim old database pages. The default is 10000.

#### 5.2.7.11. olcDbSearchStack: <integer>

Specify the depth of the stack used for search filter evaluation. Search filters are evaluated on a stack to accommodate nested `AND` / `OR` clauses. An individual stack is allocated for each server thread. The  depth of the stack determines how complex a filter can be evaluated  without requiring any additional memory allocation. Filters that are  nested deeper than the search stack depth will cause a separate stack to be allocated for that particular search operation. These separate  allocations can have a major negative impact on server performance, but  specifying too much stack will also consume a great deal of memory. Each search uses 512K bytes per level on a 32-bit machine, or 1024K bytes  per level on a 64-bit machine. The default stack depth is 16, thus 8MB  or 16MB per thread is used on 32 and 64 bit machines, respectively. Also the 512KB size of a single stack slot is set by a compile-time constant which may be changed if needed; the code must be recompiled for the  change to take effect.

Default:

```
        olcDbSearchStack: 16
```

#### 5.2.7.12. olcDbNosync: { TRUE | FALSE }

This directive causes on-disk database contents to not be immediately synchronized with in memory changes upon change.  Setting this option  to `TRUE` may improve performance at the expense of data integrity.

#### 5.2.7.13. Sample Entry

```
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcSuffix: dc=example,dc=com
olcDbDirectory: /usr/local/var/openldap-data
olcDbIndex: objectClass eq
```









## 5.3. Configuration Example

The following is an example configuration, interspersed with  explanatory text. It defines two databases to handle different parts of  the X.500 tree; both are MDB database  instances. The line numbers shown are provided for reference only and  are not included in the actual file. First, the global configuration  section:

```
  1.    # example config file - global configuration entry
  2.    dn: cn=config
  3.    objectClass: olcGlobal
  4.    cn: config
  5.    olcReferral: ldap://root.openldap.org
  6.
```

Line 1 is a comment. Lines 2-4 identify this as the global configuration entry. The `olcReferral:` directive on line 5 means that queries not local to one of the  databases defined below will be referred to the LDAP server running on  the standard port (389) at the host `root.openldap.org`. Line 6 is a blank line, indicating the end of this entry.

```
  7.    # internal schema
  8.    dn: cn=schema,cn=config
  9.    objectClass: olcSchemaConfig
 10.    cn: schema
 11.
```

Line 7 is a comment. Lines 8-10 identify this as the root of the  schema subtree. The actual schema definitions in this entry are  hardcoded into slapd so no additional attributes are specified here.  Line 11 is a blank line, indicating the end of this entry.

```
 12.    # include the core schema
 13.    include: file:///usr/local/etc/openldap/schema/core.ldif
 14.
```

Line 12 is a comment. Line 13 is an LDIF include directive which accesses the *core* schema definitions in LDIF format. Line 14 is a blank line.

Next comes the database definitions. The first database is the special `frontend` database whose settings are applied globally to all the other databases.

```
 15.    # global database parameters
 16.    dn: olcDatabase=frontend,cn=config
 17.    objectClass: olcDatabaseConfig
 18.    olcDatabase: frontend
 19.    olcAccess: to * by * read
 20.
```

Line 15 is a comment. Lines 16-18 identify this entry as the global  database entry. Line 19 is a global access control. It applies to all  entries (after any applicable database-specific access controls). Line  20 is a blank line.

The next entry defines the config backend.

```
 21.    # set a rootpw for the config database so we can bind.
 22.    # deny access to everyone else.
 23.    dn: olcDatabase=config,cn=config
 24.    objectClass: olcDatabaseConfig
 25.    olcDatabase: config
 26.    olcRootPW: {SSHA}XKYnrjvGT3wZFQrDD5040US592LxsdLy
 27.    olcAccess: to * by * none
 28.
```

Lines 21-22 are comments. Lines 23-25 identify this entry as the config database entry. Line 26 defines the *super-user* password for this database. (The DN defaults to *"cn=config"*.) Line 27 denies all access to this database, so only the super-user will be able to access it. (This is already the default access on the config database. It is just listed here for illustration, and to reiterate  that unless a means to authenticate as the super-user is explicitly  configured, the config database will be inaccessible.)

Line 28 is a blank line.

The next entry defines an MDB backend that will handle queries for  things in the "dc=example,dc=com" portion of the tree. Indices are to be maintained for several attributes, and the `userPassword` attribute is to be protected from unauthorized access.

```
 29.    # MDB definition for example.com
 30.    dn: olcDatabase=mdb,cn=config
 31.    objectClass: olcDatabaseConfig
 32.    objectClass: olcMdbConfig
 33.    olcDatabase: mdb
 34.    olcSuffix: dc=example,dc=com
 35.    olcDbDirectory: /usr/local/var/openldap-data
 36.    olcRootDN: cn=Manager,dc=example,dc=com
 37.    olcRootPW: secret
 38.    olcDbIndex: uid pres,eq
 39.    olcDbIndex: cn,sn pres,eq,approx,sub
 40.    olcDbIndex: objectClass eq
 41.    olcAccess: to attrs=userPassword
 42.      by self write
 43.      by anonymous auth
 44.      by dn.base="cn=Admin,dc=example,dc=com" write
 45.      by * none
 46.    olcAccess: to *
 47.      by self write
 48.      by dn.base="cn=Admin,dc=example,dc=com" write
 49.      by * read
 50.
```

Line 29 is a comment. Lines 30-33 identify this entry as a MDB  database configuration entry.  Line 34 specifies the DN suffix for  queries to pass to this database. Line 35 specifies the directory in  which the database files will live.

Lines 36 and 37 identify the database *super-user* entry and associated password. This entry is not subject to access control or size or time limit restrictions.

Lines 38 through 40 indicate the indices to maintain for various attributes.

Lines 41 through 49 specify access control for entries in this database. For all applicable entries, the `userPassword` attribute is writable by the entry itself and by the "admin" entry.  It may be used for authentication/authorization purposes, but is otherwise not readable. All other attributes are writable by the entry and the  "admin" entry, but may be read by all users (authenticated or not).

Line 50 is a blank line, indicating the end of this entry.

The next entry defines another MDB database. This one handles queries involving the `dc=example,dc=net` subtree but is managed by the same entity as the first database.  Note  that without line 60, the read access would be allowed due to the global access rule at line 19.

```
 51.    # MDB definition for example.net
 52.    dn: olcDatabase=mdb,cn=config
 53.    objectClass: olcDatabaseConfig
 54.    objectClass: olcMdbConfig
 55.    olcDatabase: mdb
 56.    olcSuffix: dc=example,dc=net
 57.    olcDbDirectory: /usr/local/var/openldap-data-net
 58.    olcRootDN: cn=Manager,dc=example,dc=com
 59.    olcDbIndex: objectClass eq
 60.    olcAccess: to * by users read
```

------

## 5.4. Converting old style *slapd.conf*(5) file to *cn=config* format

Before converting to the *cn=config* format you should make  sure that the config backend is properly configured in your existing  config file. While the config backend is always present inside slapd, by default it is only accessible by its rootDN, and there are no default  credentials assigned so unless you explicitly configure a means to  authenticate to it, it will be unusable.

If you do not already have a `database config` section, add something like this to the end of `slapd.conf`

```
 database config
 rootpw VerySecret
```



------

**Note:** Since the config backend can be used to load  arbitrary code into the slapd process, it is extremely important to  carefully guard whatever credentials are used to access it. Since simple passwords are vulnerable to password guessing attacks, it is usually  better to omit the rootpw and only use SASL authentication for the  config rootDN.

------



An existing *slapd.conf*(5) file can be converted to the new format using *slaptest*(8) or any of the slap tools:

```
        slaptest -f /usr/local/etc/openldap/slapd.conf -F /usr/local/etc/openldap/slapd.d
```

Test that you can access entries under `cn=config` using the default *rootdn* and the *rootpw* configured above:

```
        ldapsearch -x -D cn=config -w VerySecret -b cn=config
```

You can then discard the old *slapd.conf*(5) file. Make sure to launch *slapd*(8) with the *-F* option to specify the configuration directory if you are not using the default directory path.



------

**Note:** When converting from the slapd.conf format to  slapd.d format, any included files will also be integrated into the  resulting configuration database.

------



------

## 5.5. Recovering from a broken configuration

If the server using *cn=config* does not start, either because the configuration does not represent the current version or because it  has been corrupted, these actions are available, in the order of  decreasing preference.

Make sure you have made a backup of the "broken" version before you attempt any of these:

### 5.5.1. Generate an ldif version of the configuration database and reload from that

Most of the time, the configuration can be parsed and a text version generated with *slapcat*(8):

```
 slapcat -F /usr/local/etc/openldap/slapd.d -n0 -l extracted_config.ldif
```

After you have backed up and removed the old configuration database  contents, this output ldif can be hand-edited to adjust or remove the  offending entries and imported again:

```
 slapadd -F /usr/local/etc/openldap/slapd.d -l updated_config.ldif
 slaptest -F /usr/local/etc/openldap/slapd.d
```

### 5.5.2. Modify config in-place

If the configuration can be parsed and you know exactly what you need to do, you can use *slapmodify*(8) to effect the required changes directly:

```
 slapmodify -F /usr/local/etc/openldap/slapd.d
 dn: ..., cn=config
 changetype: ...
 ...
```

### 5.5.3. Recover with plain back-ldif

If the configuration contains items that *slapd*(8) cannot process as a *cn=config* database at all, the last resort is to disable schema checking and  operate on it as a regular back-ldif database. This might cease to work  with future versions of OpenLDAP without notice, attempt this only when  all of the above fail.

First, create a directory to serve as the hosting DB and create the structure:

```
 mkdir ./recovery ./recovery/cn=recovery
 cp /usr/local/etc/openldap/slapd.d/cn=config.ldif ./recovery/cn=recovery
 cp -r /usr/local/etc/openldap/slapd.d/cn=config ./recovery/cn=recovery
```

Or, if you have already backed up your old configuration, you can symlink it into place:

```
 mkdir ./recovery
 ln -s /usr/local/etc/openldap/slapd.d ./recovery/cn=recovery
```

Next, create a trivial *slapd.conf*(5) to access the new database:

```
 database ldif
 suffix cn=recovery
 directory ./recovery/
```

Note the change of suffix, `cn=config` is hardcoded to correspond to an active config database, so we have to home it one level deeper - at `cn=config,cn=recovery`.

Now you can use *slapmodify*(8) to modify the database, it is most likely you will need to run with schema checking disabled:

```
 slapmodify -f ./recovery.conf -s
```

You can test the validity of your config with *slaptest*(8):

```
 slaptest -F ./recovery/cn=recovery
```

And generate a full ldif with *slapcat*(8):

```
 slapcat -F ./recovery/cn=recovery -n0
```

# 6. The slapd Configuration File

This chapter describes configuring *slapd*(8) via the *slapd.conf*(5) configuration file.  *slapd.conf*(5) has been deprecated and should only be used if your site requires one  of the backends that hasn't yet been updated to work with the newer *slapd-config*(5) system.  Configuring *slapd*(8) via *slapd-config*(5) is described in the previous chapter.

The *slapd.conf*(5) file is normally installed in the `/usr/local/etc/openldap` directory.  An alternate configuration file location can be specified via a command-line option to *slapd*(8).

------

## 6.1. Configuration File Format

The *slapd.conf*(5) file consists of three types of  configuration information: global, backend specific, and database  specific.  Global information is specified first, followed by  information associated with a particular backend type, which is then  followed by information associated with a particular database instance.  Global directives can be overridden in backend and/or database  directives, and backend directives can be overridden by database  directives.

Blank lines and comment lines beginning with a '`#`' character are ignored.  If a line begins with whitespace, it is considered a  continuation of the previous line (even if the previous line is a  comment).

The general format of slapd.conf is as follows:

```
        # global configuration directives
        <global config directives>

        # backend definition
        backend <typeA>
        <backend-specific directives>

        # first database definition & config directives
        database <typeA>
        <database-specific directives>

        # second database definition & config directives
        database <typeB>
        <database-specific directives>

        # second database definition & config directives
        database <typeA>
        <database-specific directives>

        # subsequent backend & database definitions & config directives
        ...
```

A configuration directive may take arguments.  If so, they are  separated by whitespace.  If an argument contains whitespace, the  argument should be enclosed in double quotes `"like this"`. If an argument contains a double quote or a backslash character ``\`', the character should be preceded by a backslash character ``\`'.

The distribution contains an example configuration file that will be installed in the `/usr/local/etc/openldap` directory. A number of files containing schema definitions (attribute types and object classes) are also provided in the `/usr/local/etc/openldap/schema` directory.

------

## 6.2. Configuration File Directives

This section details commonly used configuration directives.  For a complete list, see the *slapd.conf*(5) manual page.  This section separates the configuration file directives  into global, backend-specific and data-specific categories, describing  each directive and its default value (if any), and giving an example of  its use.

### 6.2.1. Global Directives

Directives described in this section apply to all backends and  databases unless specifically overridden in a backend or database  definition.  Arguments that should be replaced by actual text are shown  in brackets `<>`.

#### 6.2.1.1. access to <what> [ by <who> [<accesslevel>] [<control>] ]+

This directive grants access (specified by <accesslevel>) to a  set of entries and/or attributes (specified by <what>) by one or  more requestors (specified by <who>).  See the [Access Control](https://www.openldap.org/doc/admin26/access-control.html) section of this guide for basic usage.



------

**Note:** If no `access` directives are specified, the default access control policy, `access to * by * read`, allows all both authenticated and anonymous users read access.

------



####  6.2.1.2. attributetype <[RFC4512](https://www.rfc-editor.org/rfc/rfc4512.txt) Attribute Type Description>

This directive defines an attribute type. Please see the [Schema Specification](https://www.openldap.org/doc/admin26/schema.html) chapter for information regarding how to use this directive.

#### 6.2.1.3. idletimeout <integer>

Specify the number of seconds to wait before forcibly closing an idle client connection.  An idletimeout of 0, the default, disables this  feature.

#### 6.2.1.4. include <filename>

This directive specifies that slapd should read additional  configuration information from the given file before continuing with the next line of the current file. The included file should follow the  normal slapd config file format.  The file is commonly used to include  files containing schema specifications.



------

**Note:** You should be careful when using this directive - there is no small limit on the number of nested include directives, and no loop detection is done.

------



#### 6.2.1.5. loglevel <level>

This directive specifies the level at which log statements and  operation statistics should be sent to syslog (currently logged to the *syslogd*(8) `LOG_LOCAL4` facility). You must have configured OpenLDAP `--enable-debug` (the default) for this to work, except for the two statistics levels,  which are always enabled. Log levels may be specified as integers or by  keyword. Multiple log levels may be used and the levels are additive.  The possible values for <integer> are:

| **Level** | **Keyword**    | **Description**                                              |
| --------- | -------------- | ------------------------------------------------------------ |
| -1        | any            | enable all debugging                                         |
| 0         |                | no debugging                                                 |
| 1         | (0x1 trace)    | trace function calls                                         |
| 2         | (0x2 packets)  | debug packet handling                                        |
| 4         | (0x4 args)     | heavy trace debugging                                        |
| 8         | (0x8 conns)    | connection management                                        |
| 16        | (0x10 BER)     | print out packets sent and received                          |
| 32        | (0x20 filter)  | search filter processing                                     |
| 64        | (0x40 config)  | configuration processing                                     |
| 128       | (0x80 ACL)     | access control list processing                               |
| 256       | (0x100 stats)  | stats log connections/operations/results                     |
| 512       | (0x200 stats2) | stats log entries sent                                       |
| 1024      | (0x400 shell)  | print communication with shell backends                      |
| 2048      | (0x800 parse)  | print entry parsing debugging                                |
| 16384     | (0x4000 sync)  | syncrepl consumer processing                                 |
| 32768     | (0x8000 none)  | only messages that get logged regardless of configured log level |

The desired log level can be input as a single integer that combines  the (ORed) desired levels, both in decimal or in hexadecimal notation,  as a list of integers (that are ORed internally), or as a list of the  names that are shown between brackets, such that

```
                loglevel 129
                loglevel 0x81
                loglevel 128 1
                loglevel 0x80 0x1
                loglevel acl trace
```

are equivalent.

Examples:

```
 loglevel -1
```

This will enable all log levels.

```
 loglevel conns filter
```

Just log the connection and search filter processing.

```
 loglevel none
```

Log those messages that are logged regardless of the configured  loglevel. This differs from setting the log level to 0, when no logging  occurs. At least the `None` level is required to have high priority messages logged.

Default:

```
 loglevel stats
```

Basic stats logging is configured by default.

####  6.2.1.6. objectclass <[RFC4512](https://www.rfc-editor.org/rfc/rfc4512.txt) Object Class Description>

This directive defines an object class. Please see the [Schema Specification](https://www.openldap.org/doc/admin26/schema.html) chapter for information regarding how to use this directive.

#### 6.2.1.7. referral <URI>

This directive specifies the referral to pass back when slapd cannot find a local database to handle a request.

Example:

```
        referral ldap://root.openldap.org
```

This will refer non-local queries to the global root LDAP server at  the OpenLDAP Project. Smart LDAP clients can re-ask their query at that  server, but note that most of these clients are only going to know how  to handle simple LDAP URLs that contain a host part and optionally a  distinguished name part.

#### 6.2.1.8. sizelimit <integer>

This directive specifies the maximum number of entries to return from a search operation.

Default:

```
        sizelimit 500
```

See the [Limits](https://www.openldap.org/doc/admin26/limits.html) section of this guide and *slapd.conf*(5) for more details.

#### 6.2.1.9. timelimit <integer>

This directive specifies the maximum number of seconds (in real time) slapd will spend answering a search request. If a request is not  finished in this time, a result indicating an exceeded timelimit will be returned.

Default:

```
        timelimit 3600
```

See the [Limits](https://www.openldap.org/doc/admin26/limits.html) section of this guide and *slapd.conf*(5) for more details.

### 6.2.2. General Backend Directives

Directives in this section apply only to the backend in which they  are defined. They are supported by every type of backend. Backend  directives apply to all databases instances of the same type and,  depending on the directive, may be overridden by database directives.

#### 6.2.2.1. backend <type>

This directive marks the beginning of a backend declaration. `<type>` should be one of the supported backend types listed in Table 6.2.

| **Types**  | **Description**                                       |
| ---------- | ----------------------------------------------------- |
| `asyncmet` | a       Asynchronous Metadirectory backend            |
| `config`   | Slapd configuration backend                           |
| `dnssrv`   | DNS SRV backend                                       |
| `ldap`     | Lightweight Directory Access Protocol (Proxy) backend |
| `ldif`     | Lightweight Data Interchange Format backend           |
| `mdb`      | Memory-Mapped DB backend                              |
| `meta`     | Metadirectory backend                                 |
| `monitor`  | Monitor backend                                       |
| `null`     | Null backend                                          |
| `passwd`   | Provides read-only access to *passwd*(5)              |
| `perl`     | Perl Programmable backend                             |
| `relay`    | Relay backend                                         |
| `sock`     | Socket backend                                        |
| `sql`      | SQL Programmable backend                              |
| `wt`       | WiredTiger backend                                    |

Example:

```
        backend mdb
        idlexp 16
```

This marks the beginning of a new MDB backend  definition. At present, only back-mdb implements any options of this  type, so this setting is not needed for any other backends.

### 6.2.3. General Database Directives

Directives in this section apply only to the database in which they are defined. They are supported by every type of database.

#### 6.2.3.1. database <type>

This directive marks the beginning of a database instance declaration. `<type>` should be one of the supported backend types listed in Table 6.2.

Example:

```
        database mdb
```

This marks the beginning of a new MDB database instance declaration.

#### 6.2.3.2. limits <selector> <limit> [<limit> [...]]

Specify time and size limits based on the operation's initiator or base DN.

See the [Limits](https://www.openldap.org/doc/admin26/limits.html) section of this guide and *slapd.conf*(5) for more details.

#### 6.2.3.3. readonly { on | off }

This directive puts the database into "read-only" mode. Any attempts  to modify the database will return an "unwilling to perform" error.  If  set on a consumer, modifications sent by syncrepl will still occur.

Default:

```
        readonly off
```

#### 6.2.3.4. rootdn <DN>

This directive specifies the DN that is not subject to access control or administrative limit restrictions for operations on this database.   The DN need not refer to an entry in this database or even in the  directory. The DN may refer to a SASL identity.

Entry-based Example:

```
        rootdn "cn=Manager,dc=example,dc=com"
```

SASL-based Example:

```
        rootdn "uid=root,cn=example.com,cn=digest-md5,cn=auth"
```

See the [SASL Authentication](https://www.openldap.org/doc/admin26/sasl.html#SASL Authentication) section for information on SASL authentication identities.

#### 6.2.3.5. rootpw <password>

This directive can be used to specifies a password for the DN for the rootdn (when the rootdn is set to a DN within the database).

Example:

```
        rootpw secret
```

It is also permissible to provide hash of the password in [RFC2307](https://www.rfc-editor.org/rfc/rfc2307.txt) form.  *slappasswd*(8) may be used to generate the password hash.

Example:

```
        rootpw {SSHA}ZKKuqbEKJfKSXhUbHG3fG8MDn9j1v4QN
```

The hash was generated using the command `slappasswd -s secret`.

#### 6.2.3.6. suffix <dn suffix>

This directive specifies the DN suffix of queries that will be passed to this backend database. Multiple suffix lines can be given, and at  least one is required for each database definition.

Example:

```
        suffix "dc=example,dc=com"
```

Queries with a DN ending in "dc=example,dc=com" will be passed to this backend.



------

**Note:** When the backend to pass a query to is selected,  slapd looks at the suffix line(s) in each database definition in the  order they appear in the file. Thus, if one database suffix is a prefix  of another, it must appear after it in the config file.

------



#### 6.2.3.7. syncrepl

```
        syncrepl rid=<replica ID>
                provider=ldap[s]://<hostname>[:port]
                searchbase=<base DN>
                [type=refreshOnly|refreshAndPersist]
                [interval=dd:hh:mm:ss]
                [retry=[<retry interval> <# of retries>]+]
                [filter=<filter str>]
                [scope=sub|one|base]
                [attrs=<attr list>]
                [exattrs=<attr list>]
                [attrsonly]
                [sizelimit=<limit>]
                [timelimit=<limit>]
                [schemachecking=on|off]
                [network-timeout=<seconds>]
                [timeout=<seconds>]
                [bindmethod=simple|sasl]
                [binddn=<DN>]
                [saslmech=<mech>]
                [authcid=<identity>]
                [authzid=<identity>]
                [credentials=<passwd>]
                [realm=<realm>]
                [secprops=<properties>]
                [keepalive=<idle>:<probes>:<interval>]
                [starttls=yes|critical]
                [tls_cert=<file>]
                [tls_key=<file>]
                [tls_cacert=<file>]
                [tls_cacertdir=<path>]
                [tls_reqcert=never|allow|try|demand]
                [tls_cipher_suite=<ciphers>]
                [tls_crlcheck=none|peer|all]
                [tls_protocol_min=<major>[.<minor>]]
                [suffixmassage=<real DN>]
                [logbase=<base DN>]
                [logfilter=<filter str>]
                [syncdata=default|accesslog|changelog]
```

This directive specifies the current database as a consumer of the provider content by establishing the current *slapd*(8) as a replication consumer site running a syncrepl replication engine.  The provider database is located at the replication provider site  specified by the `provider` parameter. The consumer database is  kept up-to-date with the provider content using the LDAP Content  Synchronization protocol. See [RFC4533](https://www.rfc-editor.org/rfc/rfc4533.txt) for more information on the protocol.

The `rid` parameter is used for identification of the current `syncrepl` directive within the replication consumer server, where `<replica ID>` uniquely identifies the syncrepl specification described by the current `syncrepl` directive. `<replica ID>` is non-negative and is no more than three decimal digits in length.

The `provider` parameter specifies the replication provider site containing the provider content as an LDAP URI. The `provider` parameter specifies a scheme, a host and optionally a port where the  provider slapd instance can be found. Either a domain name or IP address may be used for <hostname>. Examples are `ldap://provider.example.com:389` or `ldaps://192.168.1.1:636`. If <port> is not given, the standard LDAP port number (389 or  636) is used. Note that the syncrepl uses a consumer-initiated protocol, and hence its specification is located on the consumer.

The content of the syncrepl consumer is defined using a search  specification as its result set. The consumer slapd will send search  requests to the provider slapd according to the search specification.  The search specification includes `searchbase`, `scope`, `filter`, `attrs`, `exattrs`, `attrsonly`, `sizelimit`, and `timelimit` parameters as in the normal search specification. The `searchbase` parameter has no default value and must always be specified. The `scope` defaults to `sub`, the `filter` defaults to `(objectclass=*)`, `attrs` defaults to `"*,+"` to replicate all user and operational attributes, and `attrsonly` is unset by default. Both `sizelimit` and `timelimit` default to "unlimited", and only positive integers or "unlimited" may be specified. The `exattrs` option may also be used to specify attributes that should be omitted from incoming entries.

The LDAP Content Synchronization protocol has two operation types: `refreshOnly` and `refreshAndPersist`. The operation type is specified by the `type` parameter. In the `refreshOnly` operation, the next synchronization search operation is periodically  rescheduled at an interval time after each synchronization operation  finishes. The interval is specified by the `interval` parameter. It is set to one day by default. In the `refreshAndPersist` operation, a synchronization search remains persistent in the provider *slapd* instance. Further updates to the provider will generate `searchResultEntry` to the consumer slapd as the search responses to the persistent synchronization search.

If an error occurs during replication, the consumer will attempt to  reconnect according to the retry parameter which is a list of the  <retry interval> and <# of retries> pairs. For example,  retry="60 10 300 3" lets the consumer retry every 60 seconds for the  first 10 times and then retry every 300 seconds for the next three times before stop retrying. + in <#  of retries> means indefinite  number of retries until success.

The schema checking can be enforced at the LDAP Sync consumer site by turning on the `schemachecking` parameter. If it is turned on, every replicated entry will be checked  for its schema as the entry is stored on the consumer. Every entry in  the consumer should contain those attributes required by the schema  definition. If it is turned off, entries will be stored without checking schema conformance. The default is off.

The `network-timeout` parameter sets how long the consumer  will wait to establish a network connection to the provider.  Once a  connection is established, the `timeout` parameter determines how long the consumer will wait for the initial Bind request to complete.   The defaults for these parameters come from *ldap.conf*(5).

The `binddn` parameter gives the DN to bind as for the  syncrepl searches to the provider slapd. It should be a DN which has  read access to the replication content in the provider database.

The `bindmethod` is `simple` or `sasl`, depending on whether simple password-based authentication or SASL authentication is to be used when connecting to the provider *slapd* instance.

Simple authentication should not be used unless adequate data  integrity and confidentiality protections are in place (e.g. TLS or  IPsec). Simple authentication requires specification of `binddn` and `credentials` parameters.

SASL authentication is generally recommended.  SASL authentication requires specification of a mechanism using the `saslmech` parameter. Depending on the mechanism, an authentication identity and/or credentials can be specified using `authcid` and `credentials`, respectively.  The `authzid` parameter may be used to specify an authorization identity.

The `realm` parameter specifies a realm which a certain mechanisms authenticate the identity within. The `secprops` parameter specifies Cyrus SASL security properties.

The `keepalive` parameter sets the values of idle, probes, and interval used to check whether a socket is alive;  idle is the number  of seconds a connection needs to remain idle before TCP starts sending  keepalive probes; probes is the maximum number of keepalive probes TCP  should send before dropping the connection; interval is interval in  seconds between individual keepalive probes.  Only some systems support  the customization of these values; the keepalive parameter is ignored  otherwise, and system-wide settings are used. For example,  keepalive="240:10:30" will send a keepalive probe 10 times, every 30  seconds, after 240 seconds of idle activity.  If no response to the  probes is received, the connection will be dropped.

The `starttls` parameter specifies use of the StartTLS  extended operation to establish a TLS session before authenticating to  the provider. If the `critical` argument is supplied, the session will be aborted if the StartTLS request fails.  Otherwise the syncrepl  session continues without TLS.  The tls_reqcert setting defaults to `"demand"` and the other TLS settings default to the same as the main slapd TLS settings.

The `suffixmassage` parameter allows the consumer to pull  entries from a remote directory whose DN suffix differs from the local  directory. The portion of the remote entries' DNs that matches the  searchbase will be replaced with the suffixmassage DN.

Rather than replicating whole entries, the consumer can query logs of data modifications.  This mode of operation is referred to as *delta syncrepl*.  In addition to the above parameters, the `logbase` and `logfilter` parameters must be set appropriately for the log that will be used. The `syncdata` parameter must be set to either `"accesslog"` if the log conforms to the *slapo-accesslog*(5) log format, or `"changelog"` if the log conforms to the obsolete *changelog* format. If the `syncdata` parameter is omitted or set to `"default"` then the log parameters are ignored.

The *syncrepl* replication mechanism is supported by the *mdb* backend.

See the [LDAP Sync Replication](https://www.openldap.org/doc/admin26/replication.html#LDAP Sync Replication) chapter of this guide for more information on how to use this directive.

#### 6.2.3.8. updateref <URL>

This directive is only applicable in a *replica* (or *shadow*) *slapd*(8) instance. It specifies the URL to return to clients which submit update requests upon the replica. If specified multiple times, each URL is provided.

Example:

```
        updateref       ldap://provider.example.net
```

### 6.2.4. MDB Backend Directives

Directives in this category only apply to the MDB  database backend. They will apply to all "database mdb" instances in the configuration. For a complete reference of MDB backend configuration  directives, see *slapd-mdb*(5).

#### 6.2.4.1. idlexp <exponent>

Specify a power of 2 for the maximum size of an index slot. The  default is 16, yielding a maximum slot size of 2^16 or 65536. The  specified value must be in the range of 16-30.

This setting helps with the case where certain search filters are  slow to return results due to an index slot having collapsed to a range  value.  This occurs when the number of candidate entries that match the  filter for the index slot exceed the configured slot size.

If this setting is decreased on a server with existing MDB databases, each db will immediately need its indices to be rebuilt while slapd is offline with the "slapindex -q -t" command.

If this setting is increased on a server with existing MDB databases, each db will need its indices rebuilt to take advantage of  the change for indices that have already been converted to ranges.

### 6.2.5. MDB Database Directives

Directives in this category only apply to the MDB  database backend. That is, they must follow a "database mdb" line and  come before any subsequent "backend" or "database" lines. For a complete reference of MDB configuration directives, see *slapd-mdb*(5).

#### 6.2.5.1. directory <directory>

This directive specifies the directory where the MDB files containing the database and associated indices live.

Default:

```
        directory /usr/local/var/openldap-data
```

#### 6.2.5.2. checkpoint <kbyte> <min>

This directive specifies the frequency for flushing the database disk buffers. This directive is only needed if the *dbnosync* option is `TRUE`. The checkpoint will occur if either <kbyte> data has been written or <min> minutes have passed since the last checkpoint. Both  arguments default to zero, in which case they are ignored. When the  <min> argument is non-zero, an internal task will run every  <min> minutes to perform the checkpoint. Note: currently the  _kbyte_ setting is unimplemented.

Example:

```
   checkpoint: 1024 10
```

#### 6.2.5.3. dbnosync: { TRUE | FALSE }

This directive causes on-disk database contents to not be immediately synchronized with in memory changes upon change.  Setting this option  to `TRUE` may improve performance at the expense of data integrity.

#### 6.2.5.4. envflags: {nosync,nometasync,writemap,mapasync,nordahead}

This option specifies flags for finer-grained control of  the  LMDB  library's operation.

- `nosync`: This is exactly the same as the dbnosync directive.
- `nometasync`: Flush the data on a commit, but skip the  sync of the meta page. This mode is slightly faster than doing a full  sync, but can potentially lose the last committed transaction if the  operating system crashes. If both nometasync and nosync are set, the  nosync flag takes precedence.
- `writemap`: Use a writable memory map instead of just  read-only. This speeds up write operations but makes the database  vulnerable to corruption in case any bugs in slapd cause stray writes  into the mmap region.
- `mapasync`: When using a writable memory map and  performing flushes on each commit, use an asynchronous flush instead of a synchronous flush (the default). This option has no effect if writemap  has not been set. It also has no effect if nosync is set.
- `nordahead`: Turn off file readahead. Usually the OS  performs readahead on every read request. This usually boosts read  performance but can be harmful to random access read performance if the  system's memory is full and the DB is larger than RAM. This option is  not implemented on Windows.

#### 6.2.5.5. index: {<attrlist> | default} [pres,eq,approx,sub,none]

This directive specifies the indices to maintain for the given attribute. If only an `<attrlist>` is given, the default indices are maintained. The index keywords  correspond to the common types of matches that may be used in an LDAP  search filter.

Example:

```
   index: default pres,eq
   index: uid
   index: cn,sn pres,eq,sub
   index: objectClass eq
```

The first line sets the default set of indices to maintain to present and equality.  The second line causes the default (pres,eq) set of  indices to be maintained for the `uid` attribute type. The third line causes present, equality, and substring indices to be maintained for `cn` and `sn` attribute types.  The fourth line causes an equality index for the `objectClass` attribute type.

There is no index keyword for inequality matches. Generally these  matches do not use an index. However, some attributes do support  indexing for inequality matches, based on the equality index.

A substring index can be more explicitly specified as `subinitial`, `subany`, or `subfinal`, corresponding to the three possible components of a substring match  filter. A subinitial index only indexes substrings that appear at the  beginning of an attribute value. A subfinal index only indexes  substrings that appear at the end of an attribute value, while subany  indexes substrings that occur anywhere in a value.

Note that by default, setting an index for an attribute also affects  every subtype of that attribute. E.g., setting an equality index on the `name` attribute causes `cn`, `sn`, and every other attribute that inherits from `name` to be indexed.

By default, no indices are maintained.  It is generally advised that minimally an equality index upon objectClass be maintained.

```
   index: objectClass eq
```

Additional indices should be configured corresponding to the most  common searches that are used on the database. Presence indexing should  not be configured for an attribute unless the attribute occurs very  rarely in the database, and presence searches on the attribute occur  very frequently during normal use of the directory. Most applications  don't use presence searches, so usually presence indexing is not very  useful.

#### 6.2.5.6. maxentrysize: <bytes>

Specify the maximum size of an entry in bytes. Attempts to store an  entry larger than this size will be rejected with the error  LDAP_ADMINLIMIT_EXCEEDED. The default is 0, which is unlimited.

#### 6.2.5.7. maxreaders: <integer>

This directive specifies the maximum number of threads that may have  concurrent read access to the database. Tools such as slapcat count as a single thread, in addition to threads in any active slapd processes.  The default is 126.

#### 6.2.5.8. maxsize: <bytes>

This directive specifies the maximum size of the database in bytes. A memory map of this size is allocated at startup time and the database  will not be allowed to grow beyond this size. The default is 10485760  bytes (10MB). This setting may be changed upward if the configured limit needs to be increased.



------

**Note:** It is important to set this to as large a value  as possible, (relative to anticipated growth of the actual data over  time) since growing the size later may not be practical when the system  is under heavy load.

------



#### 6.2.5.9. mode: { <octal> | <symbolic> }

This directive specifies the file protection mode that newly created database index files should have. This can be in the form `0600` or `-rw-------`

Default:

```
   mode: 0600
```

#### 6.2.5.10. multival: { <attrlist> | default } <integer> hi,<integer> lo

Specify the number of values for which a multivalued attribute is  stored in a separate table. Normally entries are stored as a single blob inside the database. When an entry gets very large or contains  attributes with a very large number of values, modifications on that  entry may get very slow. Splitting the large attributes out to a  separate table can improve the performance of modification operations.  The threshold is specified as a pair of integers. If the number of  values exceeds the hi threshold the values will be split out. If a  modification deletes enough values to bring an attribute below the lo  threshold the values will be removed from the separate table and merged  back into the main entry blob. The threshold can be set for a specific  list of attributes, or the default can be configured for all other  attributes. The default value for both hi and lo thresholds is UINT_MAX, which keeps all attributes in the main blob.

In addition to increasing write performance of operations the use of multival can also decrease fragmentation of the primary MDB database.

#### 6.2.5.11. rtxnsize: <entries>

This directive specifies the maximum number of entries to process in a single read transaction when executing a large search. Long-lived read  transactions prevent old database pages from being reused in write  transactions, and so can cause significant growth of the database file  when there is heavy write traffic. This setting causes the read  transaction in large searches to be released and reacquired after the  given number of entries has been read, to give writers the opportunity  to reclaim old database pages. The default is 10000.

#### 6.2.5.12. searchstack: <integer>

Specify the depth of the stack used for search filter evaluation. Search filters are evaluated on a stack to accommodate nested `AND` / `OR` clauses. An individual stack is allocated for each server thread. The  depth of the stack determines how complex a filter can be evaluated  without requiring any additional memory allocation. Filters that are  nested deeper than the search stack depth will cause a separate stack to be allocated for that particular search operation. These separate  allocations can have a major negative impact on server performance, but  specifying too much stack will also consume a great deal of memory. Each search uses 512K bytes per level on a 32-bit machine, or 1024K bytes  per level on a 64-bit machine. The default stack depth is 16, thus 8MB  or 16MB per thread is used on 32 and 64 bit machines, respectively. Also the 512KB size of a single stack slot is set by a compile-time constant which may be changed if needed; the code must be recompiled for the  change to take effect.

Default:

```
   searchstack: 16
```

#### 6.2.5.13. Sample Entry

```
database mdb
suffix: "dc=example,dc=com"
directory: /usr/local/var/openldap-data
index: objectClass eq
```

## 配置文件示例

The following is an example configuration file, interspersed with  explanatory text. It defines two databases to handle different parts of  the X.500 tree; both are MDB database  instances. The line numbers shown are provided for reference only and  are not included in the actual file. First, the global configuration  section:

```
  1.    # example config file - global configuration section
  2.    include /usr/local/etc/schema/core.schema
  3.    referral ldap://root.openldap.org
  4.    access to * by * read
```

Line 1 is a comment. Line 2 includes another config file which contains *core* schema definitions. The `referral` directive on line 3 means that queries not local to one of the  databases defined below will be referred to the LDAP server running on  the standard port (389) at the host `root.openldap.org`.

Line 4 is a global access control.  It applies to all entries (after any applicable database-specific access controls).

The next section of the configuration file defines a MDB backend that will handle queries for things in the "dc=example,dc=com" portion of  the tree. The database is to be replicated to two replica slapds, one on truelies, the other on judgmentday. Indices are to be maintained for  several attributes, and the `userPassword` attribute is to be protected from unauthorized access.

```
  5.    # MDB definition for the example.com
  6.    database mdb
  7.    suffix "dc=example,dc=com"
  8.    directory /usr/local/var/openldap-data
  9.    rootdn "cn=Manager,dc=example,dc=com"
 10.    rootpw secret
 11.    # indexed attribute definitions
 12.    index uid pres,eq
 13.    index cn,sn pres,eq,approx,sub
 14.    index objectClass eq
 15.    # database access control definitions
 16.    access to attrs=userPassword
 17.        by self write
 18.        by anonymous auth
 19.        by dn.base="cn=Admin,dc=example,dc=com" write
 20.        by * none
 21.    access to *
 22.        by self write
 23.        by dn.base="cn=Admin,dc=example,dc=com" write
 24.        by * read
```

Line 5 is a comment. The start of the database definition is marked  by the database keyword on line 6. Line 7 specifies the DN suffix for  queries to pass to this database. Line 8 specifies the directory in  which the database files will live.

Lines 9 and 10 identify the database *super-user* entry and associated password. This entry is not subject to access control or size or time limit restrictions.

Lines 12 through 14 indicate the indices to maintain for various attributes.

Lines 16 through 24 specify access control for entries in this database. For all applicable entries, the `userPassword` attribute is writable by the entry itself and by the "admin" entry.  It may be used for authentication/authorization purposes, but is otherwise not readable. All other attributes are writable by the entry and the  "admin" entry, but may be read by all users (authenticated or not).

The next section of the example configuration file defines another MDB database. This one handles queries involving the `dc=example,dc=net` subtree but is managed by the same entity as the first database.  Note  that without line 39, the read access would be allowed due to the global access rule at line 4.

```
 33.    # MDB definition for example.net
 34.    database mdb
 35.    suffix "dc=example,dc=net"
 36.    directory /usr/local/var/openldap-data-net
 37.    rootdn "cn=Manager,dc=example,dc=com"
 38.    index objectClass eq
 39.    access to * by users read
```

