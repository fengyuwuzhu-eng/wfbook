```
Internet Engineering Task Force (IETF)                          D. Mills
Request for Comments: 5905                                   U. Delaware
Obsoletes: 1305, 4330                                     J. Martin, Ed.
Category: Standards Track                                            ISC
ISSN: 2070-1721                                               J. Burbank
                                                                W. Kasch
                                                                 JHU/APL
                                                               June 2010互联网工程任务组 （IETF） D. Mills 征求意见：5905 U. Delaware 过时：1305、4330 J. Martin， Ed. 类别：标准跟踪 ISC ISSN：2070-1721 J. Burbank W. Kasch JHU/APL 2010 年 6 月
 Network Time Protocol Version 4: Protocol and Algorithms Specification网络时间协议版本 4：协议和算法规范Abstract 抽象   The Network Time Protocol (NTP) is widely used to synchronize
   computer clocks in the Internet.  This document describes NTP version
   4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3),
   described in RFC 1305, as well as previous versions of the protocol.
   NTPv4 includes a modified protocol header to accommodate the Internet
   Protocol version 6 address family.  NTPv4 includes fundamental
   improvements in the mitigation and discipline algorithms that extend
   the potential accuracy to the tens of microseconds with modern
   workstations and fast LANs.  It includes a dynamic server discovery
   scheme, so that in many cases, specific server configuration is not
   required.  It corrects certain errors in the NTPv3 design and
   implementation and includes an optional extension mechanism.网络时间协议 （NTP） 广泛用于同步 Internet 中的计算机时钟。本文档介绍 NTP 版本 4 （NTPv4），它向后兼容 RFC 1305 中描述的 NTP 版本 3 （NTPv3） 以及协议的早期版本。NTPv4 包括一个修改后的协议标头，以适应 Internet 协议版本 6 地址系列。NTPv4 包括对缓解和纪律算法的根本性改进，通过现代工作站和快速局域网将潜在精度扩展到数十微秒。它包括动态服务器发现方案，因此在许多情况下，不需要特定的服务器配置。它纠正了 NTPv3 设计和实现中的某些错误，并包括可选的扩展机制。Status of This Memo 本备忘录的状态   This is an Internet Standards Track document.这是一份 Internet 标准跟踪文档。   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.本文档是 Internet 工程任务组 （IETF） 的产品。它代表了 IETF 社区的共识。它已接受公众审核，并已获得互联网工程指导小组 （IESG） 的批准发布。有关 Internet 标准的更多信息，请参见 RFC 5741 的第 2 节。   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc5905.有关本文档的当前状态、任何勘误表以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc5905。Mills, et al.                Standards Track                    [Page 1]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 1 页] RFC 5905 NTPv4 规范 2010 年 6 月
Copyright Notice 版权声明   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.版权所有 （c） 2010 IETF Trust 和被确定为文档作者的人员。保留所有权利。   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.本文档受 BCP 78 和 IETF Trust 与 IETF 文档相关的法律规定 （http://trustee.ietf.org/license-info） 的约束，该条款在本文档发布之日生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文档中提取的代码组件必须包含《信托法律规定》第 4.e 节中描述的简化 BSD 许可证文本，并且不提供简化 BSD 许可证中描述的保证。   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.本文档可能包含 2008 年 11 月 10 日之前发布或公开的 IETF 文档或 IETF 贡献中的材料。控制某些材料版权的人员可能未授予 IETF Trust 允许在 IETF 标准流程之外修改此类材料的权利。在未获得控制此类材料版权的人员的充分许可的情况下，不得在 IETF 标准流程之外修改本文档，也不得在 IETF 标准流程之外创建其衍生作品，除非将其格式化为 RFC 发布或将其翻译成英语以外的语言。Table of Contents 目录   1. Introduction ....................................................4
      1.1. Requirements Notation ......................................5
   2. Modes of Operation ..............................................6
   3. Protocol Modes ..................................................6
      3.1. Dynamic Server Discovery ...................................7
   4. Definitions .....................................................8
   5. Implementation Model ...........................................10
   6. Data Types .....................................................12
   7. Data Structures ................................................16
      7.1. Structure Conventions .....................................16
      7.2. Global Parameters .........................................16
      7.3. Packet Header Variables ...................................17
      7.4. The Kiss-o'-Death Packet ..................................24
      7.5. NTP Extension Field Format ................................25
   8. On-Wire Protocol ...............................................26
   9. Peer Process ...................................................30
      9.1. Peer Process Variables ....................................31
      9.2. Peer Process Operations ...................................33
   10. Clock Filter Algorithm ........................................371. 引言 ....................................................4 1.1.需求表示法 ......................................5 2.操作模式 ..............................................6 3.协议模式 ..................................................6 3.1.动态服务器发现...................................7 4.定义。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。8 5.实施模式...........................................10 6.数据类型 .....................................................12 7.数据结构................................................16 7.1.结构约定 .....................................16 7.2.全局参数.........................................16 7.3.数据包标头变量 ...................................17 7.4.死亡之吻..................................24 7.5.NTP 扩展字段格式 ................................25 8.在线协议...............................................26 9.对等流程...................................................30 9.1.对等进程变量 ....................................31 9.2.对等进程操作...................................33 10.时钟滤波器算法 ........................................37Mills, et al.                Standards Track                    [Page 2]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 2 页] RFC 5905 NTPv4 规范 2010 年 6 月
   11. System Process ................................................39
      11.1. System Process Variables .................................40
      11.2. System Process Operations ................................41
           11.2.1. Selection Algorithm ...............................43
           11.2.2. Cluster Algorithm .................................44
           11.2.3. Combine Algorithm .................................45
      11.3. Clock Discipline Algorithm ...............................47
   12. Clock-Adjust Process ..........................................51
   13. Poll Process ..................................................51
      13.1. Poll Process Variables ...................................51
      13.2. Poll Process Operations ..................................52
   14. Simple Network Time Protocol (SNTP) ...........................54
   15. Security Considerations .......................................55
   16. IANA Considerations ...........................................58
   17. Acknowledgements ..............................................59
   18. References ....................................................59
      18.1. Normative References .....................................59
      18.2. Informative References ...................................59
   Appendix A.  Code Skeleton  .......................................61
     A.1.  Global Definitions  .......................................61
       A.1.1. Definitions, Constants, Parameters .....................61
       A.1.2. Packet Data Structures .................................65
       A.1.3. Association Data Structures ............................66
       A.1.4. System Data Structures .................................68
       A.1.5. Local Clock Data Structures ............................69
       A.1.6. Function Prototypes ....................................69
     A.2. Main Program and Utility Routines ..........................70
     A.3. Kernel Input/Output Interface ..............................73
     A.4. Kernel System Clock Interface ..............................74
     A.5. Peer Process ...............................................76
       A.5.1. receive() ..............................................77
       A.5.2. clock_filter() .........................................85
       A.5.3. fast_xmit() ............................................88
       A.5.4. access() ...............................................89
       A.5.5. System Process .........................................90
       A.5.6. Clock Adjust Process ..................................103
       A.5.7. Poll Process ..........................................104 11. 系统流程................................................39 11.1.系统过程变量 .................................40 11.2.系统进程操作................................41 11.2.1.选择算法 ...............................43 11.2.2.聚类算法.................................44 11.2.3.组合算法.................................45 11.3.时钟规则算法 ...............................47 12.时钟调整过程..........................................51 13.投票过程..................................................51 13.1.轮询过程变量 ...................................51 13.2.轮询进程操作..................................52 14.简单网络时间协议 （SNTP） ...........................54 15.安全注意事项 .......................................55 16.IANA 注意事项 ...........................................58 17.确认。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。59 18.引用。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。59 18.1.规范性参考文献 .....................................59 18.2.信息参考 ...................................59 附录 A. 代码骨架.......................................61 答.1.全局定义 .......................................61 A.1.1.定义、常量、参数.....................61 A.1.2.数据包数据结构.................................65 A.1.3.关联数据结构............................66 A.1.4.系统数据结构.................................68 A.1.5.本地时钟数据结构............................69 A.1.6.功能原型....................................69 A.2.主程序和实用程序例程..........................70 A.3.内核输入/输出接口..............................73 答.4.内核系统时钟接口..............................74 答.5.对等进程...............................................76 A.5.1.receive（） ..............................................77 A.5.2.clock_filter（） .........................................85 A.5.3.fast_xmit（） ............................................88 A.5.4.access（） ...............................................89 A.5.5.系统流程.........................................90 A.5.6.时钟调整过程..................................103 A.5.7.投票流程..........................................104
Mills, et al.                Standards Track                    [Page 3]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 3 页] RFC 5905 NTPv4 规范 2010 年 6 月
1.  Introduction 1. 引言   This document defines the Network Time Protocol version 4 (NTPv4),
   which is widely used to synchronize system clocks among a set of
   distributed time servers and clients.  It describes the core
   architecture, protocol, state machines, data structures, and
   algorithms.  NTPv4 introduces new functionality to NTPv3, as
   described in [RFC1305], and functionality expanded from Simple NTP
   version 4 (SNTPv4) as described in [RFC4330] (SNTPv4 is a subset of
   NTPv4).  This document obsoletes [RFC1305] and [RFC4330].  While
   certain minor changes have been made in some protocol header fields,
   these do not affect the interoperability between NTPv4 and previous
   versions of NTP and SNTP.本文档定义了网络时间协议版本 4 （NTPv4），它广泛用于在一组分布式时间服务器和客户端之间同步系统时钟。它描述了核心架构、协议、状态机、数据结构和算法。NTPv4 为 NTPv3 引入了新功能，如 [RFC1305] 中所述，并且从简单 NTP 版本 4 （SNTPv4） 扩展的功能，如 [RFC4330] 中所述（SNTPv4 是 NTPv4 的子集）。本文档已废弃 [RFC1305] 和 [RFC4330]。虽然在某些协议标头字段中进行了某些细微的更改，但这些更改不会影响 NTPv4 与以前版本的 NTP 和 SNTP 之间的互操作性。   The NTP subnet model includes a number of widely accessible primary
   time servers synchronized by wire or radio to national standards.
   The purpose of the NTP protocol is to convey timekeeping information
   from these primary servers to secondary time servers and clients via
   both private networks and the public Internet.  Precisely tuned
   algorithms mitigate errors that may result from network disruptions,
   server failures, and possible hostile actions.  Servers and clients
   are configured such that values flow towards clients from the primary
   servers at the root via branching secondary servers.NTP 子网模型包括许多可广泛访问的主时间服务器，这些服务器通过有线或无线电与国家标准同步。NTP 协议的目的是通过专用网络和公共 Internet 将计时信息从这些主服务器传送到辅助时间服务器和客户端。精确调整的算法可减少网络中断、服务器故障和可能的敌对行为可能导致的错误。服务器和客户端的配置使值通过分支辅助服务器从根的主服务器流向客户端。   The NTPv4 design overcomes significant shortcomings in the NTPv3
   design, corrects certain bugs, and incorporates new features.  In
   particular, expanded NTP timestamp definitions encourage the use of
   the floating double data type throughout the implementation.  As a
   result, the time resolution is better than one nanosecond, and
   frequency resolution is less than one nanosecond per second.
   Additional improvements include a new clock discipline algorithm that
   is more responsive to system clock hardware frequency fluctuations.
   Typical primary servers using modern machines are precise within a
   few tens of microseconds.  Typical secondary servers and clients on
   fast LANs are within a few hundred microseconds with poll intervals
   up to 1024 seconds, which was the maximum with NTPv3.  With NTPv4,
   servers and clients are precise within a few tens of milliseconds
   with poll intervals up to 36 hours.NTPv4 设计克服了 NTPv3 设计中的重大缺陷，纠正了某些错误，并整合了新功能。特别是，扩展的 NTP 时间戳定义鼓励在整个实现过程中使用浮动双精度数据类型。因此，时间分辨率优于一纳秒，频率分辨率小于每秒一纳秒。其他改进包括新的时钟规则算法，该算法对系统时钟硬件频率波动的响应速度更快。使用现代机器的典型主服务器在几十微秒内精确到几十微秒。快速 LAN 上的典型辅助服务器和客户端在几百微秒内，轮询间隔长达 1024 秒，这是 NTPv3 的最大值。使用 NTPv4，服务器和客户端在几十毫秒内精确，轮询间隔长达 36 小时。   The main body of this document describes the core protocol and data
   structures necessary to interoperate between conforming
   implementations.  Appendix A contains a full-featured example in the
   form of a skeleton program, including data structures and code
   segments for the core algorithms as well as the mitigation algorithms
   used to enhance reliability and accuracy.  While the skeleton program
   and other descriptions in this document apply to a particular
   implementation, they are not intended as the only way the required
   functions can be implemented.  The contents of Appendix A are non-本文档的主体描述了在符合要求的实现之间进行互操作所需的核心协议和数据结构。附录 A 包含一个框架程序形式的全功能示例，包括核心算法的数据结构和代码段，以及用于提高可靠性和准确性的缓解算法。虽然本文档中的框架程序和其他描述适用于特定的实现，但它们并不是实现所需功能的唯一方法。附录 A 的内容是非Mills, et al.                Standards Track                    [Page 4]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 4 页] RFC 5905 NTPv4 规范 2010 年 6 月
   normative examples designed to illustrate the protocol's operation
   and are not a requirement for a conforming implementation.  While the
   NTPv3 symmetric key authentication scheme described in this document
   has been carried over from NTPv3, the Autokey public key
   authentication scheme new to NTPv4 is described in [RFC5906].旨在说明协议操作的规范性示例，而不是合规实施的要求。虽然本文档中描述的 NTPv3 对称密钥身份验证方案是从 NTPv3 继承而来的，但 [RFC5906] 中描述了 NTPv4 中新增的自动密钥公钥身份验证方案。   The NTP protocol includes modes of operation described in Section 2
   using data types described in Section 6 and data structures described
   in Section 7.  The implementation model described in Section 5 is
   based on a threaded, multi-process architecture, although other
   architectures could be used as well.  The on-wire protocol described
   in Section 8 is based on a returnable-time design that depends only
   on measured clock offsets, but does not require reliable message
   delivery.  Reliable message delivery such as TCP [RFC0793] can
   actually make the delivered NTP packet less reliable since retries
   would increase the delay value and other errors.  The synchronization
   subnet is a self-organizing, hierarchical, master-slave network with
   synchronization paths determined by a shortest-path spanning tree and
   defined metric.  While multiple masters (primary servers) may exist,
   there is no requirement for an election protocol.NTP 协议包括第 2 节中描述的操作模式，使用第 6 节中描述的数据类型和第 7 节中描述的数据结构。第 5 节中描述的实现模型基于线程式多进程架构，但也可以使用其他架构。第 8 节中描述的在线协议基于可返回时间设计，该设计仅取决于测量的时钟偏移，但不需要可靠的消息传递。可靠的消息传递（如 TCP [RFC0793]）实际上会降低传递的 NTP 数据包的可靠性，因为重试会增加延迟值和其他错误。同步子网是一个自组织、分层的主从网络，其同步路径由最短路径生成树和定义的指标确定。虽然可能存在多个主服务器（主服务器），但不需要选举协议。   This document includes material from [ref9], which contains flow
   charts and equations unsuited for RFC format.  There is much
   additional information in [ref7], including an extensive technical
   analysis and performance assessment of the protocol and algorithms in
   this document.  The reference implementation is available at
   www.ntp.org.本文档包含来自 [ref9] 的材料，其中包含不适合 RFC 格式的流程图和方程式。[参考文献7]中还有很多附加信息，包括本文档中对协议和算法的广泛技术分析和性能评估。参考实现可在 www.ntp.org 上获得。   The remainder of this document contains numerous variables and
   mathematical expressions.  Some variables take the form of Greek
   characters, which are spelled out by their full case-sensitive name.
   For example, DELTA refers to the uppercase Greek character, while
   delta refers to the lowercase character.  Furthermore, subscripts are
   denoted with '_'; for example, theta_i refers to the lowercase Greek
   character theta with subscript i, or phonetically theta sub i.  In
   this document, all time values are in seconds (s), and all
   frequencies will be specified as fractional frequency offsets (FFOs)
   (pure number).  It is often convenient to express these FFOs in parts
   per million (ppm).本文档的其余部分包含许多变量和数学表达式。一些变量采用希腊字符的形式，这些字符由其区分大小写的完整名称拼写出来。例如，DELTA 是指大写的希腊字符，而 delta 是指小写字符。此外，下标用“_”表示;例如，theta_i 指的是带有下标 i 的小写希腊字符 theta，或语音上称为 theta sub i。在本文档中，所有时间值均以秒为单位，所有频率都将指定为小数频率偏移 （FFO）（纯数）。通常，以百万分之一 （ppm） 表示这些 FFO 很方便。1.1.  Requirements Notation1.1. 需求表示法   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应该”、“不应”、“推荐”、“可以”和“可选”应按[RFC2119]中的说明解释。
Mills, et al.                Standards Track                    [Page 5]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 5 页] RFC 5905 NTPv4 规范 2010 年 6 月
2.  Modes of Operation2. 操作模式   An NTP implementation operates as a primary server, secondary server,
   or client.  A primary server is synchronized to a reference clock
   directly traceable to UTC (e.g., GPS, Galileo, etc.).  A client
   synchronizes to one or more upstream servers, but does not provide
   synchronization to dependent clients.  A secondary server has one or
   more upstream servers and one or more downstream servers or clients.
   All servers and clients who are fully NTPv4-compliant MUST implement
   the entire suite of algorithms described in this document.  In order
   to maintain stability in large NTP subnets, secondary servers SHOULD
   be fully NTPv4-compliant.  Alternative algorithms MAY be used, but
   their output MUST be identical to the algorithms described in this
   specification.NTP 实现作为主服务器、辅助服务器或客户端运行。主服务器与可直接追溯到UTC的参考时钟（例如，GPS，伽利略等）同步。客户端同步到一个或多个上游服务器，但不提供与依赖客户端的同步。辅助服务器具有一个或多个上游服务器和一个或多个下游服务器或客户端。所有完全符合 NTPv4 标准的服务器和客户端都必须实现本文档中描述的整套算法。为了在大型 NTP 子网中保持稳定性，辅助服务器应完全符合 NTPv4 标准。可以使用替代算法，但其输出必须与本规范中描述的算法相同。3.  Protocol Modes 3. 协议模式   There are three NTP protocol variants: symmetric, client/server, and
   broadcast.  Each is associated with an association mode (a
   description of the relationship between two NTP speakers) as shown in
   Figure 1.  In addition, persistent associations are mobilized upon
   startup and are never demobilized.  Ephemeral associations are
   mobilized upon the arrival of a packet and are demobilized upon error
   or timeout.有三种 NTP 协议变体：对称协议、客户端/服务器协议和广播协议。每个都与关联模式（两个 NTP 扬声器之间关系的描述）相关联，如图 1 所示。此外，持久的协会在启动时被动员起来，并且永远不会复员。临时关联在数据包到达时被调动，并在错误或超时时被解除。          +-------------------+-------------------+------------------+
          |  Association Mode | Assoc. Mode Value | Packet Mode Value|
          +-------------------+-------------------+------------------+
          | Symmetric Active  |         1         | 1 or 2           |
          | Symmetric Passive |         2         | 1                |
          | Client            |         3         | 4                |
          | Server            |         4         | 3                |
          | Broadcast Server  |         5         | 5                |
          | Broadcast Client  |         6         | N/A              |
          +-------------------+-------------------+------------------++-------------------+-------------------+------------------+ |关联模式 |Assoc. 模式值 |数据包模式值|+-------------------+-------------------+------------------+ |对称活动 |1 |1 或 2 | |对称无源 |2 |1 | |客户 |3 |4 | |服务器 |4 |3 | |广播服务器 |5 |5 | |广播客户端 |6 |不适用 |+-------------------+-------------------+------------------+                  Figure 1: Association and Packet Modes图 1：关联和数据包模式   In the client/server variant, a persistent client sends packet mode 4
   packets to a server, which returns packet mode 3 packets.  Servers
   provide synchronization to one or more clients, but do not accept
   synchronization from them.  A server can also be a reference clock
   driver that obtains time directly from a standard source such as a
   GPS receiver or telephone modem service.  In this variant, clients
   pull synchronization from servers.在客户端/服务器变体中，持久性客户端将数据包模式 4 数据包发送到服务器，服务器返回数据包模式 3 数据包。服务器提供与一个或多个客户端的同步，但不接受来自它们的同步。服务器也可以是参考时钟驱动程序，它直接从标准源（如 GPS 接收器或电话调制解调器服务）获取时间。在此变体中，客户端从服务器拉取同步。
Mills, et al.                Standards Track                    [Page 6]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 6 页] RFC 5905 NTPv4 规范 2010 年 6 月
   In the symmetric variant, a peer operates as both a server and client
   using either a symmetric active or symmetric passive association.  A
   persistent symmetric active association sends symmetric active (mode
   1) packets to a symmetric active peer association.  Alternatively, an
   ephemeral symmetric passive association can be mobilized upon the
   arrival of a symmetric active packet with no matching association.
   That association sends symmetric passive (mode 2) packets and
   persists until error or timeout.  Peers both push and pull
   synchronization to and from each other.  For the purposes of this
   document, a peer operates like a client, so references to client
   imply peer as well.在对称变体中，对等体使用对称主动或对称被动关联作为服务器和客户端运行。持久对称活动关联将对称活动（模式 1）数据包发送到对称活动对等关联。或者，可以在没有匹配关联的对称主动数据包到达时调动短暂的对称被动关联。该关联发送对称无源（模式 2）数据包，并持续到错误或超时。对等方相互推送和拉取同步。就本文档而言，对等体的操作方式与客户端类似，因此对客户端的引用也意味着对等体。   In the broadcast variant, a persistent broadcast server association
   sends periodic broadcast server (mode 5) packets that can be received
   by multiple clients.  Upon reception of a broadcast server packet
   without a matching association, an ephemeral broadcast client (mode
   6) association is mobilized and persists until error or timeout.  It
   is useful to provide an initial volley where the client operating in
   client mode exchanges several packets with the server, so as to
   calibrate the propagation delay and to run the Autokey security
   protocol, after which the client reverts to broadcast client mode.  A
   broadcast server pushes synchronization to clients and other servers.在广播变体中，持久性广播服务器关联发送可由多个客户端接收的定期广播服务器（模式 5）数据包。在接收到没有匹配关联的广播服务器数据包时，将调动临时广播客户端（模式 6）关联，并持续到错误或超时。提供初始排球很有用，其中在客户端模式下运行的客户端与服务器交换多个数据包，以便校准传播延迟并运行自动密钥安全协议，之后客户端恢复到广播客户端模式。广播服务器将同步推送到客户端和其他服务器。   Loosely following the conventions established by the telephone
   industry, the level of each server in the hierarchy is defined by a
   stratum number.  Primary servers are assigned stratum one; secondary
   servers at each lower level are assigned stratum numbers one greater
   than the preceding level.  As the stratum number increases, its
   accuracy degrades depending on the particular network path and system
   clock stability.  Mean errors, measured by synchronization distances,
   increase approximately in proportion to stratum numbers and measured
   round-trip delay.松散地遵循电话行业建立的约定，层次结构中每个服务器的级别由层号定义。主服务器被分配为第一层;每个较低级别的辅助服务器都分配了比前一级大一个的层号。随着层数的增加，其精度会根据特定的网络路径和系统时钟稳定性而降低。通过同步距离测量的平均误差大约与层数和测得的往返延迟成正比。   As a standard practice, timing network topology should be organized
   to avoid timing loops and minimize the synchronization distance.  In
   NTP, the subnet topology is determined using a variant of the
   Bellman-Ford distributed routing algorithm, which computes the
   shortest-path spanning tree rooted on the primary servers.  As a
   result of this design, the algorithm automatically reorganizes the
   subnet, so as to produce the most accurate and reliable time, even
   when there are failures in the timing network.作为标准做法，应组织定时网络拓扑，以避免定时环路并最小化同步距离。在 NTP 中，子网拓扑是使用 Bellman-Ford 分布式路由算法的变体确定的，该算法计算根植于主服务器的最短路径生成树。由于这种设计，该算法会自动重新组织子网，从而产生最准确和最可靠的时间，即使定时网络出现故障也是如此。3.1.  Dynamic Server Discovery3.1. 动态服务器发现   There are two special associations, manycast client and manycast
   server, which provide a dynamic server discovery function.  There are
   two types of manycast client associations: persistent and ephemeral.
   The persistent manycast client sends client (mode 3) packets to a有两个特殊的关联，即 manycast 客户端和 manycast 服务器，它们提供动态服务器发现功能。有两种类型的 manycast 客户端关联：持久性和临时性。持久性 manycast 客户端将客户端（模式 3）数据包发送到Mills, et al.                Standards Track                    [Page 7]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 7 页] RFC 5905 NTPv4 规范 2010 年 6 月
   designated IPv4 or IPv6 broadcast or multicast group address.
   Designated manycast servers within range of the time-to-live (TTL)
   field in the packet header listen for packets with that address.  If
   a server is suitable for synchronization, it returns an ordinary
   server (mode 4) packet using the client's unicast address.  Upon
   receiving this packet, the client mobilizes an ephemeral client (mode
   3) association.  The ephemeral client association persists until
   error or timeout.指定的 IPv4 或 IPv6 广播或组播组地址。数据包标头中生存时间 （TTL） 字段范围内的指定多播服务器侦听具有该地址的数据包。如果服务器适合同步，则使用客户端的单播地址返回普通服务器（模式 4）数据包。收到此数据包后，客户端会调动临时客户端（模式 3）关联。临时客户端关联将持续存在，直到出现错误或超时。   A manycast client continues sending packets to search for a minimum
   number of associations.  It starts with a TTL equal to one and
   continuously adding one to it until the minimum number of
   associations is made or when the TTL reaches a maximum value.  If the
   TTL reaches its maximum value and yet not enough associations are
   mobilized, the client stops transmission for a time-out period to
   clear all associations, and then repeats the search cycle.  If a
   minimum number of associations has been mobilized, then the client
   starts transmitting one packet per time-out period to maintain the
   associations.  Field constraints limit the minimum value to 1 and the
   maximum to 255.  These limits may be tuned for individual application
   needs.manycast 客户端继续发送数据包以搜索最小数量的关联。它从等于 1 的 TTL 开始，并不断向其添加 1，直到建立最小关联数或 TTL 达到最大值。如果 TTL 达到其最大值，但未调动足够的关联，则客户端将停止传输一段时间以清除所有关联，然后重复搜索周期。如果已调动最少数量的关联，则客户端开始在每个超时期间传输一个数据包以维护关联。字段约束将最小值限制为 1，将最大值限制为 255。这些限制可以根据个人应用需求进行调整。   The ephemeral associations compete among themselves.  As new
   ephemeral associations are mobilized, the client runs the mitigation
   algorithms described in Sections 10 and 11.2 for the best candidates
   out of the population, the remaining ephemeral associations are timed
   out and demobilized.  In this way, the population includes only the
   best candidates that have most recently responded with an NTP packet
   to discipline the system clock.短暂的关联相互竞争。随着新的临时关联被调动，客户端运行第 10 节和第 11.2 节中描述的缓解算法，以寻找总体中的最佳候选者，其余的临时关联将超时并复员。这样，总体仅包括最近使用 NTP 数据包响应以约束系统时钟的最佳候选者。4.  Definitions 4. 定义   A number of technical terms are defined in this section.  A timescale
   is a frame of reference where time is expressed as the value of a
   monotonically increasing binary counter with an indefinite number of
   bits.  It counts in seconds and fractions of a second, when a decimal
   point is employed.  The Coordinated Universal Time (UTC) timescale is
   defined by ITU-R TF.460 [ITU-R_TF.460].  Under the auspices of the
   Metre Convention of 1865, in 1975 the CGPM [CGPM] strongly endorsed
   the use of UTC as the basis for civil time.本节定义了许多技术术语。时间刻度是一个参考框架，其中时间表示为具有无限位数的单调递增二进制计数器的值。当使用小数点时，它以秒和几分之一秒为单位计数。协调世界时（UTC）时间刻度由ITU-R TF.460 [ITU-R_TF.460]定义。在 1865 年《米公约》的支持下，1975 年 CGPM [CGPM] 强烈支持使用 UTC 作为民用时间的基础。   The Coordinated Universal Time (UTC) timescale represents mean solar
   time as disseminated by national standards laboratories.  The system
   time is represented by the system clock maintained by the hardware
   and operating system.  The goal of the NTP algorithms is to minimize
   both the time difference and frequency difference between UTC and the
   system clock.  When these differences have been reduced below nominal
   tolerances, the system clock is said to be synchronized to UTC.协调世界时 （UTC） 时间刻度表示国家标准实验室传播的平均太阳时。系统时间由硬件和操作系统维护的系统时钟表示。NTP 算法的目标是最小化 UTC 和系统时钟之间的时间差和频率差。当这些差异减小到标称容差以下时，系统时钟被称为与UTC同步。Mills, et al.                Standards Track                    [Page 8]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 8 页] RFC 5905 NTPv4 规范 2010 年 6 月
   The date of an event is the UTC time at which the event takes place.
   Dates are ephemeral values designated with uppercase T.  Running time
   is another timescale that is coincident to the synchronization
   function of the NTP program.事件的日期是事件发生的 UTC 时间。日期是用大写字母 T 指定的临时值。 运行时间是另一个时间刻度，与 NTP 程序的同步功能重合。   A timestamp T(t) represents either the UTC date or time offset from
   UTC at running time t.  Which meaning is intended should be clear
   from the context.  Let T(t) be the time offset, R(t) the frequency
   offset, and D(t) the aging rate (first derivative of R(t) with
   respect to t).  Then, if T(t_0) is the UTC time offset determined at
   t = t_0, the UTC time offset at time t is时间戳 T（t） 表示运行时 t 时与 UTC 的 UTC 日期或时间偏移量。从上下文中应该清楚哪个含义。设 T（t） 为时间偏移，R（t） 为频率偏移，D（t） 为老化速率（R（t） 相对于 t 的一阶导数）。然后，如果 T（t_0） 是在 t = t_0 时确定的 UTC 时间偏移量，则时间 t 处的 UTC 时间偏移量为   T(t) = T(t_0) + R(t_0)(t-t_0) + 1/2 * D(t_0)(t-t_0)^2 + e,T（t） = T（t_0） + R（t_0）（t-t_0） + 1/2 * D（t_0）（t-t_0）^2 + e，   where e is a stochastic error term discussed later in this document.
   While the D(t) term is important when characterizing precision
   oscillators, it is ordinarily neglected for computer oscillators.  In
   this document, all time values are in seconds (s) and all frequency
   values are in seconds-per-second (s/s).  It is sometimes convenient
   to express frequency offsets in parts-per-million (ppm), where 1 ppm
   is equal to 10^(-6) s/s.其中 e 是本文档后面讨论的随机误差项。虽然D（t）项在表征精密振荡器时很重要，但对于计算机振荡器来说，它通常被忽略。在本文档中，所有时间值均以秒为单位，所有频率值均以秒/秒 （s/s） 为单位。有时以百万分之一 （ppm） 表示频率偏移很方便，其中 1 ppm 等于 10^（-6） s/s。   It is important in computer timekeeping applications to assess the
   performance of the timekeeping function.  The NTP performance model
   includes four statistics that are updated each time a client makes a
   measurement with a server.  The offset (theta) represents the
   maximum-likelihood time offset of the server clock relative to the
   system clock.  The delay (delta) represents the round-trip delay
   between the client and server.  The dispersion (epsilon) represents
   the maximum error inherent in the measurement.  It increases at a
   rate equal to the maximum disciplined system clock frequency
   tolerance (PHI), typically 15 ppm.  The jitter (psi) is defined as
   the root-mean-square (RMS) average of the most recent offset
   differences, and it represents the nominal error in estimating the
   offset.在计算机计时应用中，评估计时功能的性能非常重要。NTP 性能模型包括四个统计信息，每次客户端使用服务器进行测量时都会更新这些统计信息。偏移量 （theta） 表示服务器时钟相对于系统时钟的最大似然时间偏移量。延迟 （delta） 表示客户端和服务器之间的往返延迟。色散（epsilon）表示测量中固有的最大误差。它以等于最大约束系统时钟频率容差 （PHI） 的速率增加，通常为 15 ppm。抖动 （psi） 定义为最近偏移差异的均方根 （RMS） 平均值，它表示估计偏移时的标称误差。   While the theta, delta, epsilon, and psi statistics represent
   measurements of the system clock relative to each server clock
   separately, the NTP protocol includes mechanisms to combine the
   statistics of several servers to more accurately discipline and
   calibrate the system clock.  The system offset (THETA) represents the
   maximum-likelihood offset estimate for the server population.  The
   system jitter (PSI) represents the nominal error in estimating the
   system offset.  The delta and epsilon statistics are accumulated at
   each stratum level from the reference clock to produce the root delay
   (DELTA) and root dispersion (EPSILON) statistics.  The
   synchronization distance (LAMBDA) equal to EPSILON + DELTA / 2
   represents the maximum error due to all causes.  The detailed虽然 theta、delta、epsilon 和 psi 统计分别表示相对于每个服务器时钟的系统时钟测量值，但 NTP 协议包括组合多个服务器统计信息的机制，以更准确地规范和校准系统时钟。系统偏移量 （THETA） 表示服务器填充的最大似然偏移估计值。系统抖动 （PSI） 表示估计系统失调的标称误差。从参考时钟开始，在每个层级别上累积 delta 和 epsilon 统计数据，以产生根延迟 （DELTA） 和根色散 （EPSILON） 统计数据。等于 EPSILON + DELTA / 2 的同步距离 （LAMBDA） 表示由于所有原因导致的最大误差。详细的Mills, et al.                Standards Track                    [Page 9]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 9 页] RFC 5905 NTPv4 规范 2010 年 6 月
   formulations of these statistics are given in Section 11.2.  They are
   available to the dependent applications in order to assess the
   performance of the synchronization function.这些统计数据的公式在第 11.2 节中给出。它们可供相关应用程序使用，以评估同步功能的性能。5.  Implementation Model 5. 实施模式   Figure 2 shows the architecture of a typical, multi-threaded
   implementation.  It includes two processes dedicated to each server,
   a peer process to receive messages from the server or reference
   clock, and a poll process to transmit messages to the server or
   reference clock.图 2 显示了典型的多线程实现的体系结构。它包括两个专用于每个服务器的进程，一个用于从服务器或参考时钟接收消息的对等进程，以及一个用于将消息传输到服务器或参考时钟的轮询进程。   .....................................................................
   . Remote   .   Peer/Poll  .              System          .  Clock   .
   . Servers  .   Processes  .              Process         .Discipline.
   .          .              .                              . Process  .
   .+--------+. +-----------+. +------------+               .          .
   .|        |->|           |. |            |               .          .
   .|Server 1|  |Peer/Poll 1|->|            |               .          .
   .|        |<-|           |. |            |               .          .
   .+--------+. +-----------+. |            |               .          .
   .          .       ^      . |            |               .          .
   .          .       |      . |            |               .          .
   .+--------+. +-----------+. |            |  +-----------+.          .
   .|        |->|           |. | Selection  |->|           |. +------+ .
   .|Server 2|  |Peer/Poll 2|->|    and     |  | Combine   |->| Loop | .
   .|        |<-|           |. | Cluster    |  | Algorithm |. |Filter| .
   .+--------+. +-----------+. | Algorithms |->|           |. +------+ .
   .          .       ^      . |            |  +-----------+.    |     .
   .          .       |      . |            |               .    |     .
   .+--------+. +-----------+. |            |               .    |     .
   .|        |->|           |. |            |               .    |     .
   .|Server 3|  |Peer/Poll 3|->|            |               .    |     .
   .|        |<-|           |. |            |               .    |     .
   .+--------+. +-----------+. +------------+               .    |     .
   ....................^.........................................|......
                       |                                    .    V     .
                       |                                    . +-----+  .
                       +--------------------------------------| VFO |  .
                                                            . +-----+  .
                                                            .  Clock   .
                                                            .  Adjust  .
                                                            .  Process .
                                                            ................................................................................. .远程。对等/投票。系统。时钟。.服务器。过程。过程。学科。。。。。过程。.+--------+.+-----------+.+------------+ . . .||->| |.| |. . .|服务器 1| |同行/投票 1|->| |. . .||<-| |. | | . . .+--------+. +-----------+. | | . . . . ^ . | | . . . . | . | | . . .+--------+. +-----------+. | | +-----------+. . .| |->| |. |选择 |->| |.+------+ ..|服务器 2| |同行/投票 2|->|和 | |组合 |->|循环 | ..||<-| |. | 集群 | | 算法 |. |过滤器| . .+--------+. +-----------+. | 算法 |->| |. +------+ . . . ^ . | | | +>------------------------------+. | .服务器 3| |对等/投票 3|->| | .| ..||<-| |.| | .| ..+--------+.+-----------+.+------------+ .| .....................^.........................................|...... |.V .| .+-----+ .+--------------------------------------|VFO | ..+-----+ ..时钟。.调整。.过程。............                      Figure 2: Implementation Model图 2：实现模型Mills, et al.                Standards Track                   [Page 10]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 10 页] RFC 5905 NTPv4 规范 2010 年 6 月
   These processes operate on a common data structure, called an
   association, which contains the statistics described above along with
   various other data described in Section 9.  A client sends packets to
   one or more servers and then processes returned packets when they are
   received.  The server interchanges source and destination addresses
   and ports, overwrites certain fields in the packet and returns it
   immediately (in the client/server mode) or at some time later (in the
   symmetric modes).  As each NTP message is received, the offset theta
   between the peer clock and the system clock is computed along with
   the associated statistics delta, epsilon, and psi.这些过程在称为关联的通用数据结构上运行，该结构包含上述统计信息以及第 9 节中描述的各种其他数据。客户端将数据包发送到一个或多个服务器，然后在收到返回的数据包时对其进行处理。服务器交换源地址和目标地址和端口，覆盖数据包中的某些字段，并立即返回（在客户端/服务器模式下）或稍后的某个时间（在对称模式下）。当接收到每条 NTP 消息时，将对等时钟和系统时钟之间的偏移 θ 与相关的统计 delta、epsilon 和 psi 一起计算。   The system process includes the selection, cluster, and combine
   algorithms that mitigate among the various servers and reference
   clocks to determine the most accurate and reliable candidates to
   synchronize the system clock.  The selection algorithm uses Byzantine
   fault detection principles to discard the presumably incorrect
   candidates called "falsetickers" from the incident population,
   leaving only good candidates called "truechimers".  A truechimer is a
   clock that maintains timekeeping accuracy to a previously published
   and trusted standard, while a falseticker is a clock that shows
   misleading or inconsistent time.  The cluster algorithm uses
   statistical principles to find the most accurate set of truechimers.
   The combine algorithm computes the final clock offset by
   statistically averaging the surviving truechimers.系统过程包括选择、聚类和组合算法，这些算法在各种服务器和参考时钟之间进行缓解，以确定最准确和最可靠的候选算法来同步系统时钟。选择算法使用拜占庭故障检测原理从事件总体中丢弃可能不正确的候选者，称为“falsetickers”，只留下称为“truechimers”的好候选者。真嵌合器是一种时钟，可将计时精度保持在先前发布和可信的标准，而假收音器是显示误导性或不一致时间的时钟。聚类算法使用统计原理来找到最准确的真嵌合体集。组合算法通过对幸存的真嵌合体进行统计平均来计算最终时钟偏移量。   The clock discipline process is a system process that controls the
   time and frequency of the system clock, here represented as a
   variable frequency oscillator (VFO).  Timestamps struck from the VFO
   close the feedback loop that maintains the system clock time.
   Associated with the clock discipline process is the clock-adjust
   process, which runs once each second to inject a computed time offset
   and maintain constant frequency.  The RMS average of past time offset
   differences represents the nominal error or system clock jitter.  The
   RMS average of past frequency offset differences represents the
   oscillator frequency stability or frequency wander.  These terms are
   given precise interpretation in Section 11.3.时钟规则过程是控制系统时钟时间和频率的系统过程，此处表示为变频振荡器 （VFO）。从 VFO 敲击的时间戳关闭了维持系统时钟时间的反馈回路。与时钟规则过程相关的是时钟调整过程，该过程每秒运行一次，以注入计算出的时间偏移并保持恒定的频率。过去时间失调差的RMS平均值表示标称误差或系统时钟抖动。过去频率偏移差异的RMS平均值表示振荡器频率稳定性或频率漂移。这些术语在第 11.3 节中给出了准确的解释。   A client sends messages to each server with a poll interval of 2^tau
   seconds, as determined by the poll exponent tau.  In NTPv4, tau
   ranges from 4 (16 s) to 17 (36 h).  The value of tau is determined by
   the clock discipline algorithm to match the loop-time constant T_c =
   2^tau.  In client/server mode, the server responds immediately;
   however, in symmetric modes, each of two peers manages tau as a
   function of current system offset and system jitter, so they may not
   agree with the same value.  It is important that the dynamic behavior
   of the clock discipline algorithm be carefully controlled in order to
   maintain stability in the NTP subnet at large.  This requires that客户端以 2^tau 秒的轮询间隔向每个服务器发送消息，由轮询指数 tau 确定。在 NTPv4 中，tau 的范围为 4（16 秒）至 17（36 小时）。tau 的值由时钟规则算法确定，以匹配循环时间常数 T_c = 2^tau。在客户端/服务器模式下，服务器立即响应;然而，在对称模式下，两个对等体中的每一个都将 tau 作为当前系统偏移和系统抖动的函数进行管理，因此它们可能不同意相同的值。必须仔细控制时钟规则算法的动态行为，以保持整个 NTP 子网的稳定性。这要求
Mills, et al.                Standards Track                   [Page 11]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 11 页] RFC 5905 NTPv4 规范 2010 年 6 月
   the peers agree on a common tau equal to the minimum poll exponent of
   both peers.  The NTP protocol includes provisions to properly
   negotiate this value.对等体同意一个共同的 tau 等于两个对等体的最小轮询指数。NTP 协议包括正确协商此值的条款。   The implementation model includes some means to set and adjust the
   system clock.  The operating system is assumed to provide two
   functions: one to set the time directly, for example, the Unix
   settimeofday() function, and another to adjust the time in small
   increments advancing or retarding the time by a designated amount,
   for example, the Unix adjtime() function.  In this and following
   references, parentheses following a name indicate reference to a
   function rather than a simple variable.  In the intended design the
   clock discipline process uses the adjtime() function if the
   adjustment is less than a designated threshold, and the
   settimeofday() function if above the threshold.  The manner in which
   this is done and the value of the threshold as described in
   Section 10.实现模型包括一些设置和调整系统时钟的方法。假设操作系统提供两个函数：一个是直接设置时间，例如 Unix settimeofday（） 函数，另一个是以小增量调整时间，将时间提前或延迟指定量，例如 Unix adjtime（） 函数。在此引用和后续引用中，名称后面的括号表示对函数的引用，而不是对简单变量的引用。在预期的设计中，如果调整小于指定阈值，则时钟规则过程使用 adjtime（） 函数，如果高于阈值，则使用 settimeofday（） 函数。执行此操作的方式以及第 10 节中描述的阈值。6.  Data Types 6. 数据类型   All NTP time values are represented in twos-complement format, with
   bits numbered in big-endian (as described in Appendix A of [RFC0791])
   fashion from zero starting at the left, or high-order, position.
   There are three NTP time formats, a 128-bit date format, a 64-bit
   timestamp format, and a 32-bit short format, as shown in Figure 3.
   The 128-bit date format is used where sufficient storage and word
   size are available.  It includes a 64-bit signed seconds field
   spanning 584 billion years and a 64-bit fraction field resolving .05
   attosecond (i.e., 0.5e-18).  For convenience in mapping between
   formats, the seconds field is divided into a 32-bit Era Number field
   and a 32-bit Era Offset field.  Eras cannot be produced by NTP
   directly, nor is there need to do so.  When necessary, they can be
   derived from external means, such as the filesystem or dedicated
   hardware.所有 NTP 时间值都以二进制补码格式表示，位以大端序（如 [RFC0791] 的附录 A 中所述）方式编号，从左到左或高阶位置开始。有三种 NTP 时间格式：128 位日期格式、64 位时间戳格式和 32 位短格式，如图 3 所示。128 位日期格式用于具有足够存储空间和字数可用的地方。它包括一个跨越 5840 亿年的 64 位符号秒域和一个解析 .05 阿秒（即 0.5e-18）的 64 位分数域。为了便于在格式之间映射，秒字段分为 32 位 Era Number 字段和 32 位 Era Offset 字段。NTP不能直接产生时代，也没有必要这样做。必要时，它们可以从外部方式派生，例如文件系统或专用硬件。Mills, et al.                Standards Track                   [Page 12]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 12 页] RFC 5905 NTPv4 规范 2010 年 6 月
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Seconds              |           Fraction            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+秒 |分数 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               NTP Short Format NTP 短格式       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Seconds                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Fraction                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+秒 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |分数 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                             NTP Timestamp Format NTP 时间戳格式       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Era Number                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Era Offset                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                           Fraction                            |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+时代编号 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |时代偏移 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | |分数 | | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              NTP Date Format NTP 日期格式                        Figure 3: NTP Time Formats图 3：NTP 时间格式   The 64-bit timestamp format is used in packet headers and other
   places with limited word size.  It includes a 32-bit unsigned seconds
   field spanning 136 years and a 32-bit fraction field resolving 232
   picoseconds.  The 32-bit short format is used in delay and dispersion
   header fields where the full resolution and range of the other
   formats are not justified.  It includes a 16-bit unsigned seconds
   field and a 16-bit fraction field.64 位时间戳格式用于数据包标头和其他字大小有限的地方。它包括一个跨越 136 年的 32 位无符号秒字段和一个解析 232 皮秒的 32 位分数字段。32 位短格式用于延迟和色散标头字段，其中其他格式的全分辨率和范围不合理。它包括一个 16 位无符号秒字段和一个 16 位分数字段。   In the date and timestamp formats, the prime epoch, or base date of
   era 0, is 0 h 1 January 1900 UTC, when all bits are zero.  It should
   be noted that strictly speaking, UTC did not exist prior to 1 January
   1972, but it is convenient to assume it has existed for all eternity,
   even if all knowledge of historic leap seconds has been lost.  Dates
   are relative to the prime epoch; values greater than zero represent在日期和时间戳格式中，纪元 0 的素数纪元或基准日期是 1900 年 1 月 1 日 0 小时，此时所有位均为零。应该指出的是，严格来说，UTC在1972年1月1日之前并不存在，但即使所有关于历史闰秒的知识都已经丢失，也可以方便地假设它已经永远存在了。日期是相对于黄金时期的;大于零的值表示Mills, et al.                Standards Track                   [Page 13]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 13 页] RFC 5905 NTPv4 规范 2010 年 6 月
   times after that date; values less than zero represent times before
   it.  Note that the Era Offset field of the date format and the
   Seconds field of the timestamp format have the same interpretation.该日期之后的时间;小于零的值表示它之前的时间。请注意，日期格式的“时代偏移量”字段和时间戳格式的“秒”字段具有相同的解释。   Timestamps are unsigned values, and operations on them produce a
   result in the same or adjacent eras.  Era 0 includes dates from the
   prime epoch to some time in 2036, when the timestamp field wraps
   around and the base date for era 1 is established.  In either format,
   a value of zero is a special case representing unknown or
   unsynchronized time.  Figure 4 shows a number of historic NTP dates
   together with their corresponding Modified Julian Day (MJD), NTP era,
   and NTP timestamp.时间戳是无符号值，对它们的操作会在相同或相邻的时代产生结果。纪元 0 包括从黄金纪元到 2036 年某个时间的日期，此时时间戳字段环绕并建立纪元 1 的基准日期。在任一格式中，值为零是表示未知或不同步时间的特例。图 4 显示了许多历史 NTP 日期及其相应的修改儒略日 （MJD）、NTP 时代和 NTP 时间戳。   +-------------+------------+-----+---------------+------------------+
   | Date        | MJD        | NTP | NTP Timestamp | Epoch            |
   |             |            | Era | Era Offset    |                  |
   +-------------+------------+-----+---------------+------------------+
   | 1 Jan -4712 | -2,400,001 | -49 | 1,795,583,104 | 1st day Julian   |
   | 1 Jan -1    | -679,306   | -14 | 139,775,744   | 2 BCE            |
   | 1 Jan 0     | -678,491   | -14 | 171,311,744   | 1 BCE            |
   | 1 Jan 1     | -678,575   | -14 | 202,939,144   | 1 CE             |
   | 4 Oct 1582  | -100,851   | -3  | 2,873,647,488 | Last day Julian  |
   | 15 Oct 1582 | -100,840   | -3  | 2,874,597,888 | First day        |
   |             |            |     |               | Gregorian        |
   | 31 Dec 1899 | 15019      | -1  | 4,294,880,896 | Last day NTP Era |
   |             |            |     |               | -1               |
   | 1 Jan 1900  | 15020      | 0   | 0             | First day NTP    |
   |             |            |     |               | Era 0            |
   | 1 Jan 1970  | 40,587     | 0   | 2,208,988,800 | First day UNIX   |
   | 1 Jan 1972  | 41,317     | 0   | 2,272,060,800 | First day UTC    |
   | 31 Dec 1999 | 51,543     | 0   | 3,155,587,200 | Last day 20th    |
   |             |            |     |               | Century          |
   | 8 Feb 2036  | 64,731     | 1   | 63,104        | First day NTP    |
   |             |            |     |               | Era 1            |
   +-------------+------------+-----+---------------+------------------++-------------+------------+-----+---------------+------------------+ |日期 |MJD （英语：MJD） |NTP公司 |NTP 时间戳 |大纪元 | | | |时代 |时代偏移 | |+-------------+------------+-----+---------------+------------------+ |1 1月 -4712 |-2,400,001 |-49 |1,795,583,104 |第一天 朱利安 | |1 1月 -1 |-679,306 |-14 |139,775,744 |公元前 2 年 | |1 1月 0 |-678,491 |-14 |171,311,744 |公元前 1 年 | |1 1月 1 |-678,575 |-14 |202,939,144 |公元 1 年 | |1582年10月4日 |-100,851 |-3 |2,873,647,488 |最后一天 朱利安 | |1582年10月15日 |-100,840 |-3 |2,874,597,888 |第一天 | | | | | |格里高利历 | |1899年12月31日 |15019 |-1 |4,294,880,896 |最后一天 NTP 时代 | | | | | |-1 | |1900年1月1日 |15020 |0 |0 |NTP第一天 | | | | | |时代 0 | |1970年1月1日 |40,587 |0 |2,208,988,800 |UNIX 第一天 | |1 1月 1972 |41,317 |0 |2,272,060,800 |第一天 UTC | |1999年12月31日 |51,543 |0 |3,155,587,200 |最后一天 20日 | | | | | | |世纪 | |2036 年 2 月 8 日 |64,731 |1 |63,104 |NTP第一天 | | | | | |时代 1 |+-------------+------------+-----+---------------+------------------+                 Figure 4: Interesting Historic NTP Dates图 4：有趣的历史 NTP 日期   Let p be the number of significant bits in the second fraction.  The
   clock resolution is defined as 2^(-p), in seconds.  In order to
   minimize bias and help make timestamps unpredictable to an intruder,
   the non-significant bits should be set to an unbiased random bit
   string.  The clock precision is defined as the running time to read
   the system clock, in seconds.  Note that the precision defined in
   this way can be larger or smaller than the resolution.  The term rho,
   representing the precision used in the protocol, is the larger of the
   two.设 p 为第二部分中的有效位数。时钟分辨率定义为 2^（-p），以秒为单位。为了最大程度地减少偏差并帮助使入侵者无法预测时间戳，非有效位应设置为无偏的随机位串。时钟精度定义为读取系统时钟的运行时间（以秒为单位）。请注意，以这种方式定义的精度可以大于或小于分辨率。术语 rho 表示协议中使用的精度，是两者中较大的一个。
Mills, et al.                Standards Track                   [Page 14]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 14 页] RFC 5905 NTPv4 规范 2010 年 6 月
   The only arithmetic operation permitted on dates and timestamps is
   twos-complement subtraction, yielding a 127-bit or 63-bit signed
   result.  It is critical that the first-order differences between two
   dates preserve the full 128-bit precision and the first-order
   differences between two timestamps preserve the full 64-bit
   precision.  However, the differences are ordinarily small compared to
   the seconds span, so they can be converted to floating double format
   for further processing and without compromising the precision.唯一允许对日期和时间戳进行算术运算的是二进制补码减法，产生 127 位或 63 位有符号结果。至关重要的是，两个日期之间的一阶差异要保留完整的 128 位精度，而两个时间戳之间的一阶差异要保留完整的 64 位精度。但是，与秒跨度相比，差异通常很小，因此可以将它们转换为浮动双精度格式以进行进一步处理，而不会影响精度。   It is important to note that twos-complement arithmetic does not
   distinguish between signed and unsigned values (although comparisons
   can take sign into account); only the conditional branch instructions
   do.  Thus, although the distinction is made between signed dates and
   unsigned timestamps, they are processed the same way.  A perceived
   hazard with 64-bit timestamp calculations spanning an era, such as is
   possible in 2036, might result in over-run.  In point of fact, if the
   client is set within 68 years of the server before the protocol is
   started, correct values are obtained even if the client and server
   are in adjacent eras.需要注意的是，二进制补码算术不区分有符号值和无符号值（尽管比较可以考虑符号）;只有条件分支指令可以。因此，尽管对签名日期和未签名时间戳进行了区分，但它们的处理方式相同。跨一个时代的 64 位时间戳计算（例如在 2036 年可能出现的）的感知危险可能会导致超限。事实上，如果客户端在协议启动前的 68 年内设置，即使客户端和服务器处于相邻的时代，也会获得正确的值。   Some time values are represented in exponent format, including the
   precision, time constant, and poll interval.  These are in 8-bit
   signed integer format in log2 (log base 2) seconds.  The only
   arithmetic operations permitted on them are increment and decrement.
   For the purpose of this document and to simplify the presentation, a
   reference to one of these variables by name means the exponentiated
   value, e.g., the poll interval is 1024 s, while reference by name and
   exponent means the actual value, e.g., the poll exponent is 10.某些时间值以指数格式表示，包括精度、时间常数和轮询间隔。它们采用 8 位有符号整数格式，以 log2（对数基数为 2）秒为单位。唯一允许的算术运算是递增和递减。为了本文档的目的和简化表示，按名称引用这些变量之一意味着指数值，例如，轮询间隔为 1024 s，而按名称和指数引用是指实际值，例如，轮询指数为 10。   To convert system time in any format to NTP date and timestamp
   formats requires that the number of seconds s from the prime epoch to
   the system time be determined.  To determine the integer era and
   timestamp given s,要将任何格式的系统时间转换为 NTP 日期和时间戳格式，需要确定从素数纪元到系统时间的秒数。要确定给定 s 的整数 era 和时间戳，   era = s / 2^(32) and timestamp = s - era * 2^(32),era = s / 2^（32） 和时间戳 = s - era * 2^（32），   which works for positive and negative dates.  To determine s given
   the era and timestamp,这适用于正日期和负日期。要确定给定的时代和时间戳，   s = era * 2^(32) + timestamp.s = era * 2^（32） + 时间戳。   Converting between NTP and system time can be a little messy, and is
   beyond the scope of this document.  Note that the number of days in
   era 0 is one more than the number of days in most other eras, and
   this won't happen again until the year 2400 in era 3.在 NTP 和系统时间之间进行转换可能有点混乱，超出了本文档的讨论范围。请注意，纪元 0 的天数比大多数其他纪元的天数多 1 天，直到 2400 纪元 3 的天数才会再次发生。
Mills, et al.                Standards Track                   [Page 15]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 15 页] RFC 5905 NTPv4 规范 2010 年 6 月
   In the description of state variables to follow, explicit reference
   to integer type implies a 32-bit unsigned integer.  This simplifies
   bounds checks, since only the upper limit needs to be defined.
   Without explicit reference, the default type is 64-bit floating
   double.  Exceptions will be noted as necessary.在要遵循的状态变量的描述中，对整数类型的显式引用意味着一个 32 位无符号整数。这简化了边界检查，因为只需要定义上限。如果没有显式引用，默认类型为 64 位浮动 double。必要时将注明例外情况。7.  Data Structures 7. 数据结构   The NTP state machines are defined in the following sections.  State
   variables are separated into classes according to their function in
   packet headers, peer and poll processes, the system process, and the
   clock discipline process.  Packet variables represent the NTP header
   values in transmitted and received packets.  Peer and poll variables
   represent the contents of the association for each server separately.
   System variables represent the state of the server as seen by its
   dependent clients.  Clock discipline variables represent the internal
   workings of the clock discipline algorithm.  An example is described
   in Appendix A.NTP 状态机在以下各节中定义。状态变量根据它们在数据包标头、对等和轮询过程、系统过程和时钟规则过程中的功能分为几类。数据包变量表示传输和接收数据包中的 NTP 标头值。对等变量和轮询变量分别表示每个服务器的关联内容。系统变量表示服务器的依赖客户端所看到的状态。时钟规则变量表示时钟规则算法的内部工作原理。附录 A 中描述了一个示例。7.1.  Structure Conventions7.1. 结构约定   In order to distinguish between different variables of the same name
   but used in different processes, the naming convention summarized in
   Figure 5 is adopted.  A receive packet variable v is a member of the
   packet structure r with fully qualified name r.v.  In a similar
   manner, x.v is a transmit packet variable, p.v is a peer variable,
   s.v is a system variable, and c.v is a clock discipline variable.
   There is a set of peer variables for each association; there is only
   one set of system and clock variables.为了区分同名但用于不同进程的不同变量，采用了图 5 中总结的命名约定。接收数据包变量 v 是数据包结构 r 的成员，其完全限定名称为 r.v。以类似的方式，x.v 是传输数据包变量，p.v 是对等变量，s.v 是系统变量，c.v 是时钟规则变量。每个关联都有一组对等变量;只有一组系统和时钟变量。                   +------+---------------------------------+
                   | Name | Description                     |
                   +------+---------------------------------+
                   | r.   | receive packet header variable  |
                   | x.   | transmit packet header variable |
                   | p.   | peer/poll variable              |
                   | s.   | system variable                 |
                   | c.   | clock discipline variable       |
                   +------+---------------------------------++------+---------------------------------+ |中文名 |描述 |+------+---------------------------------+ |r. |接收数据包标头变量 | |十。 |传输数据包标头变量 | |页码 |对等/轮询变量 | |秒。 |系统变量 | |三. |时钟规则变量 |+------+---------------------------------+                       Figure 5: Prefix Conventions图 5：前缀约定7.2.  Global Parameters 7.2. 全局参数   In addition to the variable classes, a number of global parameters
   are defined in this document, including those shown with values in
   Figure 6.除了变量类之外，本文档还定义了许多全局参数，包括图 6 中显示的参数。
Mills, et al.                Standards Track                   [Page 16]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 16 页] RFC 5905 NTPv4 规范 2010 年 6 月
            +-----------+-------+----------------------------------+
            | Name      | Value | Description                      |
            +-----------+-------+----------------------------------+
            | PORT      | 123   | NTP port number                  |
            | VERSION   | 4     | NTP version number                   |
            | TOLERANCE | 15e-6 | frequency tolerance PHI (s/s)    |
            | MINPOLL   | 4     | minimum poll exponent (16 s)     |
            | MAXPOLL   | 17    | maximum poll exponent (36 h)     |
            | MAXDISP   | 16    | maximum dispersion (16 s)        |
            | MINDISP   | .005  | minimum dispersion increment (s) |
            | MAXDIST   | 1     | distance threshold (1 s)         |
            | MAXSTRAT  | 16    | maximum stratum number           |
            +-----------+-------+----------------------------------++-----------+-------+----------------------------------+ |中文名 |价值 |描述 |+-----------+-------+----------------------------------+ |港口 |123 |NTP 端口号 | |版本 |4 |NTP 版本号 | |容差 |15E-6型 |频率容差 PHI （s/s） | |闵波 |4 |最小轮询指数 （16 秒） | |麦克斯波尔 |17 |最大轮询指数（36小时） | |MAXDISP公司 |16 |最大色散 （16 s） | |国防部 | .005 |最小色散增量 （s） | |麦克斯迪斯特 |1 |距离阈值 （1 s） | |麦克斯特拉特 |16 |最大层数 |+-----------+-------+----------------------------------+                        Figure 6: Global Parameters图 6：全局参数   While these are the only global parameters needed for
   interoperability, a larger collection is necessary in any
   implementation.  Appendix A.1.1 contains those used by the skeleton
   for the mitigation algorithms, clock discipline algorithm, and
   related implementation-dependent functions.  Some of these parameter
   values are cast in stone, like the NTP port number assigned by the
   IANA and the version number assigned NTPv4 itself.  Others, like the
   frequency tolerance (also called PHI), involve an assumption about
   the worst-case behavior of a system clock once synchronized and then
   allowed to drift when its sources have become unreachable.  The
   minimum and maximum parameters define the limits of state variables
   as described in later sections of this document.虽然这些是互操作性所需的唯一全局参数，但在任何实现中都需要更大的集合。附录 A.1.1 包含骨架用于缓解算法、时钟规则算法和相关实现相关函数的那些。其中一些参数值是一成不变的，例如 IANA 分配的 NTP 端口号和 NTPv4 本身分配的版本号。其他的，如频率容差（也称为PHI），涉及对系统时钟一旦同步的最坏情况行为的假设，然后在其源变得无法访问时允许漂移。最小值和最大值参数定义状态变量的极限，如本文档后面的章节所述。   While shown with fixed values in this document, some implementations
   may make them variables adjustable by configuration commands.  For
   instance, the reference implementation computes the value of
   PRECISION as log2 of the minimum time in several iterations to read
   the system clock.虽然在本文档中以固定值显示，但某些实现可能会使它们成为可通过配置命令调整的变量。例如，参考实现将 PRECISION 的值计算为读取系统时钟的几次迭代中最短时间的 log2。7.3.  Packet Header Variables7.3. 数据包标头变量   The most important state variables from an external point of view are
   the packet header variables described in Figure 7 and below.  The NTP
   packet header consists of an integral number of 32-bit (4 octet)
   words in network byte order.  The packet format consists of three
   components: the header itself, one or more optional extension fields,
   and an optional message authentication code (MAC).  The header
   component is identical to the NTPv3 header and previous versions.
   The optional extension fields are used by the Autokey public key
   cryptographic algorithms described in [RFC5906].  The optional MAC is
   used by both Autokey and the symmetric key cryptographic algorithm
   described in this RFC.从外部角度来看，最重要的状态变量是图 7 和下面描述的数据包标头变量。NTP 数据包标头由按网络字节顺序排列的 32 位（4 个八位字节）字的整数组成。数据包格式由三个组件组成：标头本身、一个或多个可选扩展字段以及可选的消息身份验证代码 （MAC）。标头组件与 NTPv3 标头和早期版本相同。可选扩展字段由 [RFC5906] 中描述的自动密钥公钥加密算法使用。可选的 MAC 由本 RFC 中描述的自动密钥和对称密钥加密算法使用。Mills, et al.                Standards Track                   [Page 17]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 17 页] RFC 5905 NTPv4 规范 2010 年 6 月
               +-----------+------------+-----------------------+
               | Name      | Formula    | Description           |
               +-----------+------------+-----------------------+
               | leap      | leap       | leap indicator (LI)   |
               | version   | version    | version number (VN)   |
               | mode      | mode       | mode                  |
               | stratum   | stratum    | stratum               |
               | poll      | poll       | poll exponent         |
               | precision | rho        | precision exponent    |
               | rootdelay | delta_r    | root delay            |
               | rootdisp  | epsilon_r  | root dispersion       |
               | refid     | refid      | reference ID          |
               | reftime   | reftime    | reference timestamp   |
               | org       | T1         | origin timestamp      |
               | rec       | T2         | receive timestamp     |
               | xmt       | T3         | transmit timestamp    |
               | dst       | T4         | destination timestamp |
               | keyid     | keyid      | key ID                |
               | dgst      | dgst       | message digest        |
               +-----------+------------+-----------------------++-----------+------------+-----------------------+ |中文名 |配方 |描述 |+-----------+------------+-----------------------+ |飞跃 |飞跃 |飞跃指示器 （LI） | |版本 |版本 |版本号 （VN） | |模式 |模式 |模式 | |地层 |地层 |地层 | |民意调查 |民意调查 |轮询指数 | |精密 |RHO公司 |精密指数 | |根延迟 |delta_r |根延迟 | |rootdisp的 |epsilon_r |根系分散 | |refid |refid |参考 ID | |参考时间 |参考时间 |参考时间戳 | |组织 |T1航站楼 |源时间戳 | |建议 |T2航站楼 |接收时间戳 | |XMT系列 |T3航站楼 |传输时间戳 | |夏令时 |T4航站楼 |目标时间戳 | |密钥 ID |密钥 ID |密钥 ID | |DGST公司 |DGST公司 |消息摘要 |+-----------+------------+-----------------------+                     Figure 7: Packet Header Variables图 7：数据包标头变量   The NTP packet is a UDP datagram [RFC0768].  Some fields use multiple
   words and others are packed in smaller fields within a word.  The NTP
   packet header shown in Figure 8 has 12 words followed by optional
   extension fields and finally an optional message authentication code
   (MAC) consisting of the Key Identifier field and Message Digest
   field.NTP 数据包是 UDP 数据报 [RFC0768]。有些字段使用多个单词，而其他字段则包含在一个单词中的较小字段中。图 8 所示的 NTP 数据包报头有 12 个字，后跟可选的扩展字段，最后是可选的消息身份验证代码 （MAC），由 Key Identifier 字段和 Message Digest 字段组成。
Mills, et al.                Standards Track                   [Page 18]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 18 页] RFC 5905 NTPv4 规范 2010 年 6 月
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |LI | VN  |Mode |    Stratum     |     Poll      |  Precision   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Root Delay                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Root Dispersion                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Reference ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                     Reference Timestamp (64)                  +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                      Origin Timestamp (64)                    +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                      Receive Timestamp (64)                   +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                      Transmit Timestamp (64)                  +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      .                                                               .
      .                    Extension Field 1 (variable)               .
      .                                                               .
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      .                                                               .
      .                    Extension Field 2 (variable)               .
      .                                                               .
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Key Identifier                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                            dgst (128)                         |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+李 |越南 |模式 |地层 |投票 |精密 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |根延迟 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |根系分散 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |参考 ID |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |+ 参考时间戳 （64） + | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |+ 源时间戳 （64） + | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |+ 接收时间戳 （64） + | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |+ 传输时间戳 （64） + | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |. . .扩展字段 1（可变） . . . ||+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | |. . .扩展字段 2（可变） . . . ||+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |密钥标识符 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | |DGST （128） | | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                      Figure 8: Packet Header Format图 8：数据包标头格式
Mills, et al.                Standards Track                   [Page 19]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 19 页] RFC 5905 NTPv4 规范 2010 年 6 月
   The extension fields are used to add optional capabilities, for
   example, the Autokey security protocol [RFC5906].  The extension
   field format is presented in order for the packet to be parsed
   without the knowledge of the extension field functions.  The MAC is
   used by both Autokey and the symmetric key authentication scheme.扩展字段用于添加可选功能，例如自动密钥安全协议 [RFC5906]。提供扩展字段格式是为了在不了解扩展字段函数的情况下解析数据包。MAC 由自动密钥和对称密钥身份验证方案使用。   A list of the packet header variables is shown in Figure 7 and
   described in detail below.  Except for a minor variation when using
   the IPv6 address family, these fields are backwards compatible with
   NTPv3.  The packet header fields apply to both transmitted packets (x
   prefix) and received packets (r prefix).  In Figure 8, the size of
   some multiple-word fields is shown in bits if not the default 32
   bits.  The basic header extends from the beginning of the packet to
   the end of the Transmit Timestamp field.图 7 显示了数据包标头变量的列表，下面将详细描述。除了使用 IPv6 地址系列时略有不同外，这些字段向后兼容 NTPv3。数据包标头字段适用于传输的数据包（x 前缀）和接收的数据包（r 前缀）。在图 8 中，一些多字字段的大小以位为单位显示，如果不是默认的 32 位。基本标头从数据包的开头延伸到传输时间戳字段的末尾。   The fields and associated packet variables (in parentheses) are
   interpreted as follows:字段和关联的数据包变量（括号中）解释如下：   LI Leap Indicator (leap): 2-bit integer warning of an impending leap
   second to be inserted or deleted in the last minute of the current
   month with values defined in Figure 9.LI 闰位指示器 （闰）：2 位整数警告，表示在当月最后一分钟插入或删除即将插入或删除的闰秒，值如图 9 所示。           +-------+----------------------------------------+
           | Value | Meaning                                |
           +-------+----------------------------------------+
           | 0     | no warning                             |
           | 1     | last minute of the day has 61 seconds  |
           | 2     | last minute of the day has 59 seconds  |
           | 3     | unknown (clock unsynchronized)         |
           +-------+----------------------------------------++-------+----------------------------------------+ |价值 |意义 |+-------+----------------------------------------+ |0 |无警告 | |1 |一天的最后一分钟有 61 秒 | |2 |一天的最后一分钟有 59 秒 | |3 |未知（时钟不同步） |+-------+----------------------------------------+                         Figure 9: Leap Indicator图 9：飞跃指示器   VN Version Number (version): 3-bit integer representing the NTP
   version number, currently 4.VN 版本号（版本）：表示 NTP 版本号的 3 位整数，当前为 4。   Mode (mode): 3-bit integer representing the mode, with values defined
   in Figure 10.模式（mode）：表示模式的 3 位整数，其值如图 10 所示。Mills, et al.                Standards Track                   [Page 20]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 20 页] RFC 5905 NTPv4 规范 2010 年 6 月
                      +-------+--------------------------+
                      | Value | Meaning                  |
                      +-------+--------------------------+
                      | 0     | reserved                 |
                      | 1     | symmetric active         |
                      | 2     | symmetric passive        |
                      | 3     | client                   |
                      | 4     | server                   |
                      | 5     | broadcast                |
                      | 6     | NTP control message      |
                      | 7     | reserved for private use |
                      +-------+--------------------------++-------+--------------------------+ |价值 |意义 |+-------+--------------------------+ |0 |保留 | |1 |对称活动 | |2 |对称无源 | |3 |客户 | |4 |服务器 | |5 |广播 | |6 |NTP 控制消息 | |7 |仅供私人使用 |+-------+--------------------------+                       Figure 10: Association Modes图 10：关联模式   Stratum (stratum): 8-bit integer representing the stratum, with
   values defined in Figure 11.Stratum （stratum）：表示地层的 8 位整数，其值如图 11 所示。        +--------+-----------------------------------------------------+
        | Value  | Meaning                                             |
        +--------+-----------------------------------------------------+
        | 0      | unspecified or invalid                              |
        | 1      | primary server (e.g., equipped with a GPS receiver) |
        | 2-15   | secondary server (via NTP)                          |
        | 16     | unsynchronized                                      |
        | 17-255 | reserved                                            |
        +--------+-----------------------------------------------------++--------+-----------------------------------------------------+ |价值 |意义 |+--------+-----------------------------------------------------+ |0 |未指定或无效 | |1 |主服务器（例如，配备 GPS 接收器）| |2-15 |辅助服务器（通过 NTP） | |16 |不同步 | |17-255 |保留 |+--------+-----------------------------------------------------+                         Figure 11: Packet Stratum图 11：数据包层   It is customary to map the stratum value 0 in received packets to
   MAXSTRAT (16) in the peer variable p.stratum and to map p.stratum
   values of MAXSTRAT or greater to 0 in transmitted packets.  This
   allows reference clocks, which normally appear at stratum 0, to be
   conveniently mitigated using the same clock selection algorithms used
   for external sources (see Appendix A.5.5.1 for an example).习惯上将接收数据包中的层值 0 映射到对等变量 p.stratum 中的 MAXSTRAT （16），并将传输数据包中的 MAXSTRAT 或更大的 p.stratum 值映射到 0。这允许使用与外部源相同的时钟选择算法（参见附录 A.5.5.1）方便地缓解通常出现在第 0 层的参考时钟。   Poll: 8-bit signed integer representing the maximum interval between
   successive messages, in log2 seconds.  Suggested default limits for
   minimum and maximum poll intervals are 6 and 10, respectively.轮询：8 位有符号整数，表示连续消息之间的最大间隔，以 log2 秒为单位。建议的最小轮询间隔和最大轮询间隔的默认限制分别为 6 和 10。   Precision: 8-bit signed integer representing the precision of the
   system clock, in log2 seconds.  For instance, a value of -18
   corresponds to a precision of about one microsecond.  The precision
   can be determined when the service first starts up as the minimum
   time of several iterations to read the system clock.精度：8 位有符号整数，表示系统时钟的精度，单位为 log2 秒。例如，值 -18 对应于大约 1 微秒的精度。该精度可以在服务首次启动时确定为读取系统时钟的多次迭代的最短时间。Mills, et al.                Standards Track                   [Page 21]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 21 页] RFC 5905 NTPv4 规范 2010 年 6 月
   Root Delay (rootdelay): Total round-trip delay to the reference
   clock, in NTP short format.根延迟 （rootdelay）：参考时钟的总往返延迟，采用 NTP 短格式。   Root Dispersion (rootdisp): Total dispersion to the reference clock,
   in NTP short format.根色散 （rootdisp）：参考时钟的总色散，采用 NTP 短格式。   Reference ID (refid): 32-bit code identifying the particular server
   or reference clock.  The interpretation depends on the value in the
   stratum field.  For packet stratum 0 (unspecified or invalid), this
   is a four-character ASCII [RFC1345] string, called the "kiss code",
   used for debugging and monitoring purposes.  For stratum 1 (reference
   clock), this is a four-octet, left-justified, zero-padded ASCII
   string assigned to the reference clock.  The authoritative list of
   Reference Identifiers is maintained by IANA; however, any string
   beginning with the ASCII character "X" is reserved for unregistered
   experimentation and development.  The identifiers in Figure 12 have
   been used as ASCII identifiers:引用 ID （refid）：标识特定服务器或参考时钟的 32 位代码。解释取决于地层字段中的值。对于数据包层 0（未指定或无效），这是一个四字符的 ASCII [RFC1345] 字符串，称为“kiss 代码”，用于调试和监视目的。对于第 1 层（参考时钟），这是一个分配给参考时钟的四个八位字节、左对齐、零填充的 ASCII 字符串。参考标识符的权威列表由 IANA 维护;但是，任何以 ASCII 字符“X”开头的字符串都保留用于未注册的实验和开发。图 12 中的标识符已用作 ASCII 标识符：     +------+----------------------------------------------------------+
     | ID   | Clock Source                                             |
     +------+----------------------------------------------------------+
     | GOES | Geosynchronous Orbit Environment Satellite               |
     | GPS  | Global Position System                                   |
     | GAL  | Galileo Positioning System                               |
     | PPS  | Generic pulse-per-second                                 |
     | IRIG | Inter-Range Instrumentation Group                        |
     | WWVB | LF Radio WWVB Ft. Collins, CO 60 kHz                     |
     | DCF  | LF Radio DCF77 Mainflingen, DE 77.5 kHz                  |
     | HBG  | LF Radio HBG Prangins, HB 75 kHz                         |
     | MSF  | LF Radio MSF Anthorn, UK 60 kHz                          |
     | JJY  | LF Radio JJY Fukushima, JP 40 kHz, Saga, JP 60 kHz       |
     | LORC | MF Radio LORAN C station, 100 kHz                        |
     | TDF  | MF Radio Allouis, FR 162 kHz                             |
     | CHU  | HF Radio CHU Ottawa, Ontario                             |
     | WWV  | HF Radio WWV Ft. Collins, CO                             |
     | WWVH | HF Radio WWVH Kauai, HI                                  |
     | NIST | NIST telephone modem                                     |
     | ACTS | NIST telephone modem                                     |
     | USNO | USNO telephone modem                                     |
     | PTB  | European telephone modem                                 |
     +------+----------------------------------------------------------++------+----------------------------------------------------------+ |编号 |时钟源 |+------+----------------------------------------------------------+ |去 |地球同步轨道环境卫星 | |全球定位系统 |全球定位系统 | |盖尔 |伽利略定位系统 | |缴费灵 |通用每秒脉冲数 | |IRIG公司 |跨系列仪表组 | |世界自然联盟 |低频收音机 WWVB Ft. Collins， CO 60 kHz | |DCF公司 |低频收音机 DCF77 Mainflingen，DE 77.5 kHz | |HBG公司 |低频收音机 HBG Prangins，HB 75 kHz | |无国界医生 |LF Radio MSF Anthorn， 英国 60 kHz | |JJY公司 |低频收音机 JJY 福岛， JP 40 kHz， 佐贺， JP 60 kHz | |洛克 |MF Radio LORAN C 电台，100 kHz | |TDF系列 |MF Radio Allouis，FR 162 kHz | |朱 |HF Radio CHU 安大略省渥太华 | |世界五大 |HF Radio WWV 科罗拉多州柯林斯堡 | |WWVH公司 |HF Radio WWVH 可爱岛，夏威夷 | |NIST标准核电站（NIST）NIST电话调制解调器 | |使徒行传 |NIST电话调制解调器 | |USNO公司 |USNO 电话调制解调器 | |PTB公司 |欧洲电话调制解调器 |+------+----------------------------------------------------------+                     Figure 12: Reference Identifiers图 12：引用标识符   Above stratum 1 (secondary servers and clients): this is the
   reference identifier of the server and can be used to detect timing
   loops.  If using the IPv4 address family, the identifier is the four-
   octet IPv4 address.  If using the IPv6 address family, it is the以上层 1（辅助服务器和客户端）：这是服务器的参考标识符，可用于检测时序循环。如果使用 IPv4 地址系列，则标识符是四八位字节 IPv4 地址。如果使用 IPv6 地址系列，则为Mills, et al.                Standards Track                   [Page 22]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 22 页] RFC 5905 NTPv4 规范 2010 年 6 月
   first four octets of the MD5 hash of the IPv6 address.  Note that,
   when using the IPv6 address family on an NTPv4 server with a NTPv3
   client, the Reference Identifier field appears to be a random value
   and a timing loop might not be detected.IPv6 地址的 MD5 哈希的前四个八位字节。请注意，在具有 NTPv3 客户端的 NTPv4 服务器上使用 IPv6 地址系列时，“引用标识符”字段显示为随机值，并且可能无法检测到时序循环。   Reference Timestamp: Time when the system clock was last set or
   corrected, in NTP timestamp format.参考时间戳：上次设置或更正系统时钟的时间，采用 NTP 时间戳格式。   Origin Timestamp (org): Time at the client when the request departed
   for the server, in NTP timestamp format.源时间戳 （org）：请求离开服务器时在客户端的时间，采用 NTP 时间戳格式。   Receive Timestamp (rec): Time at the server when the request arrived
   from the client, in NTP timestamp format.接收时间戳 （rec）：请求从客户端到达服务器的时间，采用 NTP 时间戳格式。   Transmit Timestamp (xmt): Time at the server when the response left
   for the client, in NTP timestamp format.传输时间戳 （xmt）：响应离开客户端时在服务器上的时间，采用 NTP 时间戳格式。   Destination Timestamp (dst): Time at the client when the reply
   arrived from the server, in NTP timestamp format.目标时间戳 （dst）：回复从服务器到达时在客户端的时间，采用 NTP 时间戳格式。   Note: The Destination Timestamp field is not included as a header
   field; it is determined upon arrival of the packet and made available
   in the packet buffer data structure.注意：目标时间戳字段未作为标题字段包含在内;它是在数据包到达时确定的，并在数据包缓冲区数据结构中可用。   If the NTP has access to the physical layer, then the timestamps are
   associated with the beginning of the symbol after the start of frame.
   Otherwise, implementations should attempt to associate the timestamp
   to the earliest accessible point in the frame.如果 NTP 可以访问物理层，则时间戳将与帧开始后符号的开头相关联。否则，实现应尝试将时间戳关联到帧中最早的可访问点。   The MAC consists of the Key Identifier followed by the Message
   Digest.  The message digest, or cryptosum, is calculated as in
   [RFC1321] over all NTP-header and optional extension fields, but not
   the MAC itself.MAC 由密钥标识符和消息摘要组成。消息摘要或 cryptosum 按 [RFC1321] 中对所有 NTP 标头和可选扩展字段进行计算，但不计算 MAC 本身。   Extension Field n: See Section 7.5 for a description of the format of
   this field.扩展字段 n：有关此字段格式的说明，请参见第 7.5 节。   Key Identifier (keyid): 32-bit unsigned integer used by the client
   and server to designate a secret 128-bit MD5 key.密钥标识符 （keyid）：客户端和服务器用于指定机密 128 位 MD5 密钥的 32 位无符号整数。   Message Digest (digest): 128-bit MD5 hash computed over the key
   followed by the NTP packet header and extensions fields (but not the
   Key Identifier or Message Digest fields).消息摘要（摘要）：通过密钥计算的 128 位 MD5 哈希，后跟 NTP 数据包标头和扩展字段（但不包括密钥标识符或消息摘要字段）。   It should be noted that the MAC computation used here differs from
   those defined in [RFC1305] and [RFC4330] but is consistent with how
   existing implementations generate a MAC.应该注意的是，这里使用的MAC计算与[RFC1305]和[RFC4330]中定义的MAC计算不同，但与现有实现生成MAC的方式一致。
Mills, et al.                Standards Track                   [Page 23]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 23 页] RFC 5905 NTPv4 规范 2010 年 6 月
7.4.  The Kiss-o'-Death Packet7.4. 死亡之吻包   If the Stratum field is 0, which implies unspecified or invalid, the
   Reference Identifier field can be used to convey messages useful for
   status reporting and access control.  These are called Kiss-o'-Death
   (KoD) packets and the ASCII messages they convey are called kiss
   codes.  The KoD packets got their name because an early use was to
   tell clients to stop sending packets that violate server access
   controls.  The kiss codes can provide useful information for an
   intelligent client, either NTPv4 or SNTPv4.  Kiss codes are encoded
   in four-character ASCII strings that are left justified and zero
   filled.  The strings are designed for character displays and log
   files.  A list of the currently defined kiss codes is given in
   Figure 13.  Recipients of kiss codes MUST inspect them and, in the
   following cases, take these actions:如果 Stratum 字段为 0（表示未指定或无效），则 Reference Identifier 字段可用于传达对状态报告和访问控制有用的消息。这些称为 Kiss-o'-Death （KoD） 数据包，它们传达的 ASCII 消息称为 kiss 代码。KoD 数据包之所以得名，是因为早期的用途是告诉客户端停止发送违反服务器访问控制的数据包。kiss 代码可以为智能客户端（NTPv4 或 SNTPv4）提供有用的信息。 Kiss 代码以四字符 ASCII 字符串编码，这些字符串左对齐且填充为零。这些字符串专为字符显示和日志文件而设计。图 13 给出了当前定义的接吻代码列表。接吻代码的接收者必须检查它们，并在以下情况下采取以下措施：   a.  For kiss codes DENY and RSTR, the client MUST demobilize any
       associations to that server and stop sending packets to that
       server;一个。对于 KISS 代码 DENY 和 RSTR，客户端必须解除与该服务器的任何关联，并停止向该服务器发送数据包;   b.  For kiss code RATE, the client MUST immediately reduce its
       polling interval to that server and continue to reduce it each
       time it receives a RATE kiss code.b.对于 kiss 代码 RATE，客户端必须立即减少其到该服务器的轮询间隔，并在每次收到 RATE kiss 代码时继续缩短轮询间隔。   c.  Kiss codes beginning with the ASCII character "X" are for
       unregistered experimentation and development and MUST be ignored
       if not recognized.c.以 ASCII 字符“X”开头的 KISS 代码用于未注册的实验和开发，如果无法识别，则必须忽略。   d.  Other than the above conditions, KoD packets have no protocol
       significance and are discarded after inspection.d.除上述情况外，KoD数据包没有协议意义，检查后会丢弃。Mills, et al.                Standards Track                   [Page 24]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 24 页] RFC 5905 NTPv4 规范 2010 年 6 月
   +------+------------------------------------------------------------+
   | Code |                           Meaning                          |
   +------+------------------------------------------------------------+
   | ACST | The association belongs to a unicast server.               |
   | AUTH | Server authentication failed.                              |
   | AUTO | Autokey sequence failed.                                   |
   | BCST | The association belongs to a broadcast server.             |
   | CRYP | Cryptographic authentication or identification failed.     |
   | DENY | Access denied by remote server.                            |
   | DROP | Lost peer in symmetric mode.                               |
   | RSTR | Access denied due to local policy.                         |
   | INIT | The association has not yet synchronized for the first     |
   |      | time.                                                      |
   | MCST | The association belongs to a dynamically discovered server.|
   | NKEY | No key found. Either the key was never installed or is     |
   |      | not trusted.                                               |
   | RATE | Rate exceeded. The server has temporarily denied access    |
   |      | because the client exceeded the rate threshold.            |
   | RMOT | Alteration of association from a remote host running       |
   |      | ntpdc.                                                     |
   | STEP | A step change in system time has occurred, but the         |
   |      | association has not yet resynchronized.                    |
   +------+------------------------------------------------------------++------+------------------------------------------------------------+ |代码 |意义 |+------+------------------------------------------------------------+ |ACST公司 |关联属于单播服务器。| |身份验证 |服务器身份验证失败。| |汽车 |自动密钥序列失败。| |BCST标准时间 |关联属于广播服务器。| |克里普 |加密身份验证或标识失败。| |拒绝 |远程服务器拒绝访问。| |掉落 |在对称模式下丢失对等体。| |RSTR公司 |由于当地策略，访问被拒绝。| |初始化 |关联尚未同步第一个 | | |时间。| |MCST系列 |关联属于动态发现的服务器。||NKEY公司 |未找到密钥。密钥从未安装过，或者是 | | |不可信。| |价格 |超出率。服务器暂时拒绝访问 | | |因为客户端超出了速率阈值。| |RMOT公司 |从运行的远程主机更改关联 | | |NTPDC的。| |步骤 |系统时间发生了阶跃变化，但 | | |关联尚未重新同步。|+------+------------------------------------------------------------+                           Figure 13: Kiss Codes图 13：亲吻代码   The Receive Timestamp and the Transmit Timestamp (set by the server)
   are undefined when in a KoD packet and MUST NOT be relied upon to
   have valid values and MUST be discarded.在 KoD 数据包中，接收时间戳和传输时间戳（由服务器设置）是未定义的，不得依赖其具有有效值，并且必须丢弃。7.5.  NTP Extension Field Format7.5. NTP扩展字段格式   In NTPv4, one or more extension fields can be inserted after the
   header and before the MAC, which is always present when an extension
   field is present.  Other than defining the field format, this
   document makes no use of the field contents.  An extension field
   contains a request or response message in the format shown in
   Figure 14.在 NTPv4 中，可以在标头之后和 MAC 之前插入一个或多个扩展字段，当存在扩展字段时，MAC 始终存在。除了定义字段格式外，本文档不使用字段内容。扩展字段包含如图 14 所示格式的请求或响应消息。Mills, et al.                Standards Track                   [Page 25]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 25 页] RFC 5905 NTPv4 规范 2010 年 6 月
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Field Type           |            Length             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      .                                                               .
      .                            Value                              .
      .                                                               .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Padding (as needed)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+字段类型 |长度 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ . . .值 . . . +-+-+-+-+-+-+填充（根据需要） |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                     Figure 14: Extension Field Format图 14：扩展字段格式   All extension fields are zero-padded to a word (four octets)
   boundary.  The Field Type field is specific to the defined function
   and is not elaborated here.  While the minimum field length
   containing required fields is four words (16 octets), a maximum field
   length remains to be established.所有扩展字段都以零填充到单词（四个八位字节）边界。“字段类型”字段特定于定义的函数，此处不作详细说明。虽然包含必填字段的最小字段长度为 4 个单词（16 个八位字节），但最大字段长度仍有待确定。   The Length field is a 16-bit unsigned integer that indicates the
   length of the entire extension field in octets, including the Padding
   field.Length 字段是一个 16 位无符号整数，以八位字节表示整个扩展字段的长度，包括 Padding 字段。8.  On-Wire Protocol 8. 在线协议   The heart of the NTP on-wire protocol is the core mechanism that
   exchanges time values between servers, peers, and clients.  It is
   inherently resistant to lost or duplicate packets.  Data integrity is
   provided by the IP and UDP checksums.  No flow control or
   retransmission facilities are provided or necessary.  The protocol
   uses timestamps, which are either extracted from packet headers or
   struck from the system clock upon the arrival or departure of a
   packet.  Timestamps are precision data and should be restruck in the
   case of link-level retransmission and corrected for the time to
   compute a MAC in transmit.NTP 在线协议的核心是在服务器、对等体和客户端之间交换时间值的核心机制。它本身就具有抵抗丢失或重复数据包的能力。数据完整性由 IP 和 UDP 校验和提供。没有提供或不需要流量控制或重传设施。该协议使用时间戳，时间戳要么从数据包标头中提取，要么在数据包到达或离开时从系统时钟中发出。时间戳是精确数据，在链路级重传的情况下应重新敲击，并针对计算传输中 MAC 的时间进行校正。   NTP messages make use of two different communication modes, one-to-
   one and one-to-many, commonly referred to as unicast and broadcast.
   For the purposes of this document, the term broadcast is interpreted
   as any available one-to-many mechanism.  For IPv4, this equates to
   either IPv4 broadcast or IPv4 multicast.  For IPv6, this equates to
   IPv6 multicast.  For this purpose, IANA has allocated the IPv4
   multicast address 224.0.1.1 and the IPv6 multicast address ending
   :101, with the prefix determined by scoping rules.  Any other non-
   allocated multicast address may also be used in addition to these
   allocated multicast addresses.NTP 消息使用两种不同的通信模式，一对一和一对多，通常称为单播和广播。就本文档而言，术语广播被解释为任何可用的一对多机制。对于 IPv4，这相当于 IPv4 广播或 IPv4 组播。对于 IPv6，这等同于 IPv6 组播。为此，IANA 分配了 IPv4 组播地址 224.0.1.1 和以 ：101 结尾的 IPv6 组播地址，前缀由范围规则确定。除了这些分配的组播地址外，还可以使用任何其他未分配的组播地址。
Mills, et al.                Standards Track                   [Page 26]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 26 页] RFC 5905 NTPv4 规范 2010 年 6 月
   The on-wire protocol uses four timestamps numbered t1 through t4 and
   three state variables org, rec, and xmt, as shown in Figure 15.  This
   figure shows the most general case where each of two peers, A and B,
   independently measure the offset and delay relative to the other.
   For purposes of illustration, the packet timestamps are shown in
   lowercase, while the state variables are shown in uppercase.  The
   state variables are copied from the packet timestamps upon arrival or
   departure of a packet.在线协议使用四个编号为 t1 到 t4 的时间戳和三个状态变量 org、rec 和 xmt，如图 15 所示。该图显示了最一般的情况，其中两个对等体（A 和 B）中的每一个都独立测量相对于另一个对等体的偏移和延迟。为了便于说明，数据包时间戳以小写形式显示，而状态变量以大写形式显示。状态变量在数据包到达或离开时从数据包时间戳中复制。Mills, et al.                Standards Track                   [Page 27]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 27 页] RFC 5905 NTPv4 规范 2010 年 6 月
             t2            t3           t6            t7
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t1   |   |   t3    |   |    t5   |
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t2   |   |   t4    |   |    t6   |  Packet
        +---------+   +---------+   +---------+   +---------+ Timestamps
        |   t1    |   |t3=clock |   |   t5    |   |t7=clock |
        +---------+   +---------+   +---------+   +---------+
        |t2=clock |                 |t6=clock |
        +---------+                 +---------+
                                                               Peer B
        +---------+   +---------+   +---------+   +---------+
   org  |   T1    |   |    T1   |   | t5<>T1? |   |    T5   |
        +---------+   +---------+   +---------+   +---------+   State
   rec  |   T2    |   |    T2   |   |   T6    |   |    T6   | Variables
        +---------+   +---------+   +---------+   +---------+
   xmt  |    0    |   |    T3   |   |  t3=T3? |   |    T7   |
        +---------+   +---------+   +---------+   +---------+T2 T3 T6 T7 +---------+ +---------+ +---------+ +---------+ |0 | |T1系列 | |T3系列 | |T5系列 |+---------+ +---------+ +---------+ +---------+ |0 | |T2系列 | |T4系列 | |T6系列 |数据包 +---------+ +---------+ +---------+ +---------+ 时间戳 |t1 | |t3=时钟 | |t5 | |t7=时钟 |+---------+ +---------+ +---------+ +---------+ |t2=时钟 | |t6=时钟 |+---------+ +---------+ 对等 B +---------+ +---------+ +---------+ +---------+ 组织 |T1航站楼 | |T1航站楼 | |t5<>T1？ | |T5航站楼 |+---------+ +---------+ +---------+ +---------+ 状态记录 |T2航站楼 | |T2航站楼 | |T6系列 | |T6系列 |变量 +---------+ +---------+ +---------+ +---------+ xmt |0 | |T3 系列 | |t3=T3？ | |T7系列 |+---------+ +---------+ +---------+ +---------+                  t2      t3                 t6          t7
        ---------------------------------------------------------
                 /\         \                 /\            \
                 /           \                /              \
                /             \              /                \
               /               \/           /                 \/
        ---------------------------------------------------------
             t1                t4         t5                  t8T2 T3 T6 T7 --------------------------------------------------------- /\ \ /\ \ / \ / \ / \ / \ / \/ \/ \/ --------------------------------------------------------- T1 T4 T5 T8            t1            t4            t5             t8
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t1   |   |   t3    |   |    t5   |
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t2   |   |   t4    |   |    t6   |  Packet
        +---------+   +---------+   +---------+   +---------+ Timestamps
        |t1=clock |   |    t3   |   |t5=clock |   |    t7   |
        +---------+   +---------+   +---------+   +---------+
                      |t4=clock |                 |t8=clock |
                      +---------+                 +---------+
                                                               Peer A
        +---------+   +---------+   +---------+   +---------+
   org  |    0    |   |  t3<>0? |   |   T3    |   | t7<>T3? |
        +---------+   +---------+   +---------+   +---------+   State
   rec  |    0    |   |    T4   |   |   T4    |   |    T8   | Variables
        +---------+   +---------+   +---------+   +---------+
   xmt  |   T1    |   |  t1=T1? |   |   T5    |   |  t5=T5? |
        +---------+   +---------+   +---------+   +---------+T1 T4 T5 T8 +---------+ +---------+ +---------+ +---------+ |0 | |T1系列 | |T3系列 | |T5系列 |+---------+ +---------+ +---------+ +---------+ |0 | |T2系列 | |T4系列 | |T6系列 |数据包 +---------+ +---------+ +---------+ +---------+ 时间戳 |t1=时钟 | |t3 | |t5=时钟 | |T7系列 |+---------+ +---------+ +---------+ +---------+ |t4=时钟 | |t8=时钟 |+---------+ +---------+ 对等 A +---------+ +---------+ +---------+ +---------+ org |0 | |t3<>0？ | |T3 系列 | |t7<>T3？ |+---------+ +---------+ +---------+ +---------+ 状态记录 |0 | |T4 系列 | |T4 系列 | |T8系列 |变量 +---------+ +---------+ +---------+ +---------+ xmt |T1航站楼 | |t1=T1？ | |T5 系列 | |t5=T5？|+---------+ +---------+ +---------+ +---------+                        Figure 15: On-Wire Protocol图 15：在线协议Mills, et al.                Standards Track                   [Page 28]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 28 页] RFC 5905 NTPv4 规范 2010 年 6 月
   In the figure, the first packet transmitted by A contains only the
   origin timestamp t1, which is then copied to T1.  B receives the
   packet at t2 and copies t1 to T1 and the receive timestamp t2 to T2.
   At this time or some time later at t3, B sends a packet to A
   containing t1 and t2 and the transmit timestamp t3.  All three
   timestamps are copied to the corresponding state variables.  A
   receives the packet at t4 containing the three timestamps t1, t2, and
   t3 and the destination timestamp t4.  These four timestamps are used
   to compute the offset and delay of B relative to A, as described
   below.在图中，A传输的第一个数据包仅包含源时间戳t1，然后将其复制到T1。B 在 t2 处接收数据包，并将 t1 复制到 T1，并将接收时间戳 t2 复制到 T2。此时或稍后的 t3 处，B 向 A 发送一个包含 t1 和 t2 以及传输时间戳 t3 的数据包。所有三个时间戳都复制到相应的状态变量。A 在 t4 处接收包含三个时间戳 t1、t2 和 t3 以及目标时间戳 t4 的数据包。这四个时间戳用于计算 B 相对于 A 的偏移和延迟，如下所述。   Before the xmt and org state variables are updated, two sanity checks
   are performed in order to protect against duplicate, bogus, or
   replayed packets.  In the exchange above, a packet is duplicate or
   replay if the transmit timestamp t3 in the packet matches the org
   state variable T3.  A packet is bogus if the origin timestamp t1 in
   the packet does not match the xmt state variable T1.  In either of
   these cases, the state variables are updated, then the packet is
   discarded.  To protect against replay of the last transmitted packet,
   the xmt state variable is set to zero immediately after a successful
   bogus check.在更新 xmt 和 org 状态变量之前，将执行两次健全性检查，以防止重复、虚假或重放的数据包。在上面的交换中，如果数据包中的传输时间戳 t3 与组织状态变量 T3 匹配，则数据包是重复的或重放的。如果数据包中的源时间戳 t1 与 xmt 状态变量 T1 不匹配，则数据包是假的。在这两种情况下，状态变量都会更新，然后丢弃数据包。为了防止上次传输的数据包重放，xmt 状态变量在成功进行虚假检查后立即设置为零。   The four most recent timestamps, T1 through T4, are used to compute
   the offset of B relative to A最近的四个时间戳（T1 到 T4）用于计算 B 相对于 A 的偏移量   theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T3-T4)]θ = T（B） - T（A） = 1/2 * [（T2-T1） + （T3-T4）]   and the round-trip delay和往返延迟   delta = T(ABA) = (T4-T1) - (T3-T2).delta = T（ABA） = （T4-T1） - （T3-T2）。   Note that the quantities within parentheses are computed from 64-bit
   unsigned timestamps and result in signed values with 63 significant
   bits plus sign.  These values can represent dates from 68 years in
   the past to 68 years in the future.  However, the offset and delay
   are computed as sums and differences of these values, which contain
   62 significant bits and two sign bits, so they can represent
   unambiguous values from 34 years in the past to 34 years in the
   future.  In other words, the time of the client must be set within 34
   years of the server before the service is started.  This is a
   fundamental limitation with 64-bit integer arithmetic.请注意，括号内的数量是根据 64 位无符号时间戳计算得出的，并生成具有 63 位有效位加符号的有符号值。这些值可以表示从过去 68 年到未来 68 年的日期。但是，偏移量和延迟计算为这些值的总和和差值，这些值包含 62 个有效位和两个符号位，因此它们可以表示从过去 34 年到未来 34 年的明确值。换句话说，在服务启动之前，客户端的时间必须在服务器的 34 年内设置。这是 64 位整数运算的基本限制。   In implementations where floating double arithmetic is available, the
   first-order differences can be converted to floating double and the
   second-order sums and differences computed in that arithmetic.  Since在浮点双精度算术可用的实现中，一阶差分可以转换为浮点双精度，并在该算术中计算二阶和和差。因为
Mills, et al.                Standards Track                   [Page 29]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 29 页] RFC 5905 NTPv4 规范 2010 年 6 月
   the second-order terms are typically very small relative to the
   timestamp magnitudes, there is no loss in significance, yet the
   unambiguous range is restored from 34 years to 68 years.相对于时间戳量级，二阶项通常非常小，没有显着性损失，但明确的范围从 34 年恢复到 68 年。   In some scenarios where the initial frequency offset of the client is
   relatively large and the actual propagation time small, it is
   possible for the delay computation to become negative.  For instance,
   if the frequency difference is 100 ppm and the interval T4-T1 is 64
   s, the apparent delay is -6.4 ms.  Since negative values are
   misleading in subsequent computations, the value of delta should be
   clamped not less than s.rho, where s.rho is the system precision
   described in Section 11.1, expressed in seconds.在客户端初始频率偏移量较大、实际传播时间较小的一些场景下，延迟计算可能会变为负值。例如，如果频率差为 100 ppm，区间 T4-T1 为 64 s，则表观延迟为 -6.4 ms。由于负值在后续计算中具有误导性，因此 delta 的值应不小于 s.rho，其中 s.rho 是第 11.1 节中描述的系统精度，以秒为单位表示。   The discussion above assumes the most general case where two
   symmetric peers independently measure the offsets and delays between
   them.  In the case of a stateless server, the protocol can be
   simplified.  A stateless server copies T3 and T4 from the client
   packet to T1 and T2 of the server packet and tacks on the transmit
   timestamp T3 before sending it to the client.  Additional details for
   filling in the remaining protocol fields are given in a Section 9 and
   following sections and in the appendix.上面的讨论假设了最一般的情况，即两个对称对等体独立测量它们之间的偏移和延迟。在无状态服务器的情况下，可以简化协议。无状态服务器将 T3 和 T4 从客户端数据包复制到服务器数据包的 T1 和 T2，并在将其发送到客户端之前对传输时间戳 T3 进行粘接。有关填写其余协议字段的其他详细信息，请参见第 9 节和以下各节以及附录。   Note that the on-wire protocol as described resists replay of a
   server response packet.  However, it does not resist replay of the
   client request packet, which would result in a server reply packet
   with new values of T2 and T3 and result in incorrect offset and
   delay.  This vulnerability can be avoided by setting the xmt state
   variable to zero after computing the offset and delay.请注意，如上所述的在线协议可防止服务器响应数据包的重放。但是，它不会阻止客户端请求数据包的重放，这将导致服务器应答数据包具有 T2 和 T3 的新值，并导致不正确的偏移和延迟。通过在计算偏移量和延迟后将 xmt 状态变量设置为零，可以避免此漏洞。9.  Peer Process 9. 对等流程   The process descriptions to follow include a listing of the important
   state variables followed by an overview of the process operations
   implemented as routines.  Frequent reference is made to the skeleton
   in the appendix.  The skeleton includes C-language fragments that
   describe the functions in more detail.  It includes the parameters,
   variables, and declarations necessary for a conforming NTPv4
   implementation.  However, many additional variables and routines may
   be necessary in a working implementation.接下来的过程描述包括重要状态变量的列表，然后是作为例程实现的流程操作的概述。在附录中经常提到骨架。该框架包括 C 语言片段，这些片段更详细地描述了函数。它包括符合 NTPv4 实现所需的参数、变量和声明。但是，在工作实现中可能需要许多其他变量和例程。   The peer process is called upon arrival of a server or peer packet.
   It runs the on-wire protocol to determine the clock offset and round-
   trip delay and computes statistics used by the system and poll
   processes.  Peer variables are instantiated in the association data
   structure when the structure is initialized and updated by arriving
   packets.  There is a peer process, poll process, and association
   process for each server.对等进程在服务器或对等数据包到达时调用。它运行在线协议来确定时钟偏移和往返延迟，并计算系统和轮询过程使用的统计数据。当到达的数据包初始化和更新结构时，对等变量将在关联数据结构中实例化。每个服务器都有一个对等进程、轮询进程和关联进程。
Mills, et al.                Standards Track                   [Page 30]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 30 页] RFC 5905 NTPv4 规范 2010 年 6 月
9.1.  Peer Process Variables9.1. 对等进程变量   Figures 16, 17, 18, and 19 summarize the common names, formula names,
   and a short description of the peer variables.  The common names and
   formula names are interchangeable; formula names are intended to
   increase readability of equations in this specification.  Unless
   noted otherwise, all peer variables have assumed prefix p.图 16、17、18 和 19 总结了通用名称、公式名称和对等变量的简短描述。通用名称和公式名称是可以互换的;公式名称旨在提高本规范中公式的可读性。除非另有说明，否则所有对等变量都假定为前缀 p。                 +---------+----------+-----------------------+
                 | Name    | Formula  | Description           |
                 +---------+----------+-----------------------+
                 | srcaddr | srcaddr  | source address        |
                 | srcport | srcport  | source port           |
                 | dstaddr | dstaddr  | destination address   |
                 | dstport | destport | destination port      |
                 | keyid   | keyid    | key identifier key ID |
                 +---------+----------+-----------------------++---------+----------+-----------------------+ |中文名 |配方 |描述 |+---------+----------+-----------------------+ |SRCADDR公司 |SRCADDR公司 |源地址 | |SRCport（英语：SRCPORT） |SRCport（英语：SRCPORT） |源端口 | |DStaDBR格式 |DStaDBR格式 |目的地地址 | |DSTport（英语：DSTPORT） |德斯特波特 |目的港 | |密钥 ID |密钥 ID |密钥标识符密钥 ID |+---------+----------+-----------------------+              Figure 16: Peer Process Configuration Variables图 16：对等进程配置变量
                +-----------+------------+---------------------+
                | Name      | Formula    | Description         |
                +-----------+------------+---------------------+
                | leap      | leap       | leap indicator      |
                | version   | version    | version number      |
                | mode      | mode       | mode                |
                | stratum   | stratum    | stratum             |
                | ppoll     | ppoll      | peer poll exponent  |
                | rootdelay | delta_r    | root delay          |
                | rootdisp  | epsilon_r  | root dispersion     |
                | refid     | refid      | reference ID        |
                | reftime   | reftime    | reference timestamp |
                +-----------+------------+---------------------++-----------+------------+---------------------+ |中文名 |配方 |描述 |+-----------+------------+---------------------+ |飞跃 |飞跃 |闰数指示器 | |版本 |版本 |版本号 | |模式 |模式 |模式 | |地层 |地层 |地层 | |p波尔 |p波尔 |同行投票指数 | |根延迟 |delta_r |根延迟 | |rootdisp的 |epsilon_r |根系分散 | |refid |refid |参考 ID | |参考时间 |参考时间 |参考时间戳 |+-----------+------------+---------------------+                 Figure 17: Peer Process Packet Variables图 17：对等进程数据包变量
                     +------+---------+--------------------+
                     | Name | Formula | Description        |
                     +------+---------+--------------------+
                     | org  | T1      | origin timestamp   |
                     | rec  | T2      | receive timestamp  |
                     | xmt  | T3      | transmit timestamp |
                     | t    | t       | packet time        |
                     +------+---------+--------------------++------+---------+--------------------+ |中文名 |配方 |描述 |+------+---------+--------------------+ |组织 |T1航站楼 |源时间戳 | |建议 |T2航站楼 |接收时间戳 | |XMT系列 |T3航站楼 |传输时间戳 | |吨 |吨 |数据包时间 |+------+---------+--------------------+                Figure 18: Peer Process Timestamp Variables图 18：对等进程时间戳变量Mills, et al.                Standards Track                   [Page 31]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 31 页] RFC 5905 NTPv4 规范 2010 年 6 月
                     +--------+---------+-----------------+
                     | Name   | Formula | Description     |
                     +--------+---------+-----------------+
                     | offset | theta   | clock offset    |
                     | delay  | delta   | round-trip delay|
                     | disp   | epsilon | dispersion      |
                     | jitter | psi     | jitter          |
                     | filter | filter  | clock filter    |
                     | tp     | t_p     | filter time     |
                     +--------+---------+-----------------++--------+---------+-----------------+ |中文名 |配方 |描述 |+--------+---------+-----------------+ |胶印 |θ |时钟偏移 | |延迟 |达美航空 |往返延误| |磁盘 |厄普西隆 |分散体 | |抖动 |psi |抖动 | |筛选 |筛选 |时钟滤波器 | |TP |t_p |过滤时间 |+--------+---------+-----------------+               Figure 19: Peer Process Statistics Variables图 19：对等进程统计变量   The following configuration variables are normally initialized when
   the association is mobilized, either from a configuration file or
   upon the arrival of the first packet for an unknown association.以下配置变量通常在关联被调动时初始化，无论是从配置文件还是未知关联的第一个数据包到达时。   srcaddr: IP address of the remote server or reference clock.  This
   becomes the destination IP address in packets sent from this
   association.srcaddr：远程服务器的 IP 地址或参考时钟。这将成为从此关联发送的数据包中的目标 IP 地址。   srcport: UDP port number of the server or reference clock.  This
   becomes the destination port number in packets sent from this
   association.  When operating in symmetric modes (1 and 2), this field
   must contain the NTP port number PORT (123) assigned by the IANA.  In
   other modes, it can contain any number consistent with local policy.srcport：服务器或参考时钟的 UDP 端口号。这将成为从此关联发送的数据包中的目标端口号。在对称模式（1 和 2）下运行时，此字段必须包含 IANA 分配的 NTP 端口号 PORT （123）。在其他模式下，它可以包含与本地策略一致的任何数字。   dstaddr: IP address of the client.  This becomes the source IP
   address in packets sent from this association.dstaddr：客户端的 IP 地址。这将成为从此关联发送的数据包中的源 IP 地址。   dstport: UDP port number of the client, ordinarily the NTP port
   number PORT (123) assigned by the IANA.  This becomes the source port
   number in packets sent from this association.dstport：客户端的 UDP 端口号，通常为 IANA 分配的 NTP 端口号 PORT （123）。这将成为从此关联发送的数据包中的源端口号。   keyid: Symmetric key ID for the 128-bit MD5 key used to generate and
   verify the MAC.  The client and server or peer can use different
   values, but they must map to the same key.keyid：用于生成和验证 MAC 的 128 位 MD5 密钥的对称密钥 ID。客户端和服务器或对等方可以使用不同的值，但它们必须映射到同一个键。   The variables defined in Figure 17 are updated from the packet header
   as each packet arrives.  They are interpreted in the same way as the
   packet variables of the same names.  It is convenient for later
   processing to convert the NTP short format packet values r.rootdelay
   and r.rootdisp to floating doubles as peer variables.图 17 中定义的变量在每个数据包到达时从数据包标头更新。它们的解释方式与同名的数据包变量相同。将 NTP 短格式数据包值 r.rootdelay 和 r.rootdisp 转换为浮动双精度作为对等变量，便于以后处理。   The variables defined in Figure 18 include the timestamps exchanged
   by the on-wire protocol in Section 8.  The t variable is the seconds
   counter c.t associated with these values.  The c.t variable is
   maintained by the clock-adjust process described in Section 12.  It图 18 中定义的变量包括第 8 节中在线协议交换的时间戳。t 变量是与这些值关联的秒计数器 c.t。c.t 变量由第 12 节中描述的时钟调整过程维护。它Mills, et al.                Standards Track                   [Page 32]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 32 页] RFC 5905 NTPv4 规范 2010 年 6 月
   counts the seconds since the service was started.  The variables
   defined in Figure 19 include the statistics computed by the
   clock_filter() routine described in Section 10.  The tp variable is
   the seconds counter associated with these values.计算自服务启动以来的秒数。图 19 中定义的变量包括第 10 节中描述的 clock_filter（） 例程计算的统计量。tp 变量是与这些值关联的秒计数器。9.2.  Peer Process Operations9.2. 对等进程操作   The receive routine defines the process flow upon the arrival of a
   packet.  An example is described by the receive() routine in
   Appendix A.5.1.  There is no specific method required for access
   control, although it is recommended that implementations include such
   a scheme, which is similar to many others now in widespread use.  The
   access() routine in Appendix A.5.4 describes a method of implementing
   access restrictions using an access control list (ACL).  Format
   checks require correct field length and alignment, acceptable version
   number (1-4), and correct extension field syntax, if present.接收例程定义数据包到达时的处理流。附录 A.5.1 中的 receive（） 例程描述了一个示例。访问控制不需要特定的方法，但建议实现包含这样的方案，该方案类似于现在广泛使用的许多其他方案。附录 A.5.4 中的 access（） 例程描述了一种使用访问控制列表 （ACL） 实现访问限制的方法。格式检查需要正确的字段长度和对齐方式、可接受的版本号 （1-4） 以及正确的扩展字段语法（如果存在）。   There is no specific requirement for authentication; however, if
   authentication is implemented, then the MD5-keyed hash algorithm
   described in [RFC1321] must be supported.身份验证没有特定要求;但是，如果实现了身份验证，则必须支持 [RFC1321] 中描述的 MD5 密钥哈希算法。   Next, the association table is searched for matching source address
   and source port, for example, using the find_assoc() routine in
   Appendix A.5.1.  Figure 20 is a dispatch table where the columns
   correspond to the packet mode and rows correspond to the association
   mode.  The intersection of the association and packet modes
   dispatches processing to one of the following steps.接下来，在关联表中搜索匹配的源地址和源端口，例如，使用附录 A.5.1 中的 find_assoc（） 例程。图 20 是一个调度表，其中列对应数据包模式，行对应关联模式。关联模式和数据包模式的交集将处理分派到以下步骤之一。           +------------------+---------------------------------------+
           |                  |              Packet Mode              |
           +------------------+-------+-------+-------+-------+-------+
           | Association Mode |   1   |   2   |   3   |   4   |   5   |
           +------------------+-------+-------+-------+-------+-------+
           | No Association 0 | NEWPS | DSCRD | FXMIT | MANY  | NEWBC |
           | Symm. Active   1 | PROC  | PROC  | DSCRD | DSCRD | DSCRD |
           | Symm. Passive  2 | PROC  | ERR   | DSCRD | DSCRD | DSCRD |
           | Client         3 | DSCRD | DSCRD | DSCRD | PROC  | DSCRD |
           | Server         4 | DSCRD | DSCRD | DSCRD | DSCRD | DSCRD |
           | Broadcast      5 | DSCRD | DSCRD | DSCRD | DSCRD | DSCRD |
           | Bcast Client   6 | DSCRD | DSCRD | DSCRD | DSCRD | PROC  |
           +------------------+-------+-------+-------+-------+-------++------------------+---------------------------------------+ | |数据包模式 |+------------------+-------+-------+-------+-------+-------+ |关联模式 |1 |2 |3 |4 |5 |+------------------+-------+-------+-------+-------+-------+ |没有关联 0 |NEWPS系列 |DSCRD公司 |FXMIT公司 |许多 |新BC | |符号。活动 1 |程序 |程序 |DSCRD公司 |DSCRD公司 |DSCRD | |符号。被动 2 |程序 |错误 |DSCRD公司 |DSCRD公司 |DSCRD | |客户端 3 |DSCRD公司 |DSCRD公司 |DSCRD公司 |程序 |DSCRD | |服务器 4 |DSCRD公司 |DSCRD公司 |DSCRD公司 |DSCRD公司 |DSCRD | |广播 5 |DSCRD公司 |DSCRD公司 |DSCRD公司 |DSCRD公司 |DSCRD | |Bcast 客户端 6 |DSCRD公司 |DSCRD公司 |DSCRD公司 |DSCRD公司 |程序 |+------------------+-------+-------+-------+-------+-------+                      Figure 20: Peer Dispatch Table图 20：对等调度表   DSCRD.  This indicates a non-fatal violation of protocol as the
   result of a programming error, long-delayed packet, or replayed
   packet.  The peer process discards the packet and exits.DSCRD 中。这表示由于编程错误、长时间延迟的数据包或重放的数据包而导致的非致命协议违规。对等进程丢弃数据包并退出。
Mills, et al.                Standards Track                   [Page 33]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 33 页] RFC 5905 NTPv4 规范 2010 年 6 月
   ERR.  This indicates a fatal violation of protocol as the result of a
   programming error, long-delayed packet, or replayed packet.  The peer
   process discards the packet, demobilizes the symmetric passive
   association, and exits.犯 错。这表示由于编程错误、长时间延迟的数据包或重放的数据包而导致的致命协议违规。对等进程丢弃数据包，解除对称被动关联，然后退出。   FXMIT.  This indicates a client (mode 3) packet matching no
   association (mode 0).  If the destination address is not a broadcast
   address, the server constructs a server (mode 4) packet and returns
   it to the client without retaining state.  The server packet header
   is constructed.  An example is described by the fast_xmit() routine
   in Appendix A.5.3.  The packet header is assembled from the receive
   packet and system variables as shown in Figure 21.  If the
   s.rootdelay and s.rootdisp system variables are stored in floating
   double, they must be converted to NTP short format first.FXMIT的。这表示客户端（模式 3）数据包不匹配关联（模式 0）。如果目标地址不是广播地址，则服务器会构建服务器（模式 4）数据包并将其返回给客户端而不保留状态。构建服务器报文头。附录 A.5.3 中的 fast_xmit（） 例程描述了一个示例。数据包标头由接收数据包和系统变量组装而成，如图 21 所示。如果 s.rootdelay 和 s.rootdisp 系统变量以浮动双精度存储，则必须先将它们转换为 NTP 短格式。                   +-----------------------------------+
                   | Packet Variable -->   Variable    |
                   +-----------------------------------+
                   | r.leap        -->     p.leap      |
                   | r.mode        -->     p.mode      |
                   | r.stratum     -->     p.stratum   |
                   | r.poll        -->     p.ppoll     |
                   | r.rootdelay   -->     p.rootdelay |
                   | r.rootdisp    -->     p.rootdisp  |
                   | r.refid       -->     p.refid     |
                   | r.reftime     -->     p.reftime   |
                   | r.keyid       -->     p.keyid     |
                   +-----------------------------------++-----------------------------------+ |数据包变量 -->变量 |+-----------------------------------+ |r.leap --> p.leap | |r.mode --> p.mode | |r.stratum --> p.stratum | |r.poll --> p.ppoll | |r.rootdelay --> p.rootdelay | |r.rootdisp --> p.rootdisp | |r.refid --> p.refid | |r.reftime --> p.reftime | |r.keyid --> p.keyid |+-----------------------------------+                     Figure 21: Receive Packet Header图 21：接收数据包标头   Note that, if authentication fails, the server returns a special
   message called a crypto-NAK.  This message includes the normal NTP
   header data shown in Figure 8, but with a MAC consisting of four
   octets of zeros.  The client MAY accept or reject the data in the
   message.  After these actions, the peer process exits.请注意，如果身份验证失败，服务器将返回一条称为 crypto-NAK 的特殊消息。此消息包括图 8 所示的正常 NTP 报头数据，但 MAC 由四个零的八位字节组成。客户端可以接受或拒绝消息中的数据。执行这些操作后，对等进程将退出。   If the destination address is a multicast address, the sender is
   operating in manycast client mode.  If the packet is valid and the
   server stratum is less than the client stratum, the server sends an
   ordinary server (mode 4) packet, but one which uses its unicast
   destination address.  A crypto-NAK is not sent if authentication
   fails.  After these actions, the peer process exits.如果目标地址是组播地址，则发送方在组播客户端模式下运行。如果数据包有效且服务器层小于客户端层，则服务器发送普通服务器（模式 4）数据包，但该数据包使用其单播目标地址。如果身份验证失败，则不会发送加密 NAK。执行这些操作后，对等进程将退出。   MANY: This indicates a server (mode 4) packet matching no
   association.  Ordinarily, this can happen only as the result of a
   manycast server reply to a previously sent multicast client packet.MANY：这表示服务器（模式 4）数据包与无关联匹配。通常，这只能作为 manycast 服务器对先前发送的组播客户端数据包的回复的结果而发生。
Mills, et al.                Standards Track                   [Page 34]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 34 页] RFC 5905 NTPv4 规范 2010 年 6 月
   If the packet is valid, an ordinary client (mode 3) association is
   mobilized and operation continues as if the association was mobilized
   by the configuration file.如果数据包有效，则会调动普通客户端（模式 3）关联，并继续进行操作，就像配置文件调动了关联一样。   NEWBC.  This indicates a broadcast (mode 5) packet matching no
   association.  The client mobilizes either a client (mode 3) or
   broadcast client (mode 6) association.  Examples are shown in the
   mobilize() and clear() routines in Appendix A.2.  Then, the packet is
   validated and the peer variables initialized.  An example is provided
   by the packet() routine in Appendix A.5.1.1.新BC。这表示广播（模式 5）数据包与没有关联匹配。客户端调动客户端（模式 3）或广播客户端（模式 6）关联。附录 A.2 中的 mobilize（） 和 clear（） 例程中显示了示例。然后，验证数据包并初始化对等变量。附录 A.5.1.1 中的 packet（） 例程提供了一个示例。   If the implementation supports no additional security or calibration
   functions, the association mode is set to broadcast client (mode 6)
   and the peer process exits.  Implementations supporting public key
   authentication MAY run the Autokey or equivalent security protocol.
   Implementations SHOULD set the association mode to 3 and run a short
   client/server exchange to determine the propagation delay.  Following
   the exchange, the association mode is set to 6 and the peer process
   continues in listen-only mode.  Note the distinction between a mode-6
   packet, which is reserved for the NTP monitor and control functions,
   and a mode-6 association.如果实现不支持其他安全或校准功能，则关联模式设置为广播客户端（模式 6），并且对等进程退出。支持公钥身份验证的实现可以运行自动密钥或等效的安全协议。实现应将关联模式设置为 3，并运行短客户端/服务器交换以确定传播延迟。交换后，关联模式设置为 6，对等进程在仅侦听模式下继续。请注意模式 6 数据包（为 NTP 监视和控制功能保留）与模式 6 关联之间的区别。   NEWPS.  This indicates a symmetric active (mode 1) packet matching no
   association.  The client mobilizes a symmetric passive (mode 2)
   association.  An example is shown in the mobilize() and clear()
   routines in Appendix A.2.  Processing continues in the PROC section
   below.纽普斯。这表示对称活动（模式 1）数据包与没有关联匹配。客户端调动对称被动（模式 2）关联。附录 A.2 中的 mobilize（） 和 clear（） 例程中显示了一个示例。在下面的 PROC 部分中继续处理。   PROC.  This indicates a packet matching an existing association.  The
   packet timestamps are carefully checked to avoid invalid, duplicate,
   or bogus packets.  Additional checks are summarized in Figure 22.
   Note that all packets, including a crypto-NAK, are considered valid
   only if they survive these tests.过程。这表示与现有关联匹配的数据包。仔细检查数据包时间戳，以避免无效、重复或伪造的数据包。图 22 总结了其他检查。请注意，所有数据包（包括 crypto-NAK）只有在这些测试中幸存下来时才被视为有效。
Mills, et al.                Standards Track                   [Page 35]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 35 页] RFC 5905 NTPv4 规范 2010 年 6 月
   +--------------------------+----------------------------------------+
   | Packet Type              | Description                            |
   +--------------------------+----------------------------------------+
   | 1 duplicate packet       | The packet is at best an old duplicate |
   |                          | or at worst a replay by a hacker.      |
   |                          | This can happen in symmetric modes if  |
   |                          | the poll intervals are uneven.         |
   | 2 bogus packet           |                                        |
   | 3 invalid                | One or more timestamp fields are       |
   |                          | invalid. This normally happens in      |
   |                          | symmetric modes when one peer sends    |
   |                          | the first packet to the other and      |
   |                          | before the other has received its      |
   |                          | first reply.                           |
   | 4 access denied          | The access controls have blacklisted   |
   |                          | the source.                            |
   | 5 authentication failure | The cryptographic message digest does  |
   |                          | not match the MAC.                     |
   | 6 unsynchronized         | The server is not synchronized to a    |
   |                          | valid source.                          |
   | 7 bad header data        | One or more header fields are invalid. |
   +--------------------------+----------------------------------------++--------------------------+----------------------------------------+ |数据包类型 |描述 |+--------------------------+----------------------------------------+ |1 个重复数据包 |该数据包充其量是一个旧的重复数据 | | |或者最坏的情况是黑客的重播。| | |如果 | | |轮询间隔不均匀。| |2 个假数据包 | | |3 无效 |一个或多个时间戳字段是 | | |无效。这通常发生在 | | |一个对等方发送时的对称模式 | | |第一个数据包到另一个数据包和 | | |在对方收到其 | | |第一次回复。| |4 访问被拒绝 |访问控制已列入黑名单 | | |来源。| |5 身份验证失败 |加密消息摘要执行 | | |与 MAC 不匹配。| |6 不同步 |服务器未同步到 | | |有效来源。| |7 错误的标题数据 |一个或多个标头字段无效。|+--------------------------+----------------------------------------+                      Figure 22: Packet Error Checks图 22：数据包错误检查   Processing continues by copying the packet variables to the peer
   variables as shown in Figure 21.  An example is described by the
   packet() routine in Appendix A.5.1.1.  The receive() routine
   implements tests 1-5 in Figure 22; the packet() routine implements
   tests 6-7.  If errors are found, the packet is discarded and the peer
   process exits.通过将数据包变量复制到对等变量来继续处理，如图 21 所示。附录 A.5.1.1 中的 packet（） 例程描述了一个示例。receive（） 例程实现了图 22 中的测试 1-5;packet（） 例程实现测试 6-7。如果发现错误，则丢弃数据包并退出对等进程。   The on-wire protocol calculates the clock offset theta and round-trip
   delay delta from the four most recent timestamps as described in
   Section 8.  While it is, in principle, possible to do all
   calculations except the first-order timestamp differences in fixed-
   point arithmetic, it is much easier to convert the first-order
   differences to floating doubles and do the remaining calculations in
   that arithmetic, and this will be assumed in the following
   description.在线协议从第 8 节中描述的四个最新时间戳计算时钟偏移 θ 和往返延迟增量。虽然原则上可以进行除定点算术中的一阶时间戳差之外的所有计算，但将一阶差值转换为浮点双精度并在该算术中进行剩余的计算要容易得多，这将在下面的描述中假设。   Next, the 8-bit p.reach shift register in the poll process described
   in Section 13 is used to determine whether the server is reachable
   and the data are fresh.  The register is shifted left by one bit when
   a packet is sent and the rightmost bit is set to zero.  As valid
   packets arrive, the rightmost bit is set to one.  If the register
   contains any nonzero bits, the server is considered reachable;
   otherwise, it is unreachable.  Since the peer poll interval might接下来，第 13 节中描述的轮询过程中的 8 位 p.reach 移位寄存器用于确定服务器是否可访问以及数据是否为新数据。发送数据包时，寄存器向左移动一位，最右边的位设置为零。当有效数据包到达时，最右边的位设置为 1。如果寄存器包含任何非零位，则认为服务器是可访问的;否则，无法访问。由于对等轮询间隔可能Mills, et al.                Standards Track                   [Page 36]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 36 页] RFC 5905 NTPv4 规范 2010 年 6 月
   have changed since the last packet, the host poll interval is
   reviewed.  An example is provided by the poll_update() routine in
   Appendix A.5.7.2.自上次数据包以来已更改，将查看主机轮询间隔。附录 A.5.7.2 中的 poll_update（） 例程提供了一个示例。   The dispersion statistic epsilon(t) represents the maximum error due
   to the frequency tolerance and time since the last packet was sent.
   It is initialized色散统计 epsilon（t） 表示自上次发送数据包以来由于频率容差和时间而导致的最大误差。它被初始化   epsilon(t_0) = r.rho + s.rho + PHI * (T4-T1)ε（t_0） = r.rho + s.rho + PHI * （T4-T1）   when the measurement is made at t_0 according to the seconds counter.
   Here, r.rho is the packet precision described in Section 7.3 and
   s.rho is the system precision described in Section 11.1, both
   expressed in seconds.  These terms are necessary to account for the
   uncertainty in reading the system clock in both the server and the
   client.当根据秒针计数器在t_0进行测量时。在这里，r.rho 是第 7.3 节中描述的数据包精度，s.rho 是第 11.1 节中描述的系统精度，两者都以秒表示。这些术语对于解释在服务器和客户端中读取系统时钟的不确定性是必要的。   The dispersion then grows at constant rate PHI; in other words, at
   time t, epsilon(t) = epsilon(t_0) + PHI * (t-t_0).  With the default
   value PHI = 15 ppm, this amounts to about 1.3 s per day.  With this
   understanding, the argument t will be dropped and the dispersion
   represented simply as epsilon.  The remaining statistics are computed
   by the clock filter algorithm described in the next section.然后，色散以恒定速率PHI增长;换句话说，在时间 t 时，epsilon（t） = epsilon（t_0） + PHI * （t-t_0）。默认值 PHI = 15 ppm，这相当于每天约 1.3 秒。有了这种理解，参数 t 将被删除，色散简单地表示为 epsilon。其余统计信息由下一节中描述的时钟滤波器算法计算。10.  Clock Filter Algorithm10. 时钟滤波算法   The clock filter algorithm is part of the peer process.  It grooms
   the stream of on-wire data to select the samples most likely to
   represent accurate time.  The algorithm produces the variables shown
   in Figure 19, including the offset (theta), delay (delta), dispersion
   (epsilon), jitter (psi), and time of arrival (t).  These data are
   used by the mitigation algorithms to determine the best and final
   offset used to discipline the system clock.  They are also used to
   determine the server health and whether it is suitable for
   synchronization.时钟滤波器算法是对等过程的一部分。它梳理在线数据流，以选择最有可能代表准确时间的样本。该算法生成图 19 所示的变量，包括偏移 （theta）、延迟 （delta）、色散 （epsilon）、抖动 （psi） 和到达时间 （t）。缓解算法使用这些数据来确定用于约束系统时钟的最佳和最终偏移量。它们还用于确定服务器运行状况以及它是否适合同步。   The clock filter algorithm saves the most recent sample tuples
   (theta, delta, epsilon, t) in the filter structure, which functions
   as an 8-stage shift register.  The tuples are saved in the order that
   packets arrive.  Here, t is the packet time of arrival according to
   the seconds counter and should not be confused with the peer variable
   tp.时钟滤波器算法将最新的采样元组（theta、delta、epsilon、t）保存在滤波器结构中，用作 8 级移位寄存器。元组按数据包到达的顺序保存。这里，t 是根据秒计数器的数据包到达时间，不应与对等变量 tp 混淆。   The following scheme is used to ensure sufficient samples are in the
   filter and that old stale data are discarded.  Initially, the tuples
   of all stages are set to the dummy tuple (0, MAXDISP, MAXDISP, 0).
   As valid packets arrive, tuples are shifted into the filter causing
   old tuples to be discarded, so eventually only valid tuples remain.以下方案用于确保筛选器中有足够的样本，并丢弃旧的陈旧数据。最初，所有阶段的元组都设置为虚拟元组 （0， MAXDISP， MAXDISP， 0）。当有效数据包到达时，元组会转移到过滤器中，导致旧元组被丢弃，因此最终只剩下有效的元组。Mills, et al.                Standards Track                   [Page 37]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 37 页] RFC 5905 NTPv4 规范 2010 年 6 月
   If the three low-order bits of the reach register are zero,
   indicating three poll intervals have expired with no valid packets
   received, the poll process calls the clock filter algorithm with a
   dummy tuple just as if the tuple had arrived from the network.  If
   this persists for eight poll intervals, the register returns to the
   initial condition.如果到达寄存器的三个低位为零，表示三个轮询间隔已过期，未收到任何有效数据包，则轮询过程将使用虚拟元组调用时钟滤波器算法，就像元组从网络到达一样。如果这种情况持续了八个轮询间隔，寄存器将返回到初始条件。   In the next step, the shift register stages are copied to a temporary
   list and the list sorted by increasing delta.  Let i index the stages
   starting with the lowest delta.  If the first tuple epoch t_0 is not
   later than the last valid sample epoch tp, the routine exits without
   affecting the current peer variables.  Otherwise, let epsilon_i be
   the dispersion of the ith entry, then在下一步中，移位寄存器阶段将复制到临时列表中，并按增量对列表进行排序。让我索引从最低增量开始的阶段。如果第一个元组纪元t_0不晚于最后一个有效样本纪元 tp，则例程将退出，而不会影响当前对等变量。否则，让epsilon_i成为第 i 个条目的分散，那么                     i=n-1
                     ---     epsilon_i
      epsilon =       \     ----------
                      /        (i+1)
                     ---     2
                     i=0i=n-1 --- epsilon_i epsilon = \ ---------- / （i+1） --- 2 i=0   is the peer dispersion p.disp.  Note the overload of epsilon, whether
   input to the clock filter or output, the meaning should be clear from
   context.是对等离散 P.disp。注意epsilon的过载，无论是输入到时钟滤波器还是输出，其含义都应该从上下文中清楚。   The observer should note (a) if all stages contain the dummy tuple
   with dispersion MAXDISP, the computed dispersion is a little less
   than 16 s, (b) each time a valid tuple is shifted into the register,
   the dispersion drops by a little less than half, depending on the
   valid tuples dispersion, and (c) after the fourth valid packet the
   dispersion is usually a little less than 1 s, which is the assumed
   value of the MAXDIST parameter used by the selection algorithm to
   determine whether or not the peer variables are acceptable.观察者应注意 （a） 如果所有阶段都包含具有离散度 MAXDISP 的虚拟元组，则计算出的离散度略小于 16 秒，（b） 每次将有效元组移入寄存器时，色散度下降不到一半，具体取决于有效元组离散度，以及 （c） 在第四个有效数据包之后，离散度通常略小于 1 秒， 这是选择算法用于确定对等变量是否可接受的 MAXDIST 参数的假设值。   Let the first stage offset in the sorted list be theta_0; then, for
   the other stages in any order, the jitter is the RMS average设排序列表中的第一级偏移量为theta_0;然后，对于任何顺序的其他阶段，抖动是 RMS 平均值                          +-----                 -----+^1/2
                          |  n-1                      |
                          |  ---                      |
                  1       |  \                     2  |
      psi   =  -------- * |  /    (theta_0-theta_j)   |
                (n-1)     |  ---                      |
                          |  j=1                      |
                          +-----                 -----++----- -----+^1/2 |N-1 | |--- |1 |\ 2 |psi = -------- * |/ （theta_0-theta_j） |（N-1） |--- | |j=1 |+----- -----+   where n is the number of valid tuples in the filter (n > 1).  In
   order to ensure consistency and avoid divide exceptions in other其中 n 是筛选器中有效元组的数目 （n > 1）。为了保证一致性并避免其他中的划分异常Mills, et al.                Standards Track                   [Page 38]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 38 页] RFC 5905 NTPv4 规范 2010 年 6 月
   computations, the psi is bounded from below by the system precision
   s.rho expressed in seconds.  While not in general considered a major
   factor in ranking server quality, jitter is a valuable indicator of
   fundamental timekeeping performance and network congestion state.  Of
   particular importance to the mitigation algorithms is the peer
   synchronization distance, which is computed from the delay and
   dispersion.计算时，PSI 由以秒为单位表示的系统精度 S.rho 从下方限制。虽然通常不被认为是对服务器质量进行排名的主要因素，但抖动是基本计时性能和网络拥塞状态的重要指标。对于缓解算法来说，对等同步距离特别重要，它是根据延迟和离散计算得出的。   lambda = (delta / 2) + epsilon.lambda = （delta / 2） + epsilon。   Note that epsilon and therefore lambda increase at rate PHI.  The
   lambda is not a state variable, since lambda is recalculated at each
   use.  It is a component of the root synchronization distance used by
   the mitigation algorithms as a metric to evaluate the quality of time
   available from each server.请注意，epsilon 和 lambda 以 PHI 速率增加。lambda 不是状态变量，因为每次使用时都会重新计算 lambda。它是缓解算法用作评估每个服务器可用时间质量的指标的根同步距离的一个组成部分。   It is important to note that, unlike NTPv3, NTPv4 associations do not
   show a timeout condition by setting the stratum to 16 and leap
   indicator to 3.  The association variables retain the values
   determined upon arrival of the last packet.  In NTPv4, lambda
   increases with time, so eventually the synchronization distance
   exceeds the distance threshold MAXDIST, in which case the association
   is considered unfit for synchronization.需要注意的是，与 NTPv3 不同，NTPv4 关联不会通过将层设置为 16 和闰指标设置为 3 来显示超时条件。关联变量保留在最后一个数据包到达时确定的值。在 NTPv4 中，lambda 随时间增加，因此最终同步距离超过距离阈值 MAXDIST，在这种情况下，该关联被认为不适合同步。   An example implementation of the clock filter algorithm is shown in
   the clock_filter() routine of Appendix A.5.2.附录 A.5.2 的 clock_filter（） 例程中显示了时钟滤波器算法的示例实现。11.  System Process 11. 系统流程   As each new sample (theta, delta, epsilon, jitter, t) is produced by
   the clock filter algorithm, all peer processes are scanned by the
   mitigation algorithms consisting of the selection, cluster, combine,
   and clock discipline algorithms in the system process.  The selection
   algorithm scans all associations and casts off the falsetickers,
   which have demonstrably incorrect time, leaving the truechimers as
   result.  In a series of rounds, the cluster algorithm discards the
   association statistically furthest from the centroid until a
   specified minimum number of survivors remain.  The combine algorithm
   produces the best and final statistics on a weighted average basis.
   The final offset is passed to the clock discipline algorithm to steer
   the system clock to the correct time.由于每个新样本（θ、delta、epsilon、jitter、t）都是由时钟滤波器算法产生的，因此所有对等进程都由系统进程中的选择、聚类、组合和时钟规则算法组成的缓解算法进行扫描。选择算法扫描所有关联并剔除时间明显不正确的假嵌合器，从而留下真嵌合器。在一系列回合中，聚类算法在统计上丢弃离质心最远的关联，直到剩余指定的最小幸存者数。组合算法在加权平均的基础上生成最佳和最终统计数据。最终的偏移量将传递给时钟规则算法，以将系统时钟引导到正确的时间。   The cluster algorithm selects one of the survivors as the system
   peer.  The associated statistics (theta, delta, epsilon, jitter, t)
   are used to construct the system variables inherited by dependent
   servers and clients and made available to other applications running
   on the same machine.聚类算法选择其中一个幸存者作为系统对等体。关联的统计信息（theta、delta、epsilon、jitter、t）用于构造由依赖服务器和客户端继承的系统变量，并提供给在同一台机器上运行的其他应用程序。
Mills, et al.                Standards Track                   [Page 39]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 39 页] RFC 5905 NTPv4 规范 2010 年 6 月
11.1.  System Process Variables11.1. 系统进程变量   Figure 23 summarizes the common names, formula names, and a short
   description of each system variable.  Unless noted otherwise, all
   variables have assumed prefix s.图 23 总结了每个系统变量的通用名称、公式名称和简短描述。除非另有说明，否则所有变量都假定为前缀 s。                +-----------+------------+------------------------+
                | Name      | Formula    | Description            |
                +-----------+------------+------------------------+
                | t         | t          | update time            |
                | p         | p          | system peer identifier |
                | leap      | leap       | leap indicator         |
                | stratum   | stratum    | stratum                |
                | precision | rho        | precision              |
                | offset    | THETA      | combined offset        |
                | jitter    | PSI        | combined jitter        |
                | rootdelay | DELTA      | root delay             |
                | rootdisp  | EPSILON    | root dispersion        |
                | v         | v          | survivor list          |
                | refid     | refid      | reference ID           |
                | reftime   | reftime    | reference time         |
                | NMIN      | 3          | minimum survivors      |
                | CMIN      | 1          | minimum candidates     |
                +-----------+------------+------------------------++-----------+------------+------------------------+ |中文名 |配方 |描述 |+-----------+------------+------------------------+ |吨 |吨 |更新时间 | |p |p |系统对等标识符 | |飞跃 |飞跃 |闰数指示器 | |地层 |地层 |地层 | |精密 |RHO公司 |精密 | |胶印 |泰塔 |组合偏移量 | |抖动 |PSI系列 |组合抖动 | |根延迟 |达美航空 |根延迟 | |rootdisp的 |厄普西隆 |根系分散 | |五 |五 |幸存者名单 | |refid |refid |参考 ID | |参考时间 |参考时间 |参考时间 | |NMIN（纳米） |3 |最低限度的幸存者 | |CMIN公司 |1 |最低候选人 |+-----------+------------+------------------------+                    Figure 23: System Process Variables图 23：系统进程变量   Except for the t, p, offset, and jitter variables and the NMIN and
   CMIN constants, the variables have the same format and interpretation
   as the peer variables of the same name.  The NMIN and CMIN parameters
   are used by the selection and cluster algorithms described in the
   next section.除了 t、p、offset 和 jitter 变量以及 NMIN 和 CMIN 常数外，这些变量的格式和解释与同名的对等变量相同。NMIN 和 CMIN 参数由下一节中描述的选择和聚类算法使用。   The t variable is the seconds counter at the time of the last update.
   An example is shown by the clock_update() routine in
   Appendix A.5.5.4.  The p variable is the system peer identifier
   determined by the cluster() routine in Section 11.2.2.  The precision
   variable has the same format as the packet variable of the same name.
   The precision is defined as the larger of the resolution and time to
   read the clock, in log2 units.  For instance, the precision of a
   mains-frequency clock incrementing at 60 Hz is 16 ms, even when the
   system clock hardware representation is to the nanosecond.t 变量是上次更新时的秒计数器。附录 A.5.5.4 中的 clock_update（） 例程显示了一个示例。p 变量是由第 11.2.2 节中的 cluster（） 例程确定的系统对等标识符。precision 变量的格式与同名的数据包变量相同。精度定义为读取时钟的分辨率和时间中的较大者，以 log2 为单位。例如，以 60 Hz 频率递增的电源频率时钟的精度为 16 ms，即使系统时钟硬件表示为纳秒也是如此。   The offset and jitter variables are determined by the combine
   algorithm in Section 11.2.3.  These values represent the best and
   final offset and jitter used to discipline the system clock.偏移和抖动变量由第 11.2.3 节中的组合算法确定。这些值表示用于控制系统时钟的最佳和最终偏移和抖动。Mills, et al.                Standards Track                   [Page 40]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 40 页] RFC 5905 NTPv4 规范 2010 年 6 月
   Initially, all variables are cleared to zero, then the leap is set to
   3 (unsynchronized) and stratum is set to MAXSTRAT (16).  Remember
   that MAXSTRAT is mapped to zero in the transmitted packet.最初，所有变量都清除为零，然后将闰设置为 3（不同步），并将 stratum 设置为 MAXSTRAT （16）。请记住，MAXSTRAT 在传输的数据包中映射为零。11.2.  System Process Operations11.2. 系统进程操作   Figure 24 summarizes the system process operations performed by the
   clock select routine.  The selection algorithm described in
   Section 11.2.1 produces a majority clique of presumed correct
   candidates (truechimers) based on agreement principles.  The cluster
   algorithm described in Section 11.2.2 discards outliers to produce
   the most accurate survivors.  The combine algorithm described in
   Section 11.2.3 provides the best and final offset for the clock
   discipline algorithm.  An example is described in Appendix A.5.5.6.
   If the selection algorithm cannot produce a majority clique, or if it
   cannot produce at least CMIN survivors, the system process exits
   without disciplining the system clock.  If successful, the cluster
   algorithm selects the statistically best candidate as the system peer
   and its variables are inherited as the system variables.图 24 总结了时钟选择例程执行的系统进程操作。第 11.2.1 节中描述的选择算法根据一致原则生成大多数假定正确的候选者（真嵌合体）。第 11.2.2 节中描述的聚类算法丢弃异常值以生成最准确的幸存者。第 11.2.3 节中描述的组合算法为时钟规则算法提供了最佳和最终偏移量。附录 A.5.5.6 中描述了一个示例。如果选择算法不能产生多数集团，或者如果它不能产生至少一个 CMIN 幸存者，则系统进程将在不对系统时钟进行约束的情况下退出。如果成功，聚类算法将选择统计上最好的候选变量作为系统对等体，其变量将作为系统变量进行继承。
Mills, et al.                Standards Track                   [Page 41]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 41 页] RFC 5905 NTPv4 规范 2010 年 6 月
                          +-----------------+
                          | clock_select()  |
                          +-----------------+
   ................................|...........
   .                               V          .
   .      yes +---------+ +-----------------+ .
   .       +--| accept? | | scan candidates | .
   .       |  +---------+ |                 | .
   .       V        no |  |                 | .
   .  +---------+      |  |                 | .
   .  | add peer|      |  |                 | .
   .  +----------      |  |                 | .
   .       |           V  |                 | .
   .       +---------->-->|                 | .
   .                      |                 | .
   . Selection Algorithm  +-----------------+ .
   .................................|..........
                                    V
                       no +-------------------+
            +-------------|     survivors?    |
            |             +-------------------+
            |                       | yes
            |                       V
            |             +-------------------+
            |             | Cluster Algorithm |
            |             +-------------------+
            |                       |
            |                       V
            V         yes +-------------------+
            |<------------|     n < CMIN?     |
            |             +-------------------+
            V                       |
     +-----------------+            V no
     |   s.p = NULL    |  +-------------------+
     +-----------------+  |   s.p = v_0.p     |
            |             +-------------------+
            V                       |
     +-----------------+            V
     | return (UNSYNC) |  +-------------------+
     +-----------------+  |   return (SYNC)   |
                          +-------------------++-----------------+ |clock_select（） |+-----------------+ ................................|........... .V ..是的 +---------+ +-----------------+ ..+--|接受？ | |扫描候选人 | ..|+---------+ | | ..V 号 | | | ..+---------+ | | | ..|添加对等体| | | | ..+---------- | | | ..|五 | | ..+---------->-->| | ..| | ..选择算法 +-----------------+ ..................................|..........V 没有 +-------------------+ +-------------|幸存者？ | |+-------------------+ | |是 |五 |+-------------------+ | |聚类算法 | |+-------------------+ | | |V V 是 +-------------------+ |<------------|n < CMIN？ | |+-------------------+ V |+-----------------+ V 没有 |s.p = 空 |+-------------------+ +-----------------+ |s.p = v_0.p | |+-------------------+ V |+-----------------+ V |返回 （UNSYNC） |+-------------------+ +-----------------+ |返回 （SYNC） |+-------------------+                      Figure 24: Clock Select Routine图 24：时钟选择例程
Mills, et al.                Standards Track                   [Page 42]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 42 页] RFC 5905 NTPv4 规范 2010 年 6 月
11.2.1.  Selection Algorithm11.2.1. 选择算法   Note that the selection and cluster algorithms are described
   separately, but combined in the code skeleton.  The selection
   algorithm operates to find an intersection interval containing a
   majority clique of truechimers using Byzantine agreement principles
   originally proposed by Marzullo [ref6], but modified to improve
   accuracy.  An overview of the algorithm is given below and described
   in the first half of the clock_select() routine in Appendix A.5.5.1.请注意，选择算法和聚类算法是单独描述的，但组合在代码框架中。选择算法使用最初由 Marzullo [ref6] 提出的拜占庭协议原则来查找包含大多数真嵌合体群的交集区间，但进行了修改以提高准确性。下面给出了该算法的概述，并在附录 A.5.5.1 中 clock_select（） 例程的前半部分进行了描述。   First, those servers that are unusable according to the rules of the
   protocol are detected and discarded as shown by the accept() routine
   in Appendix A.5.5.3.  Next, a set of tuples (p, type, edge) is
   generated for the remaining candidates.  Here, p is the association
   identifier and type identifies the upper (+1), middle (0), and lower
   (-1) endpoints of a correctness interval centered on theta for that
   candidate.  This results in three tuples, lowpoint (p, -1, theta -
   lambda), midpoint (p, 0, theta), and highpoint (p, +1, theta +
   lambda), where lambda is the root synchronization distance.  An
   example of this calculation is shown by the rootdist() routine in
   Appendix A.5.1.1.  The steps of the algorithm are:首先，按照协议规则检测并丢弃那些无法使用的服务器，如附录 A.5.5.3 中的 accept（） 例程所示。接下来，为剩余的候选者生成一组元组（p、type、edge）。这里，p 是关联标识符，类型标识以该候选者以 theta 为中心的正确区间的上限 （+1）、中间 （0） 和下限 （-1）。这会产生三个元组，即低点 （p， -1， theta - lambda）、中点 （p， 0， theta） 和高点 （p， +1， theta + lambda），其中 lambda 是根同步距离。附录 A.5.1.1 中的 rootdist（） 例程显示了此计算的一个示例。该算法的步骤是：   1.  For each of m associations, place three tuples as defined above
   on the candidate list.1. 对于 m 个关联中的每一个，在候选列表中放置三个如上定义的元组。   2.  Sort the tuples on the list by the edge component.  Order the
   lowpoint, midpoint, and highpoint of these intervals from lowest to
   highest.  Set the number of falsetickers f = 0.2. 按边缘组件对列表中的元组进行排序。对这些区间的低点、中点和高点从低到高进行排序。设置虚假代码的数量 f = 0。   3.  Set the number of midpoints d = 0.  Set c = 0.  Scan from lowest
   endpoint to highest.  Add one to c for every lowpoint, subtract one
   for every highpoint, add one to d for every midpoint.  If c >= m - f,
   stop; set l = current lowpoint.3. 设置中点数 d = 0。设置 c = 0。从最低端点扫描到最高端点。每个低点加 1 到 c，每个高点减 1，每个中点加 1 到 d。如果 c >= m - f，则停止;设置 L = 当前低点。   4.  Set c = 0.  Scan from highest endpoint to lowest.  Add one to c
   for every highpoint, subtract one for every lowpoint, add one to d
   for every midpoint.  If c >= m - f, stop; set u = current highpoint.4. 设置 c = 0。从最高端点到最低端点扫描。每个高点加 1 到 c，每个低点减 1，每个中点加 1 到 d。如果 c >= m - f，则停止;设置 u = 当前高点。   5.  Is d = f and l < u?  If yes, then follow step 5A; else, follow
   step 5B.5. d = f 和 l < u 吗？如果是，请按照步骤 5A 操作;否则，请按照步骤 5B 操作。   5A. Success: the intersection interval is [l, u].5一个。成功：交点间隔为 [l， u]。   5B. Add one to f.  Is f < (m / 2)?  If yes, then go to step 3 again.
   If no, then go to step 6.5乙。将 1 加到 f。f 是 < （m / 2）？如果是，请再次转到步骤 3。如果没有，请转到步骤 6。   6.  Failure; a majority clique could not be found.  There are no
   suitable candidates to discipline the system clock.6.失败;找不到多数派。没有合适的候选者来约束系统时钟。Mills, et al.                Standards Track                   [Page 43]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 43 页] RFC 5905 NTPv4 规范 2010 年 6 月
   The algorithm is described in detail in Appendix A.5.5.1.  Note that
   it starts with the assumption that there are no falsetickers (f = 0)
   and attempts to find a non-empty intersection interval containing the
   midpoints of all correct servers, i.e., truechimers.  If a non-empty
   interval cannot be found, it increases the number of assumed
   falsetickers by one and tries again.  If a non-empty interval is
   found and the number of falsetickers is less than the number of
   truechimers, a majority clique has been found and the midpoint of
   each truechimer (theta) represents the candidates available to the
   cluster algorithm.该算法在附录 A.5.5.1 中进行了详细描述。请注意，它从假设没有假代码 （f = 0） 开始，并尝试找到一个非空交集间隔，其中包含所有正确服务器的中点，即真嵌合器。如果找不到非空间隔，则会将假定的假代码数增加 1，然后重试。如果找到一个非空区间，并且假嵌合器的数量小于真嵌合器的数量，则已找到多数群，并且每个真嵌合器（theta）的中点表示可用于聚类算法的候选者。   If a majority clique is not found, or if the number of truechimers is
   less than CMIN, there are insufficient candidates to discipline the
   system clock.  CMIN defines the minimum number of servers consistent
   with the correctness requirements.  Suspicious operators would set
   CMIN to ensure multiple redundant servers are available for the
   algorithms to mitigate properly.  However, for historic reasons the
   default value for CMIN is one.如果没有找到多数派，或者真嵌合体的数量少于 CMIN，则没有足够的候选者来约束系统时钟。CMIN定义了符合正确性要求的最小服务器数量。可疑操作员会设置 CMIN，以确保有多个冗余服务器可供算法正确缓解。但是，由于历史原因，CMIN 的默认值为 1。11.2.2.  Cluster Algorithm11.2.2. 聚类算法   The candidates of the majority clique are placed on the survivor list
   v in the form of tuples (p, theta_p, psi_p, lambda_p), where p is an
   association identifier, theta_p, psi_p, and stratum_p the current
   offset, jitter and stratum of association p, respectively, and
   lambda_p is a merit factor equal to stratum_p * MAXDIST + lambda,
   where lambda is the root synchronization distance for association p.
   The list is processed by the cluster algorithm below.  An example is
   shown by the second half of the clock_select() algorithm in
   Appendix A.5.5.1.多数集团的候选人以元组（p、theta_p、psi_p、lambda_p）的形式放置在幸存者名单 v 上，其中 p 是关联标识符、theta_p、psi_p，stratum_p分别是当前偏移量、抖动和关联层 p，lambda_p 是等于 stratum_p * MAXDIST + lambda 的品质因子， 其中 lambda 是关联 p 的根同步距离。该列表由下面的聚类算法处理。附录 A.5.5.1 中 clock_select（） 算法的后半部分显示了一个示例。   1.  Let (p, theta_p, psi_p, lambda_p) represent a survivor candidate.1. 设 （p， theta_p， psi_p， lambda_p） 代表幸存者候选人。   2.  Sort the candidates by increasing lambda_p.  Let n be the number
   of candidates and NMIN the minimum required number of survivors.2. 通过增加lambda_p对候选人进行排序。设 n 为候选人数，NMIN 为所需的最低幸存者人数。   3.  For each candidate, compute the selection jitter psi_s:3. 对于每个候选人，计算选择抖动psi_s：             +-----                       -----+^1/2
             |        n-1                      |
             |        ---                      |
             |   1    \                     2  |
     psi_s = | ---- * /  (theta_s - theta_j)   |
             |  n-1   ---                      |
             |        j=1                      |
             +-----                       -----++----- -----+^1/2 |N-1 | |--- | |1 \ 2 |psi_s = |---- * / （theta_s - theta_j） | |N-1 --- | |j=1 |+----- -----+   4.  Select psi_max as the candidate with maximum psi_s.4. 选择psi_max作为具有最大psi_s的候选项。Mills, et al.                Standards Track                   [Page 44]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 44 页] RFC 5905 NTPv4 规范 2010 年 6 月
   5.  Select psi_min as the candidate with minimum psi_p.5. 选择psi_min作为psi_p最少的候选人。   6.  Is psi_max < psi_min or n <= NMIN?  If yes, follow step 6A;
   otherwise, follow step 6B.6. psi_max < psi_min 或 n 是 <= NMIN？如果是，请按照步骤 6A 操作;否则，请按照步骤 6B 操作。   6A. Done.  The remaining candidates on the survivor list are ranked
   in the order of preference.  The first entry on the list represents
   the system peer; its variables are used later to update the system
   variables.6A. 完成。幸存者名单上的其余候选人按优先顺序排列。列表中的第一个条目表示系统对等体;其变量稍后用于更新系统变量。   6B. Delete the outlier candidate with psi_max; reduce n by one and go
   back to step 3.6乙。删除带有 psi_max 的异常候选项;将 n 减少 1，然后返回步骤 3。   The algorithm operates in a series of rounds where each round
   discards the statistical outlier with maximum selection jitter psi_s.
   However, if psi_s is less than the minimum peer jitter psi_p, no
   improvement is possible by discarding outliers.  This and the minimum
   number of survivors represent the terminating conditions of the
   algorithm.  Upon termination, the final value of psi_max is saved as
   the system selection jitter PSI_s for use later.该算法在一系列回合中运行，其中每回合丢弃具有最大选择抖动psi_s的统计异常值。但是，如果psi_s小于最小对等抖动psi_p，则丢弃异常值无法进行改进。这和最小幸存者数表示算法的终止条件。终止后，psi_max 的最终值将保存为系统选择抖动PSI_s以供以后使用。11.2.3.  Combine Algorithm11.2.3. 组合算法   The clock combine route processes the remaining survivors to produce
   the best and final data for the clock discipline algorithm.  The
   routine processes peer offset and jitter statistics to produce the
   combined system offset THETA and system peer jitter PSI_p, where each
   server statistic is weighted by the reciprocal of the root
   synchronization distance and the result normalized.  An example is
   shown by the clock_combine() routine in Appendix A.5.5.5时钟组合路由处理剩余的幸存者，为时钟学科算法生成最佳和最终数据。例程处理对等偏移和抖动统计，以生成组合的系统偏移 THETA 和系统对等抖动PSI_p，其中每个服务器统计量由根同步距离的倒数加权，结果归一化。附录 A.5.5.5 中的 clock_combine（） 例程显示了一个示例   The combined THETA is passed to the clock update routine.  The first
   candidate on the survivor list is nominated as the system peer with
   identifier p.  The system peer jitter PSI_p is a component of the
   system jitter PSI.  It is used along with the selection jitter PSI_s
   to produce the system jitter:组合的 THETA 将传递到时钟更新例程。幸存者列表中的第一个候选者被提名为标识符为 p 的系统对等体。系统对等抖动PSI_p是系统抖动 PSI 的一个组件。它与选择抖动PSI_s一起使用以产生系统抖动：   PSI = [(PSI_s)^2 + (PSI_p)^2]^1/2PSI = [（PSI_s）^2 + （PSI_p）^2]^1/2   Each time an update is received from the system peer, the clock
   update routine is called.  By rule, an update is discarded if its
   time of arrival p.t is not strictly later than the last update used
   s.t.  The labels IGNOR, PANIC, ADJ, and STEP refer to return codes
   from the local clock routine described in the next section.每次从系统对等体接收更新时，都会调用时钟更新例程。根据规则，如果更新的到达时间 p.t 不严格晚于上次使用的更新 s.t，则该更新将被丢弃。标签 IGNOR、PANIC、ADJ 和 STEP 引用下一节中介绍的本地时钟例程中的返回代码。   IGNORE means the update has been ignored as an outlier.  PANIC means
   the offset is greater than the panic threshold PANICT (1000 s) and
   SHOULD cause the program to exit with a diagnostic message to theIGNORE 表示更新已作为异常值被忽略。PANIC 表示偏移量大于恐慌阈值 PANICT（1000 秒），并且应使程序退出，并向Mills, et al.                Standards Track                   [Page 45]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 45 页] RFC 5905 NTPv4 规范 2010 年 6 月
   system log.  STEP means the offset is less than the panic threshold,
   but greater than the step threshold STEPT (125 ms).  In this case,
   the clock is stepped to the correct offset, but since this means all
   peer data have been invalidated, all associations MUST be reset and
   the client begins as at initial start.系统日志。STEP 表示偏移小于恐慌阈值，但大于阶跃阈值 STEPT （125 ms）。在这种情况下，时钟将单步执行到正确的偏移量，但由于这意味着所有对等数据都已失效，因此必须重置所有关联，并且客户端从初始启动开始。   ADJ means the offset is less than the step threshold and thus a valid
   update.  In this case, the system variables are updated from the peer
   variables as shown in Figure 25.ADJ 表示偏移量小于阶跃阈值，因此是有效的更新。在本例中，系统变量是从对等变量更新的，如图 25 所示。                  +-------------------------------------------+
                  | System Variable <-- System Peer Variable  |        |
                  +-------------------------------------------+
                  | s.leap      <-- p.leap                    |
                  | s.stratum   <-- p.stratum + 1             |
                  | s.offset    <-- THETA                     |
                  | s.jitter    <-- PSI                       |
                  | s.rootdelay <-- p.delta_r + delta         |
                  | s.rootdisp  <-- p.epsilon_r + p.epsilon + |
                  |                 p.psi + PHI * (s.t - p.t) |
                  |                 + |THETA|                 |
                  | s.refid     <-- p.refid                   |
                  | s.reftime   <-- p.reftime                 |
                  | s.t         <-- p.t                       |
                  +-------------------------------------------++-------------------------------------------+ |系统变量 <-- 系统对等变量 | |+-------------------------------------------+ |S.Leap <-- P.Leap | |S.Stratum <-- P.Stratum + 1 | |s.offset <-- 泰塔 | |s.jitter <-- PSI | |s.rootdelay <-- p.delta_r + 增量 | |S.rootdisp <-- p.epsilon_r + P.epsilon + | |p.psi + PHI * （s.t - p.t） | |+ |泰塔| | |S.Refid <-- P.Refid | |s.reftime <-- p.reftime | |S.T<-- P.T.（英语：S.T.）+-------------------------------------------+                    Figure 25: System Variables Update图 25：系统变量更新   There is an important detail not shown.  The dispersion increment
   (p.epsilon + p.psi + PHI * (s.t - p.t) + |THETA|) is bounded from
   below by MINDISP.  In subnets with very fast processors and networks
   and very small delay and dispersion this forces a monotone-definite
   increase in s.rootdisp (EPSILON), which avoids loops between peers
   operating at the same stratum.有一个重要的细节没有显示。色散增量 （p.epsilon + p.psi + PHI * （s.t - p.t） + |THETA|）由MINDISP从下方接壤。在具有非常快的处理器和网络以及非常小的延迟和分散的子网中，这迫使 s.rootdisp （EPSILON） 单调增加，从而避免了在同一层运行的对等体之间的循环。   The system variables are available to dependent application programs
   as nominal performance statistics.  The system offset THETA is the
   clock offset relative to the available synchronization sources.  The
   system jitter PSI is an estimate of the error in determining this
   value, elsewhere called the expected error.  The root delay DELTA is
   the total round-trip delay relative to the primary server.  The root
   dispersion EPSILON is the dispersion accumulated over the network
   from the primary server.  Finally, the root synchronization distance
   is defined as:系统变量可作为标称性能统计信息提供给相关应用程序。系统失调 THETA 是相对于可用同步源的时钟失调。系统抖动 PSI 是确定此值时误差的估计值，在其他地方称为预期误差。根延迟 DELTA 是相对于主服务器的总往返延迟。根分散 EPSILON 是从主服务器通过网络累积的分散。最后，根同步距离定义为：Mills, et al.                Standards Track                   [Page 46]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 46 页] RFC 5905 NTPv4 规范 2010 年 6 月
   LAMBDA = EPSILON + DELTA / 2,LAMBDA = EPSILON + DELTA / 2，   which represents the maximum error due all causes and is designated
   the root synchronization distance.它表示由于所有原因导致的最大误差，并被指定为根同步距离。   An example of the clock update routine is provided in
   Appendix A.5.5.4.附录 A.5.5.4 中提供了时钟更新例程的示例。11.3.  Clock Discipline Algorithm11.3. 时钟规则算法   The NTPv4 clock discipline algorithm, shortened to discipline in the
   following, functions as a combination of two quite philosophically
   different feedback control systems.  In a phase-locked loop (PLL)
   design, periodic phase updates at update intervals mu seconds are
   used directly to minimize the time error and indirectly the frequency
   error.  In a frequency-locked loop (FLL) design, periodic frequency
   updates at intervals mu are used directly to minimize the frequency
   error and indirectly the time error.  As shown in [ref7], a PLL
   usually works better when network jitter dominates, while an FLL
   works better when oscillator wander dominates.  This section contains
   an outline of how the NTPv4 design works.  An in-depth discussion of
   the design principles is provided in [ref7], which also includes a
   performance analysis.NTPv4 时钟规则算法（在下文中缩写为规则）是两个在哲学上完全不同的反馈控制系统的组合。在锁相环 （PLL） 设计中，以更新间隔 mu 秒的周期性相位更新直接用于最小化时间误差并间接减小频率误差。在锁频环 （FLL） 设计中，以 mu 为间隔的定期频率更新直接用于最小化频率误差并间接减少时间误差。如[参考文献7]所示，当网络抖动占主导地位时，PLL通常工作得更好，而当振荡器漂移占主导地位时，FLL工作得更好。本部分概述了 NTPv4 设计的工作原理。[参考文献7]中提供了对设计原则的深入讨论，其中还包括性能分析。   The discipline is implemented as the feedback control system shown in
   Figure 26.  The variable theta_r represents the combine algorithm
   offset (reference phase) and theta_c the VFO offset (control phase).
   Each update produces a signal V_d representing the instantaneous
   phase difference theta_r - theta_c.  The clock filter for each server
   functions as a tapped delay line, with the output taken at the tap
   selected by the clock filter algorithm.  The selection, cluster, and
   combine algorithms combine the data from multiple filters to produce
   the signal V_s.  The loop filter, with impulse response F(t),
   produces the signal V_c, which controls the VFO frequency omega_c and
   thus the integral of the phase theta_c which closes the loop.  The
   V_c signal is generated by the clock-adjust process in Section 12.
   The detailed equations that implement these functions are best
   presented in the routines of Appendices A.5.5.6 and A.5.6.1.该规则如图 26 所示的反馈控制系统实现。变量theta_r表示组合算法偏移量（参考相位），theta_c VFO 偏移量（控制相位）。每次更新都会产生一个信号V_d，表示瞬时相位差 theta_r - theta_c。每个服务器的时钟滤波器用作抽头延迟线，在时钟滤波器算法选择的抽头处获取输出。选择、聚类和组合算法将来自多个滤波器的数据组合在一起，以产生信号V_s。具有脉冲响应F（t）的环路滤波器产生信号V_c，该信号控制VFO频率omega_c，从而控制闭合环路的相位theta_c的积分。V_c信号由第 12 节中的时钟调整过程生成。实现这些函数的详细方程最好在附录 A.5.5.6 和 A.5.6.1 的例程中呈现。Mills, et al.                Standards Track                   [Page 47]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 47 页] RFC 5905 NTPv4 规范 2010 年 6 月
                theta_r + +---------\        +----------------+
            NTP --------->|  Phase   \  V_d  |                | V_s
                theta_c - | Detector  ------>|  Clock Filter  |----+
                +-------->|          /       |                |    |
                |         +---------/        +----------------+    |
                |                                                  |
              -----                                                |
             /     \                                               |
             | VFO |                                               |
             \     /                                               |
              -----    .......................................     |
                ^      .            Loop Filter              .     |
                |      . +---------+   x  +-------------+    .     |
                | V_c  . |         |<-----|             |    .     |
                +------.-|  Clock  |   y  | Phase/Freq  |<---------+
                       . | Adjust  |<-----| Prediction  |    .
                       . |         |      |             |    .
                       . +---------+      +-------------+    .
                       .......................................theta_r + +---------\ +----------------+ NTP --------->|阶段 \ V_d | |V_s theta_c - |探测器 ------>|时钟滤波器 |----+ +-------->|/ | | | |+---------/ +----------------+ | | |----- |/ \ | |VFO | |\ / |----- ....................................... |^ .循环滤波器。| | .+---------+ x +-------------+ .| |V_c .| |<-----| | .|+------.-|时钟 |y |相位/频率 |<---------+ .|调整 |<-----|预测 | ..| | | | ..+---------+ +-------------+ ........................................                 Figure 26: Clock Discipline Feedback Loop图 26：时钟规则反馈环路   Ordinarily, the pseudo-linear feedback loop described above operates
   to discipline the system clock.  However, there are cases where a
   non-linear algorithm offers considerable improvement.  One case is
   when the discipline starts without knowledge of the intrinsic clock
   frequency.  The pseudo-linear loop takes several hours to develop an
   accurate measurement and during most of that time the poll interval
   cannot be increased.  The non-linear loop described below does this
   in 15 minutes.  Another case is when occasional bursts of large
   jitter are present due to congested network links.  The state machine
   described below resists error bursts lasting less than 15 minutes.通常，上述伪线性反馈环路用于控制系统时钟。但是，在某些情况下，非线性算法提供了相当大的改进。一种情况是，当学科在不了解固有时钟频率的情况下开始时。伪线性环路需要几个小时才能获得准确的测量结果，并且在大部分时间内，轮询间隔无法增加。下面描述的非线性循环在 15 分钟内完成此操作。另一种情况是，由于网络链路拥塞，偶尔会出现大抖动。下面描述的状态机可抵抗持续时间少于 15 分钟的错误突发。   Figure 27 contains a summary of the variables and parameters
   including the variable (lowercase) or parameter (uppercase) name,
   formula name, and short description.  Unless noted otherwise, all
   variables have assumed prefix c.  The variables t, tc, state, hyster,
   and count are integers; the remaining variables are floating doubles.
   The function of each will be explained in the algorithm descriptions
   below.图 27 包含变量和参数的摘要，包括变量（小写）或参数（大写）名称、公式名称和简短描述。除非另有说明，否则所有变量都假定为前缀 c。变量 t、tc、state、hyster 和 count 是整数;其余变量是浮动双精度。每个函数的功能将在下面的算法说明中解释。Mills, et al.                Standards Track                   [Page 48]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 48 页] RFC 5905 NTPv4 规范 2010 年 6 月
                +--------+------------+--------------------------+
                | Name   | Formula    | Description              |
                +--------+------------+--------------------------+
                | t      | timer      | seconds counter          |
                | offset | theta      | combined offset          |
                | resid  | theta_r    | residual offset          |
                | freq   | phi        | clock frequency          |
                | jitter | psi        | clock offset jitter      |
                | wander | omega      | clock frequency wander   |
                | tc     | tau        | time constant (log2)     |
                | state  | state      | state                    |
                | adj    | adj        | frequency adjustment     |
                | hyster | hyster     | hysteresis counter       |
                | STEPT  | 125        | step threshold (.125 s)  |
                | WATCH  | 900        | stepout thresh(s)        |
                | PANICT | 1000       | panic threshold (1000 s) |
                | LIMIT  | 30         | hysteresis limit         |
                | PGATE  | 4          | hysteresis gate          |
                | TC     | 16         | time constant scale      |
                | AVG    | 8          | averaging constant       |
                +--------+------------+--------------------------++--------+------------+--------------------------+ |中文名 |配方 |描述 |+--------+------------+--------------------------+ |吨 |计时器 |秒针计时器 | |胶印 |θ |组合偏移量 | |瑞德 |theta_r |残余偏移量 | |频率 |披 |时钟频率 | |抖动 |psi |时钟失调抖动 | |徘徊 |欧米茄 |时钟频率漂移 | |TC公司 |陶 |时间常数 （log2） | |状态 |状态 |状态 | |调整后 |调整后 |频率调整 | |海斯特 |海斯特 |滞后计数器 | |斯蒂普特 |125 |步进阈值 （.125 s） | |观看 |900 |Stepout ThresH（S） | |恐慌 |1000 |恐慌阈值（1000 秒） | |限制 |30 |滞后极限 | |PGATE公司 |4 |滞后门 | |TC公司 |16 |时间常数刻度 | |平均 |8 |平均常数 |+--------+------------+--------------------------+           Figure 27: Clock Discipline Variables and Parameters图 27：时钟约束变量和参数   The process terminates immediately if the offset is greater than the
   panic threshold PANICT (1000 s).  The state transition function is
   described by the rstclock() function in Appendix A.5.5.7.  Figure 28
   shows the state transition function used by this routine.  It has
   four columns showing, respectively, the state name, predicate and
   action if the offset theta is less than the step threshold, the
   predicate and actions otherwise, and finally some comments.如果偏移量大于恐慌阈值 PANICT（1000 秒），则该过程将立即终止。状态转换函数由附录 A.5.5.7 中的 rstclock（） 函数描述。图 28 显示了此例程使用的状态转换函数。它有四列，分别显示状态名称、谓词和操作（如果偏移量 θ 小于步长阈值）、谓词和操作，否则显示谓词和操作，最后显示一些注释。
Mills, et al.                Standards Track                   [Page 49]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 49 页] RFC 5905 NTPv4 规范 2010 年 6 月
      +-------+---------------------+-------------------+--------------+
      | State | theta < STEP        | theta > STEP      | Comments     |
      +-------+---------------------+-------------------+--------------+
      | NSET  | ->FREQ              | ->FREQ            | no frequency |
      |       | adjust time         | step time         | file         |
      +-------+---------------------+-------------------+--------------+
      | FSET  | ->SYNC              | ->SYNC            | frequency    |
      |       | adjust time         | step time         | file         |
      +-------+---------------------+-------------------+--------------+
      | SPIK  | ->SYNC              | if < 900 s ->SPIK | outlier      |
      |       | adjust freq         | else ->SYNC       | detected     |
      |       | adjust time         | step freq         |              |
      |       |                     | step time         |              |
      +-------+---------------------+-------------------+--------------+
      | FREQ  | if < 900 s ->FREQ   | if < 900 s ->FREQ | initial      |
      |       | else ->SYNC         | else ->SYNC       | frequency    |
      |       | step freq           | step freq         |              |
      |       | adjust time         | adjust time       |              |
      +-------+---------------------+-------------------+--------------+
      | SYNC  | ->SYNC              | if < 900 s ->SPIK | normal       |
      |       | adjust freq         | else ->SYNC       | operation    |
      |       | adjust time         | step freq         |              |
      |       |                     | step time         |              |
      +-------+---------------------+-------------------+--------------++-------+---------------------+-------------------+--------------+ |状态 |theta < 步 | theta > 步 |评论 |+-------+---------------------+-------------------+--------------+ |NSET系列 |->FREQ |->FREQ |无频率 | | |调整时间 |步进时间 |文件 |+-------+---------------------+-------------------+--------------+ |FSET系列 |->同步 |->同步 |频率 | | |调整时间 |步进时间 |文件 |+-------+---------------------+-------------------+--------------+ |斯皮克 |->同步 |if < 900 s ->SPIK | 异常值 | | | 调整频率 | else ->SYNC | 检测到 | | | 调整时间 | 步进频率 | | | | 步进时间 | | +-------+---------------------+-------------------+--------------+ |FREQ |如果 < 900 秒 ->FREQ | 如果 < 900 秒 ->FREQ | 初始 | | | else ->SYNC | else ->SYNC | 频率 | | | 步进频率 | | | | 调整时间 | 调整时间 | | 调整时间 | | +-------+---------------------+-------------------+--------------+ |同步 |->同步 |如果 < 900 秒 ->SPIK | 正常 | | | 调整频率 | 否则 ->SYNC | 操作 | | | 调整时间 | 步进频率 | | | | 步进时间 | | +-------+---------------------+-------------------+--------------+                   Figure 28: State Transition Function图 28：状态转换函数   In the table entries, the next state is identified by the arrow ->
   with the actions listed below.  Actions such as adjust time and
   adjust frequency are implemented by the PLL/FLL feedback loop in the
   local_clock() routine.  A step clock action is implemented by setting
   the clock directly, but this is done only after the stepout threshold
   WATCH (900 s) when the offset is more than the step threshold STEPT
   (.125 s).  This resists clock steps under conditions of extreme
   network congestion.在表条目中，下一个状态由箭头 -> 标识，并执行下面列出的操作。调整时间和调整频率等操作由 local_clock（） 例程中的 PLL/FLL 反馈环路实现。步进时钟操作是通过直接设置时钟来实现的，但只有在偏移量大于步进阈值 STEPT （.125 s） 时，才能在步进阈值 WATCH （900 s） 之后完成。这在极端网络拥塞条件下可以抵抗时钟步进。   The jitter (psi) and wander (omega) statistics are computed using an
   exponential average with weight factor AVG.  The time constant
   exponent (tau) is determined by comparing psi with the magnitude of
   the current offset theta.  If the offset is greater than PGATE (4)
   times the clock jitter, the hysteresis counter hyster is reduced by
   two; otherwise, it is increased by one.  If hyster increases to the
   upper limit LIMIT (30), tau is increased by one; if it decreases to
   the lower limit -LIMIT (-30), tau is decreased by one.  Normally, tau
   hovers near MAXPOLL, but quickly decreases if a temperature spike
   causes a frequency surge.抖动 （psi） 和漂移 （omega） 统计数据是使用具有权重因子 AVG 的指数平均值计算的。时间常数指数 （tau） 是通过将 psi 与电流偏移 θ 的大小进行比较来确定的。如果偏移量大于PGATE（4）时钟抖动的倍数，则滞后计数器磁滞减小2;否则，它将增加一个。如果海斯特增加到上限 LIMIT （30），则 tau 增加 1;如果降低到下限 -LIMIT （-30），则 tau 减少 1。通常，tau 徘徊在 MAXPOLL 附近，但如果温度峰值导致频率激增，tau 会迅速减少。Mills, et al.                Standards Track                   [Page 50]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 50 页] RFC 5905 NTPv4 规范 2010 年 6 月
12.  Clock-Adjust Process12. 时钟调整过程   The actual clock-adjust process runs at one-second intervals to add
   the frequency correction and a fixed percentage of the residual
   offset theta_r.  The theta_r is, in effect, the exponential decay of
   the theta value produced by the loop filter at each update.  The TC
   parameter scales the time constant to match the poll interval for
   convenience.  Note that the dispersion EPSILON increases by PHI at
   each second.实际的时钟调整过程以一秒的间隔运行，以添加频率校正和固定百分比的残差偏移theta_r。实际上，theta_r是循环滤波器在每次更新时产生的 theta 值的指数衰减。为方便起见，TC 参数缩放时间常数以匹配轮询间隔。请注意，色散 EPSILON 每秒增加 PHI。   The clock-adjust process includes a timer interrupt facility driving
   the seconds counter c.t.  It begins at zero when the service starts
   and increments once each second.  At each interrupt, the
   clock_adjust() routine is called to incorporate the clock discipline
   time and frequency adjustments, then the associations are scanned to
   determine if the seconds counter equals or exceeds the p.next state
   variable defined in the next section.  If so, the poll process is
   called to send a packet and compute the next p.next value.时钟调整过程包括一个定时器中断设施，用于驱动秒针计数器。服务启动时，它从零开始，每秒递增一次。在每次中断时，都会调用 clock_adjust（） 例程以合并时钟规则时间和频率调整，然后扫描关联以确定秒计数器是否等于或超过下一节中定义的 p.next 状态变量。如果是这样，则调用轮询过程以发送数据包并计算下一个 p.next 值。   An example of the clock-adjust process is shown by the clock_adjust()
   routine in Appendix A.5.6.1.附录 A.5.6.1 中的 clock_adjust（） 例程显示了时钟调整过程的一个示例。13.  Poll Process 13. 投票流程   Each association supports a poll process that runs at regular
   intervals to construct and send packets in symmetric, client, and
   broadcast server associations.  It runs continuously, whether or not
   servers are reachable in order to manage the clock filter and reach
   register.每个关联都支持定期运行的轮询过程，以在对称、客户端和广播服务器关联中构造和发送数据包。无论服务器是否可访问，它都会连续运行，以便管理时钟滤波器和到达寄存器。13.1.  Poll Process Variables13.1. 轮询过程变量   Figure 29 summarizes the common names, formula names, and a short
   description of the poll process variables (lowercase) and parameters
   (uppercase).  Unless noted otherwise, all variables have assumed
   prefix p.图 29 总结了常用名称、公式名称以及轮询过程变量（小写）和参数（大写）的简短描述。除非另有说明，否则所有变量都假定为前缀 p。Mills, et al.                Standards Track                   [Page 51]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 51 页] RFC 5905 NTPv4 规范 2010 年 6 月
                   +---------+---------+--------------------+
                   | Name    | Formula | Description        |
                   +---------+---------+--------------------+
                   | hpoll   | hpoll   | host poll exponent |
                   | last    | last    | last poll time     |
                   | next    | next    | next poll time     |
                   | reach   | reach   | reach register     |
                   | unreach | unreach | unreach counter    |
                   | UNREACH | 24      | unreach limit      |
                   | BCOUNT  | 8       | burst count        |
                   | BURST   | flag    | burst enable       |
                   | IBURST  | flag    | iburst enable      |
                   +---------+---------+--------------------++---------+---------+--------------------+ |中文名 |配方 |描述 |+---------+---------+--------------------+ |HP波尔 |HP波尔 |主机轮询指数 | |最后 |最后 |上次投票时间 | |下一页 |下一页 |下一次投票时间 | |覆盖 |覆盖 |到达寄存器 | |无法触及 |无法触及 |未到达柜台 | |无法触及 |24 |未触及限制 | |伯爵 |8 |突发计数 | |突发 |旗帜 |突发使能 | |IBURST公司 |旗帜 |iburst 启用 |+---------+---------+--------------------+             Figure 29: Poll Process Variables and Parameters图 29：轮询过程变量和参数   The poll process variables are allocated in the association data
   structure along with the peer process variables.  The following is a
   detailed description of the variables.  The parameters will be called
   out in the following text.轮询过程变量与对等过程变量一起分配在关联数据结构中。以下是变量的详细说明。这些参数将在以下文本中标注。   hpoll: signed integer representing the poll exponent, in log2 secondshpoll：表示轮询指数的有符号整数，单位为 log2 秒   last: integer representing the seconds counter when the most recent
   packet was sentlast：整数表示发送最新数据包时的秒计数器   next: integer representing the seconds counter when the next packet
   is to be sentNext：整数表示发送下一个数据包时的秒计数器   reach: 8-bit integer shift register shared by the peer and poll
   processesREACH：对等和轮询进程共享的 8 位整数移位寄存器   unreach: integer representing the number of seconds the server has
   been unreachableunreach：整数表示服务器无法访问的秒数13.2.  Poll Process Operations13.2. 轮询过程操作   As described previously, once each second the clock-adjust process is
   called.  This routine calls the poll routine for each association in
   turn.  If the time for the next poll message is greater than the
   seconds counter, the routine returns immediately.  Symmetric (modes
   1, 2), client (mode 3), and broadcast server (mode 5) associations
   routinely send packets.  A broadcast client (mode 6) association runs
   the routine to update the reach and unreach variables, but does not
   send packets.  The poll process calls the transmit process to send a
   packet.  If in a burst (burst > 0), nothing further is done except
   call the poll update routine to set the next poll interval.如前所述，每秒调用一次时钟调整过程。此例程依次调用每个关联的轮询例程。如果下一个轮询消息的时间大于秒计数器，则例程将立即返回。对称（模式 1、2）、客户端（模式 3）和广播服务器（模式 5）关联定期发送数据包。广播客户端（模式 6）关联运行例程以更新 reach 和 unreach 变量，但不发送数据包。轮询过程调用传输进程来发送数据包。如果处于突发 （突发 > 0） 中，除了调用轮询更新例程以设置下一个轮询间隔外，不会执行任何进一步操作。
Mills, et al.                Standards Track                   [Page 52]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 52 页] RFC 5905 NTPv4 规范 2010 年 6 月
   If not in a burst, the reach variable is shifted left by one bit,
   with zero replacing the rightmost bit.  If the server has not been
   heard for the last three poll intervals, the clock filter routine is
   called to increase the dispersion.  An example is shown in
   Appendix A.5.7.3.如果不是突发，则 reach 变量将向左移动一位，以零替换最右边的位。如果在最后三个轮询间隔内未听到服务器的声音，则调用时钟滤波器例程以增加离散。附录 A.5.7.3 中显示了一个示例。   If the BURST flag is lit and the server is reachable and a valid
   source of synchronization is available, the client sends a burst of
   BCOUNT (8) packets at each poll interval.  The interval between
   packets in the burst is two seconds.  This is useful to accurately
   measure jitter with long poll intervals.  If the IBURST flag is lit
   and this is the first packet sent when the server has been
   unreachable, the client sends a burst.  This is useful to quickly
   reduce the synchronization distance below the distance threshold and
   synchronize the clock.如果 BURST 标志亮起，并且服务器可访问，并且有效的同步源可用，则客户端将在每个轮询间隔发送 BCOUNT （8） 数据包的突发。突发中数据包之间的间隔为 2 秒。这对于准确测量轮询间隔较长的抖动非常有用。如果 IBURST 标志亮起，并且这是服务器无法访问时发送的第一个数据包，则客户端会发送突发。这对于快速将同步距离降低到距离阈值以下并同步时钟非常有用。   If the P_MANY flag is lit in the p.flags word of the association,
   this is a manycast client association.  Manycast client associations
   send client mode packets to designated multicast group addresses at
   MINPOLL intervals.  The association starts out with a TTL of 1.  If
   by the time of the next poll there are fewer than MINCLOCK servers
   have been mobilized, the ttl is increased by one.  If the ttl reaches
   the limit TTLMAX, without finding MINCLOCK servers, the poll interval
   increases until reaching BEACON, when it starts over from the
   beginning.如果P_MANY标志在关联的 p.flags 字中亮起，则这是一个 manycast 客户端关联。Manycast 客户端关联以 MINPOLL 间隔将客户端模式数据包发送到指定的组播组地址。关联的 TTL 为 1。如果到下一次轮询时，已经动员的 MINCLOCK 服务器少于 MINCLOCK，则 ttl 将增加 1。如果 ttl 达到限制 TTLMAX，而没有找到 MINCLOCK 服务器，则轮询间隔会增加，直到到达 BEACON，此时它从头开始。   The poll() routine includes a feature that backs off the poll
   interval if the server becomes unreachable.  If reach is nonzero, the
   server is reachable and unreach is set to zero; otherwise, unreach is
   incremented by one for each poll to the maximum UNREACH.  Thereafter
   for each poll hpoll is increased by one, which doubles the poll
   interval up to the maximum MAXPOLL determined by the poll_update()
   routine.  When the server again becomes reachable, unreach is set to
   zero, hpoll is reset to the tc system variable, and operation resumes
   normally.poll（） 例程包含一个功能，如果服务器变得无法访问，则会退出轮询间隔。如果 reach 为非零，则服务器可访问，unreach 设置为零;否则，对于每个轮询，unreach 将递增 1，直至最大 UNREACH。此后，对于每个轮询，hpoll 增加 1，这会将轮询间隔加倍，直至达到由 poll_update（） 例程确定的最大 MAXPOLL。当服务器再次变得可访问时，unreach 设置为零，hpoll 重置为 tc 系统变量，操作恢复正常。   A packet is sent by the transmit process.  Some header values are
   copied from the peer variables left by a previous packet and others
   from the system variables.  Figure 30 shows which values are copied
   to each header field.  In those implementations, using floating
   double data types for root delay and root dispersion, these must be
   converted to NTP short format.  All other fields are either copied
   intact from peer and system variables or struck as a timestamp from
   the system clock.数据包由传输进程发送。一些标头值是从前一个数据包留下的对等变量复制的，而另一些是从系统变量复制的。图 30 显示了将哪些值复制到每个标头字段。在这些实现中，使用浮动双精度数据类型进行根延迟和根分散，这些数据类型必须转换为 NTP 短格式。所有其他字段要么从对等变量和系统变量中完整复制，要么作为系统时钟的时间戳进行删除。Mills, et al.                Standards Track                   [Page 53]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 53 页] RFC 5905 NTPv4 规范 2010 年 6 月
                   +-----------------------------------+
                   | Packet Variable <--   Variable    |
                   +-----------------------------------+
                   | x.leap        <--     s.leap      |
                   | x.version     <--     s.version   |
                   | x.mode        <--     s.mode      |
                   | x.stratum     <--     s.stratum   |
                   | x.poll        <--     s.poll      |
                   | x.precision   <--     s.precision |
                   | x.rootdelay   <--     s.rootdelay |
                   | x.rootdisp    <--     s.rootdisp  |
                   | x.refid       <--     s.refid     |
                   | x.reftime     <--     s.reftime   |
                   | x.org         <--     p.xmt       |
                   | x.rec         <--     p.dst       |
                   | x.xmt         <--     clock       |
                   | x.keyid       <--     p.keyid     |
                   | x.digest      <--     md5 digest  |
                   +-----------------------------------++-----------------------------------+ |数据包变量 <-- 变量 |+-----------------------------------+ |X.Leap <-- S.Leap | |x.version <-- s.version | |x.mode <-- s.mode | |x.stratum <-- s.stratum | |x.poll <-- s.poll | |X.精密 <-- S.精密 | |x.rootdelay <-- s.rootdelay | |x.rootdisp <-- s.rootdisp | |x.refid <-- s.refid | |x.reftime <-- s.reftime | |x.org <-- p.xmt | |x.rec <-- 太平洋夏令时 | |x.xmt <-- 时钟 | |x.keyid <-- p.keyid | |X.Digest <-- MD5 摘要 |+-----------------------------------+                   Figure 30: xmit_packet Packet Header图 30：xmit_packet 数据包标头   The poll update routine is called when a valid packet is received and
   immediately after a poll message has been sent.  If in a burst, the
   poll interval is fixed at 2 s; otherwise, the host poll exponent
   hpoll is set to the minimum of ppoll from the last packet received
   and hpoll from the poll routine, but not less than MINPOLL or greater
   than MAXPOLL.  Thus, the clock discipline can be oversampled but not
   undersampled.  This is necessary to preserve subnet dynamic behavior
   and protect against protocol errors.轮询更新例程在收到有效数据包时调用，并在发送轮询消息后立即调用。如果是突发，轮询间隔固定为 2 秒;否则，主机轮询指数 hpoll 将设置为接收的最后一个数据包的最小值 ppoll 和轮询例程的 hpoll，但不小于 MINPOLL 或大于 MAXPOLL。因此，时钟规则可以过采样，但不能欠采样。这对于保留子网动态行为和防止协议错误是必需的。   The poll exponent is converted to an interval, which, when added to
   the last poll time variable, determines the value of the next poll
   time variable.  Finally, the last poll time variable is set to the
   current seconds counter.轮询指数将转换为一个区间，当该区间添加到上次轮询时间变量时，该区间将确定下一个轮询时间变量的值。最后，将上次轮询时间变量设置为当前秒计数器。14.  Simple Network Time Protocol (SNTP)14. 简单网络时间协议 （SNTP）   Primary servers and clients complying with a subset of NTP, called
   the Simple Network Time Protocol (SNTPv4) [RFC4330], do not need to
   implement the mitigation algorithms described in Section 9 and
   following sections.  SNTP is intended for primary servers equipped
   with a single reference clock, as well as for clients with a single
   upstream server and no dependent clients.  The fully developed NTPv4
   implementation is intended for secondary servers with multiple
   upstream servers and multiple downstream servers or clients.  Other
   than these considerations, NTP and SNTP servers and clients are
   completely interoperable and can be intermixed in NTP subnets.符合 NTP 子集（称为简单网络时间协议 （SNTPv4） [RFC4330]）的主服务器和客户端不需要实现第 9 节和以下各节中所述的缓解算法。SNTP 适用于配备单个参考时钟的主服务器，以及具有单个上游服务器且没有从属客户端的客户端。完全开发的 NTPv4 实现适用于具有多个上游服务器和多个下游服务器或客户端的辅助服务器。除了这些注意事项之外，NTP 和 SNTP 服务器和客户端是完全可互操作的，并且可以在 NTP 子网中混合使用。Mills, et al.                Standards Track                   [Page 54]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 54 页] RFC 5905 NTPv4 规范 2010 年 6 月
   An SNTP primary server implementing the on-wire protocol described in
   Section 8 has no upstream servers except a single reference clock.
   In principle, it is indistinguishable from an NTP primary server that
   has the mitigation algorithms and therefore capable of mitigating
   between multiple reference clocks.实现第 8 节中描述的在线协议的 SNTP 主服务器除了单个参考时钟外没有上游服务器。原则上，它与具有缓解算法的 NTP 主服务器没有区别，因此能够在多个参考时钟之间缓解。   Upon receiving a client request, an SNTP primary server constructs
   and sends the reply packet as described in Figure 31.  Note that the
   dispersion field in the packet header must be updated as described in
   Section 5.收到客户端请求后，SNTP 主服务器构建并发送应答数据包，如图 31 所示。请注意，数据包标头中的分散字段必须按照第 5 节中的说明进行更新。                   +-----------------------------------+
                   | Packet Variable <--   Variable    |
                   +-----------------------------------+
                   | x.leap        <--     s.leap      |
                   | x.version     <--     r.version   |
                   | x.mode        <--     4           |
                   | x.stratum     <--     s.stratum   |
                   | x.poll        <--     r.poll      |
                   | x.precision   <--     s.precision |
                   | x.rootdelay   <--     s.rootdelay |
                   | x.rootdisp    <--     s.rootdisp  |
                   | x.refid       <--     s.refid     |
                   | x.reftime     <--     s.reftime   |
                   | x.org         <--     r.xmt       |
                   | x.rec         <--     r.dst       |
                   | x.xmt         <--     clock       |
                   | x.keyid       <--     r.keyid     |
                   | x.digest      <--     md5 digest  |
                   +-----------------------------------++-----------------------------------+ |数据包变量 <-- 变量 |+-----------------------------------+ |X.Leap <-- S.Leap | |x.version <-- r.version | |X.模式 <-- 4 | |x.stratum <-- s.stratum | |x.poll <-- r.poll | |X.精密 <-- S.精密 | |x.rootdelay <-- s.rootdelay | |x.rootdisp <-- s.rootdisp | |x.refid <-- s.refid | |x.reftime <-- s.reftime | |x.org <-- r.xmt | |x.rec <-- r.dst | |x.xmt <-- 时钟 | |x.keyid <-- r.keyid | |X.Digest <-- MD5 摘要 |+-----------------------------------+                    Figure 31: fast_xmit Packet Header图 31：fast_xmit 数据包标头   An SNTP client implementing the on-wire protocol has a single server
   and no dependent clients.  It can operate with any subset of the NTP
   on-wire protocol, the simplest approach using only the transmit
   timestamp of the server packet and ignoring all other fields.
   However, the additional complexity to implement the full on-wire
   protocol is minimal so that a full implementation is encouraged.实现在线协议的 SNTP 客户端具有单个服务器，没有依赖客户端。它可以与NTP在线协议的任何子集一起运行，最简单的方法仅使用服务器数据包的传输时间戳，而忽略所有其他字段。但是，实现完整的在线协议的额外复杂性是最小的，因此鼓励完全实施。15.  Security Considerations15. 安全注意事项   NTP security requirements are even more stringent than most other
   distributed services.  First, the operation of the authentication
   mechanism and the time synchronization mechanism are inextricably
   intertwined.  Reliable time synchronization requires cryptographic
   keys that are valid only over a designated time interval; but, time
   intervals can be enforced only when participating servers and clientsNTP 安全要求甚至比大多数其他分布式服务更严格。首先，认证机制的运作与时间同步机制密不可分。可靠的时间同步需要仅在指定时间间隔内有效的加密密钥;但是，只有在参与服务器和客户端时，才能强制执行时间间隔Mills, et al.                Standards Track                   [Page 55]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 55 页] RFC 5905 NTPv4 规范 2010 年 6 月
   are reliably synchronized to UTC.  In addition, the NTP subnet is
   hierarchical by nature, so time and trust flow from the primary
   servers at the root through secondary servers to the clients at the
   leaves.可靠地同步到 UTC。此外，NTP 子网本质上是分层的，因此时间和信任从根的主服务器流经辅助服务器流向叶的客户端。   An NTP client can claim to have authentic time to dependent
   applications only if all servers on the path to the primary servers
   are authenticated.  In NTP each server authenticates the next lower
   stratum servers and authenticates by induction the lowest stratum
   (primary) servers.  It is important to note that authentication in
   the context of NTP does not necessarily imply the time is correct.
   An NTP client mobilizes a number of concurrent associations with
   different servers and uses a crafted agreement algorithm to pluck
   truechimers from the population possibly including falsetickers.仅当主服务器路径上的所有服务器都经过身份验证时，NTP 客户端才能声明对依赖应用程序具有真实时间。在 NTP 中，每个服务器对下一个较低层服务器进行身份验证，并通过感应对最低层（主）服务器进行身份验证。需要注意的是，NTP 上下文中的身份验证并不一定意味着时间是正确的。NTP 客户端与不同服务器调动了许多并发关联，并使用精心设计的协议算法从可能包括 falseticker 的群体中提取真嵌合器。   The NTP specification assumes that the goal of the intruder is to
   inject false time values, disrupt the protocol, or clog the network,
   servers, or clients with spurious packets that exhaust resources and
   deny service to legitimate applications.  There are a number of
   defense mechanisms already built in the NTP architecture, protocol,
   and algorithms.  The on-wire timestamp exchange scheme is inherently
   resistant to spoofing, packet-loss, and replay attacks.  The
   engineered clock filter, selection and clustering algorithms are
   designed to defend against evil cliques of Byzantine traitors.  While
   not necessarily designed to defeat determined intruders, these
   algorithms and accompanying sanity checks have functioned well over
   the years to deflect improperly operating but presumably friendly
   scenarios.  However, these mechanisms do not securely identify and
   authenticate servers to clients.  Without specific further
   protection, an intruder can inject any or all of the following
   attacks:NTP 规范假定入侵者的目标是注入错误的时间值、中断协议或使用耗尽资源并拒绝为合法应用程序提供服务的虚假数据包阻塞网络、服务器或客户端。NTP 架构、协议和算法中已经内置了许多防御机制。在线时间戳交换方案本质上可以抵抗欺骗、数据包丢失和重放攻击。精心设计的时钟滤波器、选择和聚类算法旨在抵御拜占庭叛徒的邪恶集团。虽然不一定旨在击败坚定的入侵者，但这些算法和随之而来的健全性检查多年来运行良好，可以偏转操作不当但可能友好的场景。但是，这些机制不能安全地识别服务器并向客户端进行身份验证。如果没有特定的进一步保护，入侵者可以注入以下任何或所有攻击：   1.  An intruder can intercept and archive packets forever, as well as
       all the public values ever generated and transmitted over the
       net.1. 入侵者可以永久拦截和存档数据包，以及曾经通过网络生成和传输的所有公共值。   2.  An intruder can generate packets faster than the server, network
       or client can process them, especially if they require expensive
       cryptographic computations.2. 入侵者生成数据包的速度比服务器、网络或客户端处理数据包的速度更快，尤其是当它们需要昂贵的加密计算时。   3.  In a wiretap attack, the intruder can intercept, modify, and
       replay a packet.  However, it cannot permanently prevent onward
       transmission of the original packet; that is, it cannot break the
       wire, only tell lies and congest it.  Generally, the modified
       packet cannot arrive at the victim before the original packet,
       nor does it have the server private keys or identity parameters.3. 在窃听攻击中，入侵者可以拦截、修改和重放数据包。但是，它不能永久阻止原始数据包的继续传输;也就是说，它不能断线，只能说谎并拥堵它。一般情况下，修改后的数据包不能先于原始数据包到达受害者，也没有服务器私钥或身份参数。Mills, et al.                Standards Track                   [Page 56]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 56 页] RFC 5905 NTPv4 规范 2010 年 6 月
   4.  In a middleman or masquerade attack, the intruder is positioned
       between the server and client, so it can intercept, modify and
       replay a packet and prevent onward transmission of the original
       packet.  However, the middleman does not have the server private
       keys.4. 在中间人或伪装攻击中，入侵者位于服务器和客户端之间，因此它可以拦截、修改和重放数据包，并阻止原始数据包的继续传输。但是，中间人没有服务器私钥。   The NTP security model assumes the following possible limitations:NTP 安全模型假定存在以下可能的限制：   1.  The running times for public key algorithms are relatively long
       and highly variable.  In general, the performance of the time
       synchronization function is badly degraded if these algorithms
       must be used for every NTP packet.1. 公钥算法的运行时间相对较长且变化很大。通常，如果必须对每个 NTP 数据包使用这些算法，则时间同步功能的性能会严重下降。   2.  In some modes of operation, it is not feasible for a server to
       retain state variables for every client.  It is however feasible
       to regenerated them for a client upon arrival of a packet from
       that client.2. 在某些操作模式下，服务器无法为每个客户端保留状态变量。但是，在客户端到达数据包时为客户端重新生成它们是可行的。   3.  The lifetime of cryptographic values must be enforced, which
       requires a reliable system clock.  However, the sources that
       synchronize the system clock must be trusted.  This circular
       interdependence of the timekeeping and authentication functions
       requires special handling.3. 必须强制执行加密值的生存期，这需要可靠的系统时钟。但是，同步系统时钟的源必须受信任。计时和认证功能的这种循环相互依存关系需要特殊处理。   4.  Client security functions must involve only public values
       transmitted over the net.  Private values must never be disclosed
       beyond the machine on which they were created, except in the case
       of a special trusted agent (TA) assigned for this purpose.4. 客户端安全功能必须仅涉及通过网络传输的公共值。绝不能在创建私有值的计算机之外披露私有值，除非为此目的分配了特殊的受信任代理 （TA）。   Unlike the Secure Shell (SSH) security model, where the client must
   be securely authenticated to the server, in NTP the server must be
   securely authenticated to the client.  In SSH, each different
   interface address can be bound to a different name, as returned by a
   reverse-DNS query.  In this design, separate public/private key pairs
   may be required for each interface address with a distinct name.  A
   perceived advantage of this design is that the security compartment
   can be different for each interface.  This allows a firewall, for
   instance, to require some interfaces to authenticate the client and
   others not.与安全外壳 （SSH） 安全模型不同，在安全外壳 （SSH） 安全模型中，客户端必须安全地向服务器进行身份验证，而在 NTP 中，服务器必须安全地向客户端进行身份验证。在 SSH 中，每个不同的接口地址都可以绑定到不同的名称，如反向 DNS 查询返回的那样。在这种设计中，每个具有不同名称的接口地址可能需要单独的公钥/私钥对。这种设计的一个明显优势是每个接口的安全隔间可以不同。例如，这允许防火墙要求某些接口对客户端进行身份验证，而其他接口则不需要。   In the case of NTP as specified herein, NTP broadcast clients are
   vulnerable to disruption by misbehaving or hostile SNTP or NTP
   broadcast servers elsewhere in the Internet.  Such disruption can be
   minimized by several approaches.  Filtering can be employed to limit
   the access of NTP clients to known or trusted NTP broadcast servers.
   Such filtering will prevent malicious traffic from reaching the NTP
   clients.  Cryptographic authentication at the client will only allow对于本文指定的 NTP，NTP 广播客户端容易受到 Internet 中其他地方行为不端或敌对的 SNTP 或 NTP 广播服务器的干扰。这种干扰可以通过几种方法最小化。可以使用筛选来限制 NTP 客户端对已知或受信任的 NTP 广播服务器的访问。这种过滤将防止恶意流量到达 NTP 客户端。客户端的加密身份验证只允许
Mills, et al.                Standards Track                   [Page 57]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 57 页] RFC 5905 NTPv4 规范 2010 年 6 月
   timing information from properly signed NTP messages to be utilized
   in synchronizing its clock.  Higher levels of authentication may be
   gained by the use of the Autokey mechanism [RFC5906].来自正确签名的 NTP 消息的定时信息，用于同步其时钟。使用自动密钥机制可以获得更高级别的身份验证 [RFC5906]。   Section 8 describes a potential security concern with the replay of
   client requests.  Following the recommendations in that section
   provides protection against such attacks.第 8 节描述了重播客户端请求的潜在安全问题。遵循该部分中的建议可以防止此类攻击。   It should be noted that this specification is describing an existing
   implementation.  While the security shortfalls of the MD5 algorithm
   are well-known, its use in the NTP specification is consistent with
   widescale deployment in the Internet community.应该注意的是，此规范描述的是现有的实现。虽然 MD5 算法的安全缺陷是众所周知的，但它在 NTP 规范中的使用与互联网社区的大规模部署是一致的。16.  IANA Considerations 16. IANA的注意事项   UDP/TCP Port 123 was previously assigned by IANA for this protocol.
   The IANA has assigned the IPv4 multicast group address 224.0.1.1 and
   the IPv6 multicast address ending :101 for NTP.  This document
   introduces NTP extension fields allowing for the development of
   future extensions to the protocol, where a particular extension is to
   be identified by the Field Type sub-field within the extension field.
   IANA has established and will maintain a registry for Extension Field
   Types associated with this protocol, populating this registry with no
   initial entries.  As future needs arise, new Extension Field Types
   may be defined.  Following the policies outlined in [RFC5226], new
   values are to be defined by IETF Review.UDP/TCP 端口 123 以前由 IANA 为此协议分配。IANA 已为 NTP 分配了 IPv4 组播组地址 224.0.1.1 和以 ：101 结尾的 IPv6 组播地址。本文档介绍了 NTP 扩展字段，允许开发协议的未来扩展，其中特定扩展将由扩展字段中的字段类型子字段标识。IANA 已建立并将维护与此协议相关的扩展字段类型的注册管理机构，并在此注册管理机构中填充不包含初始条目。随着未来需求的出现，可能会定义新的扩展字段类型。根据 [RFC5226] 中概述的策略，IETF Review 将定义新值。   The IANA has created a new registry for NTP Reference Identifier
   codes.  This includes the current codes defined in Section 7.3, and
   may be extended on a First-Come-First-Serve (FCFS) basis.  The format
   of the registry is:IANA 为 NTP 参考标识符代码创建了一个新的注册管理机构。这包括第 7.3 节中定义的当前代码，并且可以根据先到先得 （FCFS） 进行扩展。注册表的格式为：     +------+----------------------------------------------------------+
     | ID   | Clock Source                                             |
     +------+----------------------------------------------------------+
     | GOES | Geosynchronous Orbit Environment Satellite               |
     | GPS  | Global Position System                                   |
     | ...  | ...                                                      |
     +------+----------------------------------------------------------++------+----------------------------------------------------------+ |编号 |时钟源 |+------+----------------------------------------------------------+ |去 |地球同步轨道环境卫星 | |全球定位系统 |全球定位系统 | |... |... |+------+----------------------------------------------------------+                   Figure 32: Reference Identifier Codes图 32：引用标识符代码   The IANA has created a new registry for NTP Kiss-o'-Death codes.
   This includes the current codes defined in Section 7.4, and may be
   extended on a FCFS basis.  The format of the registry is:IANA 为 NTP Kiss-o'-Death 代码创建了一个新的注册管理机构。这包括第 7.4 节中定义的当前代码，并且可以在 FCFS 的基础上进行扩展。注册表的格式为：
Mills, et al.                Standards Track                   [Page 58]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 58 页] RFC 5905 NTPv4 规范 2010 年 6 月
   +------+------------------------------------------------------------+
   | Code |                           Meaning                          |
   +------+------------------------------------------------------------+
   | ACST | The association belongs to a unicast server.               |
   | AUTH | Server authentication failed.                              |
   | ...  | ...                                                        |
   +------+------------------------------------------------------------++------+------------------------------------------------------------+ |代码 |意义 |+------+------------------------------------------------------------+ |ACST公司 |关联属于单播服务器。| |身份验证 |服务器身份验证失败。| |... |... |+------+------------------------------------------------------------+                           Figure 33: Kiss Codes图 33：亲吻代码   For both Reference Identifiers and Kiss-o'-Death codes, IANA is
   requested to never assign a code beginning with the character "X", as
   this is reserved for experimentation and development.对于参考标识符和 Kiss-o'-Death 代码，IANA 被要求永远不要分配以字符“X”开头的代码，因为这是为实验和开发而保留的。17.  Acknowledgements 17. 致谢   The editors would like to thank Karen O'Donoghue, Brian Haberman,
   Greg Dowd, Mark Elliot, Harlan Stenn, Yaakov Stein, Stewart Bryant,
   and Danny Mayer for technical reviews and specific text contributions
   to this document.编辑们要感谢 Karen O'Donoghue、Brian Haberman、Greg Dowd、Mark Elliot、Harlan Stenn、Yaakov Stein、Stewart Bryant 和 Danny Mayer 对本文档的技术审查和具体文本贡献。18.  References 18. 参考资料18.1.  Normative References18.1. 规范性参考   [RFC0768]       Postel, J., "User Datagram Protocol", STD 6, RFC 768,
                   August 1980.[RFC0768]Postel， J.，“用户数据报协议”，STD 6，RFC 768,1980 年 8 月。   [RFC0791]       Postel, J., "Internet Protocol", STD 5, RFC 791,
                   September 1981.[RFC0791]Postel， J.，“互联网协议”，STD 5，RFC 791,1981 年 9 月。   [RFC0793]       Postel, J., "Transmission Control Protocol", STD 7,
                   RFC 793, September 1981.[RFC0793]Postel， J.，“传输控制协议”，STD 7，RFC 793,1981 年 9 月。   [RFC1321]       Rivest, R., "The MD5 Message-Digest Algorithm",
                   RFC 1321, April 1992.[RFC1321]Rivest， R.，“MD5 消息摘要算法”，RFC 1321,1992 年 4 月。   [RFC2119]       Bradner, S., "Key words for use in RFCs to Indicate
                   Requirement Levels", BCP 14, RFC 2119, March 1997.[RFC2119]Bradner， S.，“在 RFC 中使用用于指示需求级别的关键词”，BCP 14，RFC 2119,1997 年 3 月。18.2.  Informative References18.2. 信息参考   [CGPM]          Bureau International des Poids et Mesures, "Comptes
                   Rendus de la 15e CGPM", 1976.[GFCM]Bureau International des Poids et Mesures，“Comptes Rendus de la 15e CGPM”，1976年。   [ITU-R_TF.460]  International Telecommunications Union, "ITU-R TF.460
                   Standard-frequency and time-signal emissions",
                   February 2002.[国际电联-R_TF.460]国际电信联盟，“ITU-R TF.460标准频率和时间信号发射”，2002年2月。Mills, et al.                Standards Track                   [Page 59]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 59 页] RFC 5905 NTPv4 规范 2010 年 6 月
   [RFC1305]       Mills, D., "Network Time Protocol (Version 3)
                   Specification, Implementation and Analysis",
                   RFC 1305, March 1992.[RFC1305]Mills， D.，“网络时间协议（第 3 版）规范、实现和分析”，RFC 1305,1992 年 3 月。   [RFC1345]       Simonsen, K., "Character Mnemonics and Character
                   Sets", RFC 1345, June 1992.[RFC1345]Simonsen， K.，“字符助记符和字符集”，RFC 1345,1992 年 6 月。   [RFC4330]       Mills, D., "Simple Network Time Protocol (SNTP)
                   Version 4 for IPv4, IPv6 and OSI", RFC 4330,
                   January 2006.[RFC4330]Mills， D.，“用于 IPv4、IPv6 和 OSI 的简单网络时间协议 （SNTP） 版本 4”，RFC 4330,2006 年 1 月。   [RFC5226]       Narten, T. and H. Alvestrand, "Guidelines for Writing
                   an IANA Considerations Section in RFCs", BCP 26,
                   RFC 5226, May 2008.[RFC5226]Narten， T. 和 H. Alvestrand，“RFC 中编写 IANA 注意事项部分的指南”，BCP 26，RFC 5226,2008 年 5 月。   [RFC5906]       Haberman, B., Ed. and D. Mills, "Network Time
                   Protocol Version 4: Autokey Specification", RFC 5906,
                   June 2010.[RFC5906]Haberman， B.， Ed. 和 D. Mills，“网络时间协议版本 4：自动密钥规范”，RFC 5906,2010 年 6 月。   [ref6]          Marzullo and S. Owicki, "Maintaining the time in a
                   distributed system", ACM Operating Systems Review 19,
                   July 1985.[参考文献6]Marzullo 和 S. Owicki，“在分布式系统中维护时间”，ACM 操作系统评论第 19 期，1985 年 7 月。   [ref7]          Mills, D.L., "Computer Network Time Synchronization -
                   the Network Time Protocol", CRC Press, 304 pp, 2006.[参考文献7]Mills， D.L.，“计算机网络时间同步 - 网络时间协议”，CRC 出版社，304 页，2006 年。   [ref9]          Mills, D.L., Electrical and Computer Engineering
                   Technical Report 06-6-1, NDSS, June 2006, "Network
                   Time Protocol Version 4 Reference and Implementation
                   Guide", 2006.[参考文献9]Mills， D.L.，电气和计算机工程技术报告 06-6-1，NDSS，2006 年 6 月，“网络时间协议第 4 版参考和实施指南”，2006 年。Mills, et al.                Standards Track                   [Page 60]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 60 页] RFC 5905 NTPv4 规范 2010 年 6 月
Appendix A.  Code Skeleton附录 A. 代码骨架   This appendix is intended to describe the protocol and algorithms of
   an implementation in a general way using what is called a code
   skeleton program.  This consists of a set of definitions, structures,
   and code fragments that illustrate the protocol operations without
   the complexities of an actual implementation of the protocol.  This
   program is not an executable and is not designed to run in the
   ordinary sense.本附录旨在使用所谓的代码骨架程序以一般方式描述实现的协议和算法。它由一组定义、结构和代码片段组成，这些定义、结构和代码片段说明了协议操作，而没有协议实际实现的复杂性。该程序不是可执行文件，也不是为在通常意义上运行而设计的。   Most of the features of the reference implementation are included
   here, with the following exceptions: there are no provisions for
   reference clocks or public key (Autokey) cryptography.  There is no
   huff-n'-puff filter, anti-clockhop hysteresis, or monitoring
   provisions.  Many of the values that can be tinkered in the reference
   implementation are assumed constants here.  There are only minimal
   provisions for the kiss-o'-death packet and no responding code.此处包含参考实现的大多数功能，但以下情况除外：没有关于参考时钟或公钥（Autokey）加密的规定。没有 huff-n'-puff 滤波器、反时钟跳滞后或监控规定。在参考实现中可以修改的许多值在这里都是假定的常量。kiss-o'-death 数据包只有最低限度的规定，没有响应代码。   The program is not intended to be fast or compact, just to
   demonstrate the algorithms with sufficient fidelity to understand how
   they work.  The code skeleton consists of eight segments, a header
   segment included by each of the other segments, plus a code segment
   for the main program, kernel I/O and system clock interfaces, and
   peer, system, clock_adjust, and poll processes.  These are presented
   in order below along with definitions and variables specific to each
   process.该程序的目的不是快速或紧凑，只是为了以足够的保真度演示算法来理解它们的工作原理。代码骨架由八个段组成，每个段都包含一个标头段，以及用于主程序、内核 I/O 和系统时钟接口以及对等、系统、clock_adjust和轮询进程的代码段。下面按顺序介绍这些内容，以及特定于每个过程的定义和变量。A.1.  Global Definitions A.1. 全局定义A.1.1.  Definitions, Constants, ParametersA.1.1. 定义、常量、参数#include <math.h>               /* avoids complaints about sqrt() */
#include <sys/time.h>           /* for gettimeofday() and friends */
#include <stdlib.h>             /* for malloc() and friends */
#include <string.h>             /* for memset() */#include < math.h> /* 避免了对 sqrt（） 的抱怨 */ #include < sys/time.h> /* 用于 gettimeofday（） 和 friends */ #include < stdlib.h> /* 用于 malloc（） 和朋友 */ #include < string.h> /* 用于 memset（） *//*
 * Data types
 *
 * This program assumes the int data type is 32 bits and the long data
 * type is 64 bits.  The native data type used in most calculations is
 * floating double.  The data types used in some packet header fields
 * require conversion to and from this representation.  Some header
 * fields involve partitioning an octet, here represented by individual
 * octets.
 *
 * The 64-bit NTP timestamp format used in timestamp calculations is
 * unsigned seconds and fraction with the decimal point to the left of/* * 数据类型 * * 此程序假定 int 数据类型为 32 位，long 数据 * 类型为 64 位。大多数计算中使用的本机数据类型是 * 浮动双精度。某些数据包标头字段 * 中使用的数据类型需要与此表示形式进行相互转换。一些标头 * 字段涉及对八位字节进行分区，此处由单个 * 八位字节表示。* * 时间戳计算中使用的 64 位 NTP 时间戳格式是 * 无符号秒数和小数点在Mills, et al.                Standards Track                   [Page 61]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 61 页] RFC 5905 NTPv4 规范 2010 年 6 月
 * bit 32.  The only operation permitted with these values is
 * subtraction, yielding a signed 31-bit difference.  The 32-bit NTP
 * short format used in delay and dispersion calculations is seconds and
 * fraction with the decimal point to the left of bit 16.  The only
 * operations permitted with these values are addition and
 * multiplication by a constant.
 *
 * The IPv4 address is 32 bits, while the IPv6 address is 128 bits.  The
 * message digest field is 128 bits as constructed by the MD5 algorithm.
 * The precision and poll interval fields are signed log2 seconds.
 */
typedef unsigned long long tstamp;   /* NTP timestamp format */
typedef unsigned int tdist;     /* NTP short format */
typedef unsigned long ipaddr;   /* IPv4 or IPv6 address */
typedef unsigned long digest;   /* md5 digest */
typedef signed char s_char;     /* precision and poll interval (log2) */* 位 32.这些值允许的唯一操作是 * 减法，产生有符号的 31 位差值。延迟和色散计算中使用的 32 位 NTP * 短格式为秒和 * 分数，小数点位于位 16 的左侧。这些值允许的唯一 * 操作是加法和 * 乘以常量。* * IPv4 地址为 32 位，而 IPv6 地址为 128 位。* 消息摘要字段为 128 位，由 MD5 算法构造。* 精度和轮询间隔字段的签名为 log2 秒。*/ typedef unsigned long long tstamp;/* NTP 时间戳格式 */ typedef unsigned int tdist;/* NTP 短格式 */ typedef unsigned long ipaddr;/* IPv4 或 IPv6 地址 */ typedef unsigned long digest;/* md5 摘要 */ typedef signed char s_char;/* 精度和轮询间隔 （log2） *//*
 * Timestamp conversion macroni
 */
#define FRIC        65536.                  /* 2^16 as a double */
#define D2FP(r)     ((tdist)((r) * FRIC))   /* NTP short */
#define FP2D(r)     ((double)(r) / FRIC)/* * 时间戳转换 macroni */ #define FRIC 65536。/* 2^16 作为双精度 */ #define D2FP（r） （（tdist）（（r） * FRIC）） /* NTP 短 */ #define FP2D（r） （（双精度）（r） / FRIC）#define FRAC       4294967296.             /* 2^32 as a double */
#define D2LFP(a)   ((tstamp)((a) * FRAC))  /* NTP timestamp */
#define LFP2D(a)   ((double)(a) / FRAC)
#define U2LFP(a)   (((unsigned long long) \
                       ((a).tv_sec + JAN_1970) << 32) + \
                       (unsigned long long) \
                       ((a).tv_usec / 1e6 * FRAC))#define FRAC 4294967296。/* 2^32 作为双精度 */ #define D2LFP（a） （（tstamp）（（a） * FRAC）） /* NTP 时间戳 */ #define LFP2D（a） （（双精度）（a） / FRAC） #define U2LFP（a） （（（（无符号长长） \ （（a）.tv_sec + JAN_1970） << 32） + \ （无符号长长） \ （（a）.tv_usec / 1e6 * FRAC））/*
 * Arithmetic conversions
 */
#define LOG2D(a)        ((a) < 0 ? 1. / (1L << -(a)) : \
                            1L << (a))          /* poll, etc. */
#define SQUARE(x)       (x * x)
#define SQRT(x)         (sqrt(x))/* * 算术转换 */ #define LOG2D（a） （（a） < 0 ？1. / （1L << -（a）） ： \ 1L << （a）） /* 轮询等 */ #define SQUARE（x） （x * x） #define SQRT（x） （sqrt（x））/*
 * Global constants.  Some of these might be converted to variables
 * that can be tinkered by configuration or computed on-the-fly.  For
 * instance, the reference implementation computes PRECISION on-the-fly
 * and provides performance tuning for the defines marked with % below.
 */
#define VERSION         4       /* version number */
#define MINDISP         .01     /* % minimum dispersion (s) *//* * 全局常量。其中一些可能会转换为变量 *，这些变量可以通过配置进行修改或动态计算。例如，参考实现动态计算 PRECISION *，并为下面标有 % 的定义提供性能调整。*/ #define 版本 4 /* 版本号 */ #define MINDISP .01 /* 最小色散百分比 （s） */Mills, et al.                Standards Track                   [Page 62]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 62 页] RFC 5905 NTPv4 规范 2010 年 6 月
#define MAXDISP         16      /* maximum dispersion (s) */
#define MAXDIST         1       /* % distance threshold (s) */
#define NOSYNC          0x3     /* leap unsync */
#define MAXSTRAT        16      /* maximum stratum (infinity metric) */
#define MINPOLL         6       /* % minimum poll interval (64 s)*/
#define MAXPOLL         17      /* % maximum poll interval (36.4 h) */
#define MINCLOCK        3       /* minimum manycast survivors */
#define MAXCLOCK        10      /* maximum manycast candidates */
#define TTLMAX          8       /* max ttl manycast */
#define BEACON          15      /* max interval between beacons */#define MAXDISP 16 /* 最大色散 （s） */ #define MAXDIST 1 /* % 距离阈值 （s） */ #define NOSYNC 0x3 /* 跳跃不同步 */ #define MAXSTRAT 16 /* 最大层（无穷大公制） */ #define MINPOLL 6 /* % 最小轮询间隔 （64 s）*/ #define MAXPOLL 17 /* % 最大轮询间隔 （36.4 小时） */ #define MINCLOCK 3 /* 最小 manycast 幸存者 */ #define MAXCLOCK 10 /* 最大 manycast 候选者 */ #define TTLMAX 8 /* 最大 ttl manycast */ #define BEACON 15 /* 最大间隔灯塔*/#define PHI             15e-6   /* % frequency tolerance (15 ppm) */
#define NSTAGE          8       /* clock register stages */
#define NMAX            50      /* maximum number of peers */
#define NSANE           1       /* % minimum intersection survivors */
#define NMIN            3       /* % minimum cluster survivors */#define PHI 15e-6 /* % 频率容差 （15 ppm） */ #define NSTAGE 8 /* 时钟寄存器级 */ #define NMAX 50 /* 最大对等体数 */ #define NSANE 1 /* % 最小交叉幸存者 */ #define NMIN 3 /* % 最小集群幸存者 *//*
 * Global return values
 */
#define TRUE            1       /* boolean true */
#define FALSE           0       /* boolean false *//* * 全局返回值 */ #define TRUE 1 /* 布尔值 true */ #define FALSE 0 /* 布尔值 false *//*
 * Local clock process return codes
 */
#define IGNORE          0       /* ignore */
#define SLEW            1       /* slew adjustment */
#define STEP            2       /* step adjustment */
#define PANIC           3       /* panic - no adjustment *//* * 本地时钟进程返回码 */ #define IGNORE 0 /* 忽略 */ #define 回摆率 1 /* 回转调整 */ #define 步骤 2 /* 步进调整 */ #define PANIC 3 /* PANIC - 无调整 *//*
 * System flags
 */
#define S_FLAGS         0       /* any system flags */
#define S_BCSTENAB      0x1     /* enable broadcast client *//* * 系统标志 */ #define S_FLAGS 0 /* 任何系统标志 */ #define S_BCSTENAB 0x1 /* 启用广播客户端 *//*
 * Peer flags
 */
#define P_FLAGS         0       /* any peer flags */
#define P_EPHEM         0x01    /* association is ephemeral */
#define P_BURST         0x02    /* burst enable */
#define P_IBURST        0x04    /* intial burst enable */
#define P_NOTRUST       0x08    /* authenticated access */
#define P_NOPEER        0x10    /* authenticated mobilization */
#define P_MANY          0x20    /* manycast client *//* * 对等标志 */ #define P_FLAGS 0 /* 任何对等标志 */ #define P_EPHEM 0x01 /* 关联是短暂的 */ #define P_BURST 0x02 /* 突发启用 */ #define P_IBURST 0x04 /* 初始突发启用 */ #define P_NOTRUST 0x08 /* 经过身份验证的访问 */ #define P_NOPEER 0x10 /* 经过身份验证的移动 */ #define P_MANY 0x20 /* manycast 客户端 */
Mills, et al.                Standards Track                   [Page 63]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 63 页] RFC 5905 NTPv4 规范 2010 年 6 月
/*
 * Authentication codes
 */
#define A_NONE          0       /* no authentication */
#define A_OK            1       /* authentication OK */
#define A_ERROR         2       /* authentication error */
#define A_CRYPTO        3       /* crypto-NAK *//* * 验证码 */ #define A_NONE 0 /* 无验证 */ #define A_OK 1 /* 验证正常 */ #define A_ERROR 2 /* 验证错误 */ #define A_CRYPTO 3 /* crypto-NAK *//*
 * Association state codes
 */
#define X_INIT          0       /* initialization */
#define X_STALE         1       /* timeout */
#define X_STEP          2       /* time step */
#define X_ERROR         3       /* authentication error */
#define X_CRYPTO        4       /* crypto-NAK received */
#define X_NKEY          5       /* untrusted key *//* * 关联状态代码 */ #define X_INIT 0 /* 初始化 */ #define X_STALE 1 /* 超时 */ #define X_STEP 2 /* 时间步长 */ #define X_ERROR 3 /* 身份验证错误 */ #define X_CRYPTO 4 /* 收到 crypto-NAK */ #define X_NKEY 5 /* 不受信任的密钥 *//*
 * Protocol mode definitions
 */
#define M_RSVD          0       /* reserved */
#define M_SACT          1       /* symmetric active */
#define M_PASV          2       /* symmetric passive */
#define M_CLNT          3       /* client */
#define M_SERV          4       /* server */
#define M_BCST          5       /* broadcast server */
#define M_BCLN          6       /* broadcast client *//* * 协议模式定义 */ #define M_RSVD 0 /* 保留 */ #define M_SACT 1 /* 对称主动 */ #define M_PASV 2 /* 对称被动 */ #define M_CLNT 3 /* 客户端 */ #define M_SERV 4 /* 服务器 */ #define M_BCST 5 /* 广播服务器 */ #define M_BCLN 6 /* 广播客户端 *//*
 * Clock state definitions
 */
#define NSET            0       /* clock never set */
#define FSET            1       /* frequency set from file */
#define SPIK            2       /* spike detected */
#define FREQ            3       /* frequency mode */
#define SYNC            4       /* clock synchronized *//* * 时钟状态定义 */ #define NSET 0 /* 时钟从不设置 */ #define FSET 1 /* 从文件设置频率 */ #define SPIK 2 /* 检测到尖峰 */ #define FREQ 3 /* 频率模式 */ #define SYNC 4 /* 时钟同步 */#define min(a, b)   ((a) < (b) ? (a) : (b))
#define max(a, b)   ((a) < (b) ? (b) : (a))#define 分钟（a， b） （a） < （b） ？（a） ： （b）） #define max（a， b） （a） < （b） ？（二）：（一））Mills, et al.                Standards Track                   [Page 64]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 64 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.1.2.  Packet Data StructuresA.1.2. 数据包数据结构/*
 * The receive and transmit packets may contain an optional message
 * authentication code (MAC) consisting of a key identifier (keyid) and
 * message digest (mac in the receive structure and dgst in the transmit
 * structure).  NTPv4 supports optional extension fields that
 * are inserted after the header and before the MAC, but these are
 * not described here.
 *
 * Receive packet
 *
 * Note the dst timestamp is not part of the packet itself.  It is
 * captured upon arrival and returned in the receive buffer along with
 * the buffer length and data.  Note that some of the char fields are
 * packed in the actual header, but the details are omitted here.
 */
struct r {
        ipaddr  srcaddr;        /* source (remote) address */
        ipaddr  dstaddr;        /* destination (local) address */
        char    version;        /* version number */
        char    leap;           /* leap indicator */
        char    mode;           /* mode */
        char    stratum;        /* stratum */
        char    poll;           /* poll interval */
        s_char  precision;      /* precision */
        tdist   rootdelay;      /* root delay */
        tdist   rootdisp;       /* root dispersion */
        char    refid;          /* reference ID */
        tstamp  reftime;        /* reference time */
        tstamp  org;            /* origin timestamp */
        tstamp  rec;            /* receive timestamp */
        tstamp  xmt;            /* transmit timestamp */
        int     keyid;          /* key ID */
        digest  mac;            /* message digest */
        tstamp  dst;            /* destination timestamp */
} r;/* * 接收和发送数据包可能包含可选的消息 * 身份验证代码 （MAC），该代码由密钥标识符 （keyid） 和 * 消息摘要（接收结构中的 mac 和传输 * 结构中的 dgst）组成。NTPv4 支持在标头之后和 MAC 之前插入 * 的可选扩展字段，但此处未介绍这些字段。* * 接收数据包 * * 请注意，dst 时间戳不是数据包本身的一部分。它在到达时被捕获，并与 * 缓冲区长度和数据一起返回到接收缓冲区中。请注意，某些 char 字段已 * 包含在实际标题中，但此处省略了详细信息。*/ struct r { ipaddr srcaddr; /* 源（远程）地址 */ ipaddr dstaddr; /* 目标（本地）地址 */ char 版本; /* 版本号 */ char leap; /* 闰指示器 */ char 模式; /* 模式 */ char stratum; /* stratum */ char 轮询; /* 轮询间隔 */ s_char精度; /* 精度 */ tdist rootdelay; /* 根延迟 */ tdist rootdisp; /* 根分散 */ char refid; /* 引用 ID */ tstamp reftime; /* 参考时间 */ tstamp org; /* 源时间戳 */ tstamp rec; /* 接收时间戳*/ tstamp xmt;/* 发送时间戳 */ int keyid;/* 密钥 ID */ 摘要 mac;/* 消息摘要 */ tstamp dst;/* 目标时间戳 */ } r;/*
 * Transmit packet
 */
struct x {
        ipaddr  dstaddr;        /* source (local) address */
        ipaddr  srcaddr;        /* destination (remote) address */
        char    version;        /* version number */
        char    leap;           /* leap indicator */
        char    mode;           /* mode */
        char    stratum;        /* stratum *//* * 传输数据包 */ struct x { ipaddr dstaddr; /* 源（本地）地址 */ ipaddr srcaddr; /* 目标（远程）地址 */ char 版本; /* 版本号 */ char leap; /* 闰码指示器 */ char 模式; /* 模式 */ char stratum; /* stratum */Mills, et al.                Standards Track                   [Page 65]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 65 页] RFC 5905 NTPv4 规范 2010 年 6 月
        char    poll;           /* poll interval */
        s_char  precision;      /* precision */
        tdist   rootdelay;      /* root delay */
        tdist   rootdisp;       /* root dispersion */
        char    refid;          /* reference ID */
        tstamp  reftime;        /* reference time */
        tstamp  org;            /* origin timestamp */
        tstamp  rec;            /* receive timestamp */
        tstamp  xmt;            /* transmit timestamp */
        int     keyid;          /* key ID */
        digest  dgst;           /* message digest */
} x;字符民意调查;/* 轮询间隔 */ s_char精度;/* 精度 */ tdist rootdelay;/* 根延迟 */ tdist rootdisp;/* 根分散 */ char refid;/* 引用 ID */ tstamp reftime;/* 参考时间 */ tstamp org;/* 原点时间戳 */ tstamp rec;/* 接收时间戳 */ tstamp xmt;/* 发送时间戳 */ int keyid;/* 密钥 ID */ 摘要 dgst;/* 消息摘要 */ } x;A.1.3.  Association Data StructuresA.1.3. 关联数据结构   /*
    * Filter stage structure.  Note the t member in this and other
    * structures refers to process time, not real time.  Process time
    * increments by one second for every elapsed second of real time.
    */
   struct f {
           tstamp  t;              /* update time */
           double  offset;         /* clock ofset */
           double  delay;          /* roundtrip delay */
           double  disp;           /* dispersion */
   } f;/* * 滤波器阶段结构。请注意，此结构和其他 * 结构中的 t 成员是指处理时间，而不是实时。处理时间 * 实时每经过一秒，就会增加一秒。*/ struct f { tstamp t; /* 更新时间 */ 双偏移量; /* 时钟设置 */ 双倍延迟; /* 往返延迟 */ 双离散; /* 色散 */ } f;   /*
    * Association structure.  This is shared between the peer process
    * and poll process.
    */
   struct p {/* * 关联结构。这在对等进程 * 和轮询进程之间共享。*/ 结构 p {           /*
            * Variables set by configuration
            */
           ipaddr  srcaddr;        /* source (remote) address */
           ipaddr  dstaddr;        /* destination (local) address */
           char    version;        /* version number */
           char    hmode;          /* host mode */
           int     keyid;          /* key identifier */
           int     flags;          /* option flags *//* * 配置设置的变量 */ ipaddr srcaddr;/* 源（远程）地址 */ ipaddr dstaddr;/* 目标（本地）地址 */ char 版本;/* 版本号 */ char hmode;/* 主机模式 */ int keyid;/* 密钥标识符 */ int 标志;/* 选项标志 */           /*
            * Variables set by received packet
            */
           char    leap;           /* leap indicator */
           char    pmode;          /* peer mode *//* * 接收数据包设置的变量 */ char leap;/* 闰跃指示器 */ char pmode;/* 对等模式 */Mills, et al.                Standards Track                   [Page 66]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 66 页] RFC 5905 NTPv4 规范 2010 年 6 月
           char    stratum;        /* stratum */
           char    ppoll;          /* peer poll interval */
           double  rootdelay;      /* root delay */
           double  rootdisp;       /* root dispersion */
           char    refid;          /* reference ID */
           tstamp  reftime;        /* reference time */
   #define begin_clear org         /* beginning of clear area */
           tstamp  org;            /* originate timestamp */
           tstamp  rec;            /* receive timestamp */
           tstamp  xmt;            /* transmit timestamp */炭层;/* 地层 */ char ppoll;/* 对等轮询间隔 */ double rootdelay;/* 根延迟 */ double rootdisp;/* 根分散 */ char refid;/* 引用 ID */ tstamp reftime;/* 参考时间 */ #define begin_clear org /* 清除区域的起点 */ tstamp org;/* 发起时间戳 */ tstamp rec;/* 接收时间戳 */ tstamp xmt;/* 传输时间戳 */           /*
            * Computed data
            */
           double  t;              /* update time */
           struct f f[NSTAGE];     /* clock filter */
           double  offset;         /* peer offset */
           double  delay;          /* peer delay */
           double  disp;           /* peer dispersion */
           double  jitter;         /* RMS jitter *//* * 计算数据 */ double t;/* 更新时间 */ struct f f[NSTAGE];/* 时钟滤波器 */ 双偏移;/* 对等偏移 */ 双延迟;/* 对等延迟 */ double disp;/* 对等色散 */ 双抖动;/* RMS 抖动 */           /*
            * Poll process variables
            */
           char    hpoll;          /* host poll interval */
           int     burst;          /* burst counter */
           int     reach;          /* reach register */
           int     ttl;            /* ttl (manycast) */
   #define end_clear unreach       /* end of clear area */
           int     unreach;        /* unreach counter */
           int     outdate;        /* last poll time */
           int     nextdate;       /* next poll time */
   } p;/* * 轮询过程变量 */ char hpoll;/* 主机轮询间隔 */ int 突发;/* 突发计数器 */ int reach;/* 到达寄存器 */ int ttl;/* ttl （manycast） */ #define end_clear unreach /* 清除区域结束 */ int unreach;/* unreach 计数器 */ int outdate;/* 上次轮询时间 */ int nextdate;/* 下一次轮询时间 */ } p;
Mills, et al.                Standards Track                   [Page 67]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 67 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.1.4.  System Data StructuresA.1.4. 系统数据结构   /*
    * Chime list.  This is used by the intersection algorithm.
    */
   struct m {                      /* m is for Marzullo */
           struct p *p;            /* peer structure pointer */
           int     type;           /* high +1, mid 0, low -1 */
           double  edge;           /* correctness interval edge */
   } m;/* * 钟声列表。这由交集算法使用。*/ struct m { /* m 表示 Marzullo */ struct p *p; /* 对等结构指针 */ int type; /* 高 +1，中 0，低 -1 */ 双边; /* 正确性区间边 */ } m;   /*
    * Survivor list.  This is used by the clustering algorithm.
    */
   struct v {
           struct p *p;            /* peer structure pointer */
           double  metric;         /* sort metric */
   } v;/* * 幸存者列表。这由聚类算法使用。*/ struct v { struct p *p; /* 对等结构指针 */ double metric; /* 排序指标 */ } v;   /*
    * System structure
    */
   struct s {
           tstamp  t;              /* update time */
           char    leap;           /* leap indicator */
           char    stratum;        /* stratum */
           char    poll;           /* poll interval */
           char    precision;      /* precision */
           double  rootdelay;      /* root delay */
           double  rootdisp;       /* root dispersion */
           char    refid;          /* reference ID */
           tstamp  reftime;        /* reference time */
           struct m m[NMAX];       /* chime list */
           struct v v[NMAX];       /* survivor list */
           struct p *p;            /* association ID */
           double  offset;         /* combined offset */
           double  jitter;         /* combined jitter */
           int     flags;          /* option flags */
           int     n;              /* number of survivors */
   } s;/* * 系统结构 */ struct s { tstamp t; /* 更新时间 */ char leap; /* 闰指标 */ char stratum; /* stratum */ char 轮询; /* 轮询间隔 */ char 精度; /* 精度 */ double rootdelay; /* 根延迟 */ double rootdisp; /* 根分散 */ char refid; /* 引用 ID */ tstamp reftime; /* 参考时间 */ struct m m[NMAX]; /* 铃声列表 */ struct v v[NMAX]; /* 幸存者列表 */ struct p *p; /* 关联 ID */ 双偏移量; /* 组合偏移量 */ 双抖动; /* 组合抖动 */ int 标志;/* 选项标志 */ int n;/* 幸存者人数 */ } s;Mills, et al.                Standards Track                   [Page 68]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 68 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.1.5.  Local Clock Data StructuresA.1.5. 本地时钟数据结构   /*
    * Local clock structure
    */
   struct c {
           tstamp  t;              /* update time */
           int     state;          /* current state */
           double  offset;         /* current offset */
           double  last;           /* previous offset */
           int     count;          /* jiggle counter */
           double  freq;           /* frequency */
           double  jitter;         /* RMS jitter */
           double  wander;         /* RMS wander */
   } c;/* * 本地时钟结构 */ struct c { tstamp t; /* 更新时间 */ int 状态; /* 当前状态 */ 双偏移; /* 电流偏移 */ double last; /* 前一个偏移量 */ int count; /* 抖动计数器 */ 双频; /* 频率 */ 双抖动; /* RMS 抖动 */ 双漂移; /* RMS 漂移 */ } c;A.1.6.  Function PrototypesA.1.6. 函数原型  /*
   * Peer process
   */
  void    receive(struct r *);    /* receive packet */
  void    packet(struct p *, struct r *); /* process packet */
  void    clock_filter(struct p *, double, double, double); /* filter */
  double  root_dist(struct p *);  /* calculate root distance */
  int     fit(struct p *);        /* determine fitness of server */
  void    clear(struct p *, int); /* clear association */
  int     access(struct r *);     /* determine access restrictions *//* * 对等进程 */ void receive（struct r *）;/* 接收数据包 */ void packet（struct p *， struct r *）;/* 进程报文 */ void clock_filter（struct p *， double， double， double）;/* 过滤器 */ double root_dist（struct p *）;/* 计算根距离 */ int fit（struct p *）;/* 确定服务器的适用性 */ void clear（struct p *， int）;/* 清除关联 */ int access（struct r *）;/* 确定访问限制 */  /*
   * System process
   */
  int     main();                 /* main program */
  void    clock_select();         /* find the best clocks */
  void    clock_update(struct p *); /* update the system clock */
  void    clock_combine();        /* combine the offsets *//* * 系统进程 */ int main（）;/* 主程序 */ void clock_select（）;/* 找到最好的时钟 */ void clock_update（struct p *）;/* 更新系统时钟 */ void clock_combine（）;/* 合并偏移量 */  /*
   * Local clock process
   */
  int     local_clock(struct p *, double); /* clock discipline */
  void    rstclock(int, double, double); /* clock state transition *//* * 本地时钟进程 */ int local_clock（struct p *， double）;/* 时钟纪律 */ void rstclock（int， double， double）;/* 时钟状态转换 */  /*
   * Clock adjust process
   */
  void    clock_adjust();         /* one-second timer process *//* * 时钟调整过程 */ void clock_adjust（）;/* 一秒定时器进程 */
Mills, et al.                Standards Track                   [Page 69]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 69 页] RFC 5905 NTPv4 规范 2010 年 6 月
  /*
   * Poll process
   */
  void    poll(struct p *);               /* poll process */
  void    poll_update(struct p *, int); /* update the poll interval */
  void    peer_xmit(struct p *);  /* transmit a packet */
  void    fast_xmit(struct r *, int, int); /* transmit a reply packet *//* * 轮询过程 */ void poll（struct p *）;/* 轮询过程 */ void poll_update（struct p *， int）;/* 更新轮询间隔 */ void peer_xmit（struct p *）;/* 传输数据包 */ void fast_xmit（struct r *， int， int）;/* 发送回复数据包 */  /*
   * Utility routines
   */
  digest  md5(int);               /* generate a message digest */
  struct p *mobilize(ipaddr, ipaddr, int, int, int, int); /* mobilize */
  struct p *find_assoc(struct r *); /* search the association table *//* * 实用程序例程 */ digest md5（int）;/* 生成消息摘要 */ struct p *mobilize（ipaddr， ipaddr， int， int， int， int）;/* 动员 */ struct p *find_assoc（struct r *）;/* 搜索关联表 */  /*
   * Kernel interface
   */
  struct r *recv_packet();        /* wait for packet */
  void    xmit_packet(struct x *); /* send packet */
  void    step_time(double);      /* step time */
  void    adjust_time(double);    /* adjust (slew) time */
  tstamp  get_time();             /* read time *//* * 内核接口 */ struct r *recv_packet（）;/* 等待数据包 */ void xmit_packet（struct x *）;/* 发送数据包 */ void step_time（double）;/* 步进时间 */ void adjust_time（double）;/* 调整（摆率）时间 */ tstamp get_time（）;/* 读取时间 */A.2.  Main Program and Utility RoutinesA.2. 主程序和实用程序例程/*
 * Definitions
 */
#define PRECISION       -18     /* precision (log2 s)  */
#define IPADDR          0       /* any IP address */
#define MODE            0       /* any NTP mode */
#define KEYID           0       /* any key identifier *//* * 定义 */ #define PRECISION -18 /* 精度 （log2 s） */ #define IPADDR 0 /* 任何 IP 地址 */ #define MODE 0 /* 任何 NTP 模式 */ #define KEYID 0 /* 任何密钥标识符 *//*
 * main() - main program
 */
int
main()
{
        struct p *p;            /* peer structure pointer */
        struct r *r;            /* receive packet pointer *//* * main（） - 主程序 */ int main（） { struct p *p; /* 对等结构指针 */ struct r *r; /* 接收数据包指针 */Mills, et al.                Standards Track                   [Page 70]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 70 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * Read command line options and initialize system variables.
         * The reference implementation measures the precision specific
         * to each machine by measuring the clock increments to read the
         * system clock.
         */
        memset(&s, sizeof(s), 0);
        s.leap = NOSYNC;
        s.stratum = MAXSTRAT;
        s.poll = MINPOLL;
        s.precision = PRECISION;
        s.p = NULL;/* * 读取命令行选项并初始化系统变量。* 参考实现通过测量时钟增量来读取 * 系统时钟，从而测量每台机器的特定精度 *。*/ memset（&s， sizeof（s）， 0）;s.leap = 不同步;s.stratum = MAXSTRAT;s.poll = MINPOLL;s.precision = 精度;s.p = 空;        /*
         * Initialize local clock variables
         */
        memset(&c, sizeof(c), 0);
        if (/* frequency file */ 0) {
                c.freq = /* freq */ 0;
                rstclock(FSET, 0, 0);
        } else {
                rstclock(NSET, 0, 0);
        }
        c.jitter = LOG2D(s.precision);/* * 初始化本地时钟变量 */ memset（&c， sizeof（c）， 0）;if （/* 频率文件 */ 0） { c.freq = /* 频率 */ 0; rstclock（FSET， 0， 0）; } else { rstclock（NSET， 0， 0）; } c.jitter = LOG2D（s.precision）;        /*
         * Read the configuration file and mobilize persistent
         * associations with specified addresses, version, mode, key ID,
         * and flags.
         */
        while (/* mobilize configurated associations */ 0) {
                p = mobilize(IPADDR, IPADDR, VERSION, MODE, KEYID,
                    P_FLAGS);
        }/* * 读取配置文件并动员具有指定地址、版本、模式、密钥 ID、* 和标志的持久 * 关联。*/ while （/* 动员配置的关联 */ 0） { p = mobilize（IPADDR， IPADDR， VERSION， MODE， KEYID， P_FLAGS）;        /*
         * Start the system timer, which ticks once per second.  Then,
         * read packets as they arrive, strike receive timestamp, and
         * call the receive() routine.
         */
        while (0) {
                r = recv_packet();
                r->dst = get_time();
                receive(r);
        }/* * 启动系统计时器，每秒滴答一次。然后，* 在数据包到达时读取数据包，strike receive timestamp，并 * 调用 receive（） 例程。*/ while （0） { r = recv_packet（）; r->dst = get_time（）; receive（r）; }        return(0);
} 返回（0）;}Mills, et al.                Standards Track                   [Page 71]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 71 页] RFC 5905 NTPv4 规范 2010 年 6 月
/*
 * mobilize() - mobilize and initialize an association
 */
struct p
*mobilize(
        ipaddr  srcaddr,        /* IP source address */
        ipaddr  dstaddr,        /* IP destination address */
        int     version,        /* version */
        int     mode,           /* host mode */
        int     keyid,          /* key identifier */
        int     flags           /* peer flags */
        )
{
        struct p *p;            /* peer process pointer *//* * mobilize（） - 动员并初始化关联 */ struct p *mobilize（ ipaddr srcaddr， /* IP 源地址 */ ipaddr dstaddr， /* IP 目标地址 */ int version， /* 版本 */ int 模式， /* 主机模式 */ int keyid， /* 密钥标识符 */ int flags /* 对等标志 */ ） { struct p *p; /* 对等进程指针 */        /*
         * Allocate and initialize association memory
         */
        p = malloc(sizeof(struct p));
        p->srcaddr = srcaddr;
        p->dstaddr = dstaddr;
        p->version = version;
        p->hmode = mode;
        p->keyid = keyid;
        p->hpoll = MINPOLL;
        clear(p, X_INIT);
        p->flags = flags;
        return (p);
}/* * 分配并初始化关联内存 */ p = malloc（sizeof（struct p））;p->srcaddr = srcaddr;p->dstaddr = dstaddr;p->version = 版本;p->hmode = 模式;p->keyid = 密钥 ID;p->hpoll = MINPOLL;清除（p，X_INIT）;p->flags = 标志;返回 （p）;}/*
 * find_assoc() - find a matching association
 */
struct p                        /* peer structure pointer or NULL */
*find_assoc(
        struct r *r             /* receive packet pointer */
        )
{
        struct p *p;            /* dummy peer structure pointer *//* * find_assoc（） - 查找匹配关联 */ struct p /* 对等结构指针或 NULL */ *find_assoc（ struct r *r /* 接收数据包指针 */ ） { struct p *p; /* 虚拟对等结构指针 */        /*
         * Search association table for matching source
         * address, source port and mode.
         */
        while (/* all associations */ 0) {
                if (r->srcaddr == p->srcaddr && r->mode == p->hmode)
                        return(p);
        }/* * 搜索关联表以匹配源 * 地址、源端口和模式。*/ while （/* 所有关联 */ 0） { if （r->srcaddr == p->srcaddr && r->mode == p->hmode） return（p）;Mills, et al.                Standards Track                   [Page 72]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 72 页] RFC 5905 NTPv4 规范 2010 年 6 月
        return (NULL);
} 返回 （NULL）;}/*
 * md5() - compute message digest
 */
digest
md5(
       int     keyid           /* key identifier */
       )
{
       /*
        * Compute a keyed cryptographic message digest.  The key
        * identifier is associated with a key in the local key cache.
        * The key is prepended to the packet header and extension fields
        * and the result hashed by the MD5 algorithm as described in
        * RFC 1321.  Return a MAC consisting of the 32-bit key ID
        * concatenated with the 128-bit digest.
        */
       return (/* MD5 digest */ 0);
}/* * md5（） - 计算消息摘要 */ 摘要 md5（ int keyid /* 密钥标识符 */ ） { /* * 计算密钥加密消息摘要。密钥 * 标识符与本地密钥缓存中的密钥相关联。* 密钥附加到数据包标头和扩展字段 * 以及由 MD5 算法哈希处理的结果，如 * RFC 1321 中所述。返回由 32 位密钥 ID * 和 128 位摘要连接的 MAC。*/ 返回 （/* MD5 摘要 */ 0）;}A.3.  Kernel Input/Output InterfaceA.3. 内核输入/输出接口   /*
    * Kernel interface to transmit and receive packets.  Details are
    * deliberately vague and depend on the operating system.
    *
    * recv_packet - receive packet from network
    */
   struct r                        /* receive packet pointer*/
   *recv_packet() {
           return (/* receive packet r */ 0);
   }/* * 用于发送和接收数据包的内核接口。细节是*故意含糊不清的，取决于操作系统。* * recv_packet - 从网络接收数据包 */ struct r /* 接收数据包指针*/ *recv_packet（） { return （/* 接收数据包 r */ 0）;
   /*
    * xmit_packet - transmit packet to network
    */
   void
   xmit_packet(
           struct x *x             /* transmit packet pointer */
           )
   {
           /* send packet x */
   }/* * xmit_packet - 向网络发送数据包 */ void xmit_packet（ struct x *x /* 传输数据包指针 */ ） { /* 发送数据包 x */ }Mills, et al.                Standards Track                   [Page 73]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 73 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.4.  Kernel System Clock InterfaceA.4. 内核系统时钟接口/*
 * System clock utility functions
 *
 * There are three time formats: native (Unix), NTP, and floating
 * double.  The get_time() routine returns the time in NTP long format.
 * The Unix routines expect arguments as a structure of two signed
 * 32-bit words in seconds and microseconds (timeval) or nanoseconds
 * (timespec).  The step_time() and adjust_time() routines expect signed
 * arguments in floating double.  The simplified code shown here is for
 * illustration only and has not been verified.
 */
#define JAN_1970        2208988800UL /* 1970 - 1900 in seconds *//* * 系统时钟实用程序函数 * * 有三种时间格式：本机 （Unix）、NTP 和浮动 * double。get_time（） 例程以 NTP 长格式返回时间。* Unix 例程要求参数为两个有符号的 * 32 位字的结构，单位为秒和微秒 （timeval） 或纳秒 * （timespec）。step_time（） 和 adjust_time（） 例程需要浮动双精度的带符号 * 参数。此处显示的简化代码仅用于 * 插图，尚未经过验证。*/ #define JAN_1970 2208988800UL /* 1970 - 1900 秒 *//*
 * get_time - read system time and convert to NTP format
 */
tstamp
get_time()
{
        struct timeval unix_time;/* * get_time - 读取系统时间并转换为 NTP 格式 */ tstamp get_time（） { struct timeval unix_time;        /*
         * There are only two calls on this routine in the program.  One
         * when a packet arrives from the network and the other when a
         * packet is placed on the send queue.  Call the kernel time of
         * day routine (such as gettimeofday()) and convert to NTP
         * format.
         */
        gettimeofday(&unix_time, NULL);
        return (U2LFP(unix_time));
}/* * 程序中只有两个关于此例程的调用。一个 * 当数据包从网络到达时，另一个 * 当 * 数据包放置在发送队列上时。调用 * day 例程的内核时间（如 gettimeofday（））并转换为 NTP * 格式。*/ gettimeofday（&unix_time， 空）;返回 （U2LFP（unix_time））;}
Mills, et al.                Standards Track                   [Page 74]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 74 页] RFC 5905 NTPv4 规范 2010 年 6 月
/*
 * step_time() - step system time to given offset value
 */
void
step_time(
        double  offset          /* clock offset */
        )
{
        struct timeval unix_time;
        tstamp  ntp_time;/* * step_time（） - 给定偏移值的步进系统时间 */ void step_time（ double offset /* 时钟偏移量 */ ） { struct timeval unix_time; tstamp ntp_time;        /*
         * Convert from double to native format (signed) and add to the
         * current time.  Note the addition is done in native format to
         * avoid overflow or loss of precision.
         */
        gettimeofday(&unix_time, NULL);
        ntp_time = D2LFP(offset) + U2LFP(unix_time);
        unix_time.tv_sec = ntp_time >> 32;
        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec) <<
            32) / FRAC * 1e6);
        settimeofday(&unix_time, NULL);
}/* * 从双精度格式转换为本机格式（签名）并添加到 * 当前时间。请注意，添加是以本机格式完成的，以避免溢出或精度损失。*/ gettimeofday（&unix_time， 空）;ntp_time = D2LFP（偏移） + U2LFP（unix_time）;unix_time.tv_sec = ntp_time >> 32;unix_time.tv_usec = （long）（（（ntp_time - unix_time.tv_sec） << 32） / FRAC * 1e6）;settimeofday（&unix_time， NULL）;}
/*
 * adjust_time() - slew system clock to given offset value
 */
void
adjust_time(
        double  offset          /* clock offset */
        )
{
        struct timeval unix_time;
        tstamp  ntp_time;/* * adjust_time（） - 将系统时钟压摆到给定偏移值 */ void adjust_time（ double offset /* 时钟偏移量 */ ） { struct timeval unix_time; tstamp ntp_time;        /*
         * Convert from double to native format (signed) and add to the
         * current time.
         */
        ntp_time = D2LFP(offset);
        unix_time.tv_sec = ntp_time >> 32;
        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec) <<
            32) / FRAC * 1e6);
        adjtime(&unix_time, NULL);
}/* * 从双精度格式转换为本机格式（签名）并添加到 * 当前时间。*/ ntp_time = D2LFP（偏移）;unix_time.tv_sec = ntp_time >> 32;unix_time.tv_usec = （long）（（（ntp_time - unix_time.tv_sec） << 32） / FRAC * 1e6）;adjtime（&unix_time， 空）;}Mills, et al.                Standards Track                   [Page 75]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 75 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.5.  Peer Process A.5. 对等流程   /*
    * A crypto-NAK packet includes the NTP header followed by a MAC
    * consisting only of the key identifier with value zero.  It tells
    * the receiver that a prior request could not be properly
    * authenticated, but the NTP header fields are correct.
    *
    * A kiss-o'-death packet is an NTP header with leap 0x3 (NOSYNC) and
    * stratum 16 (MAXSTRAT).  It tells the receiver that something
    * drastic has happened, as revealed by the kiss code in the refid
    * field.  The NTP header fields may or may not be correct.
    */
   /*
    * Peer process parameters and constants
    */
   #define SGATE           3       /* spike gate (clock filter */
   #define BDELAY          .004    /* broadcast delay (s) *//* * 加密 NAK 数据包包括 NTP 报头，后跟仅由值为零的密钥标识符组成的 MAC *。它告诉 * 接收方先前的请求无法正确 * 身份验证，但 NTP 标头字段是正确的。* * kiss-o'-death 数据包是具有闰 0x3 （NOSYNC） 和 * 层 16 （MAXSTRAT） 的 NTP 报头。它告诉接收者发生了一些 * 剧烈的事情，正如 refid * 字段中的吻代码所揭示的那样。NTP 标头字段可能正确，也可能不正确。*/ /* * 对等过程参数和常量 */ #define SGATE 3 /* 尖峰门（时钟滤波器 */ #define BDELAY .004 /* 广播延迟 （s） */   /*
    * Dispatch codes
    */
   #define ERR             -1      /* error */
   #define DSCRD           0       /* discard packet */
   #define PROC            1       /* process packet */
   #define BCST            2       /* broadcast packet */
   #define FXMIT           3       /* client packet */
   #define MANY            4       /* manycast packet */
   #define NEWPS           5       /* new symmetric passive client */
   #define NEWBC           6       /* new broadcast client *//* * 调度代码 */ #define ERR -1 /* 错误 */ #define DSCRD 0 /* 丢弃数据包 */ #define PROC 1 /* 进程数据包 */ #define BCST 2 /* 广播数据包 */ #define FXMIT 3 /* 客户端数据包 */ #define MANY 4 /* manycast 数据包 */ #define NEWPS 5 /* 新对称无源客户端 */ #define NEWBC 6 /* 新广播客户端 */   /*
    * Dispatch matrix
    *              active  passv  client server bcast */
   int table[7][5] = {
   /* nopeer  */   { NEWPS, DSCRD, FXMIT, MANY, NEWBC },
   /* active  */   { PROC,  PROC,  DSCRD, DSCRD, DSCRD },
   /* passv   */   { PROC,  ERR,   DSCRD, DSCRD, DSCRD },
   /* client  */   { DSCRD, DSCRD, DSCRD, PROC,  DSCRD },
   /* server  */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD },
   /* bcast   */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD },
   /* bclient */   { DSCRD, DSCRD, DSCRD, DSCRD, PROC}
   };/* * 调度矩阵 * active passv client server bcast */ int table[7][5] = { /* nopeer */ { NEWPS， DSCRD， FXMIT， MANY， NEWBC }， /* active */ { PROC， PROC， DSCRD， DSCRD， DSCRD }， /* passv */ { PROC， ERR， DSCRD， DSCRD， DSCRD }， /* 客户端 */ { DSCRD， DSCRD， DSCRD， PROC， DSCRD }， /* 服务器 */ { DSCRD， DSCRD， DSCRD， DSCRD， DSCRD }， /* bcast */ { DSCRD， DSCRD， DSCRD， DSCRD， DSCRD }， /* bclient */ { DSCRD， DSCRD， DSCRD， DSCRD， DSCRD， PROC} };
Mills, et al.                Standards Track                   [Page 76]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 76 页] RFC 5905 NTPv4 规范 2010 年 6 月
   /*
    * Miscellaneous macroni
    *
    * This macro defines the authentication state.  If x is 0,
    * authentication is optional; otherwise, it is required.
    */
   #define AUTH(x, y)      ((x) ? (y) == A_OK : (y) == A_OK || \
                               (y) == A_NONE)/* * 其他宏 * * 此宏定义身份验证状态。如果 x 为 0，则 * 身份验证是可选的;否则，它是必需的。*/ #define AUTH（x， y） （（x） ？（y） == A_OK ： （y） == A_OK ||\ （y） == A_NONE）   /*
    * These are used by the clear() routine
    */
   #define BEGIN_CLEAR(p)  ((char *)&((p)->begin_clear))
   #define END_CLEAR(p)    ((char *)&((p)->end_clear))
   #define LEN_CLEAR       (END_CLEAR((struct p *)0) - \
                               BEGIN_CLEAR((struct p *)0))/* * 这些由 clear（） 例程使用 */ #define BEGIN_CLEAR（p） （（char *）&（（p）->begin_clear）） #define END_CLEAR（p） （（char *）&（（p）->end_clear）） #define LEN_CLEAR （END_CLEAR（（struct p *）0） - \ BEGIN_CLEAR（（struct p *）0））A.5.1.  receive() A.5.1. 接收（）/*
 * receive() - receive packet and decode modes
 */
void
receive(
        struct r *r             /* receive packet pointer */
        )
{
        struct p *p;            /* peer structure pointer */
        int     auth;           /* authentication code */
        int     has_mac;        /* size of MAC */
        int     synch;          /* synchronized switch *//* * receive（） - 接收数据包和解码模式 */ void receive（ struct r *r /* 接收数据包指针 */ ） { struct p *p; /* 对等结构指针 */ int auth; /* 认证代码 */ int has_mac; /* MAC 大小 */ int synch; /* 同步交换机 */        /*
         * Check access control lists.  The intent here is to implement
         * a whitelist of those IP addresses specifically accepted
         * and/or a blacklist of those IP addresses specifically
         * rejected.  There could be different lists for authenticated
         * clients and unauthenticated clients.
         */
        if (!access(r))
                return;                 /* access denied *//* * 检查访问控制列表。这里的目的是实现*明确接受的IP地址的白名单*和/或明确拒绝的IP地址的黑名单。经过身份验证的 * 客户端和未经身份验证的客户端可能有不同的列表。*/ if （！access（r）） 返回;/* 访问被拒绝 */        /*
         * The version must not be in the future.  Format checks include
         * packet length, MAC length and extension field lengths, if
         * present.
         *//* * 该版本不得在将来使用。格式检查包括 * 数据包长度、MAC 长度和扩展字段长度（如果存在 *）。*/
Mills, et al.                Standards Track                   [Page 77]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 77 页] RFC 5905 NTPv4 规范 2010 年 6 月
        if (r->version > VERSION /* or format error */)
                return;                 /* format error */if （r->version > VERSION /* 或格式错误 */） 返回;/* 格式错误 */        /*
         * Authentication is conditioned by two switches that can be
         * specified on a per-client basis.
         *
         * P_NOPEER     do not mobilize an association unless
         *              authenticated.
         * P_NOTRUST    do not allow access unless authenticated
         *              (implies P_NOPEER).
         *
         * There are four outcomes:
         *
         * A_NONE       the packet has no MAC.
         * A_OK         the packet has a MAC and authentication
         *               succeeds.
         * A_ERROR      the packet has a MAC and authentication fails.
         * A_CRYPTO     crypto-NAK.  The MAC has four octets only.
         *
         * Note: The AUTH (x, y) macro is used to filter outcomes.  If x
         * is zero, acceptable outcomes of y are NONE and OK.  If x is
         * one, the only acceptable outcome of y is OK.
         *//* * 身份验证由两个开关决定，这两个开关可以基于每个客户端指定 *。* * 除非 * 经过身份验证，否则P_NOPEER不会动员关联。* 除非经过身份验证，否则P_NOTRUST不允许访问*（暗示P_NOPEER）。* * 有四种结果： * * A_NONE数据包没有 MAC。* A_OK数据包具有 MAC 并且身份验证 * 成功。* A_ERROR数据包具有 MAC 且身份验证失败。* A_CRYPTO crypto-NAK。MAC 只有四个八位字节。* * 注意：AUTH （x， y） 宏用于筛选结果。如果 x * 为零，则 y 的可接受结果为 NONE 和 OK。如果 x 为 * 一，则 y 唯一可接受的结果为 OK。        has_mac = /* length of MAC field */ 0;
        if (has_mac == 0) {
                auth = A_NONE;          /* not required */
        } else if (has_mac == 4) {
                auth = A_CRYPTO;       /* crypto-NAK */
        } else {
                if (r->mac != md5(r->keyid))
                        auth = A_ERROR; /* auth error */
                else
                        auth = A_OK;    /* auth OK */
        }has_mac = /* MAC 字段长度 */ 0;if （has_mac == 0） { auth = A_NONE; /* 不需要 */ } else if （has_mac == 4） { auth = A_CRYPTO; /* crypto-NAK */ } else { if （r->mac ！= md5（r->keyid）） auth = A_ERROR; /* 身份验证错误 */ else auth = A_OK; /* 身份验证 OK */ }        /*
         * Find association and dispatch code.  If there is no
         * association to match, the value of p->hmode is assumed NULL.
         */
        p = find_assoc(r);
        switch(table[(unsigned int)(p->hmode)][(unsigned int)(r->mode)])
        {/* * 查找关联和调度代码。如果没有要匹配的 * 关联，则假定 p->hmode 的值为 NULL。*/ p = find_assoc（r）;switch（table[（unsigned int）（p->hmode）][（unsigned int）（r->mode）]） {Mills, et al.                Standards Track                   [Page 78]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 78 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * Client packet and no association.  Send server reply without
         * saving state.
         */
        case FXMIT:/* * 客户端数据包，无关联。发送不带 * 保存状态的服务器回复。*/ 案例 FXMIT：                /*
                 * If unicast destination address, send server packet.
                 * If authentication fails, send a crypto-NAK packet.
                 *//* * 如果单播目标地址，则发送服务器数据包。* 如果身份验证失败，请发送 crypto-NAK 数据包。*/                /* not multicast dstaddr */
                if (0) {
                        if (AUTH(p->flags & P_NOTRUST, auth))
                                fast_xmit(r, M_SERV, auth);
                        else if (auth == A_ERROR)
                                fast_xmit(r, M_SERV, A_CRYPTO);
                        return;         /* M_SERV packet sent */
                }/* not multicast dstaddr */ if （0） { if （AUTH（p->flags & P_NOTRUST， auth）） fast_xmit（r， M_SERV， auth）; else if （auth == A_ERROR） fast_xmit（r， M_SERV， A_CRYPTO）; return; /* 发送M_SERV数据包 */ }                /*
                 * This must be manycast.  Do not respond if we are not
                 * synchronized or if our stratum is above the
                 * manycaster.
                 */
                if (s.leap == NOSYNC || s.stratum > r->stratum)
                        return;/* * 这必须是 manycast。如果我们没有 * 同步，或者我们的层高于 * manycaster，请不要响应。*/ if （s.leap == NOSYNC || s.stratum > r->stratum） return;                /*
                 * Respond only if authentication is OK.  Note that the
                 * unicast address is used, not the multicast.
                 */
                if (AUTH(p->flags & P_NOTRUST, auth))
                        fast_xmit(r, M_SERV, auth);
                return;/* * 仅当身份验证正常时才响应。 请注意，使用的是 * 单播地址，而不是多播地址。*/ if （AUTH（p->flags & P_NOTRUST， auth）） fast_xmit（r， M_SERV， auth）;返回;        /*
         * New manycast client ephemeral association.  It is mobilized
         * in the same version as in the packet.  If authentication
         * fails, ignore the packet.  Verify the server packet by
         * comparing the r->org timestamp in the packet with the p->xmt
         * timestamp in the multicast client association.  If they
         * match, the server packet is authentic.  Details omitted.
         *//* * 新的 manycast 客户端临时关联。它以与数据包相同的版本被动员 *。如果身份验证 * 失败，请忽略该数据包。通过将数据包中的 r->org 时间戳与组播客户端关联中的 p->xmt * 时间戳进行比较来验证服务器数据包。如果它们 * 匹配，则服务器数据包是真实的。细节省略。*/Mills, et al.                Standards Track                   [Page 79]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 79 页] RFC 5905 NTPv4 规范 2010 年 6 月
        case MANY:
                if (!AUTH(p->flags & (P_NOTRUST | P_NOPEER), auth))
                        return;         /* authentication error */案例 MANY：如果 （！AUTH（p->flags & （P_NOTRUST |P_NOPEER）、auth）） 返回;/* 认证错误 */                p = mobilize(r->srcaddr, r->dstaddr, r->version, M_CLNT,
                    r->keyid, P_EPHEM);
                break;p = mobilize（r->srcaddr， r->dstaddr， r->version， M_CLNT， r->keyid， P_EPHEM）;破;       /*
        * New symmetric passive association.  It is mobilized in the
        * same version as in the packet.  If authentication fails,
        * send a crypto-NAK packet.  If restrict no-moblize, send a
        * symmetric active packet instead.
        */
        case NEWPS:
                if (!AUTH(p->flags & P_NOTRUST, auth)) {
                        if (auth == A_ERROR)
                                fast_xmit(r, M_SACT, A_CRYPTO);
                        return;         /* crypto-NAK packet sent */
                }
                if (!AUTH(p->flags & P_NOPEER, auth)) {
                        fast_xmit(r, M_SACT, auth);
                        return;         /* M_SACT packet sent */
                }
                p = mobilize(r->srcaddr, r->dstaddr, r->version, M_PASV,
                    r->keyid, P_EPHEM);
                break;/* * 新的对称被动关联。它以与数据包相同的 * 版本进行调动。如果身份验证失败，* 发送 crypto-NAK 数据包。如果限制 no-moblize，则改为发送 * 对称活动数据包。*/ 案例 NEWPS： if （！AUTH（p->flags & P_NOTRUST， auth）） { if （auth == A_ERROR） fast_xmit（r， M_SACT， A_CRYPTO）; return; /* crypt-NAK 数据包发送 */ } if （！AUTH（p->flags & P_NOPEER， auth）） { fast_xmit（r， M_SACT， auth）; return; /* 发送M_SACT数据包 */ } p = mobilize（r->srcaddr， r->dstaddr， r->version， M_PASV， r->keyid， P_EPHEM）;破;        /*
         * New broadcast client association.  It is mobilized in the
         * same version as in the packet.  If authentication fails,
         * ignore the packet.  Note this code does not support the
         * initial volley feature in the reference implementation.
         */
        case NEWBC:
                if (!AUTH(p->flags & (P_NOTRUST | P_NOPEER), auth))
                        return;         /* authentication error *//* * 新的广播客户端关联。它以与数据包相同的 * 版本进行调动。如果身份验证失败，* 忽略数据包。请注意，此代码不支持参考实现中的 * 初始凌空功能。*/ 案例 NEWBC： if （！AUTH（p->flags & （P_NOTRUST |P_NOPEER）、auth）） 返回;/* 认证错误 */                if (!(s.flags & S_BCSTENAB))
                        return;         /* broadcast not enabled */如果 （！（s.flags & S_BCSTENAB）） 返回;/* 未启用广播 */                p = mobilize(r->srcaddr, r->dstaddr, r->version, M_BCLN,
                    r->keyid, P_EPHEM);
                break;                  /* processing continues */p = mobilize（r->srcaddr， r->dstaddr， r->version， M_BCLN， r->keyid， P_EPHEM）;破;/* 处理继续 */Mills, et al.                Standards Track                   [Page 80]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 80 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * Process packet.  Placeholdler only.
         */
        case PROC:
                break;                  /* processing continues *//* * 处理数据包。仅限占位器。*/ case PROC： break;/* 处理继续 */        /*
         * Invalid mode combination.  We get here only in case of
         * ephemeral associations, so the correct action is simply to
         * toss it.
         */
        case ERR:
                clear(p, X_ERROR);
                return;                 /* invalid mode combination *//* * 无效的模式组合。我们只有在 * 短暂的关联的情况下才会到达这里，所以正确的操作只是 * 扔掉它。*/ 案例 ERR： clear（p， X_ERROR）;返回;/* 无效模式组合 */        /*
         * No match; just discard the packet.
         */
        case DSCRD:
                return;                 /* orphan abandoned */
        }/* * 不匹配;只需丢弃数据包即可。*/ case DSCRD： 返回;/* 孤儿被遗弃 */ }        /*
         * Next comes a rigorous schedule of timestamp checking.  If the
         * transmit timestamp is zero, the server is horribly broken.
         */
        if (r->xmt == 0)
                return;                 /* invalid timestamp *//* * 接下来是严格的时间戳检查时间表。如果 * 传输时间戳为零，则服务器严重损坏。*/ if （r->xmt == 0） 返回;/* 无效的时间戳 */        /*
         * If the transmit timestamp duplicates a previous one, the
         * packet is a replay.
         */
        if (r->xmt == p->xmt)
                return;                 /* duplicate packet *//* * 如果传输时间戳与前一个时间戳重复，则 * 数据包为重放。*/ if （r->xmt == p->xmt） 返回;/* 重复数据包 */        /*
         * If this is a broadcast mode packet, skip further checking.
         * If the origin timestamp is zero, the sender has not yet heard
         * from us.  Otherwise, if the origin timestamp does not match
         * the transmit timestamp, the packet is bogus.
         *//* * 如果这是广播模式数据包，请跳过进一步检查。* 如果原始时间戳为零，则发件人尚未收到我们的*。否则，如果源时间戳与传输时间戳 * 不匹配，则数据包是假的。*/Mills, et al.                Standards Track                   [Page 81]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 81 页] RFC 5905 NTPv4 规范 2010 年 6 月
        synch = TRUE;
        if (r->mode != M_BCST) {
                if (r->org == 0)
                        synch = FALSE;  /* unsynchronized */同步 = TRUE;if （r->mode ！= M_BCST） { if （r->org == 0） synch = FALSE; /* 不同步 */                else if (r->org != p->xmt)
                        synch = FALSE;  /* bogus packet */
        }否则 if （r->org ！= p->xmt） synch = FALSE;/* 伪造数据包 */ }        /*
         * Update the origin and destination timestamps.  If
         * unsynchronized or bogus, abandon ship.
         */
        p->org = r->xmt;
        p->rec = r->dst;
        if (!synch)
                return;                 /* unsynch *//* * 更新始发地和目的地时间戳。如果 * 不同步或虚假，则弃船。*/ p->org = r->xmt;p->rec = r->dst;if （！synch） 返回;/* 不同步 */        /*
         * The timestamps are valid and the receive packet matches the
         * last one sent.  If the packet is a crypto-NAK, the server
         * might have just changed keys.  We demobilize the association
         * and wait for better times.
         */
        if (auth == A_CRYPTO) {
                clear(p, X_CRYPTO);
                return;                 /* crypto-NAK */
        }/* * 时间戳有效，接收数据包与上次发送的 * 数据包匹配。如果数据包是加密 NAK，则服务器 * 可能刚刚更改了密钥。我们复员协会*并等待更好的时机。*/ if （auth == A_CRYPTO） { clear（p， X_CRYPTO）; return; /* crypto-NAK */ }        /*
         * If the association is authenticated, the key ID is nonzero
         * and received packets must be authenticated.  This is designed
         * to avoid a bait-and-switch attack, which was possible in past
         * versions.
         */
        if (!AUTH(p->keyid || (p->flags & P_NOTRUST), auth))
                return;                 /* bad auth *//* * 如果关联经过身份验证，则密钥 ID 为非零 *，并且必须对接收的数据包进行身份验证。这是为了避免诱饵和转换攻击而设计的，这在过去 * 版本中是可能的。*/ 如果 （！AUTH（p->键ID ||（p->flags & P_NOTRUST）， auth）） 返回;/* 身份验证错误 */
Mills, et al.                Standards Track                   [Page 82]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 82 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * Everything possible has been done to validate the timestamps
         * and prevent bad guys from disrupting the protocol or
         * injecting bogus data.  Earn some revenue.
         */
        packet(p, r);
}/* * 已尽一切可能验证时间戳 * 并防止坏人破坏协议或 * 注入虚假数据。赚取一些收入。*/ 数据包（p， r）;}A.5.1.1.  packet() A.5.1.1. 数据包（）/*
 * packet() - process packet and compute offset, delay, and
 * dispersion.
 */
void
packet(
        struct p *p,            /* peer structure pointer */
        struct r *r             /* receive packet pointer */
        )
{
        double  offset;         /* sample offsset */
        double  delay;          /* sample delay */
        double  disp;           /* sample dispersion *//* * packet（） - 处理数据包并计算偏移、延迟和 * 离散。*/ void packet（ struct p *p， /* 对等结构指针 */ struct r *r /* 接收数据包指针 */ ） { double offset; /* sample offsoffset */ double delay; /* sample delay */ double disp; /* sample disp */        /*
         * By golly the packet is valid.  Light up the remaining header
         * fields.  Note that we map stratum 0 (unspecified) to MAXSTRAT
         * to make stratum comparisons simpler and to provide a natural
         * interface for radio clock drivers that operate for
         *  convenience at stratum 0.
         */
        p->leap = r->leap;
        if (r->stratum == 0)
                p->stratum = MAXSTRAT;
        else
                p->stratum = r->stratum;
        p->pmode = r->mode;
        p->ppoll = r->poll;
        p->rootdelay = FP2D(r->rootdelay);
        p->rootdisp = FP2D(r->rootdisp);
        p->refid = r->refid;
        p->reftime = r->reftime;/* * 天哪，数据包是有效的。点亮剩余的标题 * 字段。请注意，我们将第 0 层（未指定）映射到 MAXSTRAT *，以使第 1 层比较更简单，并为在第 0 层方便地运行的无线电时钟驱动器提供自然的 * 接口。*/ p->leap = r->leap;如果 （r->stratum == 0） p->stratum = MAXSTRAT;否则 p->stratum = r->stratum;p->pmode = r->模式;p->ppoll = r->poll;p->根延迟 = FP2D（r->根延迟）;p->rootdisp = FP2D（r->rootdisp）;p->refid = r->refid;p->reftime = r->reftime;        /*
         * Verify the server is synchronized with valid stratum and
         * reference time not later than the transmit time.
         *//* * 验证服务器是否与有效层同步，并且 * 参考时间不晚于传输时间。*/
Mills, et al.                Standards Track                   [Page 83]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 83 页] RFC 5905 NTPv4 规范 2010 年 6 月
        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)
                return;                 /* unsynchronized */if （p->leap == NOSYNC || p->stratum >= MAXSTRAT） 返回;/* 不同步 */        /*
         * Verify valid root distance.
         */
        if (r->rootdelay / 2 + r->rootdisp >= MAXDISP || p->reftime >
            r->xmt)
                return;                 /* invalid header values *//* * 验证有效的根距离。*/ if （r->rootdelay / 2 + r->rootdisp >= MAXDISP || p->reftime > r->xmt） return;/* 无效的标头值 */        poll_update(p, p->hpoll);
        p->reach |= 1;poll_update（p， p->hpoll）;p->达到 |= 1;        /*
         * Calculate offset, delay and dispersion, then pass to the
         * clock filter.  Note carefully the implied processing.  The
         * first-order difference is done directly in 64-bit arithmetic,
         * then the result is converted to floating double.  All further
         * processing is in floating-double arithmetic with rounding
         * done by the hardware.  This is necessary in order to avoid
         * overflow and preserve precision.
         *
         * The delay calculation is a special case.  In cases where the
         * server and client clocks are running at different rates and
         * with very fast networks, the delay can appear negative.  In
         * order to avoid violating the Principle of Least Astonishment,
         * the delay is clamped not less than the system precision.
         */
        if (p->pmode == M_BCST) {
                offset = LFP2D(r->xmt - r->dst);
                delay = BDELAY;
                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *
                    2 * BDELAY;
        } else {
                offset = (LFP2D(r->rec - r->org) + LFP2D(r->dst -
                    r->xmt)) / 2;
                delay = max(LFP2D(r->dst - r->org) - LFP2D(r->rec -
                    r->xmt), LOG2D(s.precision));
                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *
                    LFP2D(r->dst - r->org);
        }
        clock_filter(p, offset, delay, disp);
}/* * 计算偏移、延迟和色散，然后传递给 * 时钟滤波器。仔细注意隐含的处理。* 一阶差分直接在 64 位算术中完成，* 然后将结果转换为浮点双精度。所有进一步的 * 处理均采用浮点双精度算术，四舍五入 * 由硬件完成。这是避免 * 溢出和保持精度所必需的。* * 延迟计算是特例。如果 * 服务器和客户端时钟以不同的速率运行，并且 * 在非常快的网络下运行，则延迟可能显示为负数。为了避免违反最小惊奇原则，*延迟被箝位不小于系统精度。*/ if （p->pmode == M_BCST） { offset = LFP2D（r->xmt - r->dst）; delay = BDELAY; disp = LOG2D（r->precision） + LOG2D（s.） 精度） + PHI * 2 * BDELAY; } else { offset = （LFP2D（r->rec - r->org） + LFP2D（r->dst - r->xmt）） / 2; delay = max（LFP2D（r->dst - r->org） - LFP2D（r->rec - r->xmt）， LOG2D（s.precision））; disp = LOG2D（r->精度） + LOG2D（s.precision） + PHI * LFP2D（r->dst - r->org）; } clock_filter（p， 偏移、延迟、disp）;}
Mills, et al.                Standards Track                   [Page 84]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 84 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.5.2.  clock_filter() A.5.2. clock_filter（）/*
 * clock_filter(p, offset, delay, dispersion) - select the best from the
 * latest eight delay/offset samples.
 */
void
clock_filter(
        struct p *p,            /* peer structure pointer */
        double  offset,         /* clock offset */
        double  delay,          /* roundtrip delay */
        double  disp            /* dispersion */
        )
{
        struct f f[NSTAGE];     /* sorted list */
        double  dtemp;
        int     i;/* * clock_filter（p、偏移、延迟、色散） - 从 * 最新的八个延迟/偏移样本中选择最佳。*/ void clock_filter（ struct p *p， /* 对等结构指针 */ 双偏移量， /* 时钟偏移量 */ 双延迟， /* 往返延迟 */ 双disp /* 色散 */ ） { struct f f[NSTAGE]; /* 排序列表 */ 双倍温度; int i;        /*
         * The clock filter contents consist of eight tuples (offset,
         * delay, dispersion, time).  Shift each tuple to the left,
         * discarding the leftmost one.  As each tuple is shifted,
         * increase the dispersion since the last filter update.  At the
         * same time, copy each tuple to a temporary list.  After this,
         * place the (offset, delay, disp, time) in the vacated
         * rightmost tuple.
         */
        for (i = 1; i < NSTAGE; i++) {
                p->f[i] = p->f[i - 1];
                p->f[i].disp += PHI * (c.t - p->t);
                f[i] = p->f[i];
        }
        p->f[0].t = c.t;
        p->f[0].offset = offset;
        p->f[0].delay = delay;
        p->f[0].disp = disp;
        f[0] = p->f[0];/* * 时钟滤波器内容由八个元组组成（偏移量、* 延迟、色散、时间）。将每个元组向左移动，* 丢弃最左边的元组。随着每个元组的移动，* 增加自上次过滤器更新以来的离散度。同时，将每个元组复制到临时列表中。在此之后，* 将 （offset， delay， disp， time） 放在空出的 * 最右边的元组中。*/ for （i = 1; i < NSTAGE; i++） { p->f[i] = p->f[i - 1]; p->f[i].disp += PHI * （c.t - p->t）; f[i] = p->f[i]; } p->f[0].t = c.t; p->f[0].offset = 偏移; p->f[0].delay = 延迟; p->f[0].disp = disp; f[0] = p->f[0];        /*
         * Sort the temporary list of tuples by increasing f[].delay.
         * The first entry on the sorted list represents the best
         * sample, but it might be old.
         */
        dtemp = p->offset;
        p->offset = f[0].offset;
        p->delay = f[0].delay;
        for (i = 0; i < NSTAGE; i++) {
                p->disp += f[i].disp / (2 ^ (i + 1));/* * 通过增加 f[].delay 对元组的临时列表进行排序。* 排序列表中的第一个条目表示最佳 * 样本，但它可能很旧。*/ dtemp = p->偏移;p->偏移量 = f[0].偏移量;p->延迟 = f[0].延迟;for （i = 0; i < NSTAGE; i++） { p->disp += f[i].disp / （2 ^ （i + 1））;Mills, et al.                Standards Track                   [Page 85]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 85 页] RFC 5905 NTPv4 规范 2010 年 6 月
                p->jitter += SQUARE(f[i].offset - f[0].offset);
        }
        p->jitter = max(SQRT(p->jitter), LOG2D(s.precision));p->抖动 += SQUARE（f[i].offset - f[0].offset）;} p->抖动 = max（SQRT（p->抖动）， LOG2D（s.precision））;        /*
         * Prime directive: use a sample only once and never a sample
         * older than the latest one, but anything goes before first
         * synchronized.
         */
        if (f[0].t - p->t <= 0 && s.leap != NOSYNC)
                return;/* * Prime 指令：只使用一次样本，永远不要使用比最新样本早的样本，但任何事情都会先于 * 同步。*/ if （f[0].t - p->t <= 0 && s.leap ！= NOSYNC） 返回;        /*
         * Popcorn spike suppressor.  Compare the difference between the
         * last and current offsets to the current jitter.  If greater
         * than SGATE (3) and if the interval since the last offset is
         * less than twice the system poll interval, dump the spike.
         * Otherwise, and if not in a burst, shake out the truechimers.
         */
        if (fabs(p->offset - dtemp) > SGATE * p->jitter && (f[0].t -
            p->t) < 2 * s.poll)
                return;/* * 爆米花抑制器。将 * 上次和电流偏移与当前抖动之间的差值进行比较。如果 * 大于 SGATE （3），并且自上次偏移以来的间隔小于系统轮询间隔的两倍，则转储尖峰。* 否则，如果不是爆发，请抖出真嵌合物。*/ if （fabs（p->offset - dtemp） > SGATE * p->jitter && （f[0].t - p->t） < 2 * s.poll） return;        p->t = f[0].t;
        if (p->burst == 0)
                clock_select();
        return;
}p->t = f[0].t;如果 （p->burst == 0） clock_select（）;返回;}/*
 * fit() - test if association p is acceptable for synchronization
 */
int
fit(
        struct p *p             /* peer structure pointer */
        )
{
        /*
         * A stratum error occurs if (1) the server has never been
         * synchronized, (2) the server stratum is invalid.
         */
        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)
                return (FALSE);/* * fit（） - 测试关联 p 是否可接受同步 */ int fit（ struct p *p /* 对等结构指针 */ ） { /* * 如果 （1） 服务器从未 * 同步，（2） 服务器层无效，则会发生 stratum 错误。 */ if （p->leap == NOSYNC || p->stratum >= MAXSTRAT） return （FALSE）;
Mills, et al.                Standards Track                   [Page 86]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 86 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * A distance error occurs if the root distance exceeds the
         * distance threshold plus an increment equal to one poll
         * interval.
         */
        if (root_dist(p) > MAXDIST + PHI * LOG2D(s.poll))
                return (FALSE);/* * 如果根距离超过 * 距离阈值加上等于 1 轮询 * 间隔的增量，则会发生距离错误。*/ if （root_dist（p） > MAXDIST + PHI * LOG2D（s.poll）） 返回 （FALSE）;        /*
         * A loop error occurs if the remote peer is synchronized to the
         * local peer or the remote peer is synchronized to the current
         * system peer.  Note this is the behavior for IPv4; for IPv6
         * the MD5 hash is used instead.
         */
        if (p->refid == p->dstaddr || p->refid == s.refid)
                return (FALSE);/* * 如果远程对等体同步到 * 本地对等体或远程对等体与当前 * 系统对等体同步，则会发生循环错误。请注意，这是 IPv4 的行为;对于 IPv6 * 改用 MD5 哈希。*/ if （p->refid == p->dstaddr || p->refid == s.refid） 返回 （FALSE）;        /*
         * An unreachable error occurs if the server is unreachable.
         */
        if (p->reach == 0)
                return (FALSE);/* * 如果服务器无法访问，则会发生无法访问错误。*/ if （p->reach == 0） 返回 （FALSE）;        return (TRUE);
} 返回 （TRUE）;}/*
 * clear() - reinitialize for persistent association, demobilize
 * for ephemeral association.
 */
void
clear(
        struct p *p,            /* peer structure pointer */
        int     kiss            /* kiss code */
        )
{
        int i;/* * clear（） - 重新初始化持久关联，demobilize * 永久关联。*/ void clear（ struct p *p， /* 对等结构指针 */ int kiss /* kiss code */ ） { int i;        /*
         * The first thing to do is return all resources to the bank.
         * Typical resources are not detailed here, but they include
         * dynamically allocated structures for keys, certificates, etc.
         * If an ephemeral association and not initialization, return
         * the association memory as well.
         */
        /* return resources */
        if (s.p == p)
                s.p = NULL;/* * 首先要做的是将所有资源归还给银行。* 这里没有详细说明典型资源，但它们包括 * 为密钥、证书等动态分配的结构。 * 如果是临时关联而不是初始化，则返回 * 关联内存。*/ /* 返回资源 */ if （s.p == p） s.p = NULL;Mills, et al.                Standards Track                   [Page 87]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 87 页] RFC 5905 NTPv4 规范 2010 年 6 月
        if (kiss != X_INIT && (p->flags & P_EPHEM)) {
                free(p);
                return;
        }if （kiss ！= X_INIT && （p->flags & P_EPHEM）） { free（p）; return; }        /*
         * Initialize the association fields for general reset.
         */
        memset(BEGIN_CLEAR(p), LEN_CLEAR, 0);
        p->leap = NOSYNC;
        p->stratum = MAXSTRAT;
        p->ppoll = MAXPOLL;
        p->hpoll = MINPOLL;
        p->disp = MAXDISP;
        p->jitter = LOG2D(s.precision);
        p->refid = kiss;
        for (i = 0; i < NSTAGE; i++)
                p->f[i].disp = MAXDISP;/* * 初始化常规重置的关联字段。*/ memset（BEGIN_CLEAR（p）， LEN_CLEAR， 0）;p->leap = 不同步;p->层 = MAXSTRAT;p->ppoll = MAXPOLL;p->hpoll = MINPOLL;p->disp = MAXDISP;p->抖动 = LOG2D（s.precision）;p->refid = 亲吻;for （i = 0; i < NSTAGE; i++） p->f[i].disp = MAXDISP;        /*
         * Randomize the first poll just in case thousands of broadcast
         * clients have just been stirred up after a long absence of the
         * broadcast server.
         */
        p->outdate = p->t = c.t;
        p->nextdate = p->outdate + (random() & ((1 << MINPOLL) - 1));
}/* * 随机化第一次轮询，以防万一成千上万的广播 * 客户端在长时间没有 * 广播服务器后刚刚被搅动。*/ p->outdate = p->t = c.t;p->nextdate = p->outdate + （random（） & （（1 << MINPOLL） - 1））;}A.5.3.  fast_xmit() A.5.3. fast_xmit（）/*
 * fast_xmit() - transmit a reply packet for receive packet r
 */
void
fast_xmit(
        struct r *r,            /* receive packet pointer */
        int     mode,           /* association mode */
        int     auth            /* authentication code */
        )
{
        struct x x;/* * fast_xmit（） - 为接收报文 r 发送应答报文 r */ void fast_xmit（ struct r *r， /* 接收报文指针 */ int mode， /* 关联模式 */ int auth /* 认证码 */ ） { struct x x;        /*
         * Initialize header and transmit timestamp.  Note that the
         * transmit version is copied from the receive version.  This is
         * for backward compatibility.
         *//* * 初始化标头并传输时间戳。请注意，* 传输版本是从接收版本复制的。这是 * 用于向后兼容。*/
Mills, et al.                Standards Track                   [Page 88]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 88 页] RFC 5905 NTPv4 规范 2010 年 6 月
        x.version = r->version;
        x.srcaddr = r->dstaddr;
        x.dstaddr = r->srcaddr;
        x.leap = s.leap;
        x.mode = mode;
        if (s.stratum == MAXSTRAT)
                x.stratum = 0;
        else
                x.stratum = s.stratum;
        x.poll = r->poll;
        x.precision = s.precision;
        x.rootdelay = D2FP(s.rootdelay);
        x.rootdisp = D2FP(s.rootdisp);
        x.refid = s.refid;
        x.reftime = s.reftime;
        x.org = r->xmt;
        x.rec = r->dst;
        x.xmt = get_time();x.version = r->版本;x.srcaddr = r->dstaddr;x.dstaddr = r->srcaddr;x.leap = s.leap;x.mode = 模式;如果 （s.stratum == MAXSTRAT） x.stratum = 0;否则 x.stratum = s.stratum;x.poll = r->poll;x.precision = s.precision;x.rootdelay = D2FP（s.rootdelay）;x.rootdisp = D2FP（s.rootdisp）;x.refid = s.refid;x.reftime = s.reftime;x.org = r->xmt;x.rec = r->dst;x.xmt = get_time（）;        /*
         * If the authentication code is A.NONE, include only the
         * header; if A.CRYPTO, send a crypto-NAK; if A.OK, send a valid
         * MAC.  Use the key ID in the received packet and the key in
         * the local key cache.
         */
        if (auth != A_NONE) {
                if (auth == A_CRYPTO) {
                        x.keyid = 0;
                } else {
                        x.keyid = r->keyid;
                        x.dgst = md5(x.keyid);
                }
        }
        xmit_packet(&x);
}/* * 如果验证码为 A.NONE，则仅包含 * 标头;如果是 A.CRYPTO，则发送 crypto-NAK;如果 A.OK，则发送有效的 * MAC。使用接收的数据包中的密钥 ID 和本地密钥缓存中的 * 中的密钥。*/ if （auth ！= A_NONE） { if （auth == A_CRYPTO） { x.keyid = 0; } else { x.keyid = r->keyid; x.dgst = md5（x.keyid）; } } xmit_packet（&x）;}A.5.4.  access() A.5.4. access（） /*
  * access() - determine access restrictions
  */
 int
 access(
         struct r *r             /* receive packet pointer */
         )/* * access（） - 确定访问限制 */ int access（ struct r *r /* 接收数据包指针 */ ）
Mills, et al.                Standards Track                   [Page 89]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 89 页] RFC 5905 NTPv4 规范 2010 年 6 月
 {
         /*
          * The access control list is an ordered set of tuples
          * consisting of an address, mask, and restrict word containing
          * defined bits.  The list is searched for the first match on
          * the source address (r->srcaddr) and the associated restrict
          * word is returned.
          */
         return (/* access bits */ 0);
 }{ /* * 访问控制列表是一组有序的元组 *，由地址、掩码和限制字组成，其中包含 * 定义的位。在列表中搜索源地址 （r->srcaddr） 上的第一个匹配项，并返回关联的 restrict * 字。*/ 返回 （/* 访问位 */ 0）;}A.5.5.  System Process A.5.5. 系统进程A.5.5.1.  clock_select() A.5.5.1. clock_select（）/*
 * clock_select() - find the best clocks
 */
void
clock_select() {
       struct p *p, *osys;     /* peer structure pointers */
       double  low, high;      /* correctness interval extents */
       int     allow, found, chime; /* used by intersection algorithm */
       int     n, i, j;/* * clock_select（） - 找到最佳时钟 */ void clock_select（） { struct p *p， *osys; /* 对等结构指针 */ double low， high; /* 正确性区间范围 */ int allow， found， chime; /* 交集算法使用 */ int n， i， j;        /*
         * We first cull the falsetickers from the server population,
         * leaving only the truechimers.  The correctness interval for
         * association p is the interval from offset - root_dist() to
         * offset + root_dist().  The object of the game is to find a
         * majority clique; that is, an intersection of correctness
         * intervals numbering more than half the server population.
         *
         * First, construct the chime list of tuples (p, type, edge) as
         * shown below, then sort the list by edge from lowest to
         * highest.
         */
        osys = s.p;
        s.p = NULL;
        n = 0;
        while (fit(p)) {
                s.m[n].p = p;
                s.m[n].type = +1;
                s.m[n].edge = p->offset + root_dist(p);
                n++;
                s.m[n].p = p;
                s.m[n].type = 0;
                s.m[n].edge = p->offset;/* * 我们首先从服务器填充中剔除虚假代码，* 只留下真嵌合器。* 关联 p 的正确性区间是从偏移量 - root_dist（） 到 * 偏移量 + root_dist（） 的区间。游戏的目的是找到一个*多数派;也就是说，正确性 * 间隔的交集，编号超过服务器数量的一半。* * 首先，构造元组（p、type、edge）的 chime 列表，如下所示，然后按边缘从最低到 * 最高对列表进行排序。*/ 奥赛斯 = S.P;s.p = 空;n = 0;while （fit（p）） { s.m[n].p = p; s.m[n].type = +1; s.m[n].edge = p->offset + root_dist（p）; n++; s.m[n].p = p; s.m[n].type = 0; s.m[n].edge = p->偏移;Mills, et al.                Standards Track                   [Page 90]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 90 页] RFC 5905 NTPv4 规范 2010 年 6 月
                n++;
                s.m[n].p = p;
                s.m[n].type = -1;
                s.m[n].edge = p->offset - root_dist(p);
                n++;
        }n++;s.m[n].p = p;s.m[n].type = -1;s.m[n].edge = p->偏移 - root_dist（p）;n++;}        /*
         * Find the largest contiguous intersection of correctness
         * intervals.  Allow is the number of allowed falsetickers;
         * found is the number of midpoints.  Note that the edge values
         * are limited to the range +-(2 ^ 30) < +-2e9 by the timestamp
         * calculations.
         */
        low = 2e9; high = -2e9;
        for (allow = 0; 2 * allow < n; allow++) {/* * 求正确性 * 区间的最大连续交集。允许是允许的虚假代码的数量;* 找到的是中点数。请注意，通过时间戳 * 计算，边值 * 限制在 +-（2 ^ 30） < +-2e9 范围内。*/ 低 = 2e9;高 = -2E9;for （允许 = 0; 2 * 允许 < n; 允许++） {                /*
                 * Scan the chime list from lowest to highest to find
                 * the lower endpoint.
                 */
                found = 0;
                chime = 0;
                for (i = 0; i < n; i++) {
                        chime -= s.m[i].type;
                        if (chime >= n - found) {
                                low = s.m[i].edge;
                                break;
                        }
                        if (s.m[i].type == 0)
                                found++;
                }/* * 从低到高扫描铃声列表，找到 * 下端点。*/ 找到 = 0;钟声 = 0;for （i = 0; i < n; i++） { chime -= s.m[i].type; if （chime >= n - found） { low = s.m[i].edge; break; } if （s.m[i].type == 0） found++; }                /*
                 * Scan the chime list from highest to lowest to find
                 * the upper endpoint.
                 */
                chime = 0;
                for (i = n - 1; i >= 0; i--) {
                        chime += s.m[i].type;
                        if (chime >= n - found) {
                                high = s.m[i].edge;
                                break;
                        }
                        if (s.m[i].type == 0)
                                found++;
                }/* * 从高到低扫描铃声列表以找到 * 上端点。*/ 铃声 = 0;for （i = n - 1; i >= 0; i--） { chime += s.m[i].type; if （chime >= n - found） { high = s.m[i].edge; break; } if （s.m[i].type == 0） found++; }
Mills, et al.                Standards Track                   [Page 91]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 91 页] RFC 5905 NTPv4 规范 2010 年 6 月
                /*
                 * If the number of midpoints is greater than the number
                 * of allowed falsetickers, the intersection contains at
                 * least one truechimer with no midpoint.  If so,
                 * increment the number of allowed falsetickers and go
                 * around again.  If not and the intersection is
                 * non-empty, declare success.
                 */
                if (found > allow)
                        continue;/* * 如果中点数大于允许的假嵌合器数 *，则交集包含至少 * 一个没有中点的真嵌合器。如果是这样，* 增加允许的虚假代码的数量，然后再次绕行 *。如果不是，并且交集为 * 非空，则声明成功。*/ 如果（发现>允许）继续;                if (high > low)
                        break;
        }如果（高>低）突破;}        /*
         * Clustering algorithm.  Construct a list of survivors (p,
         * metric) from the chime list, where metric is dominated first
         * by stratum and then by root distance.  All other things being
         * equal, this is the order of preference.
         */
        s.n = 0;
        for (i = 0; i < n; i++) {
                if (s.m[i].edge < low || s.m[i].edge > high)
                        continue;/* * 聚类算法。从钟声列表中构造幸存者列表（p，* 度量），其中度量首先由层 * 主导，然后由根距离主导。在所有其他条件 * 相同的情况下，这是优先顺序。*/ s.n = 0;for （i = 0; i < n; i++） { if （s.m[i].edge < low || s.m[i].edge > high） 继续;                p = s.m[i].p;
                s.v[n].p = p;
                s.v[n].metric = MAXDIST * p->stratum + root_dist(p);
                s.n++;
        }p = s.m[i].p;s.v[n].p = p;s.v[n].metric = MAXDIST * p->stratum + root_dist（p）;s.n++;}        /*
         * There must be at least NSANE survivors to satisfy the
         * correctness assertions.  Ordinarily, the Byzantine criteria
         * require four survivors, but for the demonstration here, one
         * is acceptable.
         */
        if (s.n < NSANE)
                return;/* * 必须至少有 NSANE 幸存者才能满足 * 正确性断言。通常，拜占庭标准*需要四名幸存者，但对于这里的演示，一个*是可以接受的。*/ 如果 （s.n < NSANE） 返回;        /*
         * For each association p in turn, calculate the selection
         * jitter p->sjitter as the square root of the sum of squares
         * (p->offset - q->offset) over all q associations.  The idea is
         * to repeatedly discard the survivor with maximum selection
         * jitter until a termination condition is met.
         *//* * 依次计算每个关联 p 的选值 * 抖动 p->sjitter 作为所有 q 关联的平方和的平方根 * （p->offset - q->offset）。这个想法是 * 以最大选择重复丢弃幸存者 * 抖动，直到满足终止条件。*/Mills, et al.                Standards Track                   [Page 92]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 92 页] RFC 5905 NTPv4 规范 2010 年 6 月
        while (1) {
                struct p *p, *q, *qmax; /* peer structure pointers */
                double  max, min, dtemp;while （1） { struct p *p， *q， *qmax; /* 对等结构指针 */ double max， min， dtemp;                max = -2e9; min = 2e9;
                for (i = 0; i < s.n; i++) {
                        p = s.v[i].p;
                        if (p->jitter < min)
                                min = p->jitter;
                        dtemp = 0;
                        for (j = 0; j < n; j++) {
                                q = s.v[j].p;
                                dtemp += SQUARE(p->offset - q->offset);
                        }
                        dtemp = SQRT(dtemp);
                        if (dtemp > max) {
                                max = dtemp;
                                qmax = q;
                        }
                }最大 = -2E9;最小 = 2e9;for （i = 0; i < s.n; i++） { p = s.v[i].p; if （p->抖动 < min） min = p->抖动; dtemp = 0; for （j = 0; j < n; j++） { q = s.v[j].p; dtemp += SQUARE（p->offset - q->offset）; } dtemp = SQRT（dtemp）; if （dtemp > max） { max = dtemp; qmax = q; } }                /*
                 * If the maximum selection jitter is less than the
                 * minimum peer jitter, then tossing out more survivors
                 * will not lower the minimum peer jitter, so we might
                 * as well stop.  To make sure a few survivors are left
                 * for the clustering algorithm to chew on, we also stop
                 * if the number of survivors is less than or equal to
                 * NMIN (3).
                 */
                if (max < min || n <= NMIN)
                        break;/* * 如果最大选择抖动小于 * 最小对等抖动，那么抛出更多幸存者 * 不会降低最小对等抖动，所以我们不妨 * 停止。为了确保留下一些幸存者供聚类算法咀嚼，如果幸存者的数量小于或等于 * NMIN （3），我们也会停止 *。*/ if （最大 < 分钟 || n <= NMIN） 中断;                /*
                 * Delete survivor qmax from the list and go around
                 * again.
                 */
                s.n--;
        }/* * 从列表中删除幸存者 qmax，然后再次绕过 *。*/ s.n--;}        /*
         * Pick the best clock.  If the old system peer is on the list
         * and at the same stratum as the first survivor on the list,
         * then don't do a clock hop.  Otherwise, select the first
         * survivor on the list as the new system peer.
         */
        if (osys->stratum == s.v[0].p->stratum)
                s.p = osys;/* * 选择最好的时钟。如果旧系统对等体在列表 * 上，并且与列表中的第一个幸存者处于同一层，则 * 不要执行时钟跳跃。否则，请选择列表中的第一个 * 幸存者作为新的系统对等体。*/ if （osys->stratum == s.v[0].p->stratum） s.p = osys;Mills, et al.                Standards Track                   [Page 93]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 93 页] RFC 5905 NTPv4 规范 2010 年 6 月
        else
                s.p = s.v[0].p;
        clock_update(s.p);
}否则 s.p = s.v[0].p;clock_update（s.p）;}A.5.5.2.  root_dist() A.5.5.2. root_dist（）/*
 * root_dist() - calculate root distance
 */
double
root_dist(
        struct p *p             /* peer structure pointer */
        )
{/* * root_dist（） - 计算根距离 */ double root_dist（ struct p *p /* 对等结构指针 */ ） {        /*
         * The root synchronization distance is the maximum error due to
         * all causes of the local clock relative to the primary server.
         * It is defined as half the total delay plus total dispersion
         * plus peer jitter.
         */
        return (max(MINDISP, p->rootdelay + p->delay) / 2 +
            p->rootdisp + p->disp + PHI * (c.t - p->t) + p->jitter);
}/* * 根同步距离是由于 * 本地时钟相对于主服务器的所有原因导致的最大误差。* 它被定义为总延迟的一半加上总色散 * 加上对等抖动。*/ 返回 （max（MINDISP， p->rootdelay + p->delay） / 2 + p->rootdisp + p->disp + PHI * （c.t - p->t） + p->抖动）;}A.5.5.3.  accept() A.5.5.3. 接受（）/*
 * accept() - test if association p is acceptable for synchronization
 */
int
accept(
        struct p *p             /* peer structure pointer */
        )
{
        /*
         * A stratum error occurs if (1) the server has never been
         * synchronized, (2) the server stratum is invalid.
         */
        if (p->leap == NOSYNC || p->stratum >= MAXSTRAT)
                return (FALSE);/* * accept（） - 测试关联 p 是否可接受同步 */ int accept（ struct p *p /* 对等结构指针 */ ） { /* * 如果 （1） 服务器从未 * 同步，（2） 服务器层无效，则会发生 stratum 错误。 */ if （p->leap == NOSYNC || p->stratum >= MAXSTRAT） return （FALSE）;        /*
         * A distance error occurs if the root distance exceeds the
         * distance threshold plus an increment equal to one poll
         * interval.
         *//* * 如果根距离超过 * 距离阈值加上等于 1 轮询 * 间隔的增量，则会发生距离错误。*/Mills, et al.                Standards Track                   [Page 94]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 94 页] RFC 5905 NTPv4 规范 2010 年 6 月
        if (root_dist(p) > MAXDIST + PHI * LOG2D(s.poll))
                return (FALSE);如果 （root_dist（p） > MAXDIST + PHI * LOG2D（s.poll）） 返回 （FALSE）;        /*
         * A loop error occurs if the remote peer is synchronized to the
         * local peer or the remote peer is synchronized to the current
         * system peer.  Note this is the behavior for IPv4; for IPv6
         * the MD5 hash is used instead.
         */
        if (p->refid == p->dstaddr || p->refid == s.refid)
                return (FALSE);/* * 如果远程对等体同步到 * 本地对等体或远程对等体与当前 * 系统对等体同步，则会发生循环错误。请注意，这是 IPv4 的行为;对于 IPv6 * 改用 MD5 哈希。*/ if （p->refid == p->dstaddr || p->refid == s.refid） 返回 （FALSE）;        /*
         * An unreachable error occurs if the server is unreachable.
         */
        if (p->reach == 0)
                return (FALSE);/* * 如果服务器无法访问，则会发生无法访问错误。*/ if （p->reach == 0） 返回 （FALSE）;        return (TRUE);
} 返回 （TRUE）;}A.5.5.4.  clock_update() A.5.5.4. clock_update（）/*
 * clock_update() - update the system clock
 */
void
clock_update(
        struct p *p             /* peer structure pointer */
        )
{
        double dtemp;/* * clock_update（） - 更新系统时钟 */ void clock_update（ struct p *p /* 对等结构指针 */ ） { double dtemp;        /*
         * If this is an old update, for instance, as the result of a
         * system peer change, avoid it.  We never use an old sample or
         * the same sample twice.
         */
        if (s.t >= p->t)
                return;/* * 如果这是一个旧的更新，例如，由于 * 系统对等体更改，请避免它。我们从不使用旧样本或*同一样本两次。*/ if （s.t >= p->t） 返回;        /*
         * Combine the survivor offsets and update the system clock; the
         * local_clock() routine will tell us the good or bad news.
         */
        s.t = p->t;
        clock_combine();
        switch (local_clock(p, s.offset)) {/* * 合并幸存者偏移量并更新系统时钟;* local_clock（） 例程会告诉我们好消息或坏消息。*/ s.t = p->t;clock_combine（）;开关 （local_clock（p， s.offset）） {Mills, et al.                Standards Track                   [Page 95]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 95 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * The offset is too large and probably bogus.  Complain to the
         * system log and order the operator to set the clock manually
         * within PANIC range.  The reference implementation includes a
         * command line option to disable this check and to change the
         * panic threshold from the default 1000 s as required.
         */
        case PANIC:
                exit (0);/* * 偏移量太大，可能是假的。向 * 系统日志投诉并命令操作员在 PANIC 范围内手动设置时钟 *。参考实现包括一个 * 命令行选项，用于禁用此检查并根据需要将 * 紧急阈值从默认 1000 秒更改。*/ case PANIC：退出 （0）;        /*
         * The offset is more than the step threshold (0.125 s by
         * default).  After a step, all associations now have
         * inconsistent time values, so they are reset and started
         * fresh.  The step threshold can be changed in the reference
         * implementation in order to lessen the chance the clock might
         * be stepped backwards.  However, there may be serious
         * consequences, as noted in the white papers at the NTP project
         * site.
         */
        case STEP:
                while (/* all associations */ 0)
                        clear(p, X_STEP);
                s.stratum = MAXSTRAT;
                s.poll = MINPOLL;
                break;/* * 偏移量大于步进阈值（* 默认为 0.125 秒）。经过一个步骤后，所有关联现在都具有 * 不一致的时间值，因此它们将被重置并重新开始 * 重新。可以在参考 * 实现中更改步进阈值，以减少时钟 * 向后退的可能性。但是，正如NTP项目*站点的白皮书中所指出的那样，可能会产生严重的*后果。*/ case STEP： while （/* 所有关联 */ 0） clear（p， X_STEP）;s.stratum = MAXSTRAT;s.poll = MINPOLL;破;        /*
         * The offset was less than the step threshold, which is the
         * normal case.  Update the system variables from the peer
         * variables.  The lower clamp on the dispersion increase is to
         * avoid timing loops and clockhopping when highly precise
         * sources are in play.  The clamp can be changed from the
         * default .01 s in the reference implementation.
         */
        case SLEW:
                s.leap = p->leap;
                s.stratum = p->stratum + 1;
                s.refid = p->refid;
                s.reftime = p->reftime;
                s.rootdelay = p->rootdelay + p->delay;
                dtemp = SQRT(SQUARE(p->jitter) + SQUARE(s.jitter));
                dtemp += max(p->disp + PHI * (c.t - p->t) +
                    fabs(p->offset), MINDISP);
                s.rootdisp = p->rootdisp + dtemp;
                break;/* * 偏移量小于阶跃阈值，这是 * 正常情况。从对等 * 变量更新系统变量。色散增加的下部箝位是为了避免在高精度 * 源起作用时出现时时的时序环路和时钟跳频。箝位可以从参考实现中的*默认.01秒更改。*/ 案例回转：s.leap = p->leap;S.stratum = p->stratum + 1;s.refid = p->refid;s.reftime = p->reftime;s.rootDelay = p->rootdelay + p->delay;dtemp = SQRT（SQUARE（p->抖动） + SQUARE（s.jitter））;dtemp += max（p->disp + PHI * （c.t - p->t） + fabs（p->偏移）， MINDISP）;s.rootdisp = p->rootdisp + dtemp;破;Mills, et al.                Standards Track                   [Page 96]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 96 页] RFC 5905 NTPv4 规范 2010 年 6 月
        /*
         * Some samples are discarded while, for instance, a direct
         * frequency measurement is being made.
         */
        case IGNORE:
                break;
        }
}/* * 例如，在进行直接 * 频率测量时，一些样品被丢弃。*/ case IGNORE： break;} }A.5.5.5.  clock_combine() A.5.5.5. clock_combine（）/*
 * clock_combine() - combine offsets
 */
void
clock_combine()
{
        struct p *p;            /* peer structure pointer */
        double x, y, z, w;
        int     i;/* * clock_combine（） - 组合偏移量 */ void clock_combine（） { struct p *p; /* 对等结构指针 */ double x， y， z， w; int i;        /*
         * Combine the offsets of the clustering algorithm survivors
         * using a weighted average with weight determined by the root
         * distance.  Compute the selection jitter as the weighted RMS
         * difference between the first survivor and the remaining
         * survivors.  In some cases, the inherent clock jitter can be
         * reduced by not using this algorithm, especially when frequent
         * clockhopping is involved.  The reference implementation can
         * be configured to avoid this algorithm by designating a
         * preferred peer.
         */
        y = z = w = 0;
        for (i = 0; s.v[i].p != NULL; i++) {
                p = s.v[i].p;
                x = root_dist(p);
                y += 1 / x;
                z += p->offset / x;
                w += SQUARE(p->offset - s.v[0].p->offset) / x;
        }
        s.offset = z / y;
        s.jitter = SQRT(w / y);
}/* * 使用加权平均值将聚类算法幸存者 * 的偏移量与根 * 距离确定的权重合并。将选择抖动计算为第一个幸存者和其余 * 幸存者之间的加权 RMS * 差值。在某些情况下，不使用此算法可以*减少固有的时钟抖动，特别是当涉及频繁的*时钟跳频时。可以通过指定 * 首选对等体来配置参考实现以避免此算法。*/ y = z = w = 0;for （i = 0; s.v[i].p ！= NULL; i++） { p = s.v[i].p; x = root_dist（p）; y += 1 / x; z += p->offset / x; w += SQUARE（p->offset - s.v[0].p->offset） / x; } s.offset = z / y;抖动 = SQRT（w / y）;}
Mills, et al.                Standards Track                   [Page 97]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 97 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.5.5.6.  local_clock() A.5.5.6. local_clock（）/*
 * Clock discipline parameters and constants
 */
#define STEPT           .128    /* step threshold (s) */
#define WATCH           900     /* stepout threshold (s) */
#define PANICT          1000    /* panic threshold (s) */
#define PLL             65536   /* PLL loop gain */
#define FLL             MAXPOLL + 1 /* FLL loop gain */
#define AVG             4       /* parameter averaging constant */
#define ALLAN           1500    /* compromise Allan intercept (s) */
#define LIMIT           30      /* poll-adjust threshold */
#define MAXFREQ         500e-6  /* frequency tolerance (500 ppm) */
#define PGATE           4       /* poll-adjust gate *//* * 时钟规程参数和常数 */ #define STEPT .128 /* 步进阈值 */ #define WATCH 900 /* 步进阈值 */ #define PANICT 1000 /* 恐慌阈值 */ #define PLL 65536 /* PLL 环路增益 */ #define FLL MAXPOLL + 1 /* FLL 环路增益 */ #define AVG 4 /* 参数平均常数 */ #define ALLAN 1500 /* 妥协 Allan 截距 （s） */ #define LIMIT 30 /* 轮询调整阈值 */ #define MAXFREQ 500e-6 /* 频率公差 （500 ppm） */ #define PGATE 4 /* 轮询调整门 *//*
 * local_clock() - discipline the local clock
 */
int                             /* return code */
local_clock(
        struct p *p,            /* peer structure pointer */
        double  offset          /* clock offset from combine() */
        )
{
        int     state;          /* clock discipline state */
        double  freq;           /* frequency */
        double  mu;             /* interval since last update */
        int     rval;
        double  etemp, dtemp;/* * local_clock（） - 规范本地时钟 */ int /* 返回码 */ local_clock（ struct p *p， /* 对等结构指针 */ double offset /* 时钟偏移量 combine（） */ ） { int state; /* 时钟纪律状态 */ double freq; /* 频率 */ double mu; /* 自上次更新以来的间隔 */ int rval; double etemp， dtemp;        /*
         * If the offset is too large, give up and go home.
         */
        if (fabs(offset) > PANICT)
                return (PANIC);/* * 如果偏移量太大，放弃回家。*/ if （fabs（offset） > PANICT） return （PANIC）;        /*
         * Clock state machine transition function.  This is where the
         * action is and defines how the system reacts to large time
         * and frequency errors.  There are two main regimes: when the
         * offset exceeds the step threshold and when it does not.
         */
        rval = SLEW;
        mu = p->t - s.t;
        freq = 0;
        if (fabs(offset) > STEPT) {
                switch (c.state) {/* * 时钟状态机转换函数。这是 * 动作所在，并定义了系统对大时间 * 和频率误差的反应方式。有两种主要机制：当 * 偏移量超过阶跃阈值时和未超过步进阈值时。 */ rval = SLEW;μ = p->t - s.t;频率 = 0;if （fabs（offset） > STEPT） { switch （c.state） {Mills, et al.                Standards Track                   [Page 98]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 98 页] RFC 5905 NTPv4 规范 2010 年 6 月
                /*
                 * In S_SYNC state, we ignore the first outlier and
                 * switch to S_SPIK state.
                 */
                case SYNC:
                        state = SPIK;
                        return (rval);/* * 在 S_SYNC 状态下，我们忽略第一个异常值，* 切换到 S_SPIK 状态。*/ 案例 SYNC： state = SPIK;返回 （RVAL）;                /*
                 * In S_FREQ state, we ignore outliers and inliers.  At
                 * the first outlier after the stepout threshold,
                 * compute the apparent frequency correction and step
                 * the time.
                 */
                case FREQ:
                        if (mu < WATCH)
                                return (IGNORE);/* * 在S_FREQ状态下，我们忽略异常值和异常值。在步进阈值后的第一个异常值 * 处，* 计算视频校正和步进 * 时间。*/ case FREQ： if （mu < WATCH） return （IGNORE）;                        freq = (offset - c.offset) / mu;
                        /* fall through to S_SPIK */频率 = （偏移量 - c.偏移量） / 亩;/* 跌入S_SPIK */                /*
                 * In S_SPIK state, we ignore succeeding outliers until
                 * either an inlier is found or the stepout threshold is
                 * exceeded.
                 */
                case SPIK:
                        if (mu < WATCH)
                                return (IGNORE);/* * 在S_SPIK状态下，我们忽略后续的异常值，直到找到 * 个异常值或超出步出阈值。*/ case SPIK：if （mu < WATCH） 返回 （IGNORE）;                        /* fall through to default *//* 跌入默认值 */                /*
                 * We get here by default in S_NSET and S_FSET states
                 * and from above in S_FREQ state.  Step the time and
                 * clamp down the poll interval.
                 *
                 * In S_NSET state, an initial frequency correction is
                 * not available, usually because the frequency file has
                 * not yet been written.  Since the time is outside the
                 * capture range, the clock is stepped.  The frequency
                 * will be set directly following the stepout interval.
                 *
                 * In S_FSET state, the initial frequency has been set
                 * from the frequency file.  Since the time is outside
                 * the capture range, the clock is stepped immediately,
                 * rather than after the stepout interval.  Guys get
                 * nervous if it takes 17 minutes to set the clock for/* * 默认情况下，我们以 S_NSET 和 S_FSET 状态到达此处，并从上面到达 S_FREQ 状态。步进时间并 * 箝制轮询间隔。* * 在S_NSET状态下，初始频率校正 * 不可用，通常是因为频率文件尚未写入。由于时间超出了 * 捕获范围，因此时钟是步进的。频率 * 将直接在步进间隔之后设置。* * 在S_FSET状态下，初始频率已从频率文件中设置 *。由于时间超出了捕获范围 *，因此时钟会立即步进，而不是在步进间隔之后。如果设置时钟需要 17 分钟，伙计们会感到紧张Mills, et al.                Standards Track                   [Page 99]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 99 页] RFC 5905 NTPv4 规范 2010 年 6 月
                 * the first time.
                 *
                 * In S_SPIK state, the stepout threshold has expired
                 * and the phase is still above the step threshold.
                 * Note that a single spike greater than the step
                 * threshold is always suppressed, even at the longer
                 * poll intervals.
                 */
                default:* 第一次。* * 在S_SPIK状态下，步进阈值已过期 * 且相位仍高于步进阈值。* 请注意，大于步长 * 阈值的单个峰值始终被抑制，即使在较长的 * 轮询间隔下也是如此。*/违约：                        /*
                         * This is the kernel set time function, usually
                         * implemented by the Unix settimeofday() system
                         * call.
                         */
                        step_time(offset);
                        c.count = 0;
                        s.poll = MINPOLL;
                        rval = STEP;
                        if (state == NSET) {
                                rstclock(FREQ, p->t, 0);
                                return (rval);
                        }
                        break;
                }
                rstclock(SYNC, p->t, 0);
        } else {/* * 这是内核设置时间函数，通常由 Unix settimeofday（） 系统 * 调用实现。*/ step_time（偏移）;c.计数 = 0;s.poll = MINPOLL;rval = 步;if （state == NSET） { rstclock（FREQ， p->t， 0）; return （rval）; } break;} rstclock（同步， p->t， 0）;} else {                /*
                 * Compute the clock jitter as the RMS of exponentially
                 * weighted offset differences.  This is used by the
                 * poll-adjust code.
                 */
                etemp = SQUARE(c.jitter);
                dtemp = SQUARE(max(fabs(offset - c.last),
                    LOG2D(s.precision)));
                c.jitter = SQRT(etemp + (dtemp - etemp) / AVG);
                switch (c.state) {/* * 将时钟抖动计算为指数 * 加权偏移差的 RMS。这由 * poll-adjust 代码使用。*/ etemp = 平方（c.抖动）;dtemp = SQUARE（max（fabs（offset - c.last）， LOG2D（s.precision）））;c.抖动 = SQRT（etemp + （dtemp - etemp） / AVG）;开关 （c.state） {                /*
                 * In S_NSET state, this is the first update received
                 * and the frequency has not been initialized.  The
                 * first thing to do is directly measure the oscillator
                 * frequency.
                 */
                case NSET:
                        rstclock(FREQ, p->t, offset);
                        return (IGNORE);/* * 在 S_NSET 状态下，这是收到的第一个更新 * 并且频率尚未初始化。*首先要做的是直接测量振荡器*频率。*/ 案例 NSET： rstclock（FREQ， p->t， offset）;返回 （IGNORE）;Mills, et al.                Standards Track                  [Page 100]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 100 页] RFC 5905 NTPv4 规范 2010 年 6 月
                /*
                 * In S_FSET state, this is the first update and the
                 * frequency has been initialized.  Adjust the phase,
                 * but don't adjust the frequency until the next update.
                 */
                case FSET:
                        rstclock(SYNC, p->t, offset);
                        break;/* * 在S_FSET状态下，这是第一次更新，* 频率已初始化。调整相位，*但在下次更新之前不要调整频率。*/ case FSET： rstclock（SYNC， p->t， offset）;破;                /*
                 * In S_FREQ state, ignore updates until the stepout
                 * threshold.  After that, correct the phase and
                 * frequency and switch to S_SYNC state.
                 */
                case FREQ:
                        if (c.t - s.t < WATCH)
                                return (IGNORE);/* * 在S_FREQ状态下，忽略更新，直到步出 * 阈值。之后，校正相位和 * 频率并切换到 S_SYNC 状态。*/ case FREQ： if （c.t - s.t < WATCH） return （IGNORE）;                        freq = (offset - c.offset) / mu;
                        break;频率 = （偏移量 - c.偏移量） / 亩;破;                /*
                 * We get here by default in S_SYNC and S_SPIK states.
                 * Here we compute the frequency update due to PLL and
                 * FLL contributions.
                 */
                default:/* * 默认情况下，我们以 S_SYNC 和 S_SPIK 状态到达此处。* 在这里，我们计算由于 PLL 和 * FLL 贡献而导致的频率更新。*/违约：                        /*
                         * The FLL and PLL frequency gain constants
                         * depending on the poll interval and Allan
                         * intercept.  The FLL is not used below one
                         * half the Allan intercept.  Above that the
                         * loop gain increases in steps to 1 / AVG.
                         */
                        if (LOG2D(s.poll) > ALLAN / 2) {
                                etemp = FLL - s.poll;
                                if (etemp < AVG)
                                        etemp = AVG;
                                freq += (offset - c.offset) / (max(mu,
                                    ALLAN) * etemp);
                        }/* * FLL 和 PLL 频率增益常数 * 取决于轮询间隔和 Allan * 截距。FLL不用于低于艾伦截距的1 *一半。在此之上，* 环路增益以步长递增至 1 / AVG。 */ if （LOG2D（s.poll） > ALLAN / 2） { etemp = FLL - s.poll; if （etemp < AVG） etemp = AVG; freq += （offset - c.offset） / （max（mu， ALLAN） * etemp）; }Mills, et al.                Standards Track                  [Page 101]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 101 页] RFC 5905 NTPv4 规范 2010 年 6 月
                        /*
                         * For the PLL the integration interval
                         * (numerator) is the minimum of the update
                         * interval and poll interval.  This allows
                         * oversampling, but not undersampling.
                         */
                        etemp = min(mu, LOG2D(s.poll));
                        dtemp = 4 * PLL * LOG2D(s.poll);
                        freq += offset * etemp / (dtemp * dtemp);
                        rstclock(SYNC, p->t, offset);
                        break;
                }
        }/* * 对于 PLL，积分间隔 *（分子）是更新 * 间隔和轮询间隔的最小值。这允许 * 过采样，但不允许欠采样。*/ etemp = min（mu， LOG2D（s.poll））;dtemp = 4 * PLL * LOG2D（s.poll）;频率 += 偏移量 * etemp / （dtemp * dtemp）;rstclock（同步，p->t，偏移）;破;} }        /*
         * Calculate the new frequency and frequency stability (wander).
         * Compute the clock wander as the RMS of exponentially weighted
         * frequency differences.  This is not used directly, but can,
         * along with the jitter, be a highly useful monitoring and
         * debugging tool.
         */
        freq += c.freq;
        c.freq = max(min(MAXFREQ, freq), -MAXFREQ);
        etemp = SQUARE(c.wander);
        dtemp = SQUARE(freq);
        c.wander = SQRT(etemp + (dtemp - etemp) / AVG);/* * 计算新的频率和频率稳定性（漂移）。* 将时钟漂移计算为指数加权 * 频率差的 RMS。这不能直接使用，但可以与抖动一起成为非常有用的监控和调试工具。*/ 频率 += c.频率;c.freq = max（min（MAXFREQ， freq）， -MAXFREQ）;etemp = 平方（c.wander）;dtemp = 平方（频率）;c.wander = SQRT（etemp + （dtemp - etemp） / AVG）;        /*
         * Here we adjust the poll interval by comparing the current
         * offset with the clock jitter.  If the offset is less than the
         * clock jitter times a constant, then the averaging interval is
         * increased; otherwise, it is decreased.  A bit of hysteresis
         * helps calm the dance.  Works best using burst mode.
         */
        if (fabs(c.offset) < PGATE * c.jitter) {
                c.count += s.poll;
                if (c.count > LIMIT) {
                        c.count = LIMIT;
                        if (s.poll < MAXPOLL) {
                                c.count = 0;
                                s.poll++;
                        }
                }
        } else {
                c.count -= s.poll << 1;
                if (c.count < -LIMIT) {
                        c.count = -LIMIT;
                        if (s.poll > MINPOLL) {/* * 这里我们通过比较当前 * 偏移量和时钟抖动来调整轮询间隔。如果偏移量小于 * 时钟抖动乘以一个常数，则平均间隔增加 *;否则，它会减少。一点滞后*有助于平静舞蹈。使用连拍模式效果最佳。*/ if （fabs（c.offset） < PGATE * c.jitter） { c.count += s.poll; if （c.count > LIMIT） { c.count = LIMIT; if （s.poll < MAXPOLL） { c.count = 0; s.poll++; } } } else { c.count -= s.poll << 1; if （c.count < -LIMIT） { c.count = -LIMIT; if （s.poll > MINPOLL） {Mills, et al.                Standards Track                  [Page 102]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 102 页] RFC 5905 NTPv4 规范 2010 年 6 月
                                c.count = 0;
                                s.poll--;
                        }
                }
        }
        return (rval);
}c.计数 = 0;s.poll--;} } } 返回 （rval）;}A.5.5.7.  rstclock() A.5.5.7. rstclock（）  /*
   * rstclock() - clock state machine
   */
  void
  rstclock(
          int     state,          /* new state */
          double  offset,         /* new offset */
          double  t               /* new update time */
          )
  {
          /*
           * Enter new state and set state variables.  Note, we use the
           * time of the last clock filter sample, which must be earlier
           * than the current time.
           */
          c.state = state;
          c.last = c.offset = offset;
          s.t = t;
  }/* * rstclock（） - 时钟状态机 */ void rstclock（ int state， /* 新状态 */ double offset， /* 新偏移量 */ double t /* 新更新时间 */ ） { /* * 输入新状态并设置状态变量。请注意，我们使用最后一个时钟滤波器样本的 * 时间，该时间必须早于当前时间的 *。*/ c.state = 状态;c.last = c.offset = 偏移量;s.t = t;}A.5.6.  Clock Adjust ProcessA.5.6. 时钟调整过程A.5.6.1.  clock_adjust() A.5.6.1. clock_adjust（） /*
  * clock_adjust() - runs at one-second intervals
  */
 void
 clock_adjust() {
         double  dtemp;/* * clock_adjust（） - 以一秒的间隔运行 */ void clock_adjust（） { double dtemp;         /*
          * Update the process time c.t.  Also increase the dispersion
          * since the last update.  In contrast to NTPv3, NTPv4 does not
          * declare unsynchronized after one day, since the dispersion
          * threshold serves this function.  When the dispersion exceeds
          * MAXDIST (1 s), the server is considered unfit for
          * synchronization./* * 更新处理时间 c.t.自上次更新以来，还增加了色散*。与 NTPv3 相比，NTPv4 不会在一天后声明不同步，因为色散 * 阈值具有此功能。当离散度超过 * MAXDIST（1 秒）时，认为服务器不适合 * 同步。Mills, et al.                Standards Track                  [Page 103]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 103 页] RFC 5905 NTPv4 规范 2010 年 6 月
          */
         c.t++;
         s.rootdisp += PHI;*/ c.t++;s.rootdisp += PHI;         /*
          * Implement the phase and frequency adjustments.  The gain
          * factor (denominator) is not allowed to increase beyond the
          * Allan intercept.  It doesn't make sense to average phase
          * noise beyond this point and it helps to damp residual offset
          * at the longer poll intervals.
          */
         dtemp = c.offset / (PLL * min(LOG2D(s.poll), ALLAN));
         c.offset -= dtemp;/* * 实施相位和频率调整。增益 * 因子（分母）不允许增加超过 * Allan 截距。平均相位*噪声超过这一点是没有意义的，它有助于在较长的轮询间隔内抑制残余偏移*。*/ dtemp = c.offset / （PLL * min（LOG2D（s.poll）， ALLAN））;c.offset -= dtemp;         /*
          * This is the kernel adjust time function, usually implemented
          * by the Unix adjtime() system call.
          */
         adjust_time(c.freq + dtemp);/* * 这是内核调整时间函数，通常由 Unix adjtime（） 系统调用实现。*/ adjust_time（c.freq + dtemp）;         /*
          * Peer timer.  Call the poll() routine when the poll timer
          * expires.
          */
         while (/* all associations */ 0) {
                 struct p *p;    /* dummy peer structure pointer *//* * 对等计时器。当轮询计时器 * 过期时调用 poll（） 例程。*/ while （/* 所有关联 */ 0） { struct p *p; /* 虚拟对等结构指针 */                 if (c.t >= p->nextdate)
                         poll(p);
         }if （c.t >= p->nextdate） poll（p）;}         /*
          * Once per hour, write the clock frequency to a file.
          */
         /*
          * if (c.t % 3600 == 3599)
          *   write c.freq to file
          */
 }/* * 每小时一次，将时钟频率写入文件。*/ /* * if （c.t % 3600 == 3599） * 将 c.freq 写入文件 */ }A.5.7.  Poll Process A.5.7. 轮询过程   /*
    * Poll process parameters and constants
    */
   #define UNREACH         12      /* unreach counter threshold */
   #define BCOUNT          8       /* packets in a burst */
   #define BTIME           2       /* burst interval (s) *//* * 轮询进程参数和常量 */ #define UNREACH 12 /* 未到达计数器阈值 */ #define BCOUNT 8 /* 突发数据包 */ #define BTIME 2 /* 突发间隔 */Mills, et al.                Standards Track                  [Page 104]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 104 页] RFC 5905 NTPv4 规范 2010 年 6 月
A.5.7.1.  poll() A.5.7.1. poll（）/*
 * poll() - determine when to send a packet for association p->
 */
void
poll(
        struct p *p             /* peer structure pointer */
        )
{
        int     hpoll;
        int     oreach;/* * poll（） - 确定何时发送关联数据包 p-> */ void poll（ struct p *p /* 对等结构指针 */ ） { int hpoll; int oreach;        /*
         * This routine is called when the current time c.t catches up
         * to the next poll time p->nextdate.  The value p->outdate is
         * the last time this routine was executed.  The poll_update()
         * routine determines the next execution time p->nextdate.
         *
         * If broadcasting, just do it, but only if we are synchronized.
         */
        hpoll = p->hpoll;
        if (p->hmode == M_BCST) {
                p->outdate = c.t;
                if (s.p != NULL)
                        peer_xmit(p);
                poll_update(p, hpoll);
                return;
        }/* * 当当前时间 c.t 赶上 * 到下一个轮询时间 p->nextdate 时，将调用此例程。值 p->outdate 是上次执行此例程的时间。poll_update（） * 例程确定下一个执行时间 p->nextdate。* * 如果广播，就去做，但前提是我们是同步的。*/ HPoL = P->hpoll;if （p->hmode == M_BCST） { p->outdate = c.t; if （s.p ！= NULL） peer_xmit（p）; poll_update（p， hpoll）; return; }        /*
         * If manycasting, start with ttl = 1.  The ttl is increased by
         * one for each poll until MAXCLOCK servers have been found or
         * ttl reaches TTLMAX.  If reaching MAXCLOCK, stop polling until
         * the number of servers falls below MINCLOCK, then start all
         * over.
         */
        if (p->hmode == M_CLNT && p->flags & P_MANY) {
                p->outdate = c.t;
                if (p->unreach > BEACON) {
                        p->unreach = 0;
                        p->ttl = 1;
                        peer_xmit(p);
                } else if (s.n < MINCLOCK) {
                        if (p->ttl < TTLMAX)
                                p->ttl++;
                        peer_xmit(p);
                }/* * 如果是 manycasting，则从 ttl = 1 开始。每次轮询的 ttl 增加 * 1，直到找到 MAXCLOCK 服务器或 * ttl 达到 TTLMAX。如果达到 MAXCLOCK，请停止轮询，直到 * 服务器数量低于 MINCLOCK，然后重新开始所有 *。*/ if （p->hmode == M_CLNT && p->flags & P_MANY） { p->outdate = c.t; if （p->unreach > BEACON） { p->unreach = 0; p->ttl = 1; peer_xmit（p）; } else if （s.n < MINCLOCK） { if （p->ttl < TTLMAX） p->ttl++; peer_xmit（p）; }Mills, et al.                Standards Track                  [Page 105]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 105 页] RFC 5905 NTPv4 规范 2010 年 6 月
                p->unreach++;
                poll_update(p, hpoll);
                return;
        }
        if (p->burst == 0) {p->无法到达++;poll_update（p，hpoll）;返回;} 如果 （p->burst == 0） {                /*
                 * We are not in a burst.  Shift the reachability
                 * register to the left.  Hopefully, some time before
                 * the next poll a packet will arrive and set the
                 * rightmost bit.
                 */
                oreach = p->reach;
                p->outdate = c.t;
                p->reach = p->reach << 1;
                if (!(p->reach & 0x7))
                        clock_filter(p, 0, 0, MAXDISP);
                if (!p->reach) {/* * 我们没有爆发。将可访问性 * 寄存器向左移动。希望在下一次轮询之前的某个时间，一个数据包将到达并设置*最右边。*/ oreach = p->reach;p->过时 = c.t;p->reach = p->reach << 1;如果 （！（p->reach & 0x7）） clock_filter（p， 0， 0， MAXDISP）;if （！p->reach） {                        /*
                         * The server is unreachable, so bump the
                         * unreach counter.  If the unreach threshold
                         * has been reached, double the poll interval
                         * to minimize wasted network traffic.  Send a
                         * burst only if enabled and the unreach
                         * threshold has not been reached.
                         */
                        if (p->flags & P_IBURST && p->unreach == 0) {
                                p->burst = BCOUNT;
                        } else if (p->unreach < UNREACH)
                                p->unreach++;
                        else
                                hpoll++;
                        p->unreach++;
                } else {/* * 服务器无法访问，因此请颠簸 * unreach 计数器。如果已达到未到达阈值 *，则将轮询间隔 * 加倍，以最大程度地减少浪费的网络流量。仅当启用且未达到未达到 * 阈值时，才发送 * 突发。*/ if （p->flags & P_IBURST && p->unreach == 0） { p->burst = BCOUNT; } else if （p->unreach < UNREACH） p->unreach++; else hpoll++; p->unreach++; } else {                        /*
                         * The server is reachable.  Set the poll
                         * interval to the system poll interval.  Send a
                         * burst only if enabled and the peer is fit.
                         */
                        p->unreach = 0;
                        hpoll = s.poll;
                        if (p->flags & P_BURST && fit(p))
                                p->burst = BCOUNT;
                }
        } else {/* * 服务器是可访问的。将轮询 * 间隔设置为系统轮询间隔。仅当启用且对等体适合时，才发送 * 突发。*/ p->无法到达 = 0;hpoll = s.poll;if （p->flags & P_BURST && fit（p）） p->burst = BCOUNT;} } else {
Mills, et al.                Standards Track                  [Page 106]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 106 页] RFC 5905 NTPv4 规范 2010 年 6 月
                /*
                 * If in a burst, count it down.  When the reply comes
                 * back the clock_filter() routine will call
                 * clock_select() to process the results of the burst.
                 */
                p->burst--;
        }
        /*
         * Do not transmit if in broadcast client mode.
         */
        if (p->hmode != M_BCLN)
                peer_xmit(p);
        poll_update(p, hpoll);
}/* * 如果突发，请倒计时。当回复返回 * 时，clock_filter（） 例程将调用 * clock_select（） 来处理突发的结果。*/ p->突发--;} /* * 如果处于广播客户端模式，则不传输。*/ 如果 （p->hmode ！= M_BCLN） peer_xmit（p）;poll_update（p，hpoll）;}A.5.7.2.  poll_update() A.5.7.2. poll_update（）/*
 * poll_update() - update the poll interval for association p
 *
 * Note: This routine is called by both the packet() and poll() routine.
 * Since the packet() routine is executed when a network packet arrives
 * and the poll() routine is executed as the result of timeout, a
 * potential race can occur, possibly causing an incorrect interval for
 * the next poll.  This is considered so unlikely as to be negligible.
 */
void
poll_update(
        struct p *p,            /* peer structure pointer */
        int     poll            /* poll interval (log2 s) */
        )
{
        /*
         * This routine is called by both the poll() and packet()
         * routines to determine the next poll time.  If within a burst
         * the poll interval is two seconds.  Otherwise, it is the
         * minimum of the host poll interval and peer poll interval, but
         * not greater than MAXPOLL and not less than MINPOLL.  The
         * design ensures that a longer interval can be preempted by a
         * shorter one if required for rapid response.
         */
        p->hpoll = max(min(MAXPOLL, poll), MINPOLL);
        if (p->burst > 0) {
                if (p->nextdate != c.t)
                        return;
                else
                        p->nextdate += BTIME;
        } else {/* * poll_update（） - 更新关联 p 的轮询间隔 * * 注意：此例程由 packet（） 和 poll（） 例程调用。* 由于 packet（） 例程是在网络数据包到达 * 时执行的，而 poll（） 例程是作为超时的结果执行的，因此可能会发生 * 潜在的争用，从而可能导致 * 下一次轮询的间隔不正确。这被认为不太可能，可以忽略不计。*/ void poll_update（ struct p *p， /* 对等结构指针 */ int poll /* 轮询间隔 （log2 s） */ ） { /* * 此例程由 poll（） 和 packet（） * 例程调用，以确定下一次轮询时间。如果在突发 * 内，则轮询间隔为 2 秒。否则，它是主机轮询间隔和对等轮询间隔的最小值，但 * 不大于 MAXPOLL 且不小于 MINPOLL。* 设计确保在需要快速响应时，较长的间隔可以被 * 较短的间隔抢占。*/ p->hpoll = max（min（MAXPOLL， poll）， MINPOLL）;if （p->burst > 0） { if （p->nextdate ！= c.t） return; else p->nextdate += BTIME; } else {Mills, et al.                Standards Track                  [Page 107]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 107 页] RFC 5905 NTPv4 规范 2010 年 6 月
                /*
                 * While not shown here, the reference implementation
                 * randomizes the poll interval by a small factor.
                 */
                p->nextdate = p->outdate + (1 << max(min(p->ppoll,
                    p->hpoll), MINPOLL));
        }/* * 虽然此处未显示，但参考实现 * 将轮询间隔随机化了一小部分。*/ p->nextdate = p->outdate + （1 << max（min（p->ppoll， p->hpoll）， MINPOLL））;}        /*
         * It might happen that the due time has already passed.  If so,
         * make it one second in the future.
         */
        if (p->nextdate <= c.t)
                p->nextdate = c.t + 1;
}/* * 可能到期时间已经过去了。如果是这样，*将来一秒钟。*/ 如果 （p->nextdate <= c.t） p->nextdate = c.t + 1;}A.5.7.3.  peer_xmit() A.5.7.3. peer_xmit（）/*
 * transmit() - transmit a packet for association p
 */
void
peer_xmit(
        struct p *p             /* peer structure pointer */
        )
{
        struct x x;             /* transmit packet *//* * transmit（） - 传输用于关联的数据包 p */ void peer_xmit（ struct p *p /* 对等结构指针 */ ） { struct x x; /* 传输数据包 */        /*
         * Initialize header and transmit timestamp
         */
        x.srcaddr = p->dstaddr;
        x.dstaddr = p->srcaddr;
        x.leap = s.leap;
        x.version = p->version;
        x.mode = p->hmode;
        if (s.stratum == MAXSTRAT)
                x.stratum = 0;
        else
                x.stratum = s.stratum;
        x.poll = p->hpoll;
        x.precision = s.precision;
        x.rootdelay = D2FP(s.rootdelay);
        x.rootdisp = D2FP(s.rootdisp);
        x.refid = s.refid;
        x.reftime = s.reftime;
        x.org = p->org;
        x.rec = p->rec;/* * 初始化标头并传输时间戳 */ x.srcaddr = p->dstaddr;x.dstaddr = p->srcaddr;x.leap = s.leap;x.version = p->版本;x.mode = p->hmode;如果 （s.stratum == MAXSTRAT） x.stratum = 0;否则 x.stratum = s.stratum;x.poll = p->hpoll;x.precision = s.precision;x.rootdelay = D2FP（s.rootdelay）;x.rootdisp = D2FP（s.rootdisp）;x.refid = s.refid;x.reftime = s.reftime;x.org = p->org;x.rec = p->rec;Mills, et al.                Standards Track                  [Page 108]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 108 页] RFC 5905 NTPv4 规范 2010 年 6 月
        x.xmt = get_time();
        p->xmt = x.xmt;x.xmt = get_time（）;p->xmt = x.xmt;        /*
         * If the key ID is nonzero, send a valid MAC using the key ID
         * of the association and the key in the local key cache.  If
         * something breaks, like a missing trusted key, don't send the
         * packet; just reset the association and stop until the problem
         * is fixed.
         */
        if (p->keyid)
                if (/* p->keyid invalid */ 0) {
                        clear(p, X_NKEY);
                        return;
                }
                x.dgst = md5(p->keyid);
        xmit_packet(&x);
}/* * 如果密钥 ID 为非零，则使用关联的密钥 ID * 和本地密钥缓存中的密钥发送有效的 MAC。如果 * 损坏了某些内容，例如缺少可信密钥，请不要发送 * 数据包;只需重置关联并停止，直到问题 * 得到解决。*/ if （p->keyid） if （/* p->keyid 无效 */ 0） { clear（p， X_NKEY）; return; } x.dgst = md5（p->keyid）;xmit_packet（&x）;}Mills, et al.                Standards Track                  [Page 109]

RFC 5905                   NTPv4 Specification                 June 2010Mills， et al. 标准跟踪 [第 109 页] RFC 5905 NTPv4 规范 2010 年 6 月
Authors' Addresses 作者地址   Dr. David L. Mills
   University of Delaware
   Newark, DE  19716
   USDavid L. Mills 博士 特拉华大学 纽瓦克，DE 19716 美国   Phone: +1 302 831 8247
   EMail: mills@udel.edu电话： +1 302 831 8247 电子邮件： mills@udel.edu
   Jim Martin (editor)
   Internet Systems Consortium
   950 Charter Street
   Redwood City, CA  94063
   USJim Martin （编辑） 互联网系统联盟 950 Charter Street Redwood City， CA 94063 US   Phone: +1 650 423 1378
   EMail: jrmii@isc.org电话： +1 650 423 1378 电子邮件： jrmii@isc.org
   Jack Burbank
   The Johns Hopkins University Applied Physics Laboratory
   11100 Johns Hopkins Road
   Laurel, MD  20723-6099
   US杰克·伯班克 约翰·霍普金斯大学应用物理实验室 11100 Johns Hopkins Road Laurel， MD 20723-6099 US   Phone: +1 443 778 7127
   EMail: jack.burbank@jhuapl.edu电话： +1 443 778 7127 电子邮件： jack.burbank@jhuapl.edu
   William Kasch
   The Johns Hopkins University Applied Physics Laboratory
   11100 Johns Hopkins Road
   Laurel, MD  20723-6099
   USWilliam Kasch 约翰霍普金斯大学应用物理实验室 11100 Johns Hopkins Road Laurel， MD 20723-6099 US   Phone: +1 443 778 7463
   EMail: william.kasch@jhuapl.edu电话： +1 443 778 7463 电子邮件： william.kasch@jhuapl.edu
Mills, et al.                Standards Track                  [Page 110]

Mills， et al. 标准跟踪 [第 110 页]
```