# 磁盘

[TOC]

## 硬盘

### 类型

* CMR
* SMR 叠瓦

### 参数

* **平均寻道时间（Average Seek Time）**

  指磁头移动到数据所在磁道需要的时间。

* **平均潜伏期（Average Latency）**

  指当磁头移动到数据所在的磁道以后，等待指定的数据扇区转动到磁头下方的时间。

* **平均访问时间（Average Access Time）**

  指从读/写指令发出到第一笔数据读/写实际开始所用的平均时间。

* **数据传输率（Data Transfer Rate）**

  指硬盘读写数据的速度MB/s。

### 接口

* IDE（Integrated Drive Electronics，电子集成驱动器）

  IDE 硬盘也称 “ATA硬盘” 或 “PATA硬盘” 。ATA100 的硬盘理论传输速率是 100MB/s 。

* SCSI（Small Computer System Interface，小型计算机系统接口）

  广泛应用在服务器上，具有应用范围广、多任务、带宽大、CPU占用率低及支持热插拔等优点。其理论传输速率达到 320MB/s 。

* FC(Fibre Channel)

* SATA（Serial ATA，串口硬盘）

  是速度更高的硬盘标准，具备了更高的传输速率，并具备了更强的纠错能力。目前已经是 SATA 三代，理论传输速率达到 600MB/s 。目前 SATA 硬盘接口已经取代 IDE 硬盘接口和 SCSI 硬盘接口，成为主流的硬盘接口。

* SAS(Serial Attached SCSI)

### 标签

#### 希捷

* SN:为保修的唯一凭证
* MODEL:为型号
* PN:作为产品批次号，不做验证之用
* FW:为固件版本
* Date:为生产日期
* Site:为希捷硬盘工厂

### 设备命名

| 设备                   | 文件名                 |
| ---------------------- | ---------------------- |
| IDE 硬盘               | /dev/hd[a-d]           |
| SCSI / SATA / USB 硬盘 | /dev/sd[a-p]           |
| 光驱                   | /dev/cdrom  、/dev/sr0 |
| 软盘                   | /dev/fd[0-1]           |



## Logical Volume Manager (LVM)[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#logical-volume-manager-lvm)

**L**ogical **V**olume **M**anager (*LVM]*)

Volume management creates an abstract layer on top of physical  storage, offering advantages over using physical storage directly:

- More flexible disk capacity;
- Online data movement;
- Disks in *stripe* mode;
- Mirrored volumes (recopy);
- Volume snapshots (*snapshot*).

The disadvantage is that if one of the physical volumes becomes out  of order, then all the logical volumes that use this physical volume are lost. You will have to use LVM on raid disks.

LVM is available under Linux from kernel version 2.4.

!!! Note LVM is only managed by the operating system. Therefore the *BIOS* needs at least one partition without LVM to boot.

### Volume groups[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#volume-groups)

The physical volumes *PV* *Physical Volumes* (from partitions) are combined into volume groups *VG*. Each *VG* represents disk space that can be partitioned into *LV* *Logical Volumes*. *Extension* is the smallest unit of fixed-size space that can be allocated.

- **PE** : *Physical Extension*
- **LE** : *Logical Extension*

![Volume group, PE size equal to 4MB](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-004.png)

### Logical volumes[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#logical-volumes)

A volume group, *VG*, is divided into logical volumes, *LV*, offering different operating modes:

- Linear volumes;
- Volumes in *stripe* mode;
- Mirrored volumes.

![Linear volumes](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-005.png)

![Volumes in stripe mode](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-006.png)

!!! Tip Striping_ improves performance by writing data to a predetermined number of physical volumes with a *round-robin* technique.

![Mirrored volumes](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-007.png)

### LVM commands for volume management[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#lvm-commands-for-volume-management)

#### `pvcreate` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#pvcreate-command)

The `pvcreate` command is used to create physical volumes. It turns Linux partitions (or disks) into physical volumes.

```
pvcreate [-options] partition
```

Example:

```
[root]# pvcreate /dev/hdb1
pvcreate -- physical volume « /dev/hdb1 » successfully created
```

You can also use a whole disk (which facilitates disk size increases in virtual environments for example).

```
[root]# pvcreate /dev/hdb
pvcreate -- physical volume « /dev/hdb » successfully created
```

| Option | Description                                                  |
| ------ | ------------------------------------------------------------ |
| `-f`   | Forces the creation of the volume (disk already transformed into physical volume). |

#### `vgcreate` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#vgcreate-command)

The `vgcreate` command is used to create volume groups. It groups one or more physical volumes into a volume group.

```
vgcreate volume physical_volume [PV...]
```

Example:

```
[root]# vgcreate volume1 /dev/hdb1
…
vgcreate – volume group « volume1 » successfully created and activated
```

#### `lvcreate` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#lvcreate-command)

The `lvcreate` command creates logical volumes. The file system is then created on these logical volumes.

```
lvcreate -L size [-n name] VG_name
```

Example:

```
[root]# lvcreate –L 600M –n VolLog1 volume1
lvcreate -- logical volume « /dev/volume1/VolLog1 » successfully created
```

| Option    | Description                                                  |
| --------- | ------------------------------------------------------------ |
| `-L size` | Logical volume size in K, M or G.                            |
| `-n name` | LV name. Special file created in `/dev/name_volume` with this name. |

### LVM commands to view volume information[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#lvm-commands-to-view-volume-information)

#### `pvdisplay` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#pvdisplay-command)

The `pvdisplay` command allows you to view information about the physical volumes.

```
pvdisplay /dev/PV_name
```

Example:

```
[root]# pvdisplay /dev/PV_name
```

#### `vgdisplay` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#vgdisplay-command)

The `vgdisplay` command allows you to view information about volume groups.

```
vgdisplay VG_name
```

Example:

```
[root]# vgdisplay volume1
```

#### `lvdisplay` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#lvdisplay-command)

The `lvdisplay` command allows you to view information about the logical volumes.

```
lvdisplay /dev/VG_name/LV_name
```

Example:

```
[root]# lvdisplay /dev/volume1/VolLog1
```

### Preparation of the physical media[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#preparation-of-the-physical-media)

The preparation with LVM of the physical support is broken down as follows:

- Setting up the physical disk
- Partitioning of the volumes
- **LVM physical volume**
- **LVM volume groups**
- **LVM logical volumes**
- Creating file systems
- Mounting file systems
- Manage user access

## Structure of a file system[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#structure-of-a-file-system)

A *file system* **FS** is in charge of the following actions:

- Securing access and modification rights to files;
- Manipulating files: create, read, modify and delete;
- Locating files on the disk;
- Managing partition space.

The Linux operating system is able to use different file systems  (ext2, ext3, ext4, FAT16, FAT32, NTFS, HFS, BtrFS, JFS, XFS, ...).

### `mkfs` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#mkfs-command)

The `mkfs` command allows you to create a Linux file system.

```
mkfs [-t fstype] filesys
```

Example:

```
[root]# mkfs -t ext4 /dev/sda1
```

| Option | Description                               |
| ------ | ----------------------------------------- |
| `-t`   | Indicates the type of file system to use. |

!!! Warning Without a file system it is not possible to use the disk space.

Each file system has a structure which is identical on each partition. A **boot block** and a **super block** initialized by the system and then an **inode table** and a **data area** initialized by the administrator.

!!! Note The only exception is the **swap** partition.

### Boot block[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#boot-block)

The **boot block** occupies the first block on the disk  and is present on all partitions. It contains the program that starts  and initializes the system and is therefore only filled in for the boot  partition.

### Super block[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#super-block)

The size of the **super block** table is defined at creation. It is present on each partition and contains the elements necessary for its utilization.

It describes the File System:

- Name of the Logical Volume;
- Name of the File System;
- Type of the File System;
- File System Status;
- Size of the File System;
- Number of free blocks;
- Pointer to the beginning of the list of free blocks;
- Size of the inode list;
- Number and list of free inodes.

A copy is loaded in the central memory as soon as the system is  initialized. This copy is updated as soon as it is modified and the  system saves it periodically (command `sync`).

When the system stops, it also copies this table in memory to its block.

### Table of inodes[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#table-of-inodes)

The size of the **inode table** is defined at its  creation and is stored on the partition. It consists of records, called  inodes, corresponding to the files created. Each record contains the  addresses of the data blocks making up the file.

!!! Note An inode number is unique within a file system.

A copy is loaded in the central memory as soon as the system is  initialized. This copy is updated as soon as it is modified and the  system saves it periodically (command `sync`).

When the system stops, it also copies this table in memory to its block.

A file is managed by its inode number.

!!! Note The size of the inode table determines the maximum number of files the FS can contain.

Information present in the *inode table* :

- Inode number;
- File type and access permissions;
- Owner identification number;
- Identification number of the owner group;
- Number of links on this file;
- Size of the file in bytes;
- Date the file was last accessed;
- Date the file was last modified;
- Date of the last modification of the inode (= creation);
- Table of several pointers (block table) to the logical blocks containing the pieces of the file.

### Data area[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#data-area)

Its size corresponds to the rest of the available space of the  partition. This area contains the catalogs corresponding to each  directory and the data blocks corresponding to the contents of the  files.

**In order to guarantee the consistency of the file system**, an image of the superblock and the inode table is loaded into memory  (RAM) when the operating system is loaded so that all I/O operations are done through these system tables. When the user creates or modifies  files, this memory image is updated first. The operating system must  therefore regularly update the superblock of the logical disk (`sync` command).

These tables are written to the hard disk when the system is shut down.

!!! Danger In the event of a sudden stop, the file system may lose its consistency and cause data loss.

### Repairing the file system[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#repairing-the-file-system)

It is possible to check the consistency of a file system with the `fsck` command.

In case of errors, solutions are proposed to repair the  inconsistencies. After repair, files that remain without entries in the  inode table are attached to the `/lost+found` folder of the logical drive.

#### `fsck` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#fsck-command)

The `fsck` command is a console-mode integrity check and repair tool for Linux file systems.

```
fsck [-sACVRTNP] [ -t fstype ] filesys
```

Example:

```
[root]# fsck /dev/sda1
```

To check the root partition, it is possible to create a `forcefsck` file and reboot or run `shutdown` with the `-F` option.

```
[root]# touch /forcefsck
[root]# reboot
or
[root]# shutdown –r -F now
```

!!! Warning The partition to be checked must be unmounted.

## Organization of a file system[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#organization-of-a-file-system)

By definition, a File System is a tree structure of directories built from a root directory (a logical device can only contain one file  system).

![Organization of a file system](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-008.png)

!!! Note In Linux everything is a file.

Text document, directory, binary, partition, network resource, screen, keyboard, Unix kernel, user program, ...

Linux meets the **FHS** (*Filesystems Hierarchy Standard*) (see `man hier`) which defines the names of folders and their roles.

| Directory  | Observation                                                  | Abbreviation of               |
| ---------- | ------------------------------------------------------------ | ----------------------------- |
| `/`        | Contains special directories                                 |                               |
| `/boot`    | Files related to system startup                              |                               |
| `/sbin`    | Commands necessary for system startup and repair             | *system binaries*             |
| `/bin`     | Executables of basic system commands                         | *binaries*                    |
| `/usr/bin` | System administration commands                               |                               |
| `/lib`     | Shared libraries and kernel modules                          | *libraries*                   |
| `/usr`     | Everything that is not necessary for minimal system operation | *UNIX System Resources*       |
| `/mnt`     | For mounting temporary SF                                    | *mount*                       |
| `/media`   | For mounting removable media                                 |                               |
| `/root`    | Administrator's login directory                              |                               |
| `/home`    | User data                                                    |                               |
| `/tmp`     | Temporary files                                              | *temporary*                   |
| `/dev`     | Special device files                                         | *device*                      |
| `/etc`     | Configuration and script files                               | *editable text configuration* |
| `/opt`     | Specific to installed applications                           | *optional*                    |
| `/proc`    | Virtual file system representing different processes         | *processes*                   |
| `/var`     | Miscellaneous variable files                                 | *variables*                   |

- To perform a mount or unmount, at the tree level, you must not be under its mount point.
- Mounting on a non-empty directory does not delete the content. It is only hidden.
- Only the administrator can perform mounts.
- Mount points to be automatically mounted at boot time must be entered in `/etc/fstab`.

### `/etc/fstab` file[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#etcfstab-file)

The `/etc/fstab` file is read at system startup and  contains the mounts to be performed. Each file system to be mounted is  described on a single line, the fields being separated by spaces or  tabs.

!!! Note Lines are read sequentially (`fsck`, `mount`, `umount`).

```
/dev/mapper/VolGroup-lv_root   /         ext4    defaults        1   1
UUID=46….92                    /boot     ext4    defaults        1   2
/dev/mapper/VolGroup-lv_swap   swap      swap    defaults        0   0
tmpfs                          /dev/shm  tmpfs   defaults        0   0
devpts                         /dev/pts  devpts  gid=5,mode=620  0   0
sysfs                          /sys      sysfs   defaults        0   0
proc                           /proc     proc    defaults        0   0
  1                              2         3        4            5   6
```

| Column | Description                                                  |
| ------ | ------------------------------------------------------------ |
| 1      | File system device (`/dev/sda1`, UUID=..., ...)              |
| 2      | Mount point name, **absolute path** (except **swap**)        |
| 3      | Filesystem type (ext4, swap, ...)                            |
| 4      | Special options for mounting (`defaults`, `ro`, ...)         |
| 5      | Enable or disable backup management (0:not backed up, 1:backed up) |
| 6      | Check order when checking the SF with the `fsck` command (0:no check, 1:priority, 2:not priority) |

The `mount -a` command allows new mounts to be taken into account without rebooting. They are then written to the `/etc/mtab` file which contains the current mounts.

!!! Warning Only the mount points listed in `/etc/fstab` will be mounted on reboot.

It is possible to make a copy of the `/etc/mtab` file or to copy its contents to `/etc/fstab`.

### Mount management commands[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#mount-management-commands)

#### `mount` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#mount-command)

The `mount` command allows you to mount and view the logical drives in the tree.

```
mount [-option] [device] [directory]
```

Example:

```
[root]# mount /dev/sda7 /home
```

| Option | Description                                                  |
| ------ | ------------------------------------------------------------ |
| `-n`   | Mount without writing to `/etc/mtab`.                        |
| `-t`   | To indicate the type of file system to use.                  |
| `-a`   | Mounts all filesystems mentioned in `/etc/fstab`.            |
| `-r`   | Mounts the file system read-only (equivalent to `-o ro`).    |
| `-w`   | Mounts the file system read/write, by default (equivalent `-o rw`). |
| `-o`   | Argument followed by a comma-separated list of options (`remount`, `ro`, ...). |

!!! Note The `mount` command alone displays all mounted file systems.

#### `umount` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#umount-command)

The `umount` command is used to unmount logical drives.

```
umount [-option] [device] [directory]
```

Example:

```
[root]# umount /home
[root]# umount /dev/sda7
```

| Option | Description                                        |
| ------ | -------------------------------------------------- |
| `-n`   | Unmount without writing to `/etc/mtab`.            |
| `-r`   | If unmount fails, remount as read-only.            |
| `-f`   | Force unmount.                                     |
| `-a`   | Unmount all filesystems mentioned in `/etc/fstab`. |

!!! Note When disassembling, you must not stay below the mounting point. Otherwise, the following error message is displayed: `device is busy`.

## Types of files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#types-of-files)

As in any system, in order to be able to find one's way through the  tree structure and the file management, it is important to respect the  file naming rules.

- Files are coded on 255 characters;
- All ASCII characters can be used;
- Uppercase and lowercase letters are differentiated;
- No notion of extension.

Groups of words separated by spaces must be enclosed in quotation marks:

```
[root]# mkdir "working dir"
```

!!! Note While there is nothing technically wrong with creating a  file or directory with a space in it, it is generally a "best practice"  to avoid this and replace any space with an underscore.

!!! Note The **.** at the beginning of the file name only serves to hide it from a simple `ls`.

!!! Warning Under Linux, the extension of a file is not a necessary  reference to open or modify it. However, it can be useful for the user.

Examples of extension agreements:

- `.c` : source file in C language;
- `.h` : C and Fortran header file;
- `.o` : object file in C language;
- `.tar` : data file archived with the `tar` utility;
- `.cpio` : data file archived with the `cpio` utility;
- `.gz` : data file compressed with the `gzip` utility;
- `.tgz` : data file archived with the `tar` utility and compressed with the `gzip` utility;
- `.html` : web page.

### Details of a file name[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#details-of-a-file-name)

```
[root]# ls -liah /usr/bin/passwd
266037 -rwsr-xr-x 1 root root 59K mars  22  2019 /usr/bin/passwd
1      2    3     4  5    6    7       8               9
```

| Row  | Description                                                |
| ---- | ---------------------------------------------------------- |
| `1`  | Inode number                                               |
| `2`  | File type (1st character of the block of 10)               |
| `3`  | Access rights (last 9 characters of the block of 10)       |
| `4`  | Number of links (ordinary) or subdirectories (directories) |
| `5`  | Name of the owner                                          |
| `6`  | Name of the group                                          |
| `7`  | Size (byte, kilo, mega)                                    |
| `8`  | Date of last update                                        |
| `9`  | Name of the file                                           |

### Different types of files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#different-types-of-files)

The following types of files can be found on a system:

- Ordinary (text, binary, ...);
- Directories;
- Special (printers, screens, ...);
- Links;
- Communications (tubes and socket).

#### Ordinary files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#ordinary-files)

These are text, program (source), executable (after compilation) or data (binary, ASCII) and multimedia files.

```
[root]# ls -l myfile
-rwxr-xr-x   1   root  root  26  nov  31  15:21 myfile
```

The dash `-` at the beginning of the rights group (10-character block) indicates that it is an ordinary file type.

#### Directory files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#directory-files)

Directory files contain references to other files.

By default in each directory are present **.**  and **..**.

- The **.** represents the position in the tree.
- The **..** represents the father of the current position.

```
[root]# ls -l mydirectory
drwxr-xr-x   1   root  root  26  nov  31  15:21 mydirectory
```

The letter `d` at the beginning of the rights group indicates that it is a directory type file.

#### Special files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#special-files)

In order to communicate with peripherals (hard disks, printers, ...), Linux uses interface files called special files (*device file* or *special file*). They allow identification by the peripherals.

These files are special because they do not contain data but specify the access mode to communicate with the device.

They are defined in two modes:

- **block** mode;
- **character** mode.

##### Block mode[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#block-mode)

The special **block mode** file allows, using the system buffers, to transfer data to the device.

```
[root]# ls -l /dev/sda
brw-------   1   root  root  8, 0 jan 1 1970 /dev/sda
```

The letter `b` at the beginning of the rights group indicates that it is a special file **block**.

##### Character mode[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#character-mode)

The special *character mode* file is used to transfer data to  the device as a stream of one character at a time without using a  buffer. These are devices like printer, screen or DAT tapes, ...

The standard output is the screen.

```
[root]# ls -l /dev/tty0
crw-------   1   root  root  8, 0 jan 1 1970 /dev/tty0
```

The letter `c` at the beginning of the rights group indicates that it is a special character file.

#### Communication files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#communication-files)

These are the pipe (*pipes*) and the *socket* files.

- **Pipe files** pass information between processes by FIFO (*First In, First Out*). One process writes transient information to a *pipe* file and another reads it. After reading, the information is no longer accessible.
- **Socket files** allow bidirectional inter-process communication (on local or remote systems). They use an *inode* of the file system.

#### Link files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#link-files)

These files give the possibility to give several logical names to the same physical file. A new access point to the file is therefore  created.

There are two types of link files:

- Physical links;
- Symbolic links.

##### Physical link[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#physical-link)

The link file and the source file have the same *inode* number and the link counter is incremented. It is not possible to link  different directories or files from different file systems.

!!! Warning If the source file is destroyed, the counter is decremented and the link file still accesses the file.

###### Command `ln` for a physical link[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#command-ln-for-a-physical-link)

The `ln` command allows you to create physical links.

```
[root]# ls –li letter
666 –rwxr--r-- 1 root root … letter
[root]# ln /home/paul/letter /home/jack/read
[root]# ls –li /home/*/*
666 –rwxr--r-- 2 root root … letter
666 –rwxr--r-- 2 root root … read
```

![Representation of a physical link](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-009.png)

##### Symbolic link[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#symbolic-link)

Unlike the physical link, the symbolic link involves the creation of a new *inode*. At the symbolic link level, only a path is stored in the inode table.

The file created contains only an indication of the path to the file. This notion no longer has the limitations of physical links and it is  now possible to link directories and files belonging to different file  systems.

!!! Warning If the source file is destroyed, the link file can no longer access the file.

###### `ln` command for a symbolic link[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#ln-command-for-a-symbolic-link)

The command `ln` with the argument `-s` allows to create symbolic links.

```
[root]# ls –li letter
666 -rwxr--r-- 1 root root … letter
[root]# ln -s /home/paul/letter /tmp/read
[root]# ls –li /home/paul/letter /tmp/read
666 -rwxr--r--- 1 root root … letter
678 lrwxrwxrwx 1 root root … read -> letter
```

![Representation of a symbolic link](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-010.png)

## File attributes[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#file-attributes)

Linux is a multi-user operating system where the control of access to files is essential.

These controls are functions of:

- file access permissions ;
- users (*ugo* *Users Groups Others*).

The command `ls -l` allows to display the attributes.

There are 4 file access rights:

- **r**ead;
- **w**rite;
- e**x**ecution;
- **-** no right.

!!! Warning The rights associated with files differ from those associated with directories (see below).

The user types associated with file access rights are:

- **u**ser_ (owner) ;
- **g**roup_ (owner group);
- **o**thers (others users);

In some commands it is possible to designate everyone with **a** (*all*).

**a = ugo**

### Rights associated with ordinary files[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#rights-associated-with-ordinary-files)

- **r**ead: Allows reading a file (`cat`, `less`, ...) and copying a file (`cp`, ...).
- **w**rite: Allows modification of the file content (`cat`, `>>`, `vim`, ...).
- e**x**ecute: Considers the file as an e**X**ecutable (binary or script).
- **-**: No permissions.

!!! Note Moving or renaming a file depends on the rights of the  target directory. Deleting a file depends on the rights of the parent  directory.

### Rights associated with directories[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#rights-associated-with-directories)

- **r**ead: Allows reading the contents of a directory (`ls -R`).
- **w**rite: Allows modification of the contents of a directory (`touch`) and allows creation and deletion of files if the **x** permission is enabled.
- e**x**ecute: Allows descending in the directory (`cd`).
- **-**: No rights.

### Attribute management[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#attribute-management)

The display of rights is done with the command `ls -l`. It is the last 9 characters of the block of 10. More precisely 3 times 3 characters.

```
[root]# ls -l /tmp/myfile
-rwxrw-r-x  1  root  sys  ... /tmp/myfile
  1  2  3       4     5
```

| Row  | Description                                       |
| ---- | ------------------------------------------------- |
| 1    | Owner (**u**ser) permissions, here `rwx`          |
| 2    | Owner group permissions (**g**roup), here `rw-`   |
| 3    | Other users' permissions (**o**thers), here `r-x` |
| 4    | File owner                                        |
| 5    | Group owner of the file                           |

!!! Note Permissions apply to **u**ser, **g**roup and **o**ther (**ugo**) depending on the owner and group.

By default, the *owner* of a file is the one who creates it. The *group* of the file is the group of the owner who created the file. The *others* are those which are not concerned by the previous cases.

The attributes are changed with the `chmod` command.

Only the administrator and the owner of a file can change the rights of a file.

#### `chmod` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#chmod-command)

The `chmod` command allows you to change the access permissions to a file.

```
chmod [option] mode file
```

The mode indication can be an octal representation (e.g. `744`) or a symbolic representation ([`ugoa`][`+=-`][`rwxst`]).

Several symbolic operations can be separated by commas

Example:

```
[root]# chmod -R u+rwx,g+wx,o-r /tmp/file1
[root]# chmod g=x,o-r /tmp/file2
[root]# chmod -R o=r /tmp/file3
[root]# ls -l /tmp/fic*
-rwxrwx--- 1 root root … /tmp/file1
-rwx--x--- 1 root root … /tmp/file2
-rwx--xr-- 1 root root … /tmp/file3
[root]# chmod 741 /tmp/file1
[root]# chmod -R 744 /tmp/file2
[root]# ls -l /tmp/fic*
-rwxr----x 1 root root … /tmp/file1
-rwxr--r-- 1 root root … /tmp/file2
```

| Option | Observation                                                  |
| ------ | ------------------------------------------------------------ |
| `-R`   | Recursively modify the permissions of directories and their contents. |

There are two methods for making rights changes:

- The **octal** method;
- The **symbolic** method.

!!! Warning The rights of files and directories are not dissociated.  For some operations, it will be necessary to know the rights of the  directory containing the file. A write-protected file can be deleted by  another user as long as the rights of the directory containing it allow  this user to perform this operation.

#### Principle of the octal method[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#principle-of-the-octal-method)

Each right has a value.

![Octal method](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-011.png)

```
[root]# ls -l /tmp/myfile
-rwxrwxrwx  1  root  root  ... /tmp/myfile
```

![Rights 777](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-012.png)

```
[root]# chmod 741 /tmp/myfile
-rwxr----x  1  root  root  ... /tmp/myfile
```

![Rights 741](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-013.png)

#### Principle of the symbolic method[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#principle-of-the-symbolic-method)

This method can be considered as a "literal" association between a user type, an operator, and rights.

![Symbolic method](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-014.png)

```
[root]# chmod u+rwx,g+wx,o-r /tmp/myfile
[root]# chmod g=x,o-r /tmp/myfile
[root]# chmod o=r /tmp/myfile
[root]# ls -l /tmp/myfile
r--r-- 1 root root … /tmp/myfile
[root]# chmod u+rwx,g+wx,o-r /tmp/myfile
[root]# ls -l /tmp/myfile
-rwxrwx--- 1 root root … /tmp/myfile
```

### Special rights[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#special-rights)

In addition to the fundamental rights (`rwx`), there are the particular rights:

- **set-user-ID** (*SUID]*)
- **set-group-ID** (*SGID]*)
- **sticky-bit**

As with the fundamental rights, the particular rights each have a value. This value is placed before the `ugo` set of rights.

![Special rights](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-015.png)

!!! Danger `S`, `S` and `T` in capital letters **if the right does not exist**.

#### The sticky-bit[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#the-sticky-bit)

One of the peculiarities of rights in Linux is that the right to write to a directory also allows deletion of *all* files, owner or not.

The *sticky-bit* set on the directory will only allow users to delete files they own. This is the basic case for the `/tmp` directory.

The setting of the *sticky-bit* can be done as follows:

Octal method:

```
[root]# chmod 1777 directory
```



Symbolic method:

```
[root]# chmod o+t directory
```



Verification:

```
[root]# ls -l
drwxrwxrwt … directory
```



#### SUID and SGID on a command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#suid-and-sgid-on-a-command)

These rights allow execution of a command according to the rights set on the command, and not according to the user's rights.

The command is executed with the identity of the owner (*SUID*) or the group (*SGID*) of the command.

!!! Note The identity of the user requesting the execution of the order is no longer taken into account.

```
This is an additional possibility of access rights assigned to a user when it is necessary for them to have the same rights as the owner of a file or those of the group concerned.
```

Indeed, a user may have to run a program (usually a system utility)  but not have the necessary access rights. By setting the appropriate  rights (**s** at the owner level and/or at the group  level), the user of the program has, for the time of its execution, the  identity of the owner (or that of the group) of the program.

Example:

The file `/usr/bin/passwd` is an executable file (a command) with a *SUID*.

When the user *bob* runs it, he will have to access the `/etc/shadow` file, but the permissions on this file do not allow *bob* to access it.

Having a *SUID* this command, `/usr/bin/passwd`, will be executed with the *UID* of root and the *GID* of *root*. The latter being the owner of the `/etc/shadow` file, he will have read rights.

![How the SUID works](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-016.png)

The setting of *SUID* and *SGID* can be done as below with the command `chmod`:

Octal method:

```
[root]# chmod 4777 command1
[root]# chmod 2777 command2
```



Symbolic method:

```
[root]# chmod u+s command1
[root]# chmod g+s command2
```



Verification:

```
[root]# ls -l
-rwsrwxrwx … command1
-rwxrwsrwx … command2
```



!!! Warning It is not possible to pass the *SUID* or *SGID* to a shell script. The system does not allow it because it is too dangerous for security!

#### SGID on a file[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#sgid-on-a-file)

In a directory with the *SGID* right, any file created will inherit the group that owns the directory instead of that of the creating user.

Example:

```
[rockstar] $ ls -ld /data/
drwxrwsr-x 2 root users 4096 26 oct. 19:43 /data
```



```
[rockstar] $ touch /data/test_sgid /tmp/fic_reference
[rockstar] $ ls -ld /data/test_sgid /tmp/fic_reference
-rw-r--r--. 1 rockstar users 0 26 oct. 19:43 /data/test_sgid <1>
-rw-r--r--. 1 rockstar rockstar 0 26 oct. 19:43  /tmp/fic_ref
```

<1> The `test_sgid` file inherits the group owner of its `/data` folder (in this case `users`) whatever the main group of the `rockstar` user is.

## Default rights and mask[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#default-rights-and-mask)

When a file or directory is created, it already has permissions.

- For a directory: `rwxr-xr-x` or *755*.
- For a file: `rw-r-r-` or *644*.

This behavior is defined by the **default mask**.

The principle is to remove the value defined by the mask at maximum rights without the execution right.

For a directory :

![How the SUID works](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-017.png)

For a file, the execution rights are removed:

![Default rights of a file](https://docs.rockylinux.org/books/admin_guide/images/07-file-systems-018.png)

### `umask` command[¶](https://docs.rockylinux.org/zh/books/admin_guide/07-file-systems/#umask-command)

The `umask` command allows you to display and modify the mask.

```
umask [option] [mode]
```

Example:

```
$ umask 033
$ umask
0033
$ umask -S
u=rwx,g=r,o=r
$ touch umask_033
$ ls -la  umask_033
-rw-r--r-- 1 rockstar rockstar 0 nov.   4 16:44 umask_033
$ umask 025
$ umask -S
u=rwx,g=rx,o=w
$ touch umask_025
$ ls -la  umask_025
-rw-r---w- 1 rockstar rockstar 0 nov.   4 16:44 umask_025
```



| Option | Description                      |
| ------ | -------------------------------- |
| `-S`   | Symbolic display of file rights. |

!!! Warning `umask` does not affect existing files.

!!! Note `umask` modifies the mask until the disconnection.

To keep the value, you have to modify the following profile files: For all users:

- `/etc/profile`
- `/etc/bashrc`

For a particular user:

- `~/.bashrc`

!!! Warning `umask -S` displays the file rights (without  the execute right) of the files that will be created. So it is not the  display of the mask used to subtract the maximum value.

!!! Tip The `umask` command being a *bash* command, (a `type umask` returns `umask is a shell primitive`) you have to search `umask` in `man bash`.

## 分区

### 分区形式



 

全局唯一标识分区表（GUID Partition  Table，缩写：GPT）是一个实体硬盘的分区结构。它是可扩展固件接口标准的一部分，用来替代BIOS中的主引导记录分区表。 传统的主启动记录  (MBR) 磁盘分区支持最大卷为 2.2 TB (terabytes) ，每个磁盘最多有 4 个主分区（或 3 个主分区，1  个扩展分区和无限制的逻辑驱动器）。 与MBR 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18  千兆兆字节 (exabytes，1EB=10^6TB) 的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID  (GUID)。
与 MBR   分区的磁盘不同，GPT的分区信息是在分区中，而不象MBR一样在主引导扇区。为保护GPT不受MBR类磁盘管理软件的危害，GPT在主引导扇区建立了一 个保护分区 (Protective   MBR)的MBR分区表，这种分区的类型标识为0xEE，这个保护分区的大小在Windows下为128MB，Mac OS   X下为200MB，在Window磁盘管理器里名为GPT保护分区，可让MBR类磁盘管理软件把GPT看成一个未知格式的分区，而不是错误地当成一个未分 区的磁盘。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。 

 MBR (Master Boot Record，主引导记录) 存储于磁盘的头部，大小为 512 bytes。其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。

在MBR硬盘中，分区信息直接存储于主引导记录(MBR)中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。跟现代的MBR一样，GPT也使用逻辑区块地址（LBA）取代了早期的CHS寻址方式。传统MBR信息存储于LBA 0，GPT头存储于LBA  1，接下来才是分区表本身。64位Windows操作系统使用16,384字节（或32扇区）作为GPT分区表，接下来的LBA  34是硬盘上第一个分区的开始。为了减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本。与主启动记录 (MBR) 分区方法相比，GPT  具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达18  千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区ID(GUID)。 

 

**GPT结构** 

 

GPT的结构见下图 

 

![img](http://img2081.poco.cn/mypoco/myphoto/20121220/21/5616035720121220214312091.png) 

 

**传统MBR (LBA 0)** 
在GPT分区表的最开头，处于兼容性考虑仍然存储了一份传统的MBR，用来防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据，这个MBR也叫做保护MBR。在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码。在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作，除非用户特别要求删除这个分区。这就避免了意外删除分区的危险。另外，能够识别GPT分区表的操作系统会检查保护MBR中的分区表，如果分区类型不是0xEE或者MBR分区表中有多个项，也会拒绝对硬盘进行操作。
在使用MBR/GPT混合分区表的硬盘中，这部分存储了GPT分区表的一部分分区（通常是前四个分区），可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区。如Boot Camp就是使用这种方式启动Windows。
**分区表头 (LBA 1)** 
分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。在使用64位Windows Server  2003的机器上，最多可以创建128个分区，即分区表中保留了128个项，其中每个都是128字节。（EFI标准要求分区表最小要有16,384字节，即128个分区项的大小）
分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA  1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还储存着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错了，可以使用软件从硬盘最后的备份GPT中恢复整个分区表，如果备份GPT也校验错误，硬盘将不可使用。所以GPT硬盘的分区表不可以直接使用16进制编辑器修改。
分区表头的格式如下 

 

| **起始字节** | **长度** | **内容**                                                     |
| ------------ | -------- | ------------------------------------------------------------ |
| 0            | 8字节    | 签名（"EFI PART", 45 46 49 20 50 41 52 54）                  |
| 8            | 4字节    | 修订（在1.0版中，值是 00 00 01 00）                          |
| 12           | 4字节    | 分区表头的大小（单位是字节，通常是92字节，即 5C 00 00 00）   |
| 16           | 4字节    | 分区表头（第0－91字节）的CRC32 校验，在计算时，把这个字段作为0处理，需要计算出分区串行的CRC32校验后再计算本字段 |
| 20           | 4字节    | 保留，必须是 0                                               |
| 24           | 8字节    | 当前LBA（这个分区表头的位置）                                |
| 32           | 8字节    | 备份LBA（另一个分区表头的位置）                              |
| 40           | 8字节    | 第一个可用于分区的LBA（主分区表的最后一个LBA + 1）           |
| 48           | 8字节    | 最后一个可用于分区的LBA（备份分区表的第一个LBA − 1）         |
| 56           | 16字节   | 硬盘GUID（在类UNIX 系统中也叫UUID）                          |
| 72           | 8字节    | 分区表项的起始LBA（在主分区表中是2）                         |
| 80           | 4字节    | 分区表项的数量                                               |
| 84           | 4字节    | 一个分区表项的大小（通常是128）                              |
| 88           | 4字节    | 分区串行的CRC32校验                                          |
| 92           | *        | 保留，剩余的字节必须是0（对于512字节LBA的硬盘即是420个字节） |

 

主分区表和备份分区表的头分别位于硬盘的第二个扇区（LBA 1）以及硬盘的最后一个扇区。备份分区表头中的信息是关于备份分区表的。 

 

**分区表项 (LBA 2–33)** 
GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性。
GPT分区表项的格式如下 

 

| **起始字节** | **长度** | **内容**                                   |
| ------------ | -------- | ------------------------------------------ |
| 0            | 16字节   | 分区类型GUID                               |
| 16           | 16字节   | 分区GUID                                   |
| 32           | 8字节    | 起始LBA（小端序 ）                         |
| 40           | 8字节    | 末尾LBA                                    |
| 48           | 8字节    | 属性标签（如：`60` 表示“只读”）            |
| 56           | 72字节   | 分区名（可以包括36个UTF-16（小端序）字符） |

 






1. MBR（主启动记录）

   ![](../Image/m/mbr.png)自1982年以来，方案指定了在运行BIOS固件的系统上如何对磁盘进行分区。最多支持4个主分区。在Linux系统上，可以使用扩展分区和逻辑分区来创建最多15个分区。由于分区大小数据以32位值存储，最大磁盘和分区大小为2TiB。

2. GPT

   对于运行统一可扩展固件接口(UEFI)固件的系统，GPT是在物理硬盘上布置分区表的标准。最多支持128个主分区。GPT为逻辑块地址分配64位，使得GPT可支持最多8ZiB的分区和磁盘。
   
   GPT使用全局唯一标识符（GUID）来识别每个磁盘和分区。GPT提供分区表信息的冗余，主GPT位于磁盘头部，备份副本（次要GPT）位于磁盘尾部。GPT使用校验和来检测GPT头和分区表中的错误与损坏。
   
   ![](../Image/g/p/gpt.png)

### 分区作用

1. 限制应用或用户的可用空间。
2. 将操作系统和程序文件与用户文件分隔开。
3. 创建用于内存交换的单独区域。
4. 限制磁盘空间使用，以提高诊断工具和备份映像的性能。

### 分区工具

1. parted
2. fdisk
3. gdisk

## WD硬盘分类
| 颜色 | 用途          |
|-----|--------------|
| 蓝   | 日常装机存储   |
| 黑   | 高性能游戏设计 |
| 红   | NAS          |
| 紫   | 监控         |
| 金   | 数据中心      |

| 颜色                                     | 蓝     | 黑     | 红   | 紫           | 金   |
| ---------------------------------------- | ------ | ------ | ---- | ------------ | ---- |
| 应用/使用                                | 日常PC | 高性能 | NAS  | Surveillance |      |
| 克隆软件                                 | O      | O      | O    | O            |      |
| 专为游戏而设计                           |        | O      |      |              |      |
| 专门针对图形和照片、视频编辑而进行了优化 |        | O      |      |              |      |
| 家用/办公用NAS                           |        |        | O    |              |      |
| 支持RAID                                 |        |        | O    |              |      |
| 专门针对监控系统进行了优化               |        |        |      | O            |      |
| 有限保修                                 | 3      | 5      | 3    | 3            |      |


## 硬盘结构

### 外部结构

* 电源接口

* 数据接口

* 控制电路板

  ![](../Image/h/hd_c.PNG)

  * 主控制芯片
  * 数据传输芯片
  * 高速数据缓存芯片

* 固定面板

### 内部结构

* 磁头组件
  * 最昂贵的部件，是硬盘技术最重要和关键的一环
  * 采用了非接触式结构，加电后悬浮在高速旋转的磁盘表面
  * 分类：读写合一式磁头 分离式磁头
* 磁头驱动机构
* 磁盘片
* 主轴组件
* 前端控制电路

## 磁道

当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，叫做磁道。

![](../Image/h/hd_cd.PNG)

## 柱面

硬盘通常由重叠的一组盘片组成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道组成一个圆柱，称之为柱面。

![](../Image/h/hd_zhm.PNG)

## 扇区

磁盘上的每个磁道被等分为若干个弧段，称为扇区。

![](../Image/h/hd_sq.PNG)

# 持久性命名属性概述

​			作为系统管理员，您需要引用使用持久性命名属性的存储卷来构建比多个系统引导更可靠存储设置。 	

## 13.1. 非持久性命名属性的缺陷

​				Red Hat Enterprise Linux 提供识别存储设备的多种方法。在使用时，务必要使用正确的选项来识别每个设备，以避免意外访问错误的设备，特别是在安装到或重新格式化驱动器时。 		

​				通常，Linux 中使用非持久性名称来表示存储设备，格式为 `/dev/sd*（主号）**（次号）*`。当检测到设备时，会为每个设备分配主号和次号范围，以及相关的 `sd` 名称。这意味着，如果设备检测顺序发生了变化，主号和次号范围之间的关联以及相关的 `sd` 名称可能会发生变化。 		

​				在以下情况下可能会在以下情况下更改排序： 		

- ​						系统引导过程的并行化会根据每个系统引导的顺序检测到存储设备。 				
- ​						磁盘无法启动或响应 SCSI 控制器。这会导致通常的设备探测不会检测到它。磁盘不能被系统访问，后续的设备将有其主号和次号范围，包括相关的 `sd` 名称会下移。例如，如果没有检测到通常称为 `sdb` 的磁盘，则通常称为 `sdc` 的磁盘将显示为 `sdb`。 				
- ​						SCSI 控制器（主机总线适配器或 HBA）无法初始化，从而导致不能检测到与该 HBA 连接的所有磁盘。任何连接到随后探测到的 HBA 的磁盘都会被分配不同的主号和次号范围，以及不同的相关 `sd` 名称。 				
- ​						如果系统中存在不同类型的 HBA，则驱动初始化顺序会改变。这会导致连接到那些 HBA 的磁盘以不同顺序被检测到。当将 HBA 移动到系统的不同 PCI 插槽时也会出现这种情况。 				
- ​						连接到带有光纤通道、iSCSI 或 FCoE  适配器的系统的磁盘可能在检测存储设备时无法访问，例如，由于存储阵列或中间交换机断电。如果存储阵列的在线需要比系统启动的时间更长，则系统在电源失败后重启时会出现这种情况。虽然某些光纤通道驱动程序支持一种机制来将持久性 SCSI 目标 ID 指定到 WWPN 映射，但这不会保留主号和次号范围，以及相关的 `sd` 名称，它只提供一致的 SCSI 目标 ID 号。 				

​				这些原因使得在引用设备(例如在 `/etc/fstab`文件中的)时不希望使用主号和次号范围或相关的 `sd` 名称。可能挂载了错误的设备，并可能导致数据崩溃。 		

​				然而，仍然有必要引用 `sd` 名称，即使使用了其它机制，比如当设备报告错误时。这是因为 Linux 内核在有关设备的内核消息中使用 `sd` 名称（以及 SCSI 主机/通道/目标/LUN 元组）。 		

## 13.2. 文件系统和设备识别符

​				这部分解释了识别文件系统和块设备的持久性属性之间的区别。 		

#### 文件系统识别符

​				文件系统标识符与在块设备中创建的特定文件系统绑定。标识符也作为文件系统的一部分保存。如果您将文件系统复制到不同的设备中，它仍采用相同的文件系统识别符。另一方面，如果您重写设备，比如使用 `mkfs` 工具进行格式化，设备会丢失属性。 		

​				文件系统识别符包括： 		

- ​						唯一标识符（UUID） 				
- ​						标签 				

#### 设备识别符

​				设备标识符与块设备绑定：例如磁盘或者分区。如果您重写设备，比如使用 `mkfs` 工具进行格式化，设备会保留属性，因为它没有存储在文件系统中。 		

​				设备识别符包括： 		

- ​						World Wide Identifier (WWID) 				
- ​						分区 UUID 				
- ​						序列号 				

#### 建议

- ​						有些文件系统（比如逻辑卷）会跨越多个设备。红帽建议您使用文件系统识别符而不是设备标识符访问这些文件系统。 				

## 13.3. 使用 /dev/disk/ 中的 udev 机制管理的设备名称

​				本节列出了 `udev` 服务在 `/dev/disk/` 目录中提供的不同类型的持久命名属性。 		

​				`udev` 机制用于 Linux 中的所有设备，而不仅仅是存储设备。对于存储设备，Red Hat Enterprise Linux 包含 在 `/dev/disk/` 目录中创建符号链接的 `udev` 规则。这可让您使用以下方法指向存储设备： 		

- ​						其内容 				
- ​						唯一标识符 				
- ​						它们的序列号。 				

​				虽然 `udev` 命名属性是持久的，但它们在系统重启后不会自行更改，但有一部分也是可以配置的。 		

### 13.3.1. 文件系统识别符

#### /dev/disk/by-uuid/ 中的 UUID 属性

​					此目录中的条目提供一个符号链接名称，通过存储在设备上的内容（即数据）中的 **唯一标识符** (UUID) 来指向存储设备。例如： 			

```none
/dev/disk/by-uuid/3e6be9de-8139-11d1-9106-a43f08d823a6
```

​					您可以使用以下语法，使用 UUID 指向 `/etc/fstab` 文件中的设备： 			

```none
UUID=3e6be9de-8139-11d1-9106-a43f08d823a6
```

​					您可以在创建文件系统时配置 UUID 属性，您也可以稍后修改它。 			

#### /dev/disk/by-label/ 中的 Label 属性

​					这个目录中的条目提供了一个符号链接名称，它们使用保存在该设备中的内容（即数据）的一个 **label** 指向存储设备。 			

​					例如： 			

```none
/dev/disk/by-label/Boot
```

​					您可以使用以下语法，使用标签来指向 `/etc/fstab` 文件中的设备： 			

```none
LABEL=Boot
```

​					您可以在创建文件系统时配置 Label 属性，您也可以稍后修改它。 			

### 13.3.2. 设备识别符

#### /dev/disk/by-id/ 中的 WWID 属性

​					全球识别符（WWID）是一个持久的、**系统独立的标识符**，SCSI 标准要求所有 SCSI 设备都使用它。保证 WWID 标识符对于每个存储设备都是唯一的，并且独立于用于访问该设备的路径。标识符是设备的属性，但不存储在设备上的内容（也就是数据）中。 			

​					可通过发出 SCSI 询问来检索设备识别重要产品数据（第 `0x83` 页）或单元序列号（第 `0x80` 页）来获取此标识符。 			

​					Red Hat Enterprise Linux 自动维护从基于 WWID 的设备名称到该系统上当前 `/dev/sd` 名称的正确映射。应用程序可以使用 `/dev/disk/by-id/` 名称来引用磁盘上的数据，即使设备的路径有变化，即使从不同的系统访问该设备也一样。 			

例 13.1. WWID 映射

| WWID 符号链接                                                | 非持久性设备 | 备注                         |
| ------------------------------------------------------------ | ------------ | ---------------------------- |
| `/dev/disk/by-id/scsi-3600508b400105e210000900000490000`     | `/dev/sda`   | 具有页面 `0x83` 标识符的设备 |
| `/dev/disk/by-id/scsi-SSEAGATE_ST373453LW_3HW1RHM6`          | `/dev/sdb`   | 具有页面 `0x80` 标识符的设备 |
| `/dev/disk/by-id/ata-SAMSUNG_MZNLN256HMHQ-000L7_S2WDNX0J336519-part3` | `/dev/sdc3`  | 磁盘分区                     |

​					除了系统提供的这些持久名称外，您还可以使用 `udev` 规则来实现映射到存储的 WWID 的持久名称。 			

#### /dev/disk/by-partuuid 中的分区 UUID 属性

​					分区 UUID(PARTUUID)属性标识 GPT 分区表定义的分区。 			

例 13.2. 分区 UUID 映射

| PARTUUID 符号链接                   | 非持久性设备 |
| ----------------------------------- | ------------ |
| `/dev/disk/by-partuuid/4cd1448a-01` | `/dev/sda1`  |
| `/dev/disk/by-partuuid/4cd1448a-02` | `/dev/sda2`  |
| `/dev/disk/by-partuuid/4cd1448a-03` | `/dev/sda3`  |

#### /dev/disk/by-path/ 中的 Path 属性

​					此属性通过用于访问该设备的 **硬件路径** 来提供一个指向存储设备的符号链接。 			

​					如果硬件路径的任何部分（如 PCI ID、目标端口或 LUN 号）发生变化，Path 属性会失败。因此 Path 属性是不可靠的。但是 Path 属性在以下情况下可能有用： 			

- ​							您需要识别您要替换的磁盘。 					
- ​							您计划在特定位置的磁盘中安装存储服务。 					

## 13.4. 使用 DM 多路径的通用识别符

​				这部分论述了全球识别符（WWID）与设备映射器多路径配置中非持久性设备名称之间的映射。 		

​				如果系统中有多路径到某个设备，DM 多路径会使用 WWID 探测到这个设备。然后，DM 多路径会在 `/dev/mapper/wwid` 目录中显示一个"pseudo-device"，如 `/dev/mapper/3600508b400105df70000e00000ac0000`。 		

​				`multipath -l` 命令显示到非持久性标识符的映射： 		

- ​						`*Host*:*Channel*:*Target*:*LUN*` 				
- ​						`/dev/sd` 名称 				
- ​						`*major*:*minor*` 号 				

例 13.3. 多路径配置中的 WWID 映射

​					`multipath -l` 命令的一个输出示例： 			

```none
3600508b400105df70000e00000ac0000 dm-2 vendor,product
[size=20G][features=1 queue_if_no_path][hwhandler=0][rw]
\_ round-robin 0 [prio=0][active]
 \_ 5:0:1:1 sdc 8:32  [active][undef]
 \_ 6:0:1:1 sdg 8:96  [active][undef]
\_ round-robin 0 [prio=0][enabled]
 \_ 5:0:0:1 sdb 8:16  [active][undef]
 \_ 6:0:0:1 sdf 8:80  [active][undef]
```

​				DM 多路径自动维护每个基于 WWID 的设备名称到系统上相应的 `/dev/sd` 名称的正确映射。这些名称可在路径更改之间保留，在从不同系统访问该设备时会保持一致。 		

​				当使用 DM 多路径的 `user_friendly_names` 功能时，WWID 被映射成 `/dev/mapper/mpath*N*` 形式的名称。默认情况下，此映射在 `/etc/multipath/bindings` 文件中维护。只要该文件被维护，这些 `mpath*N*` 名称就会持久存在。 		

重要

​					如果使用 `user_friendly_names`，则需要额外的步骤来获得集群中的一致名称。 			

## 13.5. udev 设备命名规则的限制

​				以下是 `udev` 命名规则的一些限制： 		

- ​						执行查询时可能无法访问设备，因为当为 `udev` 事件处理 `udev` 规则时，`udev` 机制可能依赖于查询存储设备的能力。当设备不在服务器机箱中时，这更可能会在光纤频道、iSCSI 或者 FCoE 存储设备中发生。 				
- ​						内核可能会随时发送 `udev` 事件，从而导致规则被处理，并可能导致设备无法访问时，`/dev/disk/by-*/` 链接被删除。 				
- ​						在 `udev` 事件产生和处理时，如检测到大量设备，用户空间 `udevd` 服务花费一些时间来处理每个事件的规则时，可能会有延迟。这可能会在内核检测到该设备和在 `/dev/disk/by-*/` 名称可用之间出现延迟。 				
- ​						规则调用的 `blkid` 等外部程序可能会打开设备一小段时间，从而使设备无法被其他用途访问。 				
- ​						/dev/disk/ 中由 `udev` 机制管理的设备名称可能会在主版本之间有所变化，需要您更新链接。 				

## 13.6. 列出持久性命名属性

​				这个步骤描述了如何找到非持久性存储设备的持久命名属性。 		

**流程**

- ​						要列出 UUID 和 Label 属性，请使用 `lsblk` 工具： 				

  ```none
  $ lsblk --fs storage-device
  ```

  ​						例如： 				

  例 13.4. 查看文件系统的 UUID 和标签

  ```none
  $ lsblk --fs /dev/sda1
  
  NAME FSTYPE LABEL UUID                                 MOUNTPOINT
  sda1 xfs    Boot  afa5d5e3-9050-48c3-acc1-bb30095f3dc4 /boot
  ```

- ​						要列出 PARTUUID 属性，请使用 `lsblk` 工具以及 `--output +PARTUUID` 选项： 				

  ```none
  $ lsblk --output +PARTUUID
  ```

  ​						例如： 				

  例 13.5. 查看分区的 PARTUUID 属性

  ```none
  $ lsblk --output +PARTUUID /dev/sda1
  
  NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT PARTUUID
  sda1   8:1    0  512M  0 part /boot      4cd1448a-01
  ```

- ​						要列出 WWID 属性，请检查 `/dev/disk/by-id/` 目录中符号链接的目标。例如： 				

  例 13.6. 查看系统中所有存储设备的 WWID

  ```none
  $ file /dev/disk/by-id/*
  
  /dev/disk/by-id/ata-QEMU_HARDDISK_QM00001
  symbolic link to ../../sda
  /dev/disk/by-id/ata-QEMU_HARDDISK_QM00001-part1
  symbolic link to ../../sda1
  /dev/disk/by-id/ata-QEMU_HARDDISK_QM00001-part2
  symbolic link to ../../sda2
  /dev/disk/by-id/dm-name-rhel_rhel8-root
  symbolic link to ../../dm-0
  /dev/disk/by-id/dm-name-rhel_rhel8-swap
  symbolic link to ../../dm-1
  /dev/disk/by-id/dm-uuid-LVM-QIWtEHtXGobe5bewlIUDivKOz5ofkgFhP0RMFsNyySVihqEl2cWWbR7MjXJolD6g
  symbolic link to ../../dm-1
  /dev/disk/by-id/dm-uuid-LVM-QIWtEHtXGobe5bewlIUDivKOz5ofkgFhXqH2M45hD2H9nAf2qfWSrlRLhzfMyOKd
  symbolic link to ../../dm-0
  /dev/disk/by-id/lvm-pv-uuid-atlr2Y-vuMo-ueoH-CpMG-4JuH-AhEF-wu4QQm
  symbolic link to ../../sda2
  ```

## 13.7. 修改持久性命名属性

​				这个步骤描述了如何更改文件系统的 UUID 或 Label persistent naming 属性。 		

注意

​					更改 `udev` 属性在后台进行，可能需要很长时间。`udevadm settle` 命令一直等待直到更改完全注册，这样可确保您的下一个命令能够正确使用新属性。 			

​				在以下命令中： 		

- ​						将 *new-uuid* 替换为您要设置的 UUID；例如，`1cdfbc07-1c90-4984-b5ec-f61943f5ea50`。您可以使用 `uuidgen` 命令生成一个 UUID。 				
- ​						使用标签替换 *new-label*，如 `backup_data`。 				

**先决条件**

- ​						如果您要修改 XFS 文件系统的属性，首先卸载它。 				

**流程**

- ​						要更改 **XFS** 文件系统的 UUID 或 Label 属性，请使用 `xfs_admin` 工具： 				

  ```none
  # xfs_admin -U new-uuid -L new-label storage-device
  # udevadm settle
  ```

- ​						要更改 **ext4**、**ext3** 或 **ext2** 文件系统的 UUID 或 Label 属性，请使用 `tune2fs` 工具： 				

  ```none
  # tune2fs -U new-uuid -L new-label storage-device
  # udevadm settle
  ```

- ​						要更改 swap 卷的 UUID 或 Label 属性，请使用 `swaplabel` 工具： 				

  ```none
  # swaplabel --uuid new-uuid --label new-label swap-device
  # udevadm settle
  ```

# 重新划分现存分区的大小

​			作为系统管理员，您可以显示块设备的分区表来查看分区布局和单个分区的详情。有关在块设备上使用分区的优缺点的概述，请参阅以下 KBase 文章：https://access.redhat.com/solutions/163853。 	

## 14.1. 查看使用 parted 的分区表

​				这个流程描述了如何使用 `parted` 工具来查看块设备上的分区表。 		

**流程**

1. ​						启动交互式 `parted` shell： 				

   ```none
   # parted block-device
   ```

   - ​								使用您要检查的设备的路径替换 *block-device* ：例如：`/dev/sda`。 						

2. ​						查看分区表： 				

   ```none
   (parted) print
   ```

3. ​						另外，使用以下命令切换到您想要检查下一个设备的另一个设备： 				

   ```none
   (parted) select block-device
   ```

**其它资源**

- ​						`parted(8)` 手册页。 				

## 14.2. parted print 的输出示例

​				本节提供了 `parted` shell 中的 `print` 命令的输出示例，并描述了输出中的字段。 		

例 14.1. print 命令的输出

```none
Model: ATA SAMSUNG MZNLN256 (scsi)
Disk /dev/sda: 256GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size    Type      File system  Flags
 1      1049kB  269MB   268MB   primary   xfs          boot
 2      269MB   34.6GB  34.4GB  primary
 3      34.6GB  45.4GB  10.7GB  primary
 4      45.4GB  256GB   211GB   extended
 5      45.4GB  256GB   211GB   logical
```

​					下面是这些字段的描述： 			

- `模型：ATA SAMSUNG MZNLN256(scsi)`

  ​								磁盘类型、制造商、型号号和接口。 						

- `磁盘 /dev/sda: 256GB`

  ​								块设备的文件路径和存储容量。 						

- `分区表：msdos`

  ​								磁盘标签类型。 						

- `Number`

  ​								分区号。例如，次号 1 的分区对应于 `/dev/sda1`。 						

- `Start` 和 `End`

  ​								在分区启动和结束的设备中的位置。 						

- `Type`

  ​								有效类型为 metadata、free、primary、extended 或 logical。 						

- `File system`

  ​								文件系统类型。如果设备的 `File system` 字段未显示值，这意味着其文件系统类型为未知。`parted` 工具无法识别加密设备上的文件系统。 						

- `标记`

  ​								列出为分区设置的标记。可用的标志有 `boot`、`root`、`swap`、`hidden`、`raid`、`lvm` 或 `lba`。 						

# 第 15 章 在磁盘中创建分区表

​			作为系统管理员，您可以使用不同类型的分区表格式化块设备来启用该设备的分区。 	

警告

​				使用分区表格式化块设备会删除该设备中所有存储的数据。 		

## 15.1. 修改磁盘分区前的注意事项

​				本节列出了在创建、删除或重新定义分区大小前需要考虑的关键点。 		

注意

​					本节不涵盖 DASD 分区表，它特定于 IBM Z 构架。有关 DASD 的详情请参考： 			

- ​							[在 IBM Z 中配置 Linux 实例](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/performing_a_standard_rhel_installation/configuring-a-linux-instance-on-ibm-z_installing-rhel) 					
- ​							IBM 知识库中的 [您应该知道的有关 DASD 的内容](https://www.ibm.com/support/knowledgecenter/linuxonibm/com.ibm.linux.z.lgdd/lgdd_c_dasd_know.html) 的文章 					

#### 分区的最大数量

​				设备中的分区数量受分区表类型的限制： 		

- ​						在使用 **主引导记录(MBR)** 分区表格式化的设备上，您可以有： 				
  - ​								最多四个主分区，或者 						
  - ​								最多有三个主分区，以及一个扩展分区，其中包括多个逻辑分区。 						
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大的分区数为 128。尽管 GPT 规范通过增大为分区表保留的空间来允许更多的分区，但 `parted` 工具的常用的做法是将其限制为足够容纳 128 个分区的空间。 				

注意

​					红帽建议，除非有其他原因，否则 *至少* 要创建以下分区： `swap`、`/boot/` 和 `/` (root)。 			

#### 分区的最大大小

​				设备中的分区大小受分区表类型的限制： 		

- ​						在使用**主引导记录（MBR）** 分区表格式化的设备中，最大值为 2TiB。 				
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大大小为 8ZiB。 				

​				如果要创建一个大于 2TiB 的分区，该磁盘必须使用 GPT 格式化。 		

#### 大小协调

​				`parted` 工具可让您使用多个不同的后缀来指定分区的大小： 		

- MiB、GiB 或 TiB

  ​							大小为 2 的指数代表。 					 								分区的起点与根据大小指定的扇区一致。 							 								结束点与指定大小减 1 扇区一致。 							

- MB、GB 或 TB

  ​							以 10 的指数表示容量。 					 						起始和结束点在指定单元的一半内一致：例如,使用 MB 后缀时 ±500KB。 					

## 15.2. 分区表类型比较

​				本节比较您可以在块设备中创建的不同类型的分区表的属性。 		

表 15.1. 分区表类型

| 分区表             | 最多分区数                                                | 最大分区大小 |
| ------------------ | --------------------------------------------------------- | ------------ |
| 主引导记录（MBR）  | 4 个主分区，或 3 个主分区和一个扩展分区中的 12 个逻辑分区 | 2TiB         |
| GUID 分区表（GPT） | 128                                                       | 8ZiB         |

## 15.3. MBR 磁盘分区

​				本章图表显示分区表与实际磁盘分开。但这并不完全准确。实际上，分区表被保存在磁盘的最开始，并在任何文件系统或用户数据之前。为了简洁，下图将它们分开。 		

图 15.1. 有 MBR 分区表的磁盘

[![未使用的分区驱动器](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/729dac53c612267f9339a39af8037e9a/unused-partitioned-drive.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/729dac53c612267f9339a39af8037e9a/unused-partitioned-drive.png)

​				如上图所示，分区表被分为四节（四个主分区）。主分区是在硬盘中只能包含一个逻辑驱动器（或部分）的分区。每个部分都保存定义单个分区所需的信息，意味着分区表可定义不超过四个分区。 		

​				每个分区表条目包含分区的几个重要特征： 		

- ​						磁盘上分区开始和结束的地方。 				
- ​						分区是否 **活跃**。只能有一个分区被标记为**活跃**分区。 				
- ​						分区的类型。 				

​				起点和结束点定义了分区的大小和在磁盘中的位置。"active（活跃）"标志是被某些操作系统引导装载程序使用。换句话说，位于被标记为"活跃"的分区中的操作系统会被引导。 		

​				类型是一个数字，用于识别分区预定的用法。某些操作系统使用分区类型来表示特定的文件系统类型，来将分区标记为与特定操作系统关联的分区，来表示分区包含可引导的操作系统，或三者的某种组合。 		

​				下图显示了含有单一分区的驱动器示例： 		

图 15.2. 只有一个分区的磁盘

[![dos 单个分区](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/048e540976112eb27289cb3b808dd595/dos-single-partition.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/048e540976112eb27289cb3b808dd595/dos-single-partition.png)

​				本例中的单个分区被标记为 `DOS`。此标签显示分区类型，`DOS` 是最常见的分区类型之一。 		

## 15.4. 扩展 MBR 分区

​				如果四个分区不足，您可以使用扩展分区来创建额外的分区。您可以把分区类型设置为"Extended"来达到此目的。 		

​				扩展分区本身就如同磁盘驱动器一样 - 它有自己的分区表，指向一个或多个分区（现在称为逻辑分区，而不是四个主分区），它完全包含在扩展的分区中。下图显示了一个磁盘驱动器，它有两个主分区和一个包含两个逻辑分区（以及一些未分区的可用空间）的扩展分区： 		

图 15.3. 带主和扩展 MBR 分区的磁盘

[![扩展分区](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/fcb08c146100495c9c8c2b08e2c52de8/extended-partitions.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/fcb08c146100495c9c8c2b08e2c52de8/extended-partitions.png)

​				如图表中所暗示,主分区和逻辑分区之间有一个区别 - 主分区和扩展分区的数量只能是 4 个，但逻辑分区的数量没有固定限制。但是，由于在 Linux 中访问分区的方式，单个磁盘驱动器上不能定义超过 15 个逻辑分区。 		

## 15.5. MBR 分区类型

​				下表显示了一些常用的 MBR 分区类型和用于代表它们的十六进制数字。 		

表 15.2. MBR 分区类型

| **MBR 分区类型**     | **值** | **MBR 分区类型**   | **值** |
| -------------------- | ------ | ------------------ | ------ |
| 空                   | 00     | Novell Netware 386 | 65     |
| DOS 12-bit FAT       | 01     | PIC/IX             | 75     |
| XENIX root           | O2     | Old MINIX          | 80     |
| XENIX usr            | O3     | Linux/MINUX        | 81     |
| DOS 16-bit ⇐32M      | 04     | Linux swap         | 82     |
| Extended             | 05     | Linux native       | 83     |
| DOS 16-bit >=32      | 06     | Linux extended     | 85     |
| OS/2 HPFS            | 07     | Amoeba             | 93     |
| AIX                  | 08     | Amoeba BBT         | 94     |
| AIX bootable         | 09     | BSD/386            | a5     |
| OS/2 Boot Manager    | 0a     | OpenBSD            | a6     |
| Win95 FAT32          | 0b     | NEXTSTEP           | a7     |
| Win95 FAT32(LBA)     | 0c     | BSDI fs            | b7     |
| Win95 FAT16(LBA)     | 0e     | BSDI swap          | b8     |
| Win95 Extended (LBA) | 0f     | Syrinx             | c7     |
| Venix 80286          | 40     | CP/M               | db     |
| Novell               | 51     | DOS access         | e1     |
| PRep Boot            | 41     | DOS R/O            | e3     |
| GNU HURD             | 63     | DOS secondary      | f2     |
| Novell Netware 286   | 64     | BBT                | ff     |

## 15.6. GUID 分区表

​				GUID 分区表(GPT)是基于使用全局唯一标识符(GUID)的分区方案。GPT 的开发目的是弥补 MBR  分区表的限制，特别是对磁盘的最大可寻址存储空间的限制。MBR 无法寻址大于 2 TiB 的存储（等同于大约 2.2 TB）,而 GPT  可以用于大于这个存储限制的硬盘，其可寻址的最大磁盘大小为 2.2 ZiB。另外，GPT 默认支持创建最多 128  个主分区。这个号码可以通过为分区表分配更多空间来扩展。 		

注意

​					GPT 有基于 GUID 的分区类型。请注意，某些分区需要一个特定的 GUID。例如，EFI 引导加载程序的系统分区需要 GUID `C12A7328-F81F-11D2-BA4B-00A0C93EC93B`。 			

​				GPT 磁盘使用逻辑块寻址(LBA)，分区布局如下： 		

- ​						为了保持与 MBR 磁盘的向后兼容性，GPT 的第一个扇区(LBA 0)被保留给 MBR 数据，它称为"保护的 MBR"。 				
- ​						主 GPT 头从设备的第二个逻辑块(LBA 1)开始。标头中包含磁盘 GUID、主分区表的位置、从属 GPT 标头的位置、自身的 CRC32 checksum 以及主分区表。它还指定表上的分区条目数目。 				
- ​						默认情况下，主 GPT 包括 128 个分区条目，每个条目的大小为 128 字节，具有分区类型 GUID 和唯一分区 GUID。 				
- ​						二级 GPT 与主 GPT 相同。它主要用作恢复的备份表，以防主分区表损坏。 				
- ​						辅助 GPT 头位于磁盘的最后一个逻辑扇区，在主头损坏时可用于恢复 GPT 信息。它包含磁盘 GUID、二级分区表和主 GPT 标头的位置、自身的 CRC32 checksums 校验、从属分区表，以及可能的分区条目数目。 				

图 15.4. 带有 GUID 分区表的磁盘

[![GPT 分区](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/05e1efbc480f071bcc0b4d415cbc56a3/gpt-partition.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/05e1efbc480f071bcc0b4d415cbc56a3/gpt-partition.png)

重要

​					必须有一个 BIOS 引导分区才能成功安装引导装载程序到包含 GPT（GUID 分区表）的磁盘中。这包括 **Anaconda** 初始化的磁盘。如果磁盘已经包含 BIOS 引导分区，则它可以被重复使用。 			

## 15.7. 使用 parted 在磁盘中创建分区表

​				这个流程描述了如何使用 `parted` 工具将块设备格式化为具有分区表。 		

**流程**

1. ​						启动交互式 `parted` shell： 				

   ```none
   # parted block-device
   ```

   - ​								使用您要创建分区表的设备的路径替换 *block-device* ：例如 `/dev/sda`。 						

2. ​						确定该设备中是否已有一个分区表： 				

   ```none
   (parted) print
   ```

   ​						如果设备已经包含分区，将在后续步骤中删除它们。 				

3. ​						创建新分区表： 				

   ```none
   (parted) mklabel table-type
   ```

   - ​								用预期的分区表类型来替换 *table-type*： 						
     - ​										用于的 MBR 的 `msdos` 								
     - ​										用于 GPT 的 `gpt` 								

   例 15.1. 创建 GPT 表

   ​							例如，要在磁盘中创建 GPT 表，请使用： 					

   ```none
   (parted) mklabel gpt
   ```

   ​						输入此命令后，这些更改就会生效，因此在执行前请先重新检查。 				

4. ​						查看分区表以确认分区表是否存在： 				

   ```none
   (parted) print
   ```

5. ​						退出 `parted` shell: 				

   ```none
   (parted) quit
   ```

**其它资源**

- ​						`parted(8)` 手册页。 				

# 第 16 章 创建分区

​			作为系统管理员，您可以在磁盘上创建新分区。 	

## 16.1. 修改磁盘分区前的注意事项

​				本节列出了在创建、删除或重新定义分区大小前需要考虑的关键点。 		

注意

​					本节不涵盖 DASD 分区表，它特定于 IBM Z 构架。有关 DASD 的详情请参考： 			

- ​							[在 IBM Z 中配置 Linux 实例](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/performing_a_standard_rhel_installation/configuring-a-linux-instance-on-ibm-z_installing-rhel) 					
- ​							IBM 知识库中的 [您应该知道的有关 DASD 的内容](https://www.ibm.com/support/knowledgecenter/linuxonibm/com.ibm.linux.z.lgdd/lgdd_c_dasd_know.html) 的文章 					

#### 分区的最大数量

​				设备中的分区数量受分区表类型的限制： 		

- ​						在使用 **主引导记录(MBR)** 分区表格式化的设备上，您可以有： 				
  - ​								最多四个主分区，或者 						
  - ​								最多有三个主分区，以及一个扩展分区，其中包括多个逻辑分区。 						
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大的分区数为 128。尽管 GPT 规范通过增大为分区表保留的空间来允许更多的分区，但 `parted` 工具的常用的做法是将其限制为足够容纳 128 个分区的空间。 				

注意

​					红帽建议，除非有其他原因，否则 *至少* 要创建以下分区： `swap`、`/boot/` 和 `/` (root)。 			

#### 分区的最大大小

​				设备中的分区大小受分区表类型的限制： 		

- ​						在使用**主引导记录（MBR）** 分区表格式化的设备中，最大值为 2TiB。 				
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大大小为 8ZiB。 				

​				如果要创建一个大于 2TiB 的分区，该磁盘必须使用 GPT 格式化。 		

#### 大小协调

​				`parted` 工具可让您使用多个不同的后缀来指定分区的大小： 		

- MiB、GiB 或 TiB

  ​							大小为 2 的指数代表。 					 								分区的起点与根据大小指定的扇区一致。 							 								结束点与指定大小减 1 扇区一致。 							

- MB、GB 或 TB

  ​							以 10 的指数表示容量。 					 						起始和结束点在指定单元的一半内一致：例如,使用 MB 后缀时 ±500KB。 					

## 16.2. 分区类型

​				本节描述了指定分区类型的不同属性。 		

#### 分区类型或标志

​				正在运行的系统很少使用分区类型或标志。但是，分区类型与动态生成器有关，例如 `systemd-gpt-auto-generator`，其使用分区类型来自动识别和挂载设备。 		

- ​						`parted` 工具通过将分区类型映射到 *标志* 来提供对分区类型的一些控制。parted 工具只能处理某些分区类型：例如 LVM、swap 或 RAID。 				
- ​						`fdisk` 工具通过指定十六进制代码来支持所有的分区类型。 				

#### 分区文件系统类型

​				`parted` 工具在创建分区时接受文件系统类型参数。该值用于： 		

- ​						在 MBR 中设定分区标记，或者 				
- ​						在 GPT 中设定分区 UUID 类型。例如，`swap`、`fat` 或 `hfs` 文件系统类型设置不同的 GUID。默认值为 Linux Data GUID。 				

​				参数不会以任何形式修改分区中的文件系统。它只区分受支持的标志或 GUID。 		

​				支持以下文件系统类型： 		

- ​						`xfs` 				
- ​						`ext2` 				
- ​						`ext3` 				
- ​						`ext4` 				
- ​						`fat16` 				
- ​						`fat32` 				
- ​						`hfs` 				
- ​						`hfs+` 				
- ​						`linux-swap` 				
- ​						`ntfs` 				
- ​						`reiserfs` 				

注意

​					RHEL 9 中唯一支持的本地文件系统是 `ext4` 和 `xfs`。 			

## 16.3. 分区命名方案

​				Red Hat Enterprise Linux 使用基于文件的命名方案，其文件名采用 `/dev/*xxyN*` 的形式。 		

​				设备和分区名称由以下结构组成： 		

- `***/dev/\***`

  ​							这是所有设备文件所在的目录名称。由于分区放置在硬盘上，而硬盘就是设备，因此代表所有可能分区的文件位于 `/dev` 中。 					

- `***xx\***`

  ​							分区名称的前两个字母表示分区所在的设备的类型，通常是 `sd`。 					

- `***y\***`

  ​							这个字母标明分区所在的设备。例如，第一个硬盘为 `/dev/sda`，第二个硬盘为 `/dev/sdb`，以此类推。在超过 26 个驱动器的系统中，您可以使用更多字母。例如： `/dev/sdaa1`。 					

- `***N\***`

  ​							最后的字母代表分区的数字。前四个（主或扩展）分区编号为 `1` 到 `4`。逻辑分区从 `5` 开始。例如，`/dev/sda3` 是第一个硬盘上的第三个主分区或扩展分区，`/dev/sdb6` 是第二个硬盘上的第二个逻辑分区。驱动器分区编号只适用于 MBR 分区表。请注意，***N\*** 并不总是意味着分区。 					

注意

​					即使 Red Hat Enterprise Linux 可以识别和引用 *所有*类型的磁盘分区，它可能无法读取文件系统，因此无法访问分区类型中保存的数据。然而，在很多情况下，成功访问专用于另一个操作系统的分区中的数据是可能的。 			

## 16.4. 挂载点和磁盘分区

​				在 Red Hat Enterprise Linux 中，每个分区都被用来成为支持一组文件和目录所必需的存储的一部分。这可使用名为 *mounting* 的进程完成，该进程可将分区和目录相关联。挂载分区使其存储从指定的目录(称为 *挂载点* )开始可用。 		

​				例如，如果分区 `/dev/sda5` 挂载在 `/usr/` 上，这意味着 `/usr/` 下的所有文件和目录都在 `/dev/sda5` 上。因此，文件 `/usr/share/doc/FAQ/txt/Linux-FAQ` 将存储在 `/dev/sda5` 上，而文件 `/etc/gdm/custom.conf` 则不会存储在 /dev/sda5 上。 		

​				继续这个示例，也可以将 `/usr/` 下的一个或多个目录作为其他分区的挂载点。例如，分区 `/dev/sda7` 可以挂载到 `/usr/local` 上，意味着 `/usr/local/man/whatis` 将位于 `/dev/sda7` 上，而不是 `/dev/sda5` 上。 		

## 16.5. 使用 parted 创建分区

​				这个流程描述了如何使用 `parted` 工具在块设备上创建新分区。 		

**先决条件**

- ​						磁盘上有一个分区表。有关如何格式化磁盘的详情，请参阅 [在磁盘上创建分区表](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/managing_file_systems/index#assembly_creating-a-partition-table-on-a-disk_managing-file-systems)。 				
- ​						如果您要创建的分区大于 2TiB，则必须使用 GUID 分区表(GPT)格式化该磁盘。 				

**流程**

1. ​						启动交互式 `parted` shell： 				

   ```none
   # parted block-device
   ```

   - ​								使用您要创建分区的设备的路径替换 *block-device* ：例如 `/dev/sda`。 						

2. ​						查看当前的分区表来确定是否有足够空闲空间： 				

   ```none
   (parted) print
   ```

   - ​								如果没有足够的可用空间，您可以调整现有分区的大小。如需更多信息，请参阅 [重新定义分区大小](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/managing_file_systems/index#assembly_resizing-a-partition_managing-file-systems)。 						
   - ​								从分区表中决定： 						
     - ​										新分区的开始和结束点 								
     - ​										在 MBR 上，应该是什么分区类型。 								

3. ​						创建新分区： 				

   ```none
   (parted) mkpart part-type name fs-type start end
   ```

   - ​								根据您在分区表中的决定，使用 `primary`、`logical` 或 `extended` 替换 *part-type*。这只适用于 MBR 分区表。 						
   - ​								使用任意分区名称替换 *name*。对于 GPT 分区表，这是必需的。 						
   - ​								使用 `xfs` 、`ext2`、`ext3`、`ext4`、`fat16`、`fat32`、`hfs`、`hfs+`、`Linux-swap`、`ntfs` 或 `reiserfs` 其中之一替换 *fs-type*。*fs-type* 参数是可选的。请注意，`parted` 不会在分区上创建文件系统。 						
   - ​								使用从磁盘开头计算分区开始和结束点的大小替换 *start* 和 *end*。您可以使用大小后缀，如 `512MiB`、`20GiB` 或 `1.5TiB`。默认大小 MB。 						

   例 16.1. 创建小的主分区

   ​							例如：要在 MBR 表中创建主分区（从 1024MiB 到 2048MiB），使用： 					

   ```none
   (parted) mkpart primary 1024MiB 2048MiB
   ```

   ​						输入此命令后，这些更改就会生效，因此在执行前请先重新检查。 				

4. ​						查看分区表以确认创建的分区位于分区表中，并具有正确的分区类型、文件系统类型和大小： 				

   ```none
   (parted) print
   ```

5. ​						退出 `parted` shell: 				

   ```none
   (parted) quit
   ```

6. ​						使用以下命令等待系统注册新设备节点： 				

   ```none
   # udevadm settle
   ```

7. ​						验证内核是否识别了新的分区： 				

   ```none
   # cat /proc/partitions
   ```

**其它资源**

- ​						`parted(8)` 手册页。 				

## 16.6. 使用 fdisk 设置分区类型

​				这个流程描述了如何使用 `fdisk` 工具设置分区类型或标志。 		

**先决条件**

- ​						磁盘上有一个分区。 				

**流程**

1. ​						启动交互式 `fdisk` shell： 				

   ```none
   # fdisk block-device
   ```

   - ​								使用您要设置分区类型的设备的路径替换 *block-device* ：例如 `/dev/sda`。 						

2. ​						查看当前的分区表以确定副分区号码： 				

   ```none
   Command (m for help): print
   ```

   ​						您可以在 `Type` 列中看到当前的分区类型，在 `Id` 列中看到相应的类型 ID 。 				

3. ​						输入分区类型命令并使用它的副号码选择分区： 				

   ```none
   Command (m for help): type
   Partition number (1,2,3 default 3): 2
   ```

4. ​						另外，还可列出可用的十六进制代码： 				

   ```none
   Hex code (type L to list all codes): L
   ```

5. ​						设置分区类型： 				

   ```none
   Hex code (type L to list all codes): 8e
   ```

6. ​						写入更改并退出 `fdisk` shell： 				

   ```none
   Command (m for help): write
   The partition table has been altered.
   Syncing disks.
   ```

7. ​						验证您的更改： 				

   ```none
   # fdisk --list block-device
   ```

# 第 17 章 删除分区

​			作为系统管理员，您可以删除不再用来释放磁盘空间的磁盘分区。 	

警告

​				删除分区将删除保存在分区中的所有数据。 		

## 17.1. 修改磁盘分区前的注意事项

​				本节列出了在创建、删除或重新定义分区大小前需要考虑的关键点。 		

注意

​					本节不涵盖 DASD 分区表，它特定于 IBM Z 构架。有关 DASD 的详情请参考： 			

- ​							[在 IBM Z 中配置 Linux 实例](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/performing_a_standard_rhel_installation/configuring-a-linux-instance-on-ibm-z_installing-rhel) 					
- ​							IBM 知识库中的 [您应该知道的有关 DASD 的内容](https://www.ibm.com/support/knowledgecenter/linuxonibm/com.ibm.linux.z.lgdd/lgdd_c_dasd_know.html) 的文章 					

#### 分区的最大数量

​				设备中的分区数量受分区表类型的限制： 		

- ​						在使用 **主引导记录(MBR)** 分区表格式化的设备上，您可以有： 				
  - ​								最多四个主分区，或者 						
  - ​								最多有三个主分区，以及一个扩展分区，其中包括多个逻辑分区。 						
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大的分区数为 128。尽管 GPT 规范通过增大为分区表保留的空间来允许更多的分区，但 `parted` 工具的常用的做法是将其限制为足够容纳 128 个分区的空间。 				

注意

​					红帽建议，除非有其他原因，否则 *至少* 要创建以下分区： `swap`、`/boot/` 和 `/` (root)。 			

#### 分区的最大大小

​				设备中的分区大小受分区表类型的限制： 		

- ​						在使用**主引导记录（MBR）** 分区表格式化的设备中，最大值为 2TiB。 				
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大大小为 8ZiB。 				

​				如果要创建一个大于 2TiB 的分区，该磁盘必须使用 GPT 格式化。 		

#### 大小协调

​				`parted` 工具可让您使用多个不同的后缀来指定分区的大小： 		

- MiB、GiB 或 TiB

  ​							大小为 2 的指数代表。 					 								分区的起点与根据大小指定的扇区一致。 							 								结束点与指定大小减 1 扇区一致。 							

- MB、GB 或 TB

  ​							以 10 的指数表示容量。 					 						起始和结束点在指定单元的一半内一致：例如,使用 MB 后缀时 ±500KB。 					

## 17.2. 使用 parted 删除分区

​				这个流程描述了如何使用 `parted` 工具删除磁盘分区。 		

**流程**

1. ​						启动交互式 `parted` shell： 				

   ```none
   # parted block-device
   ```

   - ​								使用您要删除分区的设备的路径替换 *block-device* ：例如 `/dev/sda`。 						

2. ​						查看当前的分区表以确定要删除的分区的次号： 				

   ```none
   (parted) print
   ```

3. ​						删除分区： 				

   ```none
   (parted) rm minor-number
   ```

   - ​								使用您要删除的分区的次号替换 *minor-number* ：例如 `3`。 						

   ​						输入此命令后，这些更改就会生效，因此在执行前请先重新检查。 				

4. ​						确认分区已从分区表中被删除： 				

   ```none
   (parted) print
   ```

5. ​						退出 `parted` shell: 				

   ```none
   (parted) quit
   ```

6. ​						确定内核知道已删除该分区： 				

   ```none
   # cat /proc/partitions
   ```

7. ​						如果分区存在，请从 `/etc/fstab` 文件中删除该分区。找到声明删除的分区的行，并将其从文件中删除。 				

8. ​						重新生成挂载单元，以便您的系统注册新的 `/etc/fstab` 配置： 				

   ```none
   # systemctl daemon-reload
   ```

9. ​						如果您删除了交换分区或删除了 LVM 部分，请从 `/etc/default/grub` 文件的内核命令行中删除对分区的所有引用，并重新生成 GRUB 配置： 				

   - ​								在基于 BIOS 的系统中： 						

     ```none
     # grub2-mkconfig --output=/etc/grub2.cfg
     ```

   - ​								在基于 UEFI 的系统中： 						

     ```none
     # grub2-mkconfig --output=/etc/grub2-efi.cfg
     ```

10. ​						要在早期引导系统中注册更改，请重建 `initramfs` 文件系统： 				

    ```none
    # dracut --force --verbose
    ```

**其它资源**

- ​						`parted(8)` 手册页 				

# 第 18 章 重新定义分区尺寸

​			作为系统管理员，您可以扩展分区来利用未使用的磁盘空间，或者缩小分区以达到不同的目的。 	

## 18.1. 修改磁盘分区前的注意事项

​				本节列出了在创建、删除或重新定义分区大小前需要考虑的关键点。 		

注意

​					本节不涵盖 DASD 分区表，它特定于 IBM Z 构架。有关 DASD 的详情请参考： 			

- ​							[在 IBM Z 中配置 Linux 实例](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/performing_a_standard_rhel_installation/configuring-a-linux-instance-on-ibm-z_installing-rhel) 					
- ​							IBM 知识库中的 [您应该知道的有关 DASD 的内容](https://www.ibm.com/support/knowledgecenter/linuxonibm/com.ibm.linux.z.lgdd/lgdd_c_dasd_know.html) 的文章 					

#### 分区的最大数量

​				设备中的分区数量受分区表类型的限制： 		

- ​						在使用 **主引导记录(MBR)** 分区表格式化的设备上，您可以有： 				
  - ​								最多四个主分区，或者 						
  - ​								最多有三个主分区，以及一个扩展分区，其中包括多个逻辑分区。 						
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大的分区数为 128。尽管 GPT 规范通过增大为分区表保留的空间来允许更多的分区，但 `parted` 工具的常用的做法是将其限制为足够容纳 128 个分区的空间。 				

注意

​					红帽建议，除非有其他原因，否则 *至少* 要创建以下分区： `swap`、`/boot/` 和 `/` (root)。 			

#### 分区的最大大小

​				设备中的分区大小受分区表类型的限制： 		

- ​						在使用**主引导记录（MBR）** 分区表格式化的设备中，最大值为 2TiB。 				
- ​						在使用 **GUID 分区表(GPT)** 格式化的设备上，最大大小为 8ZiB。 				

​				如果要创建一个大于 2TiB 的分区，该磁盘必须使用 GPT 格式化。 		

#### 大小协调

​				`parted` 工具可让您使用多个不同的后缀来指定分区的大小： 		

- MiB、GiB 或 TiB

  ​							大小为 2 的指数代表。 					 								分区的起点与根据大小指定的扇区一致。 							 								结束点与指定大小减 1 扇区一致。 							

- MB、GB 或 TB

  ​							以 10 的指数表示容量。 					 						起始和结束点在指定单元的一半内一致：例如,使用 MB 后缀时 ±500KB。 					

## 18.2. 使用 parted 重新定义分区大小

​				这个过程使用 `parted` 工具重新定义磁盘分区大小。 		

**先决条件**

- ​						如果您想缩小分区，备份保存在分区上的数据。 				

  警告

  ​							缩小分区可能会导致分区上的数据丢失。 					

- ​						如果要将分区大小调整为大于 2TiB，必须使用 GUID 分区表(GPT)对磁盘进行格式化。有关如何格式化磁盘的详情，请参阅 [在磁盘上创建分区表](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/managing_file_systems/index#assembly_creating-a-partition-table-on-a-disk_managing-file-systems)。 				

**流程**

1. ​						如果您想缩小分区，首先缩小它上面的文件系统，使其不大于重新定义大小的分区。请注意 XFS 不支持缩小。 				

2. ​						启动交互式 `parted` shell： 				

   ```none
   # parted block-device
   ```

   - ​								使用您要调整分区大小的设备的路径替换 *block-device* ：例如 `/dev/sda`。 						

3. ​						查看当前的分区表： 				

   ```none
   (parted) print
   ```

   ​						从分区表中决定： 				

   - ​								分区的从号码 						
   - ​								调整大小后现有分区的位置和新结束点 						

4. ​						重新定义分区大小： 				

   ```none
   (parted) resizepart minor-number new-end
   ```

   - ​								使用您要调整大小的分区的次号替换 *minor-number* ：例如 `3`。 						
   - ​								用决定重新定义大小的新分区的结束点（从磁盘开始计算）替换 *new-end*。您可以使用大小后缀，如 `512MiB`、`20GiB` 或 `1.5TiB`。默认大小 MB。 						

   例 18.1. 扩展分区

   ​							例如，要将位于磁盘开头的分区大小扩展为 2GiB，请使用： 					

   ```none
   (parted) resizepart 1 2GiB
   ```

   ​						输入此命令后，这些更改就会生效，因此在执行前请先重新检查。 				

5. ​						查看分区表以确认调整了大小的分区位于分区表中，且大小正确： 				

   ```none
   (parted) print
   ```

6. ​						退出 `parted` shell: 				

   ```none
   (parted) quit
   ```

7. ​						验证内核是否识别了新的分区： 				

   ```none
   # cat /proc/partitions
   ```

8. ​						如果您扩展了分区，也扩展了它上面的文件系统。详情请参阅（参考）。 				

**其它资源**

- ​						`parted(8)` 手册页。 				

# 第 19 章 重新分区磁盘策略

​			重新分区磁盘的方法有几种。本节讨论以下可能的方法： 	

- ​					有可用的未分区的空闲空间 			
- ​					有可用的未使用过的分区 			
- ​					被活跃使用的分区内有可用的空闲空间 			

​			请注意，本节仅从理论上讨论了前面提到的概念，不包括关于如何逐步执行磁盘重新分区的任何流程步骤。 	

注意

​				为了清晰起见，以下示意图进行了简化，不反映您在实际安装 Red Hat Enterprise Linux 时遇到的确切分区布局。 		

## 19.1. 使用未分区的空闲空间

​				在这种情况下，已定义的分区不会跨越整个硬盘，留下的未分配空间不是任何已定义分区的一部分。下图显示了这可能是什么样子： 		

图 19.1. 有未分区的可用空间的磁盘

[![未分区空间](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/251ce9a91c9da679b841ccac7c41e00c/unpart-space.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/251ce9a91c9da679b841ccac7c41e00c/unpart-space.png)

​				在上例中，第一个图表示一个具有一个主分区的磁盘，以及一个具有未分配空间的未定义分区的磁盘，第二个图表示具有两个定义分区且分配了空间的磁盘。 		

​				未使用的硬盘也属于这一类别。唯一的区别是，*所有* 空间并不是任何定义的分区的一部分。 		

​				无论哪种情况，您都可以从未使用的空间创建必要的分区。这种情境很可能是新磁盘。大部分预安装的操作系统都被配置为占据磁盘驱动器上所有可用空间。 		

## 19.2. 使用未使用分区中的空间

​				在这种情况下，您可以有一个或者多个不再使用的分区。下图显示了这种情况。 		

图 19.2. 有未使用分区的磁盘

[![未使用的分区](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/26edb7f157ae58406f9db2758f65250e/unused-partition.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/26edb7f157ae58406f9db2758f65250e/unused-partition.png)

​				在上例中，第一个图表示带有未使用分区的磁盘，第二个图表示为 Linux 重新分配未使用的分区。 		

​				在这种情况下，您可以使用分配给未使用分区的空间。您必须删除分区，然后在此位置上创建合适的 Linux 分区。您可以删除未使用的分区，并在安装过程中手动创建新分区。 		

## 19.3. 使用活跃分区中的空闲空间

​				这是最常见的情况。它也是最难处理的，因为即使您有足够的可用空间，它目前也被分配给一个已经在使用的分区。如果您购买了一台带有预装软件的计算机，硬盘很可能有一个大型分区存放操作系统和数据。 		

​				除了向系统添加新硬盘外，您还可以选择破坏性和非破坏性重新分区。 		

### 19.3.1. 破坏性重新分区

​					这会删除分区并创建几个较小的分区。您必须进行完整备份，因为原始分区中的所有数据都会被破坏。创建两个备份，使用验证（如果您的备份软件提供的话），并在删除分区 *前* 尝试从备份中读取数据。 			

警告

​						如果在该分区上安装了操作系统,必须重新安装它才能使用该系统。请注意，一些预装了操作系统的计算机可能不包括安装介质来重新安装原始操作系统。在销毁原始分区及其操作系统安装 *前*，您应该检查这是否适合您的系统。 				

​					为现有操作系统创建一个更小的分区后，您可以重新安装软件，恢复您的数据并启动 Red Hat Enterprise Linux 安装。 			

图 19.3. 在磁盘上进行破坏性重新分区动作

[![dstrct reprt](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/8b2813bf315821d206fc8b02c00adb1e/dstrct-reprt.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/8b2813bf315821d206fc8b02c00adb1e/dstrct-reprt.png)

警告

​						原有分区中的数据将会丢失。 				

### 19.3.2. 非破坏性重新分区

​					通过非破坏性重新分区，您可以执行一个程序，使大分区变小，而又不会丢失该分区中存储的任何文件。这个方法通常是可靠的，但在大型驱动器上可能非常耗时。 			

​					非破坏性重新分区过程很简单，它由三个步骤组成： 			

1. ​							压缩和备份现存数据 					
2. ​							重新划分现存分区的大小 					
3. ​							创建新分区 					

​					每个步骤都会详细介绍。 			

#### 19.3.2.1. 压缩现有数据

​						第一步要压缩现存分区上的数据。这样做的原因是重新安排数据，以最大化分区"结尾"处的可用空间。 				

图 19.4. 磁盘压缩

[![compression](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/c61c8c0e59fddc90d20e02339d1e1993/compression.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/c61c8c0e59fddc90d20e02339d1e1993/compression.png)

​						在上例中，第一个图代表压缩前的磁盘，第二个图表代表压缩后的磁盘。 				

​						这一步骤至关重要。如果没有它，数据的位置可能会阻止分区调整为所需的大小。请注意，有些数据不能移动。在这种情况下，它会严重限制新分区的大小，并且可能会强制您以破坏性方式重新分区磁盘。 				

#### 19.3.2.2. 重新调整现有分区的大小

​						下图显示了实际调整大小的流程。虽然重新调整大小操作的实际结果会有所不同，具体取决于所使用的软件，但在大多数情况下，新释放的空间用于创建与原始分区类型相同的、未格式化的分区。 				

图 19.5. 分区在磁盘上调整大小

[![部分调整大小](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/4719e2aaa3aec68836384b2721f3660c/part-resize.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/4719e2aaa3aec68836384b2721f3660c/part-resize.png)

​						在上例中，第一个图表示调整大小前的分区，第二个图表示调整大小后的分区。 				

​						务必要了解调整大小的软件如何处理新释放的空间，以便您可以执行相应的步骤。在此处演示的情形中，最好删除新的 DOS 分区，并创建合适的 Linux 分区。 				

#### 19.3.2.3. 创建新分区

​						如上例中所述，也不一定要创建新分区。然而，除非重新分区软件支持安装 Linux 系统，您很可能需要删除在调整大小过程中创建的分区。 				

图 19.6. 带有最终分区配置的磁盘

[![nondestruct fin](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/f2d30412c04ae6343c21a71c368f7b4f/nondestruct-fin.png)](https://access.redhat.com/webassets/avalon/d/Red_Hat_Enterprise_Linux-9-Managing_file_systems-zh-CN/images/f2d30412c04ae6343c21a71c368f7b4f/nondestruct-fin.png)

​						在上例中，第一个图表示配置前的磁盘，第二个图表示配置后的磁盘。 				

## Other

lsblk

blkid

cat /proc/partitions

1956年，IBM推出第一台硬盘驱动器 IBM RAMAC 350

