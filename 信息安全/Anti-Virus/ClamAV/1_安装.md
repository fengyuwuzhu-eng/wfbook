# 安装

[TOC]

## 使用 Package Manager 安装

ClamAV 可从第三方包管理器中广泛获得，适用于大多数操作系统。这通常是安装 ClamAV 的最快方法。它也将使升级更容易。

## 使用安装程序安装

Pre-compiled packages provided on [the clamav.net downloads page](https://www.clamav.net/downloads) have all external library dependencies statically compiled in.
[clamav.net 下载页面上](https://www.clamav.net/downloads)提供的预编译包包含静态编译的所有外部库依赖项。

We hope to round out these sharp corners in the future and to make setup more convenient, but for now be advised that setup from one  of these packages is a little bit more work than you may be used to.
这些安装程序可能与其他打包工具提供的软件包不同，因为需要创建和配置 `freshclam.conf` 和 `clamd.conf` 文件。可能还需要添加 `clamav` 服务用户帐户，并调整数据库目录的权限。希望将来能完善这些尖锐的角落，使设置更加方便，但现在请注意，从这些软件包之一进行设置比您习惯的要多一些工作。

> *Note*: In the event that a vulnerability is found in one of the dependencies  that may impact ClamAV, we will publish new packages with updated  dependencies as soon as we're able.
> *注意* ：如果在可能影响 ClamAV 的依赖项之一中发现漏洞，我们将尽快发布具有更新依赖项的新软件包。

### Linux (.deb, .rpm)

从 ClamAV 0.104 开始，提供适用于 x86_64（64 位）和 i686（32 位）架构的 Debian 和 RPM 软件包。这将在分发包不容易获得并且不想从源代码构建 ClamAV 的情况下更容易获取最新版本。

> *Note*: These packages do not presently include `clamav-milter`. You can help help us add `clamav-milter` to the packages by developing a Mussels recipe for building the libmilter.a static library and contributing it to our [Mussels cookbook](https://github.com/Cisco-Talos/clamav-mussels-cookbook/).
> *注意* ：这些软件包目前不包含 `clamav-milter`。您可以通过开发用于构建 libmilter.a 静态库的 Mussels 配方并将其贡献到我们的 [Mussels 说明书](https://github.com/Cisco-Talos/clamav-mussels-cookbook/)中，来帮助我们将 `clamav-milter` 添加到软件包中。

#### RPM packages (for AlmaLinux, Fedora, openSUSE, etc.)

These are compiled on AlmaLinux 8. They should be compatible with all RPM-based linux distributions running `glibc` version `2.28` or newer.
这些是在 AlmaLinux 8 上编译的。它们应与运行 `glibc` 版本 `2.28` 或更高版本的所有基于 RPM 的 Linux 发行版兼容。

要安装，请使用 `yum` 或 `dnf` 为您的系统下载软件包。例如：

```bash
dnf install ~/Downloads/clamav-1.4.0.linux.x86_64.rpm
```

可以使用以下方法验证软件包是否已安装：

```bash
dnf info clamav
```

此软件包安装到 `/usr/local` 。

Unlike packages provided by Debian or other distributions, this package does not presently include a preconfigured `freshclam.conf`, `clamd.conf`, database directory, or `clamav` user accounts for FreshClam and ClamD. You can follow [these instructions](https://docs.clamav.net/manual/Usage/Configuration.html) to configure FreshClam and ClamD. You can follow [these instructions](https://docs.clamav.net/manual/Installing/Add-clamav-user.html) to create the `clamav` user account for running FreshClam and ClamD services.
与 Debian 或其他发行版提供的软件包不同，此软件包目前不包含预配置的 `freshclam.conf`、`clamd.conf`、数据库目录或 FreshClam 和 ClamD 的 `clamav` 用户帐户。您可以按照[这些说明](https://docs.clamav.net/manual/Usage/Configuration.html)配置 FreshClam 和 ClamD。你可以按照[这些说明](https://docs.clamav.net/manual/Installing/Add-clamav-user.html)创建 `clamav` 用户账户来运行 FreshClam 和 ClamD 服务。

使用以下命令卸载软件包：

```bash
dnf remove ~/Downloads/clamav-1.4.0.linux.x86_64.rpm
```

#### DEB packages (for Debian, Ubuntu, etc.)

These are compiled on Ubuntu 18.04, and have all external library  dependencies statically compiled in. They should be compatible with all  Debian-based linux distributions running `glibc` version `2.27` or newer.
这些是在 Ubuntu 18.04 上编译的，并且所有外部库依赖项都是静态编译的。它们应该与运行 `glibc` ` 版本 2.27` 或更高版本的所有基于 Debian 的 linux 发行版兼容。

```bash
apt install ~/Downloads/clamav-1.4.0.libnux.x86_64.deb
```

可以使用以下方法验证软件包是否已安装：

```bash
apt info clamav
```

此软件包安装到 `/usr/local` 。

Unlike packages provided by Debian or other distributions, this package does not presently include a preconfigured `freshclam.conf`, `clamd.conf`, database directory, or `clamav` user accounts for FreshClam and ClamD. You can follow [these instructions](https://docs.clamav.net/manual/Usage/Configuration.html) to configure FreshClam and ClamD. You can follow [these instructions](https://docs.clamav.net/manual/Installing/Add-clamav-user.html) to create the `clamav` user account for running FreshClam and ClamD services.
与 Debian 或其他发行版提供的软件包不同，此软件包目前不包含预配置的 `freshclam.conf`、`clamd.conf`、数据库目录或 FreshClam 和 ClamD 的 `clamav` 用户帐户。您可以按照[这些说明](https://docs.clamav.net/manual/Usage/Configuration.html)配置 FreshClam 和 ClamD。你可以按照[这些说明](https://docs.clamav.net/manual/Installing/Add-clamav-user.html)创建 `clamav` 用户账户来运行 FreshClam 和 ClamD 服务。

使用以下命令卸载软件包：

```bash
apt remove clamav
```

### macOS

Beginning with ClamAV 0.104, we offer a PKG installer for macOS. These are  universal binaries built for Intel x86_64 and Apple M1 arm64 processors.
从 ClamAV 0.104 开始，我们提供适用于 macOS 的 PKG 安装程序。这些是为 Intel x86_64 和 Apple M1 arm64 处理器构建的通用二进制文件。

To install, download the macOS `.pkg` installer. Double-click the installer and follow the directions.
要安装，请下载 macOS `.pkg` 安装程序。双击安装程序并按照说明进行作。

This package installs to `/usr/local/clamav`. This is **not** in the default system `PATH` environment variable. You may wish to add `/usr/local/clamav/bin` and `/usr/local/clamav/sbin` to your `PATH` so you can run the ClamAV programs without entering the full path. To do this add this line to `~/.zshrc`:
此软件包安装到 `/usr/local/clamav`。这**不在**默认系统 `PATH` 环境变量中。你或许希望将 `/usr/local/clamav/bin` 及 `/usr/local/clamav/sbin` 加入到 `PATH` 内，这样你便可以不输入完整路径来执行 ClamAV 程式。要做到这一点，请在 `~/.zshrc` 中添加这一行：

```bash
export PATH=/usr/local/clamav/bin:/usr/local/clamav/sbin:$PATH
```

然后运行 `source ~/.zshrc` 或打开一个新的终端。

Unlike packages provided by Homebrew, this package does not presently include a preconfigured `freshclam.conf`, `clamd.conf`, or database directory. You can follow [these instructions](https://docs.clamav.net/manual/Usage/Configuration.html) to configure FreshClam and ClamD.
与 Homebrew 提供的软件包不同，此软件包目前不包含预配置的 `freshclam.conf`、`clamd.conf` 或数据库目录。您可以按照[这些说明](https://docs.clamav.net/manual/Usage/Configuration.html)配置 FreshClam 和 ClamD。

macOS package installers do not provide a mechanism for automatically  uninstalling the package. In the future, we hope to add a script to aid  with uninstallation. But for now, to make it easier to remove, our macOS installer installs to `/usr/local/clamav`. To uninstall, all you need to do is run:
macOS 软件包安装程序不提供自动卸载软件包的机制。将来，我们希望添加一个脚本来帮助卸载。但现在，为了更容易删除，我们的 macOS 安装程序安装到 `/usr/local/clamav`。要卸载，运行：

```bash
sudo rm -rf /usr/local/clamav
```

### Windows

ClamAV 团队[在 ClamAV 下载页面上](https://www.clamav.net/downloads#otherversions)提供了适用于 Windows 的官方 ClamAV 版本。可以选择传统的可执行安装程序或便携式安装 ZIP 包。

要使用可执行安装程序，请双击安装程序并按照说明进行作。

要从 ZIP 包安装，请将 portable 安装包解压缩到任何目录。

## 官方 ClamAV Docker 镜像


ClamAV 可以在 Docker 容器中运行。Docker Hub 上现在有官方的 ClamAV 镜像。可以在 [Docker Hub 的 `clamav` ](https://hub.docker.com/r/clamav/clamav) 下找到这些镜像。

ClamAV versions 0.104 and newer are available using a Docker image tag with  the specific version number, or using "stable" to get the latest stable  release.
ClamAV 版本 0.104 及更高版本可使用具有特定版本号的 Docker 映像标签，或使用“稳定”获取最新的稳定版本。

We also offer images with builds of the latest development version. We call this "unstable".
我们还提供具有最新开发版本内部版本的映像。我们称之为 “unstable”。

### 内存要求

无论使用的是官方的 ClamAV docker 镜像还是运行 ClamAV 的第三方镜像，都需要确保有足够的 RAM。

ClamAV 的推荐 RAM（截至 2020 年 9 月 20 日）：

- 最小值：3 GiB
- 首选：4 GiB

#### 为什么需要这么多 RAM ？

ClamAV uses upwards of 1.2 GiB of RAM simply to load the signature definitions into matching structures in the construct we call an "engine". This  does not take into account any RAM required to process the files during  the scanning process.
ClamAV 使用超过 1.2 GiB 的 RAM 来将签名定义加载到称为“引擎”的结构中的匹配结构中。这不包括在扫描过程中处理文件所需的任何 RAM。

ClamAV uses upwards of 2.4 GiB of RAM for a short period each day when loading new signature definitions. When the `clamd` processs reloads the databases after an update, the default behavior is for ClamAV to build a new engine based on the updated signatures first. Once loaded and once all scans that use the old engine have completed,  the old engine is unloaded. This process is called "concurrent  reloading" and enables scans to continue during the reload. As a  consequence, `clamd` will use twice the amount of RAM for a brief period. During the reload.
ClamAV 在加载新的签名定义时，每天在短时间内使用超过 2.4 GiB 的 RAM。当 `clamd` 进程在更新后重新加载数据库时，默认行为是 ClamAV 首先根据更新的签名构建新引擎。加载后，使用旧引擎的所有扫描都已完成，旧引擎将被卸载。此过程称为 “并发重新加载”，它允许在重新加载期间继续扫描。因此，`clamd` 将在短时间内使用两倍的 RAM。在重新加载期间。

The `freshclam` process may also consume a sizeable chunk of memory when load-testing  newly downloaded databases. It won't use quite as much as a `clamd` database reload, but it may still be enough to cause issues on some systems.
在对新下载的数据库进行负载测试时，`freshclam` 进程也可能会消耗相当大的内存块。它不会像 `clamd` 数据库重新加载那样使用，但可能仍然足以在某些系统上引起问题。

If your container does not have enough RAM you can expect that the OS (or Docker) may kill your `clamd` process. Within Docker, this may cause your container to become  unresponsive. If you're observing issues with ClamAV failing or becoming unresponsive once a day, it is likely that your system does not have  enough RAM to run ClamAV.
如果你的容器没有足够的 RAM，你可以预期作系统（或 Docker）可能会杀死你的 `clamd` 进程。在 Docker 中，这可能会导致您的容器变得无响应。如果您观察到 ClamAV 每天失败或无响应一次的问题，则可能是您的系统没有足够的 RAM 来运行 ClamAV。

#### 我该怎么做才能最大限度地减少 RAM 的使用量？

##### [`clamd` reload memory usage `clamd` reload 内存使用情况](https://docs.clamav.net/manual/Installing/Docker.html#clamd-reload-memory-usage)

You can minimize `clamd` RAM usage by setting `ConcurrentDatabaseReload no` in `clamd.conf`.
您可以通过在 `clamd.conf` 中设置 `ConcurrentDatabaseReload no` 来最大限度地减少 `clamd` RAM 的使用。

The downside is that `clamd` will block any new scans until reload is complete.
缺点是 `clamd` 会阻止任何新的扫描，直到重新加载完成。

##### [`freshclam` memory usage `Freshclam` 内存使用情况](https://docs.clamav.net/manual/Installing/Docker.html#freshclam-memory-usage)

You can disable `freshclam` database load testing to minimize RAM usage by setting `TestDatabases no` in `freshclam.conf`.
您可以通过在 `freshclam.conf` 中设置 `TestDatabases no` 来禁用 `freshclam` 数据库负载测试，以最大限度地减少 RAM 使用。

The downside here is a risk that a download may fail in an unexpected way and that `freshclam` will unknowingly keep the broken database, causing `clamd` to fail to load/reload the broken file.
这样做的缺点是下载可能会以意外的方式失败，并且 `freshclam` 会在不知不觉中保留损坏的数据库，从而导致 `clamd` 无法加载/重新加载损坏的文件。

### Docker Hub 上的官方镜像

[Docker Hub 上的 ](https://hub.docker.com/r/clamav/clamav) ClamAV 映像标签遵循这些命名约定。

所有镜像都有两种形式：

- `clamav/clamav：<version>`：预加载了签名数据库的发行版。

  Use this if you will keep the image around so that you don't download the entire  database set every time you start a new container. Updating with  FreshClam from existing databases set does not use much data.
  使用此容器将为 ClamAV 项目节省一些带宽。如果要保留映像，以便每次启动新容器时都不会下载整个数据库集，请使用此选项。使用现有数据库集中的 FreshClam 进行更新不会占用太多数据。

- `clamav/clamav：<version>_base`：没有签名数据库的发行版。

  Use this container **only** if you mount a volume in your container under `/var/lib/clamav` to persist your signature database databases. This method is the best  option because it will reduce data costs for ClamAV and for the Docker  registry, but it does require advanced familiarity with Linux and  Docker.
  仅当在容器中的 `/var/lib/clamav` 下挂载卷以保留签名数据库数据库时， **才**使用此容器。此方法是最佳选择，因为它将降低 ClamAV 和 Docker 注册表的数据成本，但它确实需要对 Linux 和 Docker 有深入的了解。

  > *Caution*: Using this image without mounting an existing database directory will  cause FreshClam to download the entire database set each time you start a new container.
  > *注意* ： 如果不挂载现有数据库目录，则会导致 FreshClam 在每次启动新容器时下载整个数据库集。

有一系列标签可帮助获取所需的版本：

- `clamav/clamav:<MAJOR.MINOR.PATCH>_base` and `clamav/clamav:<MAJOR.MINOR.PATCH>`: This is a tag for a specific image for a given patch version. The  "base" version of this image will never change, and the non-base version will only ever be updated to have newer signature databases.
   `clamav/clamav:<MAJOR.MINOR.PATCH>_base` 和 `clamav/clamav:<MAJOR.MINOR.PATCH>` ：这是给定补丁版本的特定映像的标记。此映像的 “base” 版本永远不会更改，非 base 版本只会更新为具有更新的签名数据库。

  If we need to publish a new image to resolve CVE's in the underlying  dependencies, then another image will be created with a build-number  suffix.
  如果我们需要发布新映像来解决底层依赖项中的 CVE，则将创建另一个带有 build-number 后缀的映像。

  For example: `0.104.2-2_base` is a new image to resolve security issues found in busybox in the `0.104.2_base` image.
  例如：`0.104.2-2_base` 是一个新映像，用于解决 `0.104.2_base` 映像中 busybox 中发现的安全问题。

- `clamav/clamav:<MAJOR.MINOR>_base` and `clamav/clamav:<MAJOR.MINOR>`: This is a tag for the latest patch version of ClamAV 0.104. When the  image for a new patch version is created, this tag will be updated so  that it always points to the latest image for ClamAV 0.104.
   `clamav/clamav:<MAJOR.MINOR>_base` 和 `clamav/clamav：<MAJOR。MINOR>`：这是 ClamAV 0.104 最新补丁版本的标签。创建新补丁版本的映像时，此标签将更新，以便它始终指向 ClamAV 0.104 的最新映像。

- `clamav/clamav:stable_base` and `clamav/clamav:stable`: These tags point to the latest stable patch version image. We use the  word "stable" to make it clear that these do not track the latest commit in Github. As of 2022-02-15, that makes these equivalent to `0.104` and `0.104_base`. When 0.105 is released, these will be updated to track `0.105` and `0.105_base`.
  `clamav/clamav：stable_base` 和 `clamav/clamav：stable`：这些标签指向最新的稳定补丁版本镜像。我们使用 “stable” 这个词来清楚地表明，这些不会跟踪 Github 中的最新提交。截至 2022 年 2 月 15 日，这相当于 `0.104` 和 `0.104_base`。当 0.105 发布时，这些将更新为跟踪 `0.105` 和 `0.105_base`。

- `clamav/clamav:latest_base` and `clamav/clamav:latest`: These are the same as `clamav/clamav:stable_base` and `clamav/clamav:stable`. They exist because many users expect all images to have a "latest".
  `clamav/clamav：latest_base` 和 `clamav/clamav：latest`：这些与 `clamav/clamav：stable_base` 和 `clamav/clamav：stable` 相同。它们之所以存在，是因为许多用户希望所有图像都具有“最新”。

- `clamav/clamav:unstable_base` and `clamav/clamav:unstable`: These tags point to the latest commit in the `main` branch on github.com/Cisco-Talos/clamav. Provided something doesn't go  wrong, these are updated every evening that something changes in the  ClamAV Git repository.
  `clamav/clamav：unstable_base` 和 `clamav/clamav：unstable`：这些标签指向 github.com/Cisco-Talos/clamav ` 上 main` 分支中的最新提交。只要没有出错，这些内容会在 ClamAV Git 存储库中发生更改时每天晚上更新。

### 镜像选择建议

Instead of choosing the specific image for a patch release, choose the tag for a feature release, such as `clamav/clamav:0.104` or `clamav/clamav:0.104_base`.
不要为补丁版本选择特定映像，而是为功能版本选择标签，例如 `clamav/clamav：0.104` 或 `clamav/clamav：0.104_base`。

Only select a "latest" or "stable" tags if you're comfortable with the the  risk involved with updating to a new feature release right away without  evaluating it first.
仅当您对立即更新到新功能版本而不先评估它所涉及的风险感到满意时，才选择 “latest” 或 “stable” 标签。

Choose the `_base` tag and set up a volume to persist your signature databases. This will  save us and you bandwidth. You may choose to set up a container that has the Freshclam daemon enabled, and have multiple others that do not. The ClamD daemon in the all images will occasionally check to see if there  are newer signatures in the mounted volume and will reload the databases as needed.
选择 `_base` 标签并设置一个卷以保留您的签名数据库。这将为我们和您节省带宽。您可以选择设置一个启用了 Freshclam 守护进程的容器，并设置多个未启用  Freshclam 守护进程的容器。所有镜像中的 ClamD 守护进程会偶尔检查挂载的卷中是否有更新的签名，并根据需要重新加载数据库。

ClamAV uses quite a bit of RAM to load the signature databases into memory.  2GB may be insufficient. Configure your containers to have 4GB of RAM.
ClamAV 使用相当多的 RAM 将签名数据库加载到内存中。2GB 可能不够用。将容器配置为具有 4GB 的 RAM。

### End of Life 生命周期结束

The ClamAV Docker images are subject to ClamAV's [End-of-Life (EOL) policy](https://docs.clamav.net/faq/faq-eol.html). After EOL for a given feature release, those images will no longer be updated and may be unable to download signature updates.
ClamAV Docker 镜像受 ClamAV 的[生命周期终止 （EOL） 政策](https://docs.clamav.net/faq/faq-eol.html)的约束。在给定功能版本 EOL 后，这些映像将不再更新，并且可能无法下载签名更新。

### Building the ClamAV image 构建 ClamAV 镜像](https://docs.clamav.net/manual/Installing/Docker.html#building-the-clamav-image)

While it is recommended to pull the image from our [Docker Hub registry](https://hub.docker.com/r/clamav/clamav), some may want to build the image locally instead.
虽然建议从 [Docker Hub 注册表](https://hub.docker.com/r/clamav/clamav)中提取镜像，但有些人可能希望在本地构建镜像。

To do this, you will need to get the  `Dockerfile` and the supporting `scripts/` directory from the [clamav-docker Git repository](https://github.com/Cisco-Talos/clamav-docker/tree/main/clamav). Be sure to select the correct one for this ClamAV release.
为此，您需要从 [clamav-docker Git 存储库](https://github.com/Cisco-Talos/clamav-docker/tree/main/clamav)获取 `Dockerfile` 和支持 `scripts/` 目录。请务必为此 ClamAV 版本选择正确的版本。

> *Tip*: For unreleased ClamAV versions, such as when building from the `main` git branch, you should select the files from the `clamav-docker/clamav/unstable/<distro>` directory.
> *提示* ： 对于未发布的 ClamAV 版本，例如从`主 ` git 分支构建时，您应该从 `clamav-docker/clamav/unstable/<distro>` 目录中选择文件。

Place the `Dockerfile` and `scripts/` directory in the ClamAV source directory. Then you can build the image. For example, run:
将 `Dockerfile` 和 `scripts/` 目录放在 ClamAV 源目录下。然后，您可以构建映像。例如，运行：

```

docker build --tag "clamav:TICKET-123" .
```

in the current directory. This will build the ClamAV image and tag it with the name "clamav:TICKET-123". Any name can generally be used and it is  this name that needs to be referred to later when running the image.
在当前目录中。这将构建 ClamAV 镜像，并为其添加名称 “clamav：TICKET-123” 的标签。通常可以使用任何名称，稍后在运行映像时需要引用此名称。

### [Running ClamD 运行 ClamD](https://docs.clamav.net/manual/Installing/Docker.html#running-clamd)

To run `clamd` in a Docker container, first, an image either has to be built or pulled from a Docker registry.
要在 Docker 容器中运行 `clamd`，首先必须构建镜像或从 Docker 注册表中提取镜像。

### [Running ClamD using the official ClamAV images from Docker Hub 使用 Docker Hub 的官方 ClamAV 镜像运行 ClamD](https://docs.clamav.net/manual/Installing/Docker.html#running-clamd-using-the-official-clamav-images-from-docker-hub)

To pull the ClamAV "unstable" image from Docker Hub, run:
要从 Docker Hub 拉取 ClamAV “unstable” 镜像，请运行：

```
docker pull clamav/clamav:unstable
```

> *Tip*: Substitute `unstable` with a different version as needed.
> *提示* ： 根据需要将 `unstable` 替换为不同的版本。

To pull *and run* the official ClamAV images from the Docker Hub registry, try the following command:
要从 Docker Hub 注册表中提取*并运行*官方 ClamAV 镜像，请尝试以下命令：

```
docker run \
    --interactive \
    --tty \
    --rm \
    --name "clam_container_01" \
    clamav/clamav:unstable
```

The above creates an interactive container with the current TTY connected  to it. This is optional but useful when getting started as it allows one to directly see the output and, in the case of `clamd`, send `ctrl-c` to close the container. The `--rm` parameter ensures the container is cleaned up again after it exits and the `--name` parameter names the container, so it can be referenced through other  (Docker) commands, as several containers of the same image can be  started without conflicts.
上面创建了一个交互式容器，其中连接了当前 TTY。这是可选的，但在开始时很有用，因为它允许直接查看输出，并且在 `clamd` 的情况下，发送 `ctrl-c` 来关闭容器。`--rm` 参数可确保容器在退出后再次清理容器，而 `--name` 参数会为容器命名，以便可以通过其他 （Docker） 命令引用容器，因为同一映像的多个容器可以启动而不会发生冲突。

> *Note*: Pulling is not always required. `docker run` will pull the image if it cannot be found locally. `docker run --pull always` will always pull beforehand to ensure the most up-to-date container is being used. Do not use `--pull always` with the larger ClamAV images.
> *注意* ：拉取并不总是必需的。如果在本地找不到镜像，`docker run` 将拉取该镜像。`docker run --pull always` 将始终提前拉取，以确保使用最新的容器。不要始终对较大的 ClamAV 图像使用 `--pull`。

> *Tip*: It's common to see `-it` instead of `--interactive --tty`.
> *提示* ： 通常会看到 `-it` 而不是 `--interactive --tty`。

> *Tip*: It's common to also publish (forward) the ClamAV TCP port to the local host to use the [TCP socket](https://docs.clamav.net/manual/Installing/Docker.html#tcp) using `--publish 3310:3310` in the `docker run` command
> *提示* ： 通常也可以使用 `docker run` 命令中的 `--publish 3310：3310` 将 ClamAV TCP 端口发布（转发）到本地主机以使用 [TCP 套接字](https://docs.clamav.net/manual/Installing/Docker.html#tcp)

### [Running ClamD using a Locally Built Image 使用本地构建的镜像运行 ClamD](https://docs.clamav.net/manual/Installing/Docker.html#running-clamd-using-a-locally-built-image)

You can run a container using an image built locally ([see "Building the ClamAV Image"](https://docs.clamav.net/manual/Installing/Docker.html#building-the-clamav-image)). Just run:
您可以使用本地构建的镜像运行容器（[ 请参阅“构建 ClamAV 镜像”）。](https://docs.clamav.net/manual/Installing/Docker.html#building-the-clamav-image) 只需运行：

```

docker run -it --rm \
    --name "clam_container_01" \
    clamav:TICKET-123
```

### [Persisting the virus database (volume) 保留病毒数据库 （卷）](https://docs.clamav.net/manual/Installing/Docker.html#persisting-the-virus-database-volume)

The virus database in `/var/lib/clamav` is by default unique to each container and thus is normally not shared. For simple setups this is fine, where only one instance of `clamd` is expected to run in a dockerized environment. However some use cases  may want to efficiently share the database or at least persist it across short-lived ClamAV containers.
默认情况下，`/var/lib/clamav` 中的病毒数据库对于每个容器都是唯一的，因此通常不会共享。对于简单的设置，这很好，其中只有一个 `clamd` 实例需要在 Docker 化环境中运行。但是，某些用例可能希望有效地共享数据库，或者至少在短期 ClamAV 容器中持久化数据库。

To do so, you have two options:
为此，您有两个选项：

1. Create a [Docker volume](https://docs.docker.com/storage/volumes/) using the `docker volume` command. Volumes are completely managed by Docker and are the best choice for creating a persistent database volume.
   [使用](https://docs.docker.com/storage/volumes/) `docker volume` 命令。卷完全由 Docker 管理，是创建持久性数据库卷的最佳选择。

   For example, create a "clam_db" volume:
   例如，创建一个 “clam_db” 卷：

   ```
   
   ```

```bash
docker volume create clam_db
```

Then start one or more containers using this volume. The first container to  use a new database volume will download the full database set.  Subsequent containers will use the existing databases and may update  them as needed:
然后使用此卷启动一个或多个容器。第一个使用新数据库卷的容器将下载完整的数据库集。后续容器将使用现有数据库，并可能需要更新它们：

```

docker run -it --rm \
    --name "clam_container_01" \
    --mount source=clam_db,target=/var/lib/clamav \
    clamav/clamav:unstable_base
```

Create a [Bind Mount](https://docs.docker.com/storage/bind-mounts/) that maps a file system directory to a path within the container. Bind  Mounts depend on the directory structure, permissions, and operating  system of the Docker host machine.
创建一个 [Bind Mount](https://docs.docker.com/storage/bind-mounts/)，将文件系统目录映射到容器中的路径。绑定挂载取决于 Docker 主机的目录结构、权限和作系统。

Run the container with these arguments to mount the a directory from your host environment as a volume in the container.
使用这些参数运行容器，将主机环境中的 a 目录作为卷挂载到容器中。

```

    --mount type=bind,source=/path/to/databases,target=/var/lib/clamav
```

When doing this, it's best to use the `<version>_base` image tags so as to save on bandwith. E.g.:
执行此作时，最好使用 `<version>_base` 图像标签，以节省带宽。例如：

```

```

1. ```bash
   docker run -it --rm \
       --name "clam_container_01" \
       --mount type=bind,source=/path/to/databases,target=/var/lib/clamav \
       clamav/clamav:unstable_base
   ```

   > *Disclaimer*: When using a Bind Mount, the container's entrypoint script will change  ownership of this directory to its "clamav" user. This enables FreshClam and ClamD with the required permissions to read and write to the  directory, though these changes will also affect those files on the  host.
   > *免责声明* ：使用 Bind Mount 时，容器的入口点脚本会将此目录的所有权更改为其 “clamav” 用户。这使得 FreshClam 和 ClamD 能够对目录进行读写作，但这些更改也会影响主机上的这些文件。

If you're thinking about running multiple containers that share a single database volume, [here are some notes on how this might work](https://docs.clamav.net/manual/Installing/Docker.html#multiple-containers-sharing-the-same-mounted-databases).
如果您正在考虑运行共享单个数据库卷的多个容器，[ 以下是有关其工作原理的一些说明 ](https://docs.clamav.net/manual/Installing/Docker.html#multiple-containers-sharing-the-same-mounted-databases)。

### [Running ClamD using non-root user using --user and --entrypoint 使用非 root 用户使用 --user 和 --entrypoint 运行 ClamD](https://docs.clamav.net/manual/Installing/Docker.html#running-clamd-using-non-root-user-using---user-and---entrypoint)

You can run a container using the non-root user "clamav" with the  unprivileged entrypoint script. To do this with Docker, you will need to add these two options: `--user "clamav" --entrypoint /init-unprivileged`
您可以使用非 root 用户 “clamav” 和无特权入口点脚本运行容器。要使用 Docker 执行此作，您需要添加以下两个选项： `--user "clamav" --entrypoint /init-unprivileged` 

For example: 例如：

```

docker run -it --rm \
      --user "clamav" \
      --entrypoint /init-unprivileged \
      --name "clam_container_01" \
    clamav/clamav:unstable_base
```

### [Running Clam(D)Scan 运行 Clam（D）Scan](https://docs.clamav.net/manual/Installing/Docker.html#running-clamdscan)

Scanning files using `clamscan` or `clamdscan` is possible in various ways with Docker. This section briefly describes them, but the other sections of this document are best read before hand to better understand some of the concepts.
使用 `Clamscan` 或 `clamdscan` 可以通过多种方式使用 Docker 扫描文件。本节简要介绍了它们，但最好先阅读本文档的其他部分，以便更好地理解某些概念。

One important aspect is however to realize that Docker by default does not  have access to any of the hosts files. And so to scan these within  Docker, they need to be mounted with a [bind mount](https://docs.docker.com/storage/bind-mounts/) to be made accessible.
但是，一个重要的方面是要意识到 Docker 默认无权访问任何 hosts 文件。因此，要在 Docker 中扫描这些内容，需要使用 [bind 挂载](https://docs.docker.com/storage/bind-mounts/)来挂载它们才能使其可访问。

For example, running the container with these arguments ...
例如，使用以下参数运行容器 ...

```

    --mount type=bind,source=/path/to/scan,target=/scandir
    --mount type=bind,source=/path/to/scan,target=/scandir
```

... would make the hosts file/directory `/path/to/scan` available in the container as `/scandir` and thus invoking `clamscan` would thus be done on `/scandir`.
...将使主机文件/目录 `/path/to/scan` 在容器中作为 `/scandir` 可用，因此调用 `clamscan` 将在 `/scandir` 上完成。

Note that while technically possible to run either scanners via `docker exec` this is not described as it is unlikely the container has access to the files to be scanned.
请注意，虽然从技术上讲可以通过 `docker exec` 运行任一扫描程序，但未对此进行描述，因为容器不太可能访问要扫描的文件。

### [ClamScan 蛤蜊扫描](https://docs.clamav.net/manual/Installing/Docker.html#clamscan)

Using `clamscan` outside of the Docker container is how normally `clamscan` is invoked. To make use of the available shared dockerized resources  however, it is possible to expose the virus database and share that for  example. E.g. it could be possible to run a Docker container with only  the `freshclam` daemon running, and share the virus database directory `/var/lib/clamav`. This could be useful for file servers for example, where only `clamscan` is installed on the host, and `freshclam` is managed in a Docker container.
在 Docker 容器之外使用 `clamscan` 是调用 `clamscan` 的通常方式。但是，要利用可用的共享 dockerized 资源，可以公开病毒库并共享该病毒库。例如，可以运行一个只运行 `freshclam` 守护进程的 Docker 容器，并共享病毒数据库目录 `/var/lib/clamav`。这对于文件服务器可能很有用，例如，主机上只安装了 `clamscan`，而 `freshclam` 在 Docker 容器中进行管理。

> *Note*: Running the `freshclam` daemon separated from `clamd` is less recommended, unless the `clamd` socket is shared with `freshclam` as `freshclam` would not be able to inform `clamd` of database updates.
> *注意* ： 不建议与 `clamd` 分开运行 `freshclam` 守护进程，除非 `clamd` 套接字与 `freshclam` 共享，因为 `freshclam` 无法通知 `clamd` 数据库更新。

### [Dockerized ClamScan Docker 化的 ClamScan](https://docs.clamav.net/manual/Installing/Docker.html#dockerized-clamscan)

To run `clamscan` in a Docker container, the Docker container can be invoked as:
要在 Docker 容器中运行 `clamscan`，可以通过以下方式调用 Docker 容器：

```

docker run -it --rm \
    --mount type=bind,source=/path/to/scan,target=/scandir \
    clamav/clamav:unstable \
    clamscan /scandir
```

However, this will use whatever signatures are found in the image, which may be slightly out of date. If using `clamscan` in this way, it would be best to use a [database volume](https://docs.clamav.net/manual/Installing/Docker.html#persisting-the-virus-database-volume) that is up-to-date so that you scan with the latest signatures. E.g.:
但是，这将使用在图像中找到的任何签名，这些签名可能略微过时。如果以这种方式使用 `clamscan`，最好使用最新的[数据库卷 ](https://docs.clamav.net/manual/Installing/Docker.html#persisting-the-virus-database-volume)，以便使用最新的签名进行扫描。例如：

```

docker run -it --rm \
    --mount type=bind,source=/path/to/scan,target=/scandir \
    --mount type=bind,source=/path/to/databases,target=/var/lib/clamav \
    clamav/clamav:unstable_base \
    clamscan /scandir
```

### [ClamDScan ClamDS 扫描](https://docs.clamav.net/manual/Installing/Docker.html#clamdscan)

As with `clamscan`, `clamdscan` can also be run when installed on the host, by connecting to the dockerized `clamd`. This can be done by either pointing `clamdscan` to the exposed TCP/UDP port or unix socket.
与 `clamscan` 一样，`clamdscan` 也可以在安装在主机上时通过连接到 dockerized `clamd` 来运行。这可以通过将 `clamdscan` 指向公开的 TCP/UDP 端口或 unix 套接字来完成。

### [Dockerized ClamDScan Docker 化的 ClamDScan](https://docs.clamav.net/manual/Installing/Docker.html#dockerized-clamdscan)

Running both `clamd` and `clamdscan` is also easily possible, as all that is needed is the shared socket between the two containers. The only caveat here is to:
同时运行 `clamd` 和 `clamdscan` 也很容易，因为只需要两个容器之间的共享套接字即可。这里唯一需要注意的是：

1. mount the files to be scanned in the container that will run `clamd`, or
   将要扫描的文件挂载到将运行 `clamd` 的容器中，或者
2. mount the files to be scanned in the container that will `clamdscan` run if using `clamdscan --stream`. The `--stream` option will be slower, but enables submitting files from a different machine on a network.
   将需要扫描的文件挂载到使用 `clamdscan --stream` 时将运行 `clamdscan` 的容器中。`--stream` 选项会变慢，但允许从网络上的其他计算机提交文件。

For example: 例如：

```

docker run -it --rm \
    --mount type=bind,source=/path/to/scan,target=/scandir \
    --mount type=bind,source=/var/lib/docker/data/clamav/sockets/,target=/run/clamav/ \
    clamav/clamav:unstable

docker run -it --rm \
    --mount type=bind,source=/path/to/scan,target=/scandir \
    --mount type=bind,source=/var/lib/docker/data/clamav/sockets/,target=/run/clamav/ \
    clamav/clamav:unstable_base \
    clamdscan /scandir
```

### [Controlling the container 控制容器](https://docs.clamav.net/manual/Installing/Docker.html#controlling-the-container)

The ClamAV container actually runs both `freshclam` and `clamd` daemons by default. Optionally available to the container is ClamAV's  milter daemon. To control the behavior of the services started within  the container, the following flags can be passed to the `docker run` command with the `--env` (`-e`) parameter.
默认情况下，ClamAV 容器实际上同时运行 `freshclam` 和 `clamd` 守护进程。容器可以选择使用 ClamAV 的 milter 守护程序。要控制在容器中启动的服务的行为，可以使用 `--env` （`-e`） 参数将以下标志传递给 `docker run` 命令。

- CLAMAV_NO_CLAMD [true|**false**] Do not start `clamd`. (default: `clamd` daemon is started)
  CLAMAV_NO_CLAMD [true|**false**] 不要启动 `clamd`。（默认：`clamd` 守护进程已启动）
- CLAMAV_NO_FRESHCLAMD [true|**false**] Do not start the `freshclam` daemon. (default: `freshclam` daemon is started)
  CLAMAV_NO_FRESHCLAMD [true|**false**] 不要启动 `freshclam` 守护进程。（默认：`Freshclam` 守护进程已启动）
- CLAMAV_NO_MILTERD [**true**|false] Do not start the `clamav-milter` daemon. (default: `clamav-milter` daemon is **not** started)
  CLAMAV_NO_MILTERD [**true**|false] 不要启动 `clamav-milter` 守护程序。（默认：`clamav-milter` 守护进程**未**启动）
- CLAMD_STARTUP_TIMEOUT [integer] Seconds to wait for `clamd` to start. (default: 1800)
  CLAMD_STARTUP_TIMEOUT [integer] 等待 `clamd` 启动的秒数。（默认值：1800）
- FRESHCLAM_CHECKS [integer] `freshclam` daily update frequency. (default: once per day)
  FRESHCLAM_CHECKS [integer] `freshclam` 每日更新频率。（默认：每天一次）

So to additionally also enable `clamav-milter`, the following flag can be added:
因此，要另外启用 `clamav-milter`，可以添加以下标志：

```

    --env 'CLAMAV_NO_MILTERD=false'
```

Further more, all of the configuration files that live in `/etc/clamav` can be overridden by doing a volume-mount to the specific file. The  following argument can be added for this purpose. The example uses the  entire configuration directory, but this can be supplied multiple times  if individual files deem to be replaced.
此外，所有位于 `/etc/clamav` 中的配置文件都可以通过对特定文件进行卷挂载来覆盖。为此，可以添加以下参数。该示例使用整个配置目录，但如果单个文件认为需要替换，则可以多次提供该目录。

```

    --mount type=bind,source=/full/path/to/clamav/,target=/etc/clamav
```

> *Note*: Even when disabling the `freshclam` daemon, `freshclam` will always run at least once during container startup if there is no  virus database. While not recommended, the virus database location  itself `/var/lib/clamav/` could be a persistent Docker volume. This however is slightly more advanced and out of scope of this document.
> *注意* ：即使禁用了 `freshclam` 守护进程，如果没有病毒库，`freshclam` 在容器启动期间也始终至少运行一次。虽然不建议这样做，但病毒数据库位置本身 `/var/lib/clamav/` 可以是持久性 Docker 卷。但是，这稍微高级一些，超出了本文档的范围。

### [Connecting to the container 连接到容器](https://docs.clamav.net/manual/Installing/Docker.html#connecting-to-the-container)

### [Executing commands within a running container 在正在运行的容器中执行命令](https://docs.clamav.net/manual/Installing/Docker.html#executing-commands-within-a-running-container)

To connect to a running ClamAV container, `docker exec` can be used to run a command on an already running container. To do so, the name needs to be either obtained from `docker ps` or supplied during container start via the `--name` parameter. The most interesting command in this case can be `clamdtop`.
要连接到正在运行的 ClamAV 容器，可以使用 `docker exec` 在已经运行的容器上运行命令。为此，需要从 `docker ps` 获取名称，或者在容器启动时通过 `--name` 参数提供该名称。在这种情况下，最有趣的命令可以是 `clamdtop`。

```

docker exec --interactive --tty "clamav_container_01" clamdtop
```

Alternatively, a shell can be started to inspect and run commands within the container as well.
或者，也可以启动 shell 来检查和运行容器内的命令。

```

docker exec --interactive --tty "clamav_container_01" /bin/sh
```

### [Unix sockets Unix 套接字](https://docs.clamav.net/manual/Installing/Docker.html#unix-sockets)

The default socket for `clamd` is located inside the container as `/tmp/clamd.sock` and can be connected to when exposed via a Docker volume mount. To ensure, that `clamd` within the container can freely create and remove the socket, the path  for the socket is to be volume-mounted, to expose it for others on the  same host to use. The following volume can be used for this purpose. Do  ensure that the directory on the host actually exists and clamav inside  the container has permission to access it. Caution is required when  managing permissions, as incorrect permission could open clamd for  anyone on the host system.
`clamd` 的默认套接字位于容器内部的 `/tmp/clamd.sock` 中，当通过 Docker 卷挂载公开时，可以连接到该套接字。为了确保容器内的 `clamd`  可以自由创建和删除套接字，套接字的路径是卷挂载的，以便将其暴露给同一主机上的其他人使用。以下卷可用于此目的。务必确保主机上的目录确实存在，并且容器内的 clamav 有权访问它。管理权限时需要小心，因为不正确的权限可能会为主机系统上的任何人打开 clamd。

```

    --mount type=bind,source=/var/lib/docker/data/clamav/sockets/,target=/tmp/
```

> *Note*: If you override the `LocalSocket` option with a custom `clamd.conf` config file, then you may find the `clamd.sock` file in a different location.
> *注* ： 如果使用自定义 `clamd.conf` 配置文件覆盖 `LocalSocket` 选项，则可能会在其他位置找到 `clamd.sock` 文件。

With the socket exposed to the host, any other service can now talk to `clamd` as well. If for example `clamdtop` where installed on the local host, calling
将套接字暴露给主机后，任何其他服务现在也可以与 `clamd` 通信。例如，如果 `clamdtop` 安装在本地主机上，则调用

```

clamdtop "/var/lib/docker/data/clamav/sockets/clamd.sock"
```

should work just fine. Likewise, running `clamdtop` in a different container, but sharing the socket will equally work. While `clamdtop` works well as an example here, it is of course important to realize, this can also be used to connect a mail server to `clamd`.
应该工作得很好。同样，在不同的容器中运行 `clamdtop`，但共享套接字同样有效。虽然 `clamdtop` 在这里作为一个例子效果很好，但意识到这一点当然很重要，这也可以用于将邮件服务器连接到 `clamd`。

### [TCP TCP 协议](https://docs.clamav.net/manual/Installing/Docker.html#tcp)

ClamAV in the official Docker images is configured to listen for TCP connections on these ports:
官方 Docker 镜像中的 ClamAV 配置为侦听以下端口上的 TCP 连接：

- `clamd`: 3310 `蛤蜊 `： 3310
- `clamav-milter`: 7357
  `clamav-milter`：7357

While `clamd` and `clamav-milter` will listen on the above TCP ports, Docker does not expose these by  default to the host. Only within containers can these ports be accessed. To expose, or "publish", these ports to the host, and thus potentially  over the (inter)network, the `--publish` (or `--publish-all`) flag to `docker run` can be used. While more advanced/secure mappings can be done as per documentation, the basic way is to `--publish [<host_port>:]<container_port>` to make the port available to the host.
虽然 `clamd` 和 `clamav-milter` 将侦听上述 TCP 端口，但 Docker 默认不会向主机公开这些端口。只有在容器内才能访问这些端口。要向主机公开或“发布”这些端口，从而可能通过（内部）网络，可以使用 `docker run` 的 `--publish`（或 `--publish-all`）标志。虽然可以根据文档完成更高级/安全的映射，但基本方法是 `--publish [<host_port>:]<container_port>` 使端口对主机可用。

```

    --publish 13310:3310 \
    --publish 7357
```

The above would thus publish:
因此，上述内容将发布：

- `clamd` port `3310` as `13310` on the host
  主机上的 `clamd` 端口 `3310` 为 `13310`
- `milter` port `7357` as a *random* to the host. The *random* port can be inspected via `docker ps`.
  `milter` 端口 `7357` 作为*随机*端口分配给主机。可以通过 `docker ps` 检查*随机*端口。

But if you're just running one ClamAV container, you probably will just  want to use the default port numbers, which are the same port numbers  suggested in the `clamd.conf.sample` file provided with ClamAV:
但是，如果你只运行一个 ClamAV 容器，你可能只想使用默认的端口号，它与 `ClamAV 提供的 clamd.conf.sample` 文件中建议的端口号相同：

```

    --publish 3310:3310 \
    --publish 7357:7357
```

> **Warning**: Extreme caution is to be taken when using `clamd` over TCP as there are no protections on that level. All traffic is  un-encrypted. Extra care is to be taken when using TCP communications.
> **警告** ： 在 TCP 上使用 `clamd` 时要格外小心，因为该级别没有保护措施。所有流量均未加密。使用 TCP 通信时需要格外小心。

### [Container ClamD health-check 集装箱 ClamD 健康检查](https://docs.clamav.net/manual/Installing/Docker.html#container-clamd-health-check)

Docker has the ability to run simple `ping` checks on services running inside containers. If `clamd` is running inside the container, Docker will on occasion send a `ping` to `clamd` on the default port and wait for the pong from `clamd`. If `clamd` fails to respond, Docker will treat this as an error. The healthcheck results can be viewed with `docker inspect`.
Docker 能够对容器内运行的服务运行简单的 `ping` 检查。如果 `clamd` 在容器内运行，Docker 有时会向默认端口上的 `clamd` 发送 `ping` 信号，并等待 `clamd` 发出 pong。如果 `clamd` 没有响应，Docker 会将其视为错误。可以使用 `docker inspect` 查看 healthcheck 结果。

### [Performance 性能](https://docs.clamav.net/manual/Installing/Docker.html#performance)

The performance impact of running `clamd` in Docker is negligible. Docker is in essence just a wrapper around Linux's cgroups and cgroups can be thought of as `chroot` or FreeBSD's `jail`. All code is executed on the host without any translation. Docker does  however do some isolation (through cgroups) to isolate the various  systems somewhat.
在 Docker 中运行 `clamd` 对性能的影响可以忽略不计。Docker 本质上只是 Linux 的 cgroups 的包装器，而 cgroups 可以被视为 `chroot` 或 FreeBSD 的 `jail`。所有代码都在主机上执行，无需任何转换。但是，Docker 确实会进行一些隔离（通过 cgroups）以在一定程度上隔离各种系统。

Of course, nothing in life is free, and so there is some overhead.  Disk-space being the most prominent one. The Docker container might have some duplication of files for example between the host and the  container. Further more, also RAM memory may be duplicated for each  instance, as there is no RAM-deduplication. Both of which can be solved  on the host however. A filesystem that supports disk-deduplication and a memory manager that does RAM-deduplication.
当然，生活中没有什么是免费的，因此会有一些开销。磁盘空间是最突出的一个。Docker 容器可能会有一些文件重复，例如，在主机和容器之间。此外，每个实例的 RAM 内存也可能被复制，因为没有 RAM  重复数据删除。但是，这两者都可以在主机上解决。支持磁盘重复数据删除的文件系统和执行 RAM 重复数据删除的内存管理器。

The base container image in itself is already quite small 80 / 225 MB  (compressed/uncompressed) at the time of this writing, this cost is  still very tiny, where the advantages are very much worth the cost in  general.
在撰写本文时，基本容器镜像本身已经非常小，只有 80 / 225 MB（压缩/未压缩），这个成本仍然非常小，一般来说，其优势非常值得。

The container including the virus database is about 300 / 456 MB (compressed/uncompressed) at the time of this writing.
在撰写本文时，包含病毒库的容器约为 300 / 456 MB（压缩/未压缩）。

### [Bandwidth 带宽](https://docs.clamav.net/manual/Installing/Docker.html#bandwidth)

Please, be kind when using 'free' bandwidth, both for the virus databases but  also the Docker registry. Try not to download the entire database set or the larger ClamAV database images on a regular basis.
请在使用“免费”带宽时保持善意，无论是用于病毒数据库还是 Docker 注册表。尽量不要定期下载整个数据库集或较大的 ClamAV 数据库映像。

### [Advanced container configurations 高级容器配置](https://docs.clamav.net/manual/Installing/Docker.html#advanced-container-configurations)

### [Multiple containers sharing the same mounted databases 多个容器共享相同的挂载数据库](https://docs.clamav.net/manual/Installing/Docker.html#multiple-containers-sharing-the-same-mounted-databases)

You can run multiple containers that share the same database volume, but be aware that the FreshClam daemons on each would compete to update the  databases. Most likely, one would update the databases and trigger its  ClamD to load the new databases, while the others would be oblivious to  the new databases and would continue with the old signatures until the  next ClamD self-check.
你可以运行多个共享同一数据库卷的容器，但请注意，每个容器上的 FreshClam 守护进程会争用更新数据库。最有可能的是，一个会更新数据库并触发其 ClamD 以加载新数据库，而其他会忽略新数据库并继续使用旧签名，直到下一次 ClamD 自检。

This is fine, honestly. It won't take that long before the new signatures  are detected by ClamD's self-check and the databases are reloaded  automatically.
老实说，这很好。用不了多久，ClamD 的自检就会检测到新的签名，并且数据库会自动重新加载。

To reload the databases on all ClamD containers immediately after an update, you could [disable the FreshClam daemon](https://docs.clamav.net/manual/Installing/Docker.html#controlling-the-container) when you start the containers. Later, use `docker exec` to perform an update and again as needed to have ClamD load updated databases.
要在更新后立即重新加载所有 ClamD 容器上的数据库，你可以在启动容器时[禁用 FreshClam 守护进程 ](https://docs.clamav.net/manual/Installing/Docker.html#controlling-the-container)。稍后，使用 `docker exec` 执行更新，并根据需要再次让 ClamD 加载更新的数据库。

> *Note*: This really isn't necessary but you could do this if you wish.
> *注意* ：这确实不是必需的，但如果您愿意，可以这样做。

Exactly how you orchestrate this will depend on your environment. You might do something along these lines:
具体如何编排这将取决于您的环境。您可以按照以下思路执行一些作：

1. Create a "clam_db" volume, if you don't already have one:
   创建一个 “clam_db” 卷（如果还没有）：

   ```
   
   ```

```bash
docker volume create clam_db
```

Start your containers: 启动容器：

```

docker run -it --rm \
    --name "clam_container_01" \
    --mount source=clam_db,target=/var/lib/clamav \
    --env 'CLAMAV_NO_FRESHCLAMD=true' \
    clamav/clamav:0.104_base
```

Wait for the first one to download the databases (if it's a new database volume). Then start more:
等待第一个 Shells 下载数据库（如果它是新的数据库卷）。然后开始更多：

```

docker run -it --rm \
    --name "clam_container_02" \
    --mount source=clam_db,target=/var/lib/clamav \
    --env 'CLAMAV_NO_FRESHCLAMD=true' \
    clamav/clamav:0.104_base
```

Check for updates, as needed:
根据需要检查更新：

```

docker exec -it clam_container_01 freshclam --on-update-execute=EXIT_1 || \
if [ $? == 1 ]; then \
    docker exec -it clam_container_01 clamdscan --reload; \
    docker exec -it clam_container_02 clamdscan --reload; \
fi
```

## 从源码安装

如果需要，还可以从源码编译安装 ClamAV：

- [Unix/Linux/Mac 说明](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html)
- [Windows 说明](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html)

### 使用 CMake 构建 ClamAV（v0.104 及以上版本）

The following are instructions to build ClamAV *version 0.104 and newer* using CMake.
以下是使用 CMake 构建 ClamAV  *版本 0.104 及更高版本*的说明。

> *Tip*: If you wish to build ClamAV *version 0.103 or older* from source, follow [these instructions to build ClamAV using Autotools](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix-old.html).
> *提示* ： 如果您希望从源代码构建 ClamAV  *版本 0.103 或更早版本* ，请按照[这些说明使用 Autotools 构建 ClamAV](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix-old.html)。



> *Note*: Some of the dependencies are optional if you elect to not build all of  the command line applications, or elect to only build the libclamav  library. Specifically:
> *注意* ：如果您选择不构建所有命令行应用程序，或者选择仅构建 libclamav 库，则某些依赖项是可选的。具体说来：
>
> - libcurl:  *required for libfreshclam, freshclam, clamsubmit, clamonacc*
>   libcurl：*libfreshclam、freshclam、clamsubmit、clamonacc 必需*
> - ncurses:  *required for clamdtop*
>   ncurses：*clamdtop 必需*
>
> For more information about customized builds and which dependencies can be skipped, please see the `INSTALL.md` document accompanying the source code.
> 有关自定义构建以及可以跳过哪些依赖项的更多信息，请参阅源代码随附的 `INSTALL.md` 文档。

#### [Install prerequisites 安装先决条件](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-prerequisites)

> *Note*: Some of the instructions below rely on Python 3's Pip package manager  to install CMake. This is because some distributions do not provide a  new enough version of CMake required to build ClamAV.
> *注意* ：下面的一些说明依赖于 Python 3 的 Pip 包管理器来安装 CMake。这是因为某些发行版没有提供构建 ClamAV 所需的足够新的 CMake 版本。

> *Tip*: The Python 3 `pytest` package is recommended in the instructions below in case the unit tests fail so that the test output is easy to read. *You're welcome to skip it.* However, if you have Python 2's `pytest` installed but not Python 3's `pytest`, the tests may fail to run.
> *提示* ：如果单元测试失败，则在下面的说明中建议使用 Python 3 `pytest` 包，以便测试输出易于阅读。 *欢迎你跳过它。* 但是，如果您安装了 Python 2 的 `pytest`，但未安装 Python 3 的 `pytest`，则测试可能无法运行。

##### [Alpine 高山](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#alpine)

As root or with `sudo`, run:
以 root 身份或使用 `sudo` 运行：

```

apk update && apk add \
  `# install tools` \
  g++ gcc gdb make cmake py3-pytest python3 valgrind \
  `# install clamav dependencies` \
  bzip2-dev check-dev curl-dev json-c-dev libmilter-dev libxml2-dev \
  linux-headers ncurses-dev openssl-dev pcre2-dev zlib-dev
```

Version 0.105+: install the Rust toolchain. The best option is to [install the Rust toolchain using rustup](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) your Rust toolchain. Alpine users on the latest release may also find an adequate Rust toolchain with:
版本 0.105+：安装 Rust 工具链。最好的选择[是使用 rustup 安装 Rust 工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) 你的 Rust 工具链。最新版本的 Alpine 用户还可以找到一个合适的 Rust 工具链，其中包含：

```

apk add cargo rust
```

##### [AlmaLinux / Redhat / Centos / Fedora](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#almalinux--redhat--centos--fedora)

*For RHEL 8 or Centos Stream**, you will probably need to run this to enable EPEL & PowerTools. As root or with `sudo`, run:
*对于 RHEL 8 或 Centos Stream**，您可能需要运行此程序以启用 EPEL 和 PowerTools。以 root 身份或使用 `sudo` 运行：

```

dnf install -y epel-release
dnf install -y dnf-plugins-core
dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm
dnf config-manager --set-enabled PowerTools | \
  dnf config-manager --set-enabled powertools | true
```

As root or with `sudo`, run:
以 root 身份或使用 `sudo` 运行：

```

dnf install -y \
  `# install tools` \
  gcc gcc-c++ make python3 python3-pip valgrind \
  `# install clamav dependencies` \
  bzip2-devel check-devel json-c-devel libcurl-devel libxml2-devel \
  ncurses-devel openssl-devel pcre2-devel sendmail-devel zlib-devel
```

> *Note*: If you get `dnf: command not found`, use `yum` instead.
> *注意* ：如果您收到 `dnf： command not found`，请改用 `yum`。

As a regular user, run:
作为普通用户，运行：

```

python3 -m pip install --user cmake pytest
```

> *Tip*: If you don't have a user account, e.g. in a Docker container, run:
> *提示* ：如果您没有用户帐户，例如在 Docker 容器中，请运行：
>
> ```
> 
> ```

> ```sh
> python3 -m pip install cmake pytest
> ```

Version 0.105+: install the Rust toolchain. The best option is to [install the Rust toolchain using rustup](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) your Rust toolchain. Fedora users that are unable or unwilling to use `rustup` may have luck with:
版本 0.105+：安装 Rust 工具链。最好的选择[是使用 rustup 安装 Rust 工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) 你的 Rust 工具链。无法或不愿意使用 `rustup` 的 Fedora 用户可能会很幸运：

```

dnf install -y cargo rust
```

##### [SUSE / openSUSE](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#suse--opensuse)

As root or with `sudo`, run:
以 root 身份或使用 `sudo` 运行：

```

zypper install -y \
  `# install tools` \
  gcc gcc-c++ make python3 valgrind cmake python-pytest \
  `# install clamav dependencies` \
  libbz2-devel check-devel libjson-c-devel libcurl-devel libxml2-devel \
  ncurses-devel libopenssl-devel pcre2-devel sendmail-devel zlib-devel \
```

> *Tip*: If you you're on an older release and if the `cmake` provided by your release is too old, then you may need to remove `cmake`, install `python3-pip`, and then install `cmake` like this:
> *提示* ： 如果你使用的是旧版本，并且你的版本提供的 `cmake` 太旧，那么你可能需要删除 `cmake`，安装 `python3-pip`，然后像这样安装 `cmake`：
>
> ```
> 
> ```

> ```sh
> python3 -m pip install --user cmake
> ```

Version 0.105+: install the Rust toolchain. The best option is to [install the Rust toolchain using rustup](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) your Rust toolchain. openSUSE users that are unable or unwilling to use `rustup` may have luck with:
版本 0.105+：安装 Rust 工具链。最好的选择[是使用 rustup 安装 Rust 工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) 你的 Rust 工具链。不能或不愿意使用 `rustup` 的 openSUSE 用户可能会很幸运：

```

zypper install -y cargo rust
```

##### [Ubuntu / Debian](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#ubuntu--debian)

As root or with `sudo`, run:
以 root 身份或使用 `sudo` 运行：

```

apt-get update && apt-get install -y \
  `# install tools` \
  gcc make pkg-config python3 python3-pip python3-pytest valgrind cmake \
  `# install clamav dependencies` \
  check libbz2-dev libcurl4-openssl-dev libjson-c-dev libmilter-dev \
  libncurses5-dev libpcre2-dev libssl-dev libxml2-dev zlib1g-dev
```

> *Tip*: If you you're on an older release and if the `cmake` provided by your release is too old, then you may need to remove `cmake`, install `python3-pip`, and then install `cmake` like this:
> *提示* ： 如果你使用的是旧版本，并且你的版本提供的 `cmake` 太旧，那么你可能需要删除 `cmake`，安装 `python3-pip`，然后像这样安装 `cmake`：
>
> ```
> 
> ```

> ```sh
> python3 -m pip install --user cmake
> ```

Version 0.105+: install the Rust toolchain. The best option is to [install the Rust toolchain using rustup](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) your Rust toolchain. Debian users are unlikely to find an adequate Rust toolchain through the distribution's package manager. Ubuntu users will have better luck. At the time of writing, even Ubuntu 18.04 appears to  have relatively recent Rust tools available (1.57.0, where the latest  security patch for `rustc` is version 1.58.1). Debian and Ubuntu users may install the Rust toolchain with:
版本 0.105+：安装 Rust 工具链。最好的选择[是使用 rustup 安装 Rust 工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) 你的 Rust 工具链。Debian 用户不太可能通过发行版的包管理器找到合适的 Rust 工具链。Ubuntu 用户将有更好的运气。在撰写本文时，即使是 Ubuntu 18.04 似乎也有相对较新的 Rust 工具可用（1.57.0，` 其中 rustc` 的最新安全补丁是 1.58.1 版）。Debian 和 Ubuntu 用户可以使用以下命令安装 Rust 工具链：

```

apt-get install -y cargo rustc
```

> *Note*: Debian and Ubuntu chose to call it `rustc` and not `rust`, like the others. Ubuntu users may instead install `rust-all` for a few additional Rust development tools that you would normally install through `rustup`. The `rust-all` package does not appear to exist for Debian 11 (bullseye).
> *注意* ：Debian 和 Ubuntu 选择将其称为 `rustc` 而不是 `rust`，就像其他的一样。Ubuntu 用户可以为一些额外的 Rust 开发工具安装 `rust-all`，您通常会通过 `rustup` 安装这些工具。Debian 11 （bullseye） 的 `rust-all` 软件包似乎不存在。

##### [macOS macOS 的](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#macos)

The following instructions require you to install [HomeBrew](https://brew.sh/) to install tools and library dependencies.
以下说明要求您安装 [HomeBrew](https://brew.sh/) 以安装工具和库依赖项。

```

brew update

packages=(
  # install tools
  python3 cmake
  # install clamav dependencies
  bzip2 check curl-openssl json-c libxml2 ncurses openssl@1.1 pcre2 zlib
)
for item in "${packages[@]}"; do
  brew install $item || true; brew upgrade $item || brew upgrade $item
done

python3 -m pip install --user cmake pytest
```

> *Note*: You may also need to install `pkg-config` if not already present on your system. You can use Homebrew to do this with: `brew install pkg-config`
> *注意* ：如果您的系统上尚未安装 `pkg-config，您可能还需要安装 pkg-config`。您可以使用 Homebrew 来执行此作：`brew install pkg-config`

Version 0.105+: install the Rust toolchain. The best option is to [install the Rust toolchain using rustup](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) your Rust toolchain.
版本 0.105+：安装 Rust 工具链。最好的选择[是使用 rustup 安装 Rust 工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) 你的 Rust 工具链。

##### [FreeBSD FreeBSD 软件](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#freebsd)

As root or with `sudo`, run:
以 root 身份或使用 `sudo` 运行：

```

pkg install -y \
  `# install tools` \
  gmake cmake pkgconf py38-pip python38 \
  `# install clamav dependencies` \
  bzip2 check curl json-c libmilter libxml2 ncurses pcre2
```

Now as a regular user, run:
现在，以普通用户身份运行：

```

python3.8 -m pip install --user pytest
```

> *Tip*: If you don't have a user account, e.g. in a Docker container, run:
> *提示* ：如果您没有用户帐户，例如在 Docker 容器中，请运行：
>
> ```
> 
> ```

> ```sh
> python3 -m pip install pytest
> ```

Version 0.105+: install the Rust toolchain. The best option is to [install the Rust toolchain using rustup](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain) . FreeBSD users may find an adequate version using the package manager  to install the Rust toolchain, depending on their release. FreeBSD users may install the Rust toolchain with:
版本 0.105+：安装 Rust 工具链。最好的选择是使用 [rustup 安装 Rust 工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain)。FreeBSD 用户可能会使用包管理器找到合适的版本来安装 Rust 工具链，具体取决于他们的版本。FreeBSD 用户可以使用以下方式安装 Rust 工具链：

```

pkg install -y rust
```

#### [Install Rust toolchain 安装 Rust 工具链](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#install-rust-toolchain)

Starting with ClamAV v0.105, a Rust toolchain is required to compile portions of libclamav. You can install the appropriate toolchain for your  development environment by following the instructions on the [rustup](https://rustup.rs) website. This ensures that you have the most up-to-date compiler  available at the time of installation; keep your toolchain updated for  new features and bug/security fixes by periodically executing: `rustup update`.
从 ClamAV v0.105 开始，需要 Rust 工具链来编译 libclamav 的各个部分。您可以按照 [rustup](https://rustup.rs) 网站上的说明为您的开发环境安装适当的工具链。这可确保您在安装时拥有最新的编译器;通过定期执行 `RustUp Update` 来保持工具链的新功能和错误/安全修复。

> *Note*: The minimum supported Rust version varies with each ClamAV release. We  make a best effort to never raise the minimum Rust version with patch  versions. For example:
> *注意* ：支持的最低 Rust 版本因每个 ClamAV 版本而异。我们尽最大努力从不使用补丁版本来提高最低 Rust 版本。例如：
>
> - the minimum Rust version for ClamAV 1.0 LTS is Rust 1.61.0. All ClamAV 1.0.x versions should also build with Rust 1.61.0.
>   ClamAV 1.0 LTS 的最低 Rust 版本为 Rust 1.61.0。所有 ClamAV 1.0.x 版本也应使用 Rust 1.61.0 构建。
> - the minimum Rust version for ClamAV 1.4 LTS is Rust 1.70.0. All ClamAV 1.4.x versions should also build with Rust 1.70.0.
>   ClamAV 1.4 LTS 的最低 Rust 版本为 Rust 1.70.0。所有 ClamAV 1.4.x 版本也应使用 Rust 1.70.0 构建。
>
> Your distribution may provide a `rust` or `cargo` package, but there is a very good chance it that it will be too old to compile ClamAV.
> 你的发行版可能提供了一个 `rust` 或 `cargo` 包，但很有可能它太旧了，无法编译 ClamAV。

Depending on your target environment, compilers may be manually installed without downloading and executing the `rustup` script. Some platforms (e.g., Alpine Linux) provide packages that are  recent-enough to build ClamAV. For distributions that provide no  package, or toolchains that are too old, if you are unable or unwilling  to utilize `rustup`, you may [download and install prebuilt toolchain binaries directly from rust-lang.org](https://forge.rust-lang.org/infra/other-installation-methods.html#standalone).
根据你的目标环境，编译器可以手动安装，而无需下载和执行 `rustup` 脚本。一些平台（例如 Alpine Linux）提供了足够新的软件包来构建 ClamAV。对于不提供包的发行版或太旧的工具链，如果你不能或不愿意使用 `rustup`，你可以[直接从 rust-lang.org 下载并安装预构建的工具链二进制文件 ](https://forge.rust-lang.org/infra/other-installation-methods.html#standalone)。

#### [Adding new system user and group 添加新的系统用户和组](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#adding-new-system-user-and-group)

If installing to the system, and if you intend to run `freshclam` or `clamd` as as service, you should create a service account before compiling and installing ClamAV.
如果安装到系统，并且你打算将 `freshclam` 或 `clamd` 作为服务运行，你应该在编译和安装 ClamAV 之前创建一个服务帐户。

[Follow these steps to create a service account](https://docs.clamav.net/manual/Installing/Add-clamav-user.html).
[按照以下步骤创建服务账户 ](https://docs.clamav.net/manual/Installing/Add-clamav-user.html)。

#### [Download the source code 下载源代码](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#download-the-source-code)

Download the source from [the clamav.net downloads page](https://www.clamav.net/downloads).
从 [clamav.net 下载页面](https://www.clamav.net/downloads)下载源代码。

Extract the archive: 提取存档：

```

tar xzf clamav-[ver].tar.gz
cd clamav-[ver]
```

#### [Build ClamAV 构建 ClamAV](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#build-clamav)

First, make a "build" subdirectory. This will enable you to easily delete your build files if something goes wrong and you need to re-configure and  try again.
首先，创建一个 “build” 子目录。这将使您能够在出现问题并且需要重新配置并重试时轻松删除构建文件。

```

mkdir build && cd build
```

Next, select the build options you desire. For a full list of configuration  options, see the "Custom CMake options" section in the `INSTALL.md` file included with the source code.
接下来，选择所需的构建选项。有关配置选项的完整列表，请参阅源代码中包含的 `INSTALL.md` 文件中的“自定义 CMake 选项”部分。

To help you get started, here are some popular build configurations.
为了帮助您入门，以下是一些常见的构建配置。

##### [The Default Build 默认版本](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#the-default-build)

The default build type is `RelWithDebInfo`, that is "Release mode with Debugging symbols". It will install to `/usr/local`.
默认构建类型为 `RelWithDebInfo`，即“带有调试元件的发布模式”。它将安装到 `/usr/local`。

```

cmake ..
cmake --build .
ctest
sudo cmake --build . --target install
```

> *Tip*: If building for macOS, you may need to override the system provided LibreSSL with the OpenSSL you installed using Homebrew. For example:
> *提示* ：如果为 macOS 构建，您可能需要使用使用 Homebrew 安装的 OpenSSL 覆盖系统提供的 LibreSSL。例如：
>
> ```
> 
> ```

> ```sh
> cmake .. \
>   -D CMAKE_INSTALL_PREFIX=/usr/local/clamav                                    \
>   -D OPTIMIZE=OFF                                                              \
>   -D OPENSSL_ROOT_DIR=/usr/local/opt/openssl@1.1/                              \
>   -D OPENSSL_CRYPTO_LIBRARY=/usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib \
>   -D OPENSSL_SSL_LIBRARY=/usr/local/opt/openssl@1.1/lib/libssl.1.1.dylib
> make
> sudo make install
> ```

##### [A Linux Distribution-style Build Linux 发行版式构建](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#a-linux-distribution-style-build)

This build type mimics the layout you may be familiar with if installing a  ClamAV package on Debian, Ubuntu, Alpine, and some other distributions:
这种构建类型模拟了你在 Debian、Ubuntu、Alpine 和其他一些发行版上安装 ClamAV 包时可能熟悉的布局：

```

cmake .. \
    -D CMAKE_INSTALL_PREFIX=/usr \
    -D CMAKE_INSTALL_LIBDIR=lib \
    -D APP_CONFIG_DIRECTORY=/etc/clamav \
    -D DATABASE_DIRECTORY=/var/lib/clamav \
    -D ENABLE_JSON_SHARED=OFF
cmake --build .
ctest
sudo cmake --build . --target install
```

Using the above example: 使用上面的示例：

- `CMAKE_INSTALL_PREFIX` - The install "prefix" will be `/usr`.
  `CMAKE_INSTALL_PREFIX` - 安装“前缀”将为 `/usr`。

- `CMAKE_INSTALL_LIBDIR` - The library directory will be `lib` (i.e. `/usr/lib`).
  `CMAKE_INSTALL_LIBDIR` - 库目录将为 `lib`（即 `/usr/lib`）。

  This may be the default anyways, but you may want to specify if CMake tries to install to `lib64` and if `lib64` is not desired.
  无论如何，这可能是默认设置，但您可能希望指定 CMake 是否尝试安装到 `lib64` 以及是否需要 `lib64`。

- `APP_CONFIG_DIRECTORY` - The config directory will be `/etc/clamav`.
  `APP_CONFIG_DIRECTORY` - 配置目录将为 `/etc/clamav`。

  *Note*: This absolute path is non-portable.
  *注意* ：此绝对路径是不可移植的。

- `DATABASE_DIRECTORY` - The database directory will be `/var/lib/clamav`.
  `DATABASE_DIRECTORY` - 数据库目录将为 `/var/lib/clamav`。

  *Note*: This absolute path is non-portable.
  *注意* ：此绝对路径是不可移植的。

> *Tip*: Setting `ENABLE_JSON_SHARED=OFF` is preferred, but it will require json-c version 0.15 or newer unless  you build json-c yourself with custom options. If json-c 0.15+ is not  available to you, you may omit the option and just use the json-c shared library. But be warned that downstream applications which use `libclamav.so` may crash if they also use a different JSON library.
> *提示* ： 最好设置 `ENABLE_JSON_SHARED=OFF`，但它需要 json-c 版本 0.15 或更高版本，除非您使用自定义选项自己构建 json-c。如果您无法使用 json-c 0.15+，您可以省略该选项，只使用 json-c 共享库。但请注意，如果使用 `libclamav.so` 的下游应用程序也使用不同的 JSON 库，则它们可能会崩溃。

Some other popular configuration options include:
其他一些常用的配置选项包括：

- `CMAKE_INSTALL_DOCDIR` - Specify exact documentation subdirectory, relative to the install  prefix. The default may vary depending on your system and how you  install CMake.
  `CMAKE_INSTALL_DOCDIR` - 指定相对于安装前缀的确切 documentation 子目录。默认值可能会因您的系统和安装 CMake 的方式而异。

  E.g., `-D CMAKE_INSTALL_DOCDIR=share/doc/packages/clamav` 例如。 `-D CMAKE_INSTALL_DOCDIR=share/doc/packages/clamav` 

- `CMAKE_SKIP_RPATH` - If enabled, no RPATH is built into anything. This may be required  when building packages for some Linux distributions. See the [CMake wiki](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling) for more detail about CMake's RPATH handling.
  `CMAKE_SKIP_RPATH` - 如果启用，则不会将 RPATH 内置到任何内容中。在为某些 Linux 发行版构建软件包时，可能需要这样做。有关 CMake 的 RPATH 处理的更多详细信息，请参阅 [CMake wiki](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling)。

  E.g., `-D CMAKE_SKIP_RPATH=ON`
  例如，`-D CMAKE_SKIP_RPATH=ON`

Please see the [CMake documentation](https://cmake.org/cmake/help/latest/command/install.html#installing-files) for more instructions on how to customize the install paths.
有关如何自定义安装路径的更多说明，请参阅 [CMake 文档 ](https://cmake.org/cmake/help/latest/command/install.html#installing-files)。

##### [A Build for Development 为开发而构建](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#a-build-for-development)

This suggested development configuration generates a Ninja-based build  system instead of the default Makefile-based build system. Ninja is  faster than Make, but you will have to install "ninja" (or  "ninja-build"). With the following commands, ClamAV will be compiled in `Debug` mode with optimizations disabled. It will install to an "install" subdirectory and SystemD integration is disabled so that `sudo` is not required for the install and SystemD unit files are not  installed to the system. This build also enables building a static `libclamav.a` library as well as building the example applications.
此建议的开发配置会生成基于 Ninja 的构建系统，而不是默认的基于 Makefile 的构建系统。Ninja 比 Make 更快，但您必须安装“ninja”（或“ninja-build”）。使用以下命令，ClamAV 将在 `Debug` 模式下编译，并禁用优化。它将安装到 “install” 子目录，并且 SystemD 集成被禁用，因此安装不需要 `sudo`，并且 SystemD 单元文件不会安装到系统中。此版本还支持构建静态 `libclamav.a` 库以及构建示例应用程序。

```

cmake .. -G Ninja \
    -D CMAKE_BUILD_TYPE=Debug \
    -D OPTIMIZE=OFF \
    -D CMAKE_INSTALL_PREFIX=`pwd`/install \
    -D ENABLE_EXAMPLES=ON \
    -D ENABLE_STATIC_LIB=ON \
    -D ENABLE_SYSTEMD=OFF
cmake --build .
ctest --verbose
cmake --build . --target install
```

You can find additional instructions [in our Development chapter](https://docs.clamav.net/manual/Development/development-builds.html).
您可以在[我们的 开发 章节](https://docs.clamav.net/manual/Development/development-builds.html)中找到其他说明。

##### [About the tests 关于测试](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#about-the-tests)

ClamAV's public test suite is run using `ctest`. On Linux systems, our build system will detect if you have Valgrind. If installed, each test will run a second time using Valgrind to check for leaks.
ClamAV 的公共测试套件使用 `ctest` 运行。在 Linux 系统上，我们的构建系统将检测您是否拥有 Valgrind。如果安装，每个测试将使用 Valgrind 进行第二次运行以检查泄漏。

If a test fails, please [report the issue on GitHub](https://github.com/Cisco-Talos/clamav/issues). You will find `.log` files for each of the tests in the `build/unit_tests` directory. The output from `ctest --verbose` may give us enough information, but if not it could be helpful to zip up the `.log` files and attach them to the ticket.
如果测试失败，请在 [GitHub 上报告问题 ](https://github.com/Cisco-Talos/clamav/issues)。您将在 `build/unit_tests` 目录中找到每个测试的 `.log` 个文件。`ctest --verbose` 的输出可能会为我们提供足够的信息，但如果没有，压缩 `.log` 文件并将它们附加到票证可能会有所帮助。

#### [Un-install 卸载](https://docs.clamav.net/manual/Installing/Installing-from-source-Unix.html#un-install)

CMake doesn't provide a simple command to uninstall. However, CMake does build an `install_manifest.txt` file when you do the install. You can use the manifest to remove the installed files.
CMake 没有提供简单的卸载命令。但是，当您进行安装时，CMake 确实会构建一个 `install_manifest.txt` 文件。您可以使用清单删除已安装的文件。

You will find the manifest in the directory where you compiled ClamAV. If  you followed the recommendations (above), then you will find it at `<clamav source directory>/build/install_manifest.txt`.
您将在编译 ClamAV 的目录中找到清单。如果您遵循了上述建议，则可以在 `<clamav source directory>/build/install_manifest.txt` 中找到它。

Feel free to inspect the file so you're comfortable knowing what you're about to delete.
请随意检查文件，以便轻松了解要删除的内容。

Open a terminal and `cd` to that `<clamav source directory>/build` directory. Then run:
打开一个终端并 `cd` 到该 `<clamav source directory>/build` 目录。然后运行：

```

xargs rm < install_manifest.txt
```

This will leave behind the directories, and will leave behind any files  added after install including the signature databases and any config  files. You will have to delete these extra files yourself.
这将留下目录，并留下安装后添加的所有文件，包括签名数据库和任何配置文件。您必须自己删除这些额外的文件。

> *Tip*: You may need to use `sudo`, depending on where you installed to.
> *提示* ： 您可能需要使用 `sudo`，具体取决于您的安装位置。

### [Installing ClamAV on Windows from Source 从 Windows 源安装 ClamAV](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#installing-clamav-on-windows-from-source)

The following are instructions to build ClamAV *version 0.104 and newer* using CMake.
以下是使用 CMake 构建 ClamAV  *版本 0.104 及更高版本*的说明。

> *Tip*: If you wish to build ClamAV from source in ClamAV *version 0.103 and older*, you'll have to use the Visual Studio solution, please see the [Win32 ClamAV Build Instructions](https://github.com/Cisco-Talos/clamav/blob/rel/0.103/win32/README.md) located in our source release materials on [ClamAV.net](https://www.clamav.net/downloads) and on [GitHub](https://github.com/Cisco-Talos/clamav).
> *提示* ：如果您希望从 ClamAV  *版本 0.103 及更早版本的*源代码构建 ClamAV，则必须使用 Visual Studio 解决方案，请参阅位于 [ClamAV.net](https://www.clamav.net/downloads) 和 [GitHub](https://github.com/Cisco-Talos/clamav) 上的源代码发布资料中的 [Win32 ClamAV 构建说明 ](https://github.com/Cisco-Talos/clamav/blob/rel/0.103/win32/README.md)。

- Installing ClamAV on Windows from Source
  从 Windows 源安装 ClamAV
  - Install prerequisites 安装先决条件
    - [Building the library dependencies
      构建库依赖项](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-the-library-dependencies)
    - [Install Rust toolchain 安装 Rust 工具链](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-rust-toolchain)
  - [Download the source code 下载源代码](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#download-the-source-code)
  - Build ClamAV 构建 ClamAV
    - Building with Mussels 用贻贝建造
      - [Building the library dependencies with Mussels
        使用 Mussels 构建库依赖项](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-the-library-dependencies-with-mussels)
      - [Building ClamAV 构建 ClamAV](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-clamav)
    - [Building with vcpkg 使用 vcpkg 构建](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-with-vcpkg)
    - [Build the Installer 构建安装程序](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#build-the-installer)
  - [What now? 现在怎么办？](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#what-now)

> *Note*: Some of the dependencies are optional if you elect to not build all of  the command line applications, or elect to only build the libclamav  library. Specifically:
> *注意* ：如果您选择不构建所有命令行应用程序，或者选择仅构建 libclamav 库，则某些依赖项是可选的。具体说来：
>
> - libcurl:  *required for libfreshclam, freshclam, clamsubmit*
>   libcurl：*libfreshclam、freshclam、clamsubmit 必需*
> - ncurses:  *required for clamdtop*
>   ncurses：*clamdtop 必需*
>
> For more information about customized builds and which dependencies can be skipped, please see the `INSTALL.md` document accompanying the source code.
> 有关自定义构建以及可以跳过哪些依赖项的更多信息，请参阅源代码随附的 `INSTALL.md` 文档。

#### [Install prerequisites 安装先决条件](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-prerequisites)

**The following commands for building on Windows are written for Powershell**.
**以下用于在 Windows 上构建的命令是为 Powershell 编写**的。

At a minimum you will need:
您至少需要：

- Visual Studio 2015 or newer
  Visual Studio 2015 或更高版本
- CMake
- [The Rust programming language toolchain](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-rust-toolchain) (for ClamAV version 0.105+)
  [Rust 编程语言工具链 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-rust-toolchain)（适用于 ClamAV 版本 0.105+）

If you want to build the installer, you'll also need WiX Toolset.
如果要构建安装程序，还需要 WiX Toolset。

If you're using Chocolatey, you can install CMake and WiX simply like this:
如果您使用的是 Chocolatey，您可以简单地像这样安装 CMake 和 WiX：

```

choco install cmake wixtoolset
```

If you're using Mussels to build the library dependencies (see below),  then you may also need to install Netwide Assembler (NASM) and  ActivePerl. These are also simple to install using Chocolatey:
如果您使用 Mussels 构建库依赖项（见下文），那么您可能还需要安装 Netwide Assembler （NASM） 和 ActivePerl。使用 Chocolatey 安装这些也很简单：

```

choco install nasm activeperl
```

Then open a new terminal so that CMake and WiX will be in your `$PATH`.
然后打开一个新终端，以便 CMake 和 WiX 将位于您的 `$PATH`。

##### [Building the library dependencies 构建库依赖项](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-the-library-dependencies)

There are two options for building and supplying the library dependencies. These are Mussels and vcpkg.
有两个选项可用于构建和提供库依赖项。它们是 Mussels 和 vcpkg。

Mussels is an open source project developed in-house by the ClamAV team. It  offers great flexibility for defining your own collections (cookbooks)  of build instructions (recipes) instead of solely relying on a  centralized repository of ports. And unlike vcpkg, Mussels does not  implement CMake build tooling for projects that don't support CMake, but instead leverages whatever build system is provided by the project.  This means that Mussels builds may require installing additional tools,  like NMake and ActivePerl rather than simply requiring CMake. The  advantage is that you'll be building those projects the same way that  those developers intended, and that Mussels recipes are generally very  light weight. Mussels has some sharp edges because it's a newer and much smaller project than vcpkg.
Mussels 是由 ClamAV  团队内部开发的开源项目。它为定义您自己的构建说明（配方）集合（说明书）提供了极大的灵活性，而不是仅仅依赖集中式端口存储库。与 vcpkg  不同的是，Mussels 不会为不支持 CMake 的项目实现 CMake 构建工具，而是利用项目提供的任何构建系统。这意味着 Mussels  构建可能需要安装额外的工具，如 NMake 和 ActivePerl，而不仅仅是需要  CMake。这样做的好处是，您将按照与开发人员相同的方式构建这些项目，并且贻贝食谱通常非常轻巧。Mussels 有一些锋利的边缘，因为它是一个比 vcpkg 更新且小得多的项目。

Vcpkg is an open source project developed by Microsoft and is heavily  oriented towards CMake projects. Vcpkg offers a very large collection of "ports" for almost any project you may need to build. It is very easy  to get started with vcpkg.
Vcpkg 是由 Microsoft 开发的开源项目，主要面向 CMake 项目。Vcpkg 为你可能需要构建的任何项目提供了非常大的 “端口” 集合。vcpkg 很容易上手。

Mussels is the preferred tool to supply the library dependencies at least until such time as the vcpkg Debug-build libclamav unit test heap-corruption  crash is resolved [(see below)](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-with-vcpkg).
Mussels 是提供库依赖项的首选工具，至少在 vcpkg Debug-build libclamav unit test heap-corruption 崩溃得到解决之前 [（见下文）。](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-with-vcpkg)

***Details for how to use Mussels and vcpkg will be provided with the build instructions (below), as the instructions differ \*significantly\* depending on which you choose.
有关如何使用 Mussels 和 vcpkg 的详细信息将随构建说明（如下）一起提供，因为根据您选择的说明，说明会\*有很大\*差异。***

> *Tip*: Installing the Python 3 `pytest` package is also recommended in case the unit tests fail so that the test output is easy to read. *You're welcome to skip it.* However, if you have Python 2's `pytest` installed but not Python 3's `pytest`, the tests may fail to run.
> *提示* ： 如果单元测试失败，还建议安装 Python 3 `pytest` 包，以便测试输出易于阅读。 *欢迎你跳过它。* 但是，如果您安装了 Python 2 的 `pytest`，但未安装 Python 3 的 `pytest`，则测试可能无法运行。
>
> You can install pytest by running:
> 您可以通过运行以下命令来安装 pytest：
>
> ```
> 
> ```

> ```ps1
> python3 -m pip install --user pytest
> ```

##### [Install Rust toolchain 安装 Rust 工具链](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-rust-toolchain)

Starting with ClamAV version 0.105, the Rust toolchain is required to compile  ClamAV. You can install the appropriate toolchain for your development  environment by following the instructions on the [rustup](https://rustup.rs) website. This ensures that you have the most up-to-date compiler  available at the time of installation; keep your toolchain updated for  new features and bug/security fixes by periodically executing: `rustup update`.
从 ClamAV 版本 0.105 开始，编译 ClamAV 需要 Rust 工具链。您可以按照 [rustup](https://rustup.rs) 网站上的说明为您的开发环境安装适当的工具链。这可确保您在安装时拥有最新的编译器;通过定期执行 `RustUp Update` 来保持工具链的新功能和错误/安全修复。

Building ClamAV requires, at a minimum, Rust compiler version 1.56, as it relies on features introduced in the [Rust 2021 Edition](https://doc.rust-lang.org/edition-guide/rust-2021/index.html).
构建 ClamAV 至少需要 Rust 编译器版本 1.56，因为它依赖于 [Rust 2021 版](https://doc.rust-lang.org/edition-guide/rust-2021/index.html)中引入的功能。

#### [Download the source code 下载源代码](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#download-the-source-code)

Download the source from [the clamav.net downloads page](https://www.clamav.net/downloads).
从 [clamav.net 下载页面](https://www.clamav.net/downloads)下载源代码。

Extract the archive. You should be able to right click on it and extract it to a folder, then in that folder, do the same for the `clamav-[ver].tar` file.
提取存档。你应该能够右键单击它并将其解压到一个文件夹中，然后在该文件夹中，对 `clamav-[ver].tar` 文件执行相同的作。

The rest of the instructions will assume you've opened Powershell in the clamav source directory.
其余说明将假定你已在 clamav 源目录中打开 Powershell。

#### [Build ClamAV 构建 ClamAV](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#build-clamav)

First, make a "build" subdirectory. This will enable you to easily delete your build files if something goes wrong and you need to re-configure and  try again.
首先，创建一个 “build” 子目录。这将使您能够在出现问题并且需要重新配置并重试时轻松删除构建文件。

```

mkdir build && cd build
```

##### [Building with Mussels 用贻贝建造](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-with-mussels)

###### [Building the library dependencies with Mussels 使用 Mussels 构建库依赖项](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-the-library-dependencies-with-mussels)

Much like `vcpkg`, [Mussels](https://github.com/Cisco-Talos/Mussels) can be used to automatically build the ClamAV library dependencies. Unlike `vcpkg`, Mussels does not provide a mechanism for CMake to automatically detect the library paths.
与 `vcpkg` 非常相似，[Mussels](https://github.com/Cisco-Talos/Mussels) 可用于自动构建 ClamAV 库依赖项。与 `vcpkg` 不同，Mussels 没有为 CMake 提供自动检测库路径的机制。

To build the library dependencies with Mussels, use Python's `pip` package manager to install Mussels:
要使用 Mussels 构建库依赖项，请使用 Python 的 `pip` 包管理器安装 Mussels：

```

python3 -m pip install mussels
```

> *Important*: Always run `mussels` or `msl` in a small sub-directory. Mussels will recursively search your current  directory for YAML recipe files. In a large directory, such as your home directory, this may take a long time.
> *重要*说明：始终在小子目录中运行 `mussels` 或 `msl`。Mussels 将递归搜索您的当前目录以查找 YAML 配方文件。在大型目录（如主目录）中，这可能需要很长时间。

Update the Mussels cookbooks to get the latest build recipes and set the `clamav` cookbook to be trusted:
更新 Mussels 说明书以获取最新的构建配方，并将 `clamav` cookbook 值得信任：

```

msl update
msl cookbook trust clamav
```

Use `msl list` if you wish to see the recipes provided by the `clamav` cookbook.
如果您希望查看 `clamav` 说明书提供的配方，请使用 `msl list`。

To build with Mussels, you may need to install a few extra tools required  to build some of the libraries. These include NASM and ActivePerl. See [install prerequisites](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-prerequisites), above.
要使用 Mussels 进行构建，您可能需要安装一些构建某些库所需的额外工具。这些包括 NASM 和 ActivePerl。请参阅上面的[安装先决条件 ](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#install-prerequisites)。

Build the `clamav_deps` recipe to compile ClamAV's library dependencies. By default, Mussels will install them to `~\.mussels\install\<target>`
构建 `clamav_deps` 配方以编译 ClamAV 的库依赖项。默认情况下，Mussels 会将它们安装到 `~\.mussels\install\<target>`

```

msl build clamav_deps
```

If this worked, you should be ready to build ClamAV.
如果这有效，您应该准备好构建 ClamAV。

> *Tip*: You can also build for 32-bit systems, using `msl build clamav_deps -t x86`.
> *提示* ： 您还可以使用 `msl build clamav_deps -t x86` 为 32 位系统进行构建。

###### [Building ClamAV 构建 ClamAV](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-clamav)

To configure the project, run the following, substiting "Visual Studio 16 2019" with your Visual Studio version:
要配置项目，请运行以下命令，将“Visual Studio 16 2019”替换为您的 Visual Studio 版本：

```

cmake ..  -G "Visual Studio 16 2019" -A x64 `
  -D JSONC_INCLUDE_DIR="$home\.mussels\install\x64\include\json-c"         `
  -D JSONC_LIBRARY="$home\.mussels\install\x64\lib\json-c.lib"             `
  -D ENABLE_JSON_SHARED=OFF                                              `
  -D BZIP2_INCLUDE_DIR="$home\.mussels\install\x64\include"                `
  -D BZIP2_LIBRARY_RELEASE="$home\.mussels\install\x64\lib\libbz2.lib"     `
  -D CURL_INCLUDE_DIR="$home\.mussels\install\x64\include"                 `
  -D CURL_LIBRARY="$home\.mussels\install\x64\lib\libcurl_imp.lib"         `
  -D OPENSSL_ROOT_DIR="$home\.mussels\install\x64"                         `
  -D OPENSSL_INCLUDE_DIR="$home\.mussels\install\x64\include"              `
  -D OPENSSL_CRYPTO_LIBRARY="$home\.mussels\install\x64\lib\libcrypto.lib" `
  -D OPENSSL_SSL_LIBRARY="$home\.mussels\install\x64\lib\libssl.lib"       `
  -D ZLIB_LIBRARY="$home\.mussels\install\x64\lib\libssl.lib"              `
  -D LIBXML2_INCLUDE_DIR="$home\.mussels\install\x64\include"              `
  -D LIBXML2_LIBRARY="$home\.mussels\install\x64\lib\libxml2.lib"          `
  -D PCRE2_INCLUDE_DIR="$home\.mussels\install\x64\include"                `
  -D PCRE2_LIBRARY="$home\.mussels\install\x64\lib\pcre2-8.lib"            `
  -D CURSES_INCLUDE_DIR="$home\.mussels\install\x64\include"               `
  -D CURSES_LIBRARY="$home\.mussels\install\x64\lib\pdcurses.lib"          `
  -D PThreadW32_INCLUDE_DIR="$home\.mussels\install\x64\include"           `
  -D PThreadW32_LIBRARY="$home\.mussels\install\x64\lib\pthreadVC2.lib"    `
  -D ZLIB_INCLUDE_DIR="$home\.mussels\install\x64\include"                 `
  -D ZLIB_LIBRARY="$home\.mussels\install\x64\lib\zlibstatic.lib"          `
  -D LIBCHECK_INCLUDE_DIR="$home\.mussels\install\x64\include"             `
  -D LIBCHECK_LIBRARY="$home\.mussels\install\x64\lib\checkDynamic.lib"    `
  -D CMAKE_INSTALL_PREFIX="install"
```

> *Tip*: You have to drop the `-A x64` arguments if you're building for 32-bits (or specify `-A win32`) and substitute `x64` with `x86` in the library paths.
> *提示* ： 如果要构建 32 位（或指定 `-A win32`），则必须删除 `-A x64` 参数，并在库路径中将 `x64` 替换为 `x86`。

Now, go ahead and build the project:
现在，继续构建项目：

```

cmake --build . --config RelWithDebInfo
```

> *Tip*: If you're having include-path issues when building, try building with detailed verbosity so you can verify that the paths are correct:
> *提示* ： 如果您在构建时遇到 include-path 问题，请尝试使用详细的详细内容进行构建，以便您可以验证路径是否正确：

```

cmake --build . --config RelWithDebInfo -- /verbosity:detailed
```

You can run the test suite with `ctest`:
您可以使用 `ctest` 运行测试套件：

```

ctest -C RelWithDebInfo
```

And you can install to the `install` (set above) like this:
您可以像这样安装到`安装 `（上面设置）：

```

cmake --build . --config RelWithDebInfo --target install
```

> *Tip*: For a full list of configuration options, see the "Custom CMake Config Options" section of the `INSTALL.md` file included with the source code.
> *提示* ： 有关配置选项的完整列表，请参阅源代码中包含的 `INSTALL.md` 文件的“自定义 CMake 配置选项”部分。

##### [Building with vcpkg 使用 vcpkg 构建](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#building-with-vcpkg)

`vcpkg` can be used to build the ClamAV library dependencies automatically.
`vcpkg` 可用于自动构建 ClamAV 库依赖项。

`vcpkg` integrates really well with CMake, enabling CMake to find your compiled libraries automatically, so you don't have to specify the include & library paths manually as you do when using Mussels.
`vcpkg` 与 CMake 集成得非常好，使 CMake 能够自动找到你的编译库，所以你不必像使用 Mussels 时那样手动指定包含和库路径。

> *DISCLAIMER*: There is a known issue with the unit tests when building with vcpkg in `Debug` mode. When you run the libclamav unit tests (`check_clamav`), the program will crash and a popup will claim there was heap corruption. If > you use Task Manager to kill the `check_clamav.exe` process, the rest of the tests pass just fine. This issue does not  occur when using Mussels to supply the library dependencies. Commenting  out the following lines in `readdb.c` resolves the heap corruption crash when running `check_clamav`, but of course introduces a memory leak:
> *免责声明* ：在`调试`模式下使用 vcpkg 进行构建时，单元测试存在一个已知问题。当您运行 libclamav 单元测试 （`check_clamav`） 时，程序将崩溃，并且弹出窗口将声称存在堆损坏。如果>使用 Task Manager 终止 `check_clamav.exe` 进程，则其余测试会顺利通过。使用 Mussel 提供库依赖项时，不会出现此问题。注释掉 `readdb.c` 中的以下行可以解决运行 `check_clamav` 时堆损坏崩溃，但当然会引入内存泄漏：
>
> ```
> 
> ```

> ```c
>     if (engine->stats_data)
>         free(engine->stats_data);
> ```
>
> If anyone has time to figure out the real cause of the vcpkg `Debug`-build crash in `check_clamav`, it would be greatly appreciated.
> 如果有人有时间找出 `check_clamav` 中 vcpkg `Debug-build` 崩溃的真正原因，我们将不胜感激。

You'll need to install [vcpkg](https://github.com/microsoft/vcpkg). See the `vcpkg` README for installation instructions.
您需要安装 [vcpkg](https://github.com/microsoft/vcpkg)。有关安装说明，请参阅 `vcpkg` README。

Once installed, set the variable `$VCPKG_PATH` to the location where you installed `vcpkg`:
安装后，将变量 `$VCPKG_PATH` 设置为安装 `vcpkg` 的位置：

```
$VCPKG_PATH="..." # Path to your vcpkg installation
```

By default, CMake and `vcpkg` build for 32-bit. If you want to build for 64-bit, set the `VCPKG_DEFAULT_TRIPLET` environment variable:
默认情况下，CMake 和 `vcpkg` 构建 32 位。如果要构建 64 位，请设置 `VCPKG_DEFAULT_TRIPLET` 环境变量：

```
$env:VCPKG_DEFAULT_TRIPLET="x64-windows"
```

Next, use `vcpkg` to build the required library dependencies:
接下来，使用 `vcpkg` 生成所需的库依赖项：

```
& "$VCPKG_PATH\vcpkg" install 'curl[openssl]' 'json-c' 'libxml2' 'pcre2' 'pthreads' 'zlib' 'pdcurses' 'bzip2' 'check'
```

Now configure the ClamAV build using the `CMAKE_TOOLCHAIN_FILE` variable which will enable CMake to automatically find the libraries we built with `vcpkg`.
现在使用 `CMAKE_TOOLCHAIN_FILE` 变量配置 ClamAV 版本，这将使 CMake 能够自动查找我们使用 `vcpkg` 构建的库。

```
cmake .. -A x64 `
  -D CMAKE_TOOLCHAIN_FILE="$VCPKG_PATH\scripts\buildsystems\vcpkg.cmake" `
  -D CMAKE_INSTALL_PREFIX="install"
```

Now, go ahead and build the project:
现在，继续构建项目：

```
cmake --build . --config RelWithDebInfo
```

You can run the test suite with `ctest`:
您可以使用 `ctest` 运行测试套件：

```
ctest -C RelWithDebInfo
```

And you can install to the `install` directory (set above) like this:
您可以像这样安装到`安装`目录（上面设置）：

```
cmake --build . --config RelWithDebInfo --target install
```

##### [Build the Installer 构建安装程序](https://docs.clamav.net/manual/Installing/Installing-from-source-Windows.html#build-the-installer)

To build the installer, you must have WIX Toolset installed. If you're using Chocolatey, you can install it simply with `choco install wixtoolset` and then open a new terminal so that WIX will be in your PATH.
要构建安装程序，您必须安装 WIX Toolset。如果您使用的是 Chocolatey，您只需使用 `choco install wixtoolset` 安装它，然后打开一个新终端，以便 WIX 位于您的 PATH 中。

```
cpack -C RelWithDebInfo
```


## 使用 GPG 验证 ClamAV.net 下载

可以使用 [GnuPG](http://www.gnupg.org/) 验证 [ClamAV 下载页面上](https://www.clamav.net/downloads)提供的 ClamAV 发布包的真实性。

1. 安装 GnuPG。

2. 下载 [Cisco Talos GPG 公钥 ](https://raw.githubusercontent.com/Cisco-Talos/clamav-documentation/main/src/manual/cisco-talos.gpg)。

3. 将密钥导入本地公钥环：

   ```bash
   gpg --import cisco-talos.gpg
   ```

4. 将 ClamAV 包和相应的 `.sig` 文件下载到同一目录。

5. 验证稳定版本下载是否已使用 [Cisco Talos GPG 公钥] 进行签名：

   ```bash
   gpg --verify clamav-X.XX.tar.gz.sig
   ```

   生成的输出应如下所示。具体细节会有所不同，因为我们每隔几年轮换一次 GPG 密钥：

   ```bash
       gpg: Signature made Wed Jan 24 19:31:26 2018 EST
       gpg:                using RSA key F13F9E16BCA5BFAD
       gpg: Good signature from "Talos (Talos, Cisco Systems Inc.) [email address]" [unknown]
   ```

## 添加服务用户帐户

If you're planning to run `freshclam` or `clamd` as a service on a Linux or Unix system, you should create a service  account. The following instructions assume that you will use the an  account named "clamav" for both services, although you may create a  different account name for each if you wish.
如果打算在 Linux 或 Unix 系统上将 `freshclam` 或 `clamd` 作为服务运行，则应创建一个服务帐户。以下说明假定将对这两种服务使用名为 “clamav” 的账户，但如果您愿意，可以为每个服务创建不同的账户名称。

> *Note*: *These instructions are mostly just for folks building & installing from source.* If you installed a package from your Linux/Unix distribution, it probably created the account(s) for you.
> *注意* ： *这些说明主要只适用于从源代码构建和安装的人。* 如果您从 Linux/Unix 发行版安装了软件包，则它可能为您创建了帐户。

### 创建服务用户帐户（和组）

#### Linux / Unix

以 root 身份或使用 `sudo` 运行：

```bash
groupadd clamav
useradd -g clamav -s /bin/false -c "Clam Antivirus" clamav
```

If your operating system does not have the `groupadd` and `useradd` utilities, consult a system manual. **Don’t forget to lock access to the account!**
如果您的作系统没有 `groupadd` 和 `useradd` 实用程序，请查阅系统手册。 **不要忘记锁定对帐户的访问！**

#### macOS

Prep by identifying an unused group id (gid), and an unused user UniqueID.
通过标识未使用的组 ID （gid） 和未使用的用户 UniqueID 进行准备。

This command will display all current group PrimaryGroupIDs:
此命令将显示所有当前组 PrimaryGroupID：

```bash
dscl . list /Groups PrimaryGroupID | tr -s ' ' | sort -n -t ' ' -k2,2
```

This command will display all current user UniqueIDs:
此命令将显示所有当前用户的唯一 ID：

```bash
dscl . list /Users UniqueID | tr -s ' ' | sort -n -t ' ' -k2,2
```

然后，这些命令可以用于创建 `clamav` 组和 `clamav` 用户。

```bash
sudo dscl . create /Groups/clamav
sudo dscl . create /Groups/clamav RealName "Clam Antivirus Group"
sudo dscl . create /Groups/clamav gid 799           # Ensure this is unique!
sudo dscl . create /Users/clamav
sudo dscl . create /Users/clamav RealName "Clam Antivirus User"
sudo dscl . create /Users/clamav UserShell /bin/false
sudo dscl . create /Users/clamav UniqueID 599       # Ensure this is unique!
sudo dscl . create /Users/clamav PrimaryGroupID 799 # Must match the above gid!
```

### 关于服务账户的使用方式

At present, the behavior differs slightly between `clamd` and `freshclam`. When run as root:
目前，` 蛤蜊`和`新鲜蛤的行为`略有不同。以 root 身份运行时：

- `freshclam` will always switch to run as the "DatabaseOwner" user account. The  default account name is "clamav", or may be customized by specifying the "DatabaseOwner" setting in `freshclam.conf`.
  `freshclam` 将始终切换为以 “DatabaseOwner” 用户帐户运行。默认帐户名称为 “clamav”，也可以通过在 `freshclam.conf` 中指定 “DatabaseOwner” 设置来自定义。
- `clamd` will only switch to run as the "User" user account if the "User" setting is specified in `clamd.conf`. If you do not specify a "User" in the config, `clamd` will continue to run as the root user! We may change this behavior in a future version to prevent `clamd` from being run as root.
  如果在 `clamd.conf` 中指定了 “User” 设置，`clamd` 只会切换为以 “User” 用户帐户身份运行。如果你没有在配置文件中指定 “User”，`clamd` 会继续以 root 用户身份运行！我们可能会在将来的版本中更改此行为，以防止 `clamd` 以 root 身份运行。

> *Caution*: We do not recommend running `clamd` as root for safety reasons because ClamAV scans untrusted files that may be *malware*. Always configure the "User" setting in `clamd.conf` if you plan to run `clamd` as a service.
> *注意* ：出于安全原因，我们不建议以 root 身份运行 `clamd`，因为 ClamAV 会扫描可能是*恶意软件*的不受信任的文件。如果你打算将 `clamd` 作为服务运行，请始终在 `clamd.conf` 中配置 “User” 设置。

On Unix/Linux systems, `freshclam` and `clamd` will switch to run as a different user if you start them as the root user, or using `sudo`. By default, that user account is named "clamav". The purpose is t
在 Unix/Linux 系统上，`` 如果您以 root 用户身份启动或使用 `sudo，freshclam` 和 `clamd` 将切换为以其他用户身份运行。默认情况下，该用户帐户名为 “clamav”。目的是 t

If you are running `freshclam` and `clamd` as root or with `sudo`, and you did not explicitly configure with `--disable-clamav`, you will want to ensure that the `DatabaseOwner` user specified in `freshclam.conf` owns the database directory so it can download signature updates.
如果你以 root 或 `sudo` 身份运行 `freshclam` 和 `clamd`，并且没有明确使用 `--disable-clamav` 进行配置，你需要确保 `freshclam.conf` 中指定的 `DatabaseOwner` 用户拥有数据库目录，以便它可以下载签名更新。

The user that `clamd`, `clamdscan`, and `clamscan` run as may be the same user, but if it isn't -- it merely needs *read* access to the database directory.
运行 `clamd`、`clamdscan` 和 `clamscan` 的用户可能是同一个用户，但如果不是 -- 它只需要对数据库目录的*读取*权限。

If you choose to use the default `clamav` user to run `freshclam` and `clamd`, you'll need to create the clamav group and the clamav user account the first time you install ClamAV.
如果你选择使用默认的 `clamav` 用户来运行 `freshclam` 和 `clamd`，则需要在第一次安装 ClamAV 时创建 clamav 组和 clamav 用户账户。

### *After installation*: Make the service account own the database directory *安装后* ：使服务帐户拥有数据库目录

After you've installed ClamAV, you will want to make it so that the database  directory is owned by the same service account as you're using for `freshclam`.
安装 ClamAV 后，你需要使数据库目录由你用于 `freshclam` 的同一服务帐户拥有。

As root or with `sudo`, run:
以 root 身份或使用 `sudo` 运行：

```bash
sudo chown -R clamav:clamav /usr/local/share/clamav
```

Or (if you customized the database path):
或者（如果您自定义了数据库路径）：

```bash
chown -R clamav:clamav /var/lib/clamav/
```